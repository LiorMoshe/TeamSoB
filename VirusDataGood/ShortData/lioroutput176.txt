10432 20:06:33.178223 stat64("/usr/share/perl5/Errno.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.178236 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.178248 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10432 20:06:33.178269 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10432 20:06:33.178283 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f358) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.178295 _llseek(8, 0, [0], SEEK_CUR) = 0
10432 20:06:33.178377 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10432 20:06:33.179150 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10432 20:06:33.179642 _llseek(8, 5966, [5966], SEEK_SET) = 0
10432 20:06:33.179659 _llseek(8, 0, [5966], SEEK_CUR) = 0
10432 20:06:33.179669 close(8)          = 0
10432 20:06:33.180125 brk(0x827b000)    = 0x827b000
10432 20:06:33.180251 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10432 20:06:33.180739 _llseek(6, 6698, [6698], SEEK_SET) = 0
10432 20:06:33.180754 _llseek(6, 0, [6698], SEEK_CUR) = 0
10432 20:06:33.180765 close(6)          = 0
10432 20:06:33.180784 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.180798 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.180938 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.180970 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.180998 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.181011 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.181025 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.181037 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.181050 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.181062 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.181075 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.181089 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10432 20:06:33.181111 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10432 20:06:33.181125 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f808) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.181136 _llseek(6, 0, [0], SEEK_CUR) = 0
10432 20:06:33.181153 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10432 20:06:33.181516 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181532 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181545 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181558 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181572 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181585 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181599 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181611 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181624 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181636 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181650 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181663 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181677 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.181690 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10432 20:06:33.181711 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10432 20:06:33.181726 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f358) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.181737 _llseek(8, 0, [0], SEEK_CUR) = 0
10432 20:06:33.181754 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10432 20:06:33.182578 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10432 20:06:33.182780 brk(0x829c000)    = 0x829c000
10432 20:06:33.183121 read(8, "", 4096) = 0
10432 20:06:33.183137 close(8)          = 0
10432 20:06:33.184264 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10432 20:06:33.184719 _llseek(6, 6496, [6496], SEEK_SET) = 0
10432 20:06:33.184735 _llseek(6, 0, [6496], SEEK_CUR) = 0
10432 20:06:33.184745 close(6)          = 0
10432 20:06:33.184804 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.184820 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.184834 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.184847 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.184893 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.184946 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.184975 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.184987 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.185001 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.185013 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.185040 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.185053 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10432 20:06:33.185075 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10432 20:06:33.185090 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f808) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.185102 _llseek(6, 0, [0], SEEK_CUR) = 0
10432 20:06:33.185117 brk(0x82bd000)    = 0x82bd000
10432 20:06:33.185134 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10432 20:06:33.186109 _llseek(6, 1386, [1386], SEEK_SET) = 0
10432 20:06:33.329690 _llseek(6, 0, [1386], SEEK_CUR) = 0
10432 20:06:33.329690 close(6)          = 0
10432 20:06:33.329737 stat64("/etc/perl/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849762 stat64("/etc/perl/IO/Dir.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.849788 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849806 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.849820 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849834 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.849848 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849860 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.849873 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849886 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfd8f9fc) = -1 ENOENT (No such file or directory)
10432 20:06:33.849906 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfd8faec) = -1 ENOENT (No such file or directory)
10432 20:06:33.849921 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10432 20:06:33.849945 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10432 20:06:33.849962 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f808) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.849976 _llseek(6, 0, [0], SEEK_CUR) = 0
10432 20:06:33.850005 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10432 20:06:33.850275 stat64("/etc/perl/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850293 stat64("/etc/perl/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850307 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850320 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850334 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850347 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850373 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850385 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850399 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850411 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850424 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850437 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850451 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.850464 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10432 20:06:33.850486 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10432 20:06:33.850502 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f358) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.850514 _llseek(8, 0, [0], SEEK_CUR) = 0
10432 20:06:33.850534 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10432 20:06:33.850851 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10432 20:06:33.851405 read(8, "", 4096) = 0
10432 20:06:33.851422 close(8)          = 0
10432 20:06:33.851456 stat64("/etc/perl/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851471 stat64("/etc/perl/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851486 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851499 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851513 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851526 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851540 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851552 stat64("/usr/lib/perl5/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851566 stat64("/usr/share/perl5/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851578 stat64("/usr/share/perl5/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851592 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851605 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfd8f54c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851619 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfd8f63c) = -1 ENOENT (No such file or directory)
10432 20:06:33.851632 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10432 20:06:33.851654 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10432 20:06:33.851669 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8f358) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.851684 _llseek(8, 0, [0], SEEK_CUR) = 0
10432 20:06:33.851702 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10432 20:06:33.852153 stat64("/etc/perl/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852171 stat64("/etc/perl/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852185 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852203 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852218 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852231 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852246 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852258 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852271 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852284 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852297 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852310 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfd8f09c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852324 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfd8f18c) = -1 ENOENT (No such file or directory)
10432 20:06:33.852338 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10432 20:06:33.852370 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10432 20:06:33.852386 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8eea8) = -1 ENOTTY (Inappropriate ioctl for device)
10432 20:06:33.852398 _llseek(10, 0, [0], SEEK_CUR) = 0
10432 20:06:33.852417 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10432 20:06:33.852808 brk(0x82de000)    = 0x82de000
10432 20:06:33.853167 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10432 20:06:33.853770 _llseek(10, 6916, [6916], SEEK_SET) = 0
10432 20:06:33.853787 _llseek(10, 0, [6916], SEEK_CUR) = 0
10432 20:06:33.853798 close(10)         = 0
10432 20:06:33.854031 _llseek(8, 1334, [1334], SEEK_SET) = 0
10432 20:06:33.854048 _llseek(8, 0, [1334], SEEK_CUR) = 0
10432 20:06:33.854059 close(8)          = 0
10432 20:06:33.854652 brk(0x82ff000)    = 0x82ff000
10432 20:06:33.854799 _llseek(6, 2689, [2689], SEEK_SET) = 0
10432 20:06:33.854814 _llseek(6, 0, [2689], SEEK_CUR) = 0
10432 20:06:33.854825 close(6)          = 0
10432 20:06:33.854994 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d89908) = 10433
10433 20:06:33.869925 getppid()         = 10432
10433 20:06:33.870412 open("/etc/nsswitch.conf", O_RDONLY) = 6
10433 20:06:33.870438 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10433 20:06:33.870458 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f4f000
10433 20:06:33.870472 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10433 20:06:33.870569 read(6, "", 4096) = 0
10433 20:06:33.870579 close(6)          = 0
10433 20:06:33.870590 munmap(0xb7f4f000, 4096) = 0
10433 20:06:33.870616 open("/etc/ld.so.cache", O_RDONLY) = 6
10433 20:06:33.870630 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10433 20:06:33.870653 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d56000
10433 20:06:33.870665 close(6)          = 0
10433 20:06:33.870676 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10433 20:06:33.870695 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870710 stat64("/lib/tls/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870724 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870738 stat64("/lib/tls/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870750 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870763 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.870781 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870794 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.870812 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870825 stat64("/lib/tls/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870836 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870848 stat64("/lib/tls/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870860 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870872 stat64("/lib/tls/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870883 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870895 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.870912 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870925 stat64("/lib/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870936 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870948 stat64("/lib/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870960 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.870972 stat64("/lib/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.870983 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871005 stat64("/lib/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871018 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871030 stat64("/lib/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871042 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871053 stat64("/lib/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871064 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871076 stat64("/lib/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871087 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871098 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.871115 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871129 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871141 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871153 stat64("/usr/lib/tls/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871165 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871182 stat64("/usr/lib/tls/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871194 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871207 stat64("/usr/lib/tls/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871218 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871231 stat64("/usr/lib/tls/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871242 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871255 stat64("/usr/lib/tls/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871266 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871279 stat64("/usr/lib/tls/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871290 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871302 stat64("/usr/lib/tls", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871313 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871326 stat64("/usr/lib/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871338 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871351 stat64("/usr/lib/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871362 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871375 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.871393 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871405 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.871423 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871435 stat64("/usr/lib/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871447 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871459 stat64("/usr/lib/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871470 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871482 stat64("/usr/lib/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871572 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871585 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10433 20:06:33.871602 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871616 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871629 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871643 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871655 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871669 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871681 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871694 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871706 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871720 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871735 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871748 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871760 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871773 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871786 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871798 stat64("/lib/i486-linux-gnu/tls", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871810 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871824 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871837 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871850 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871862 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871875 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871888 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871900 stat64("/lib/i486-linux-gnu/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871912 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871926 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871938 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871951 stat64("/lib/i486-linux-gnu/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871962 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.871975 stat64("/lib/i486-linux-gnu/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.871987 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872000 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.872018 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872032 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872045 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872059 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872112 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872129 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872157 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872170 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872183 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872196 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872209 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872223 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872238 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872252 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872264 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872278 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872290 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872303 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872316 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872330 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872342 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872356 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872368 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872381 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872394 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872407 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872420 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872433 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872445 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872458 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfd8fa2c) = -1 ENOENT (No such file or directory)
10433 20:06:33.872471 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10433 20:06:33.872484 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10433 20:06:33.872503 munmap(0xb7d56000, 29913) = 0
10433 20:06:33.872524 open("/etc/ld.so.cache", O_RDONLY) = 6
10433 20:06:33.872537 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10433 20:06:33.872553 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d56000
10433 20:06:33.872564 close(6)          = 0
10433 20:06:33.872575 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10433 20:06:33.872597 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10433 20:06:33.872613 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10433 20:06:33.872709 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10433 20:06:33.872731 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d4b000
10433 20:06:33.872744 mmap2(0xb7d54000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d54000
10433 20:06:33.872765 close(6)          = 0
10433 20:06:33.872789 munmap(0xb7d56000, 29913) = 0
10433 20:06:33.872806 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10433 20:06:33.872823 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10433 20:06:33.872838 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10433 20:06:33.872856 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d5d000
10433 20:06:33.872867 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10433 20:06:33.873055 close(6)          = 0
10433 20:06:33.873065 munmap(0xb7d5d000, 4096) = 0
10433 20:06:33.873083 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10433 20:06:33.873097 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10433 20:06:33.873120 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d5d000
10433 20:06:33.873133 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10433 20:06:33.873313 close(6)          = 0
10433 20:06:33.873323 munmap(0xb7d5d000, 4096) = 0
10433 20:06:33.873350 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10433 20:06:33.873371 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8ff38) = -1 EINVAL (Invalid argument)
10433 20:06:33.873384 _llseek(6, 0, 0xbfd8ff80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10433 20:06:33.873397 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd8ff38) = -1 EINVAL (Invalid argument)
10433 20:06:33.873408 _llseek(6, 0, 0xbfd8ff80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10433 20:06:33.873418 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10433 20:06:33.873472 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10433 20:06:33.873507 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10433 20:06:33.873533 listen(6, 5)      = 0
10433 20:06:33.873588 accept(6,  <unfinished ...>
10432 20:06:33.873844 exit_group(0)     = ?
10430 20:06:33.873934 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10432
10430 20:06:33.873950 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10430 20:06:33.873961 --- SIGCHLD (Child exited) @ 0 (0) ---
10430 20:06:33.873968 waitpid(-1, 0xbfef5a68, WNOHANG) = -1 ECHILD (No child processes)
10430 20:06:33.873979 sigreturn()       = ? (mask now [])
10430 20:06:33.873995 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10430 20:06:33.874053 exit_group(0)     = ?
4519  20:06:33.874089 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10430
4519  20:06:33.874105 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:06:33.874185 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:06:33.874212 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:06:33.874235 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:06:33.874256 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:06:33.874318 time(NULL)        = 1495670793
4519  20:06:33.874329 time(NULL)        = 1495670793
4519  20:06:33.874386 gettimeofday({1495670793, 874391}, NULL) = 0
4519  20:06:33.874400 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:06:33.874430 clock_gettime(CLOCK_MONOTONIC, {47603, 691443382}) = 0
4519  20:06:33.874442 gettimeofday({1495670793, 874446}, NULL) = 0
4519  20:06:33.874454 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [4 7], left {1, 0})
4519  20:06:33.874494 clock_gettime(CLOCK_MONOTONIC, {47603, 691506613}) = 0
4519  20:06:33.874505 recv(7, "PRIVMSG  #testit1 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\nPRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 104
4519  20:06:33.874531 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874549 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874563 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874584 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874599 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874613 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874626 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874640 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874653 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874666 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874679 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874693 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874706 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874720 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874733 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874746 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874759 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874773 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874786 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874801 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874814 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874828 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874846 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874861 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874875 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874889 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874902 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874916 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874929 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874942 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874960 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874973 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.874987 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
4519  20:06:33.875000 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 120000}, ...}) = 0
