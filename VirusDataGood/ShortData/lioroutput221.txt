10600 20:08:18.195169 _llseek(6, 6698, [6698], SEEK_SET) = 0
10600 20:08:18.195187 _llseek(6, 0, [6698], SEEK_CUR) = 0
10600 20:08:18.195198 close(6)          = 0
10600 20:08:18.195220 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195273 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195291 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195320 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195335 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195349 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195363 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195376 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195390 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195403 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195417 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195432 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10600 20:08:18.195455 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10600 20:08:18.195472 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf938) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.195485 _llseek(6, 0, [0], SEEK_CUR) = 0
10600 20:08:18.195503 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10600 20:08:18.195982 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.195999 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196013 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196026 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196040 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196053 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196067 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196079 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196093 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196105 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196118 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196132 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196146 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.196159 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10600 20:08:18.196180 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10600 20:08:18.196195 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf488) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.196206 _llseek(8, 0, [0], SEEK_CUR) = 0
10600 20:08:18.196224 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10600 20:08:18.197080 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10600 20:08:18.197455 brk(0x829c000)    = 0x829c000
10600 20:08:18.197735 read(8, "", 4096) = 0
10600 20:08:18.197751 close(8)          = 0
10600 20:08:18.199056 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10600 20:08:18.199515 _llseek(6, 6496, [6496], SEEK_SET) = 0
10600 20:08:18.199533 _llseek(6, 0, [6496], SEEK_CUR) = 0
10600 20:08:18.199545 close(6)          = 0
10600 20:08:18.199626 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199643 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199658 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199672 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199687 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199700 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199715 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199728 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199742 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199755 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199768 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.199783 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10600 20:08:18.199840 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10600 20:08:18.199875 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf938) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.199888 _llseek(6, 0, [0], SEEK_CUR) = 0
10600 20:08:18.199905 brk(0x82bd000)    = 0x82bd000
10600 20:08:18.199922 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10600 20:08:18.201119 _llseek(6, 1386, [1386], SEEK_SET) = 0
10600 20:08:18.361086 _llseek(6, 0, [1386], SEEK_CUR) = 0
10600 20:08:18.361086 close(6)          = 0
10600 20:08:18.361106 stat64("/etc/perl/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361124 stat64("/etc/perl/IO/Dir.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361138 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361151 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361165 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361178 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361192 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361204 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361217 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361229 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfebfb2c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361242 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfebfc1c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361256 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10600 20:08:18.361277 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10600 20:08:18.361293 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf938) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.361305 _llseek(6, 0, [0], SEEK_CUR) = 0
10600 20:08:18.361326 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10600 20:08:18.361954 stat64("/etc/perl/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361972 stat64("/etc/perl/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361986 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.361999 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362013 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362026 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362039 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362051 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362064 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362076 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362089 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362102 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362119 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.362133 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10600 20:08:18.362154 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10600 20:08:18.362168 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf488) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.362180 _llseek(8, 0, [0], SEEK_CUR) = 0
10600 20:08:18.362200 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10600 20:08:18.362563 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10600 20:08:18.363157 read(8, "", 4096) = 0
10600 20:08:18.363174 close(8)          = 0
10600 20:08:18.363205 stat64("/etc/perl/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363220 stat64("/etc/perl/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363234 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363247 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363261 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363273 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363287 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363299 stat64("/usr/lib/perl5/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363312 stat64("/usr/share/perl5/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363324 stat64("/usr/share/perl5/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363353 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363392 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfebf67c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363420 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfebf76c) = -1 ENOENT (No such file or directory)
10600 20:08:18.363433 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10600 20:08:18.363454 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10600 20:08:18.363469 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf488) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.363480 _llseek(8, 0, [0], SEEK_CUR) = 0
10600 20:08:18.363497 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10600 20:08:18.363974 stat64("/etc/perl/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.363993 stat64("/etc/perl/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364007 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364020 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364034 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364047 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364061 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364073 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364087 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364099 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364112 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364125 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfebf1cc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364139 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfebf2bc) = -1 ENOENT (No such file or directory)
10600 20:08:18.364152 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10600 20:08:18.364173 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10600 20:08:18.364188 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebefd8) = -1 ENOTTY (Inappropriate ioctl for device)
10600 20:08:18.364199 _llseek(10, 0, [0], SEEK_CUR) = 0
10600 20:08:18.364218 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10600 20:08:18.364656 brk(0x82de000)    = 0x82de000
10600 20:08:18.365122 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10600 20:08:18.365754 _llseek(10, 6916, [6916], SEEK_SET) = 0
10600 20:08:18.365770 _llseek(10, 0, [6916], SEEK_CUR) = 0
10600 20:08:18.365781 close(10)         = 0
10600 20:08:18.366016 _llseek(8, 1334, [1334], SEEK_SET) = 0
10600 20:08:18.366033 _llseek(8, 0, [1334], SEEK_CUR) = 0
10600 20:08:18.366043 close(8)          = 0
10600 20:08:18.366695 brk(0x82ff000)    = 0x82ff000
10600 20:08:18.366909 _llseek(6, 2689, [2689], SEEK_SET) = 0
10600 20:08:18.366927 _llseek(6, 0, [2689], SEEK_CUR) = 0
10600 20:08:18.366937 close(6)          = 0
10600 20:08:18.367088 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d6c908) = 10601
10601 20:08:18.500987 getppid()         = 10600
10601 20:08:18.501551 open("/etc/nsswitch.conf", O_RDONLY) = 6
10601 20:08:18.501591 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10601 20:08:18.501611 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f32000
10601 20:08:18.501626 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10601 20:08:18.501677 read(6, "", 4096) = 0
10601 20:08:18.501688 close(6)          = 0
10601 20:08:18.501698 munmap(0xb7f32000, 4096) = 0
10601 20:08:18.501726 open("/etc/ld.so.cache", O_RDONLY) = 6
10601 20:08:18.501739 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10601 20:08:18.501756 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d39000
10601 20:08:18.501767 close(6)          = 0
10601 20:08:18.501778 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10601 20:08:18.501797 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.501811 stat64("/lib/tls/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.501825 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.501838 stat64("/lib/tls/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.501849 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.501881 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.501929 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.501959 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.501996 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502008 stat64("/lib/tls/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502019 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502031 stat64("/lib/tls/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502042 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502054 stat64("/lib/tls/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502065 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502076 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.502093 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502105 stat64("/lib/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502123 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502135 stat64("/lib/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502146 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502158 stat64("/lib/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502169 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502180 stat64("/lib/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502191 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502203 stat64("/lib/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502213 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502225 stat64("/lib/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502235 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502247 stat64("/lib/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502257 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502268 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.502284 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502297 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502309 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502322 stat64("/usr/lib/tls/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502333 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502346 stat64("/usr/lib/tls/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502367 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502406 stat64("/usr/lib/tls/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502418 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502430 stat64("/usr/lib/tls/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502456 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502468 stat64("/usr/lib/tls/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502479 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502491 stat64("/usr/lib/tls/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502502 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502514 stat64("/usr/lib/tls", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502525 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502538 stat64("/usr/lib/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502549 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502561 stat64("/usr/lib/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502572 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502585 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.502602 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502614 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.502631 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502646 stat64("/usr/lib/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502657 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502669 stat64("/usr/lib/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502680 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502692 stat64("/usr/lib/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502703 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502714 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10601 20:08:18.502730 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502744 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502756 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502770 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502782 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502794 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502807 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502819 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502831 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502844 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502866 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502905 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502918 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502947 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502959 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502971 stat64("/lib/i486-linux-gnu/tls", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.502983 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.502996 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503008 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503021 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503033 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503046 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503058 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503070 stat64("/lib/i486-linux-gnu/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503082 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503095 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503106 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503119 stat64("/lib/i486-linux-gnu/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503133 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503146 stat64("/lib/i486-linux-gnu/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503157 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503170 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.503187 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503201 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503214 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503227 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503239 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503253 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503265 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503278 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503290 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503304 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503316 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503329 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503341 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503364 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503403 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503431 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503443 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503456 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503469 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503482 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503508 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503521 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503533 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503546 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503558 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503571 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503583 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503596 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503608 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503620 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfebfb5c) = -1 ENOENT (No such file or directory)
10601 20:08:18.503635 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10601 20:08:18.503648 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10601 20:08:18.503667 munmap(0xb7d39000, 29913) = 0
10601 20:08:18.503688 open("/etc/ld.so.cache", O_RDONLY) = 6
10601 20:08:18.503701 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10601 20:08:18.503717 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d39000
10601 20:08:18.503728 close(6)          = 0
10601 20:08:18.503738 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10601 20:08:18.503753 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10601 20:08:18.503767 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10601 20:08:18.503869 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10601 20:08:18.503922 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d2e000
10601 20:08:18.503968 mmap2(0xb7d37000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d37000
10601 20:08:18.503985 close(6)          = 0
10601 20:08:18.504009 munmap(0xb7d39000, 29913) = 0
10601 20:08:18.504026 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10601 20:08:18.504043 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10601 20:08:18.504058 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10601 20:08:18.504075 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d40000
10601 20:08:18.504086 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10601 20:08:18.504272 close(6)          = 0
10601 20:08:18.504282 munmap(0xb7d40000, 4096) = 0
10601 20:08:18.504300 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10601 20:08:18.504314 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10601 20:08:18.504330 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d40000
10601 20:08:18.504341 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10601 20:08:18.504618 close(6)          = 0
10601 20:08:18.504628 munmap(0xb7d40000, 4096) = 0
10601 20:08:18.504657 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10601 20:08:18.504679 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfec0068) = -1 EINVAL (Invalid argument)
10601 20:08:18.504693 _llseek(6, 0, 0xbfec00b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10601 20:08:18.504705 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfec0068) = -1 EINVAL (Invalid argument)
10601 20:08:18.504716 _llseek(6, 0, 0xbfec00b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10601 20:08:18.504726 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10601 20:08:18.504782 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10601 20:08:18.504818 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10601 20:08:18.504877 listen(6, 5)      = 0
10601 20:08:18.504985 accept(6,  <unfinished ...>
10600 20:08:18.505272 exit_group(0)     = ?
10601 20:08:18.851087 <... accept resumed> {sa_family=AF_INET, sin_port=htons(33511), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10601 20:08:18.851087 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf058) = -1 EINVAL (Invalid argument)
10601 20:08:18.851087 _llseek(8, 0, 0xbfebf0a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10601 20:08:18.851099 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfebf058) = -1 EINVAL (Invalid argument)
